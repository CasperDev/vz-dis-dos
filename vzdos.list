# file opened: vzdos.asm
   1  0000              	DEVICE NOSLOT64K
   2  0000              	SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
   3  0000              ;***************************************************************************************************
   4  0000              ;
   5  0000              ; The R/W head is positioned to the desired track by applying the control signals to the stepper motor.
   6  0000              ; The stepper motor rotates 2 steps per track.
   7  0000              ;
   8  0000              ; In order to assure proper positioning of the R/W head after powering on, a step-out operation
   9  0000              ; (recalibration) is performed until it is locked at track 00 by the track 00 stopper.
  10  0000              ;
  11  0000              ; The drive is selected by activating the -BENBL line. After being selected, the drive motor
  12  0000              ; and the LED on the front panel bezel will be on.
  13  0000              ;
  14  0000              CR					EQU		$0d			; CR char
  15  0000              UP					EQU		$1b			; Cursor Up
  16  0000
  17  0000              SYS_INT_STATE		equ		$6800		; Hardware INT line on bit 7
  18  0000              AllKeyRows			equ		$6800		; Address to read all keys at once
  19  0000              CtrlKeyRow			equ		$68fd		; Address of Keyboard Row with CTRL key
  20  0000              CtrlKeyCol			equ		2			; Bit Number of Keyboard Column with CTRL key
  21  0000              SpaceKeyRow			equ		$68ef		; Address of Keyboard Row with SPACE key
  22  0000              SpaceKeyCol			equ		4			; Bit Number of Keyboard Column with SPACE key
  23  0000              BreakKeybRow		equ		$68df		; Address of Keyboard Row with BREAK key
  24  0000
  25  0000              BreakKeybMask		equ		%00000100	; Bitmask of Keyboard Column with BREAK key
  26  0000              BreakKeyCol			equ		2			; Bit Number of Keyboard Column with BREAK key
  27  0000
  28  0000
  29  0000              ;***************************************************************************************************
  30  0000              ;
  31  0000              ;   S Y S T E M   V A R I A B L E S
  32  0000              ;
  33  0000              ;---------------------------------------------------------------------------------------------------
  34  0000              SysVecParse			equ		$7804	;
  35  0000              SysCursorAddr		equ		$7820	; Address of Cursor position on Screen
  36  0000              SYS_BASIC_STACK		EQU		$78a0
  37  0000              SYS_MEMTOP_PTR    	EQU     $78B1   ; Address of highest available RAM
  38  0000              SYS_STRING_SPACE	EQU		$78d6 	; String space pointer (current location).
  39  0000              SYS_BACKSP_STACK	EQU		$78e8   ; backspaced stack address
  40  0000              SYS_BASIC_PRG		equ		$7ae9	; address of first byte of BASIC program
  41  0000              SYS_BASIC_START_PTR	equ 	$78a4	; 16bit pointer to start of current BASIC Program
  42  0000              SYS_BASIC_END_PTR	equ 	$78f9	; 16bit pointer to end of current BASIC Program
  43  0000              SYS_ARR_START_PTR	equ 	$78fb	; 16bit pointer to start of area for BASIC arrays
  44  0000              SYS_ARR_END_PTR		equ 	$78fd	; 16bit pointer to end of area for BASIC arrays
  45  0000              BasicLineNumber		equ		$78a2	; Current line being processed by BASIC.
  46  0000              BasicLineBufPtr		equ		$78a7	; Current line being processed by BASIC.
  47  0000
  48  0000              CmdINPUTSrcFlag		equ     $78a9	; Source for DATA/INPUT - 0 if cassete input else non zero
  49  0000              ErrorLineNumber		equ		$78ea	; BASIC Line where Error occoured
  50  0000              EditLineNumber		equ		$78ec	; BASIC Line currently edited
  51  0000              EditBufCounter		equ		$7aaf	; Number of characters in Edit Buffer left to process
  52  0000
  53  0000              SYS_ACC				equ		$7921	; BASIC Accumulator starts here (double 8 bytes, single 4 bytes, int 2 bytes, string 3 bytes)
  54  0000              ;***************************************************************************************************
  55  0000              ;
  56  0000              ;   S Y S T E M   R O U T I N E S
  57  0000              ;
  58  0000              ;---------------------------------------------------------------------------------------------------
  59  0000              SysPrintChar		equ		$032a	; Prints char from register a to screen (also spec char like CR)
  60  0000              SysNewLine			equ		$20f9	; Outputs CR to screen if cursor is not already at the beginning of line
  61  0000              SysMsgOut			EQU		$28a7	; MsgOut(hl)
  62  0000              SysStartBASIC		equ		$1a19	; Start BASIC
  63  0000              SysRaiseError 		equ		$19a2	; Raise BASIC Error - Error number in A
  64  0000              SysRaiseSyntaxError	equ		$1997	; Raise BASIC Syntax Error routine
  65  0000              SysBASICStop		equ		$1da0	; BASIC STOP proc with Break Key pressed
  66  0000              SysBASICReset		equ 	$1b9a	; Restart BASIC
  67  0000              SysBASICDeletePrg	equ		$1b4d	; Wipe out BASIC variables and set BASIC Ready
  68  0000              PrintMsg_IN_LINE	equ		$0fa7	; Print IN <line number from hl>
  69  0000              SysCheckNextChar	equ 	$1d78	; BASIC Parser Main routine
  70  0000              SysExecRUN			equ		$36e9	; Execute BASIC RUN command
  71  0000              SysParseNextExpr	equ		$1d1e	; Parse next BASIC expression
  72  0000              SysSetPrgReady		equ		$1ae8	; Reset BASIC and set BASIC Program ready to run (start adr pushed on Stack)
  73  0000
  74  0000              SysCheckIllegalDirect equ	$2828	; Throw ILLEGAL DIRECT Error if current BASIC line <> FFFF
  75  0000
  76  0000              SysEvalByteExpr		equ		$2b1c	; Evaluate Integer expression and places it in ACC and register de
  77  0000              SysEvalBasicExpr	equ		$2337	; Evaluate any BASIC expression and place result in ACC
  78  0000
  79  0000              SysNumToStr			equ		$0fbd	; Convert Numeric value from ACC to String (hl will point to start of string)
  80  0000              SysStrVarToBCD		equ		$09c4	; Copy String Vector to BCD (BC=chars address, D=length)
  81  0000              SysStrToACC			equ		$2865	; Create String Vector from (hl) and store in ACC
  82  0000              SysGetStrVarPtr		equ		$29da	; Get VARPTR of string stored in ACC
  83  0000              SysExecINPUTProc	equ		$21bd	; Execute part of BASIC INPUT command to evaluate Variable value
  84  0000              SysErrRaiseFuncCode equ		$1e4a	; Raise BASIC FUNCTION CODE	Error
  85  0000              TXT_READY			equ		$1929	; 'READY' text
  86  0000
  87  0000              ;***************************************************************************************************
  88  0000
  89  0000              ; Bit 0..Bit 3 : Stepper-motor control phases (active HIGH)
  90  0000              ; Bit 4        : Drive 1 enable.(active HIGH)
  91  0000              ; Bit 5        : Write Data (inverted, active LOW writes 1) => Output pulse when writing to diskette
  92  0000              ; Bit 6        : Write Request (active LOW) => Access type (0 = write, 1 = read)
  93  0000              ; Bit 7        : Drive 2 enable (active HIGH)
  94  0000              FLCTRL				equ		$10		; (write only) Floppy Disk Control Register
  95  0000
  96  0000              FLDATA				equ		$11		; (read only) Data Byte from FDC
  97  0000
  98  0000              FLPOOL				equ		$12		; (read only) Clock Pulse from FDC (Bit 7)
  99  0000
 100  0000              FLWRPROT			equ		$13		; (read only) Write Protect Status (Bit 7) 1=Write Protected
 101  0000
 102  0000              ;--------- Bits
 103  0000              FL_STEPPER_MASK	equ	%00001111		; Bit 0 -.Bit 3 :Stepper-motor control phases (active HIGH)
 104  0000              FL_DRV_1_ENABLE	equ	%00010000		; Bit 4 : Drive 1 enable.(active HIGH)
 105  0000              FL_WRITE_DATA	equ	%00100000		; Bit 5 : Write Data Bit
 106  0000              FL_WRITE_REQ	equ	%01000000		; Bit 6 : Write Request (active LOW)
 107  0000              FL_DRV_2_ENABLE	equ	%10000000		; Bit 7 : Drive 2 enable (active HIGH)
 108  0000
 109  0000
 110  0000              FCB_OPENFLAG	equ	0
 111  0000              FCB_ACCESS		equ	1
 112  0000              FCB_FNAM		equ	2
 113  0000              FCB_TRKN0		equ	10
 114  0000              FCB_SCTRNO		equ	11
 115  0000              FCB_PTR			equ	12
 116  0000
 117  0000              FCBLENGTH		equ 13
 118  0000
 119  0000              ; File number.
 120  0000              ; When processing a data file, this is the number of the FCB block used.
 121  0000              ;   0 = FCB1
 122  0000              ;   1 = FCB2
 123  0000              FILNO 				equ		0		; IY+00 FILE# (1 byte)
 124  0000
 125  0000              ; Filename
 126  0000              ; Name of the file to process. Must be entered by the user program before
 127  0000              ; each file/program access.
 128  0000              FNAM				equ		1		; IY+0l FILENAME (8 bytes)
 129  0000
 130  0000              ; File Type (2 bytes)
 131  0000              ;   Byte 1 = target type.
 132  0000              ;   Byte 2 = actual type.
 133  0000              ; From the user program, the type of file to be processed is in the first byte.
 134  0000              TYPE 				equ		9		; IY+09 FILE TYPE (2 bytes)
 135  0000
 136  0000              ; Selected Drive.
 137  0000              ;   0x10 = Drive 1
 138  0000              ;   0x80 = Drive 2
 139  0000              ; Drive 1 (0x10) is set during initialization.
 140  0000              DK 					equ		11		; IY+0b SELECTED DRIVE#  (1 byte)
 141  0000
 142  0000              ; Access type.
 143  0000              ;   0 = read
 144  0000              ;   1 = write
 145  0000              ; Must be set by the user program.
 146  0000              ; With BASIC, this is done with the OPEN command.
 147  0000              RQST 				equ		12		; IY+0c REQUEST CODE (1 byte)
 148  0000
 149  0000              ; Starting drive (source)
 150  0000              ;   1 = Drive 1
 151  0000              ;   2 = Drive 2
 152  0000              ; Used by DCOPY command
 153  0000              SOURCE 				equ		13		; IY+0d SOURCE DRIVE FOR DCOPY (1 byte)
 154  0000
 155  0000              ; User Buffer Address
 156  0000              ; Address of a user buffer area to or from which data is to be transferred.
 157  0000              ; When loading and saving programs, this is the program area.
 158  0000              ; When reading data files, it is the BASIC input/output buffer.
 159  0000              UBFR 				equ		14		; IY+0e USER BUFFER ADDRESS (16bit address)
 160  0000
 161  0000              ; Target drive (destination)
 162  0000              ;   1 = Drive 1
 163  0000              ;   2 = Drive 2
 164  0000              ; Used by DCOPY command
 165  0000              DESTIN 				equ		16		; IY+10 DEST DRIVE FOR DCOPY (1 byte)
 166  0000
 167  0000              ; User Sector Number.
 168  0000              ; Number of the Sector to be used in current operation.
 169  0000              SCTR 				equ		17		; IY+11 USER SPEC. SECTOR NUMBER
 170  0000
 171  0000              ; User Track Number.
 172  0000              ; Number of the Track to be used in current operation.
 173  0000              TRCK 				equ		18		; IY+12 USER SPEC. TRACK NUMBER
 174  0000
 175  0000              ; Retry counter for read errors (checksum).
 176  0000              ; Set to 10 upon initialization.
 177  0000              RETRY 				equ		19		; IY+13 RETRY COUNT (1 byte)
 178  0000
 179  0000              ; Current track number over which the read/write head is located.
 180  0000              DTRCK 				equ		20		; IY+14 CURRENT TRACK NUMBER (1 byte)
 181  0000
 182  0000              ; Marker field for the next sector to be addressed.
 183  0000              NSCT 				equ		21		; IY+15 NEXT SCTR NUMBER (1 byte)
 184  0000
 185  0000              ; Marker field for the next track to be addressed.
 186  0000              NTRK 				equ		22		; IY+16 NEXT TRK NUMBER (1 byte)
 187  0000
 188  0000              ; File Control Block 1. (13 bytes)
 189  0000              ;   0  FLAG Indicates the status of the FCB.
 190  0000              ;             0 - FCB not used
 191  0000              ;             1 - FCB used, file currently not active
 192  0000              ;             2 - FCR used, file active.
 193  0000              ;            Active means that a current sector of this file is in the data buffer for processing
 194  0000              ;   1 ACCESS Access type for this file.
 195  0000              ;             0 - read
 196  0000              ;             1 - write
 197  0000              ;   2 FNAM   Filename (8 bytes)
 198  0000              ;  10 TRK#   Track Number
 199  0000              ;  11 SCTR#  Number of currently processed Sector
 200  0000              ;  12 PTR    Index to the next byte in this sector to be processed
 201  0000              FCB1 				equ		23		; IY+17 FILE CONTROL BLOCK 1 (13 bytes)
 202  0000
 203  0000              ; File Control Block 2. (13 bytes)
 204  0000              ;   0  FLAG Indicates the status of the FCB.
 205  0000              ;             0 - FCB not used
 206  0000              ;             1 - FCB used, file currently not active
 207  0000              ;             2 - FCR used, file active.
 208  0000              ;            Active means that a current sector of this file is in the data buffer for processing
 209  0000              ;   1 ACCESS Access type for this file.
 210  0000              ;             0 - read
 211  0000              ;             1 - write
 212  0000              ;   2 FNAM   Filename (8 bytes)
 213  0000              ;  10 TRK#   Track Number
 214  0000              ;  11 SCTR#  Number of currently processed Sector
 215  0000              ;  12 PTR    Index to the next byte in this sector to be processed
 216  0000
 217  0000              FCB2 				equ		36		; IY+24 FILE CONTROL BLOCK 1 (13 bytes)
 218  0000
 219  0000
 220  0000              ; Pointer to the DOS data buffer.
 221  0000              ; Used for writing and reading a sector.
 222  0000              ; This is located immediately after the DOS vectors in the work area.
 223  0000              DBFR 				equ		49		; IY+31 DATA BUFFER ADDRESS (16bit address)
 224  0000
 225  0000              ; Copy of the command byte sent to the Floppy Disk Controller.
 226  0000              LTHCPY 				equ		51		; IY+33 COPY OF LATCH (1 byte)
 227  0000
 228  0000              ; Disk Allocation Map buffer.
 229  0000              ; Pointer to the DOS buffer in which
 230  0000              ; the sector alloacation map is temporarily stored.
 231  0000              ; This is behind the data buffer in the DOS work area.
 232  0000              MAPADR 				equ		52		; IY+34 TRACK/SECTOR MAP ADDRESS (16bit address)
 233  0000
 234  0000              ; Track counter for the DCOPY command.
 235  0000              TRKCNT 				equ		54		; IY+36 TRK CNT FOR DCOPY (1 byte)
 236  0000
 237  0000              ; Track pointer for the DCOPY command.
 238  0000              TRKPTR 				equ		55		; IY+37 TRK PTR FOR DCOPY (1 byte)
 239  0000
 240  0000
 241  0000              ; Step pulse raster for moving drive head (track adjustment).
 242  0000              ; Floppy Controller accept 4 bits of Stepping Motor Phase but for simplicity
 243  0000              ; of futher calculations this variable holds 8 bits with 4 lower bits mirrored in 4 high bits.
 244  0000              PHASE 				equ		56		; IY+38 STEPPER PHASE (1 byte)
 245  0000
 246  0000              ; Flag for DCOPY
 247  0000              DCPYF				equ 	57		; IY+39 DCOPY FLAG (1 byte)
 248  0000
 249  0000              ; Reserved for extensions.
 250  0000              RESVE				equ 	58		; IY+3a  Reserved for extensions. (10 bytes)
 251  0000
 252  0000              SectorHeader		equ		67		; IY+43 SECTOR HEADER (10 bytes) (ending sequence: GAP2 + IDAM ending)
 253  0000
 254  0000              SectorBuffer		equ		77		; IY+4d BUFFER DATA (128 bytes + 2 bytes Checksum)
 255  0000
 256  0000              SectorCRCBuf		equ		205		; IY+CD	BUFFER DATA CRC (2 bytes)
 257  0000
 258  0000              Unknown				equ     207  	; IY+CF ??? (24 bytes)
 259  0000
 260  0000              MapBuffer		equ			231		; IY+e7 DISK ALLOCATION MAP BUFFER (80 bytes)
 261  0000
 262  0000
 263  0000
 264  0000
 265  0000              ;***************************************************************************************************
 266  0000              ; ROM SEQUENCE & INIT PROC
 267  0000              	org	$4000
 268  4000 AA 55 E7 18  	db $aa,$55,$e7,$18																				;4000	aa 55 e7 18
 269  4004
 270  4004              ;***************************************************************************************************
 271  4004 F3           	di								; disable Interrupts											;4004	f3
 272  4005 C3 47 40     	jp DOSInit						; DOS initialize routine 										;4005	c3 47 40
 273  4008 C3 41 5F     	jp PWRON						; Disk power ON													;4008	c3 41 5f 	. A _
 274  400B C3 52 5F     	jp PWROFF						; Disk power OFF												;400b	c3 52 5f 	. R _
 275  400E C3 41 42     	jp ERROR						; Error handling routine										;400e	c3 41 42 	. A B
 276  4011 C3 17 47     	jp RDMAP						; Read the track map of the disk								;4011	c3 17 47 	. . G
 277  4014 C3 49 47     	jp CLEAR						; Clear a sector of the disk									;4014	c3 49 47 	. I G
 278  4017 C3 54 47     	jp SVMAP						; Save sector allocation map to the disk						;4017	c3 54 47 	. T G
 279  401A C3 08 4B     	jp INIT							; Initialize the disk											;401a	c3 08 4b 	. . K
 280  401D C3 67 53     	jp CSI							; Command string interpreter									;401d	c3 67 53 	. g S
 281  4020 C3 B9 53     	jp HEX							; Convert ASCII to HEX											;4020	c3 b9 53 	. . S
 282  4023 C3 EA 53     	jp IDAM							; Read identification address mark								;4023	c3 ea 53 	. . S
 283  4026 C3 7B 58     	jp CREATE						; Create an entry in directory									;4026	c3 7b 58 	. { X
 284  4029 C3 BF 58     	jp MAP							; Search for empty sector										;4029	c3 bf 58 	. . X
 285  402C C3 13 59     	jp SEARCH						; Search for file in directory									;402c	c3 13 59 	. . Y
 286  402F C3 68 59     	jp FIND							; Search empty space in directory								;402f	c3 68 59 	. h Y
 287  4032 C3 A1 59     	jp WRITE						; Write a sector to disk										;4032	c3 a1 59 	. . Y
 288  4035 C3 27 5B     	jp READ							; Read a sector from disk										;4035	c3 27 5b 	. ' [
 289  4038 C3 BE 5E     	jp DLY							; Delay mS in reg C												;4038	c3 be 5e 	. . ^
 290  403B C3 CE 5E     	jp STPIN						; Track step in													;403b	c3 ce 5e 	. . ^
 291  403E C3 01 5F     	jp STPOUT						; Track step out												;403e	c3 01 5f 	. . _
 292  4041 C3 B1 43     	jp LOAD							; Load a file from disk											;4041	c3 b1 43 	. . C
 293  4044 C3 6E 44     	jp SAVE							; Save a file to disk											;4044	c3 6e 44 	. n D
 294  4047
 295  4047
 296  4047
 297  4047              ;***************************************************************************************************
 298  4047              ; DOS INIT
 299  4047              ; Executes at computer BOOT time when OS detects DOS ROM exists.
 300  4047              ; - Resets Floppy Drive Controller hardware do default state.
 301  4047              ; - Allocates 311 bytes at top of RAM for DOS Work Area (variables and buffers)
 302  4047              ; - install hook to intercept BASIC command parser
 303  4047              ;***************************************************************************************************
 304  4047              DOSInit:
 305  4047              ; Setup Drive Controller
 306  4047              ; * Step Motor 0001
 307  4047              ; * Drive 1 disabled
 308  4047              ; * Drive 2 disabled
 309  4047              ; * Write Request (inactive)
 310  4047              ; * Write Data = 1
 311  4047 3E 61        	ld a,%01100001					; Write Req + Write Data + Step Motor Phase (0001)				;4047	3e 61 	> a
 312  4049 D3 10        	out (FLCTRL),a					; set Flopy Control byte										;4049	d3 10 	. .
 313  404B
 314  404B              ; -- Allocate DOS memory - check top memory
 315  404B 2A B1 78     	ld hl,(SYS_MEMTOP_PTR)			; hl - current top memory address								;404b	2a b1 78 	* . x
 316  404E E5           	push hl							; save hl - top address											;404e	e5 	.
 317  404F              ; -- reserve 310 bytes
 318  404F 11 CA FE     	ld de,-310						; de = -310 bytes to substract									;404f	11 ca fe 	. . .
 319  4052 19           	add hl,de						; substract 310 bytes											;4052	19 	.
 320  4053              ; -- set DOS Base address to IY
 321  4053 E5           	push hl							; transfer hl - new top address									;4053	e5 	.
 322  4054 FD E1        	pop iy							; ... to IY register - DOS Base									;4054	fd e1 	. .
 323  4056
 324  4056              ; -- check if enough memory
 325  4056 E1           	pop hl							; hl - old top memory											;4056	e1 	.
 326  4057 11 00 80     	ld de,$8000						; de = -32767													;4057	11 00 80 	. . .
 327  405A B7           	or a							; clear Carry Flag												;405a	b7 	.
 328  405B ED 52        	sbc hl,de						; check if top mem less than $8000								;405b	ed 52 	. R
 329  405D D2 6A 40     	jp nc,.continue					; no - continue													;405d	d2 6a 40 	. j @
 330  4060
 331  4060              ; -- not enough memory - display error and jump to BASIC
 332  4060 21 44 41     	ld hl,ERR_InsufficientMemoryForDOS	; Error message												;4060	21 44 41 	! D A
 333  4063 FB           	ei								; enable interrupts												;4063	fb 	.
 334  4064 CD A7 28     	call SysMsgOut					; print message on screen										;4064	cd a7 28 	. . (
 335  4067 C3 19 1A     	jp SysStartBASIC				; jump to BASIC													;4067	c3 19 1a 	. . .
 336  406A
 337  406A
 338  406A
 339  406A              ; **************************************************************************************************
 340  406A              ; Reserve 311 bytes for DOS
 341  406A              ; Reallocate all BASIC pointers
 342  406A              .continue:
 343  406A              ; -- set new MEMTOP 311 bytes lower
 344  406A 19           	add hl,de						; restore hl back to old top memory								;406a	19 	.
 345  406B 11 37 01     	ld de,311						; reserve 311 bytes of memory									;406b	11 37 01 	. 7 .
 346  406E ED 52        	sbc hl,de						; substract 311 bytes from old top mem							;406e	ed 52 	. R
 347  4070 22 B1 78     	ld (SYS_MEMTOP_PTR),hl			; store as new MEMTOP											;4070	22 b1 78 	" . x
 348  4073              ; -- update BASIC String Space Pointer
 349  4073 22 D6 78     	ld (SYS_STRING_SPACE),hl		; store as new String Space Pointer								;4073	22 d6 78 	" . x
 350  4076              ; -- update BASIC Stack Address
 351  4076 11 32 00     	ld de,50						; 50 bytes of String Space										;4076	11 32 00 	. 2 .
 352  4079 B7           	or a							; clear Carry Flag												;4079	b7 	.
 353  407A ED 52        	sbc hl,de						; calculate new address											;407a	ed 52 	. R
 354  407C 22 A0 78     	ld (SYS_BASIC_STACK),hl			; store as new BASIC Stack Address								;407c	22 a0 78 	" . x
 355  407F              ; -- update BASIC Backspaced Stack Address
 356  407F 2B           	dec hl																							;407f	2b 	+
 357  4080 2B           	dec hl							; decrement by 2												;4080	2b 	+
 358  4081 22 E8 78     	ld (SYS_BACKSP_STACK),hl		; store as new Backspaced Stack Address							;4081	22 e8 78 	" . x
 359  4084              ; -- set CPU Stack Pointer to new value
 360  4084 23           	inc hl																							;4084	23 	#
 361  4085 23           	inc hl							; increment back by 2											;4085	23 	#
 362  4086 F9           	ld sp,hl						; set CPU stack Pointer											;4086	f9 	.
 363  4087
 364  4087
 365  4087
 366  4087              ; **************************************************************************************************
 367  4087              ; Initialize DOS Block Memory
 368  4087              ; Reset all parameters to default values
 369  4087              ;
 370  4087 FD 36 14 00  	ld (iy+DTRCK),0					; Current Track Number = 0	(Drive Head position)				;4087	fd 36 14 00 	. 6 . .
 371  408B FD 36 12 00  	ld (iy+TRCK),0					; User Track Number	= 0											;408b	fd 36 12 00 	. 6 . .
 372  408F FD 36 11 00  	ld (iy+SCTR),0					; User Sector Number = 0										;408f	fd 36 11 00 	. 6 . .
 373  4093 FD 36 13 0A  	ld (iy+RETRY),10				; Read/Write Retry Counter = 10									;4093	fd 36 13 0a 	. 6 . .
 374  4097 FD 36 16 00  	ld (iy+NTRK),0					; Next Track = 0												;4097	fd 36 16 00 	. 6 . .
 375  409B FD 36 15 00  	ld (iy+NSCT),0					; Next Sector = 0												;409b	fd 36 15 00 	. 6 . .
 376  409F FD 36 17 00  	ld (iy+FCB1),0					; File Control Block 1 Open Flag = not open 					;409f	fd 36 17 00 	. 6 . .
 377  40A3 FD 36 24 00  	ld (iy+FCB2),0					; File Control Block 2 Open Flag = not open						;40a3	fd 36 24 00 	. 6 $ .
 378  40A7 FD 36 39 00  	ld (iy+DCPYF),0					; Flag for DCOPY command = none									;40a7	fd 36 39 00 	. 6 9 .
 379  40AB FD 36 0B 10  	ld (iy+DK),$10					; Selected Drive 1												;40ab	fd 36 0b 10 	. 6 . .
 380  40AF FD 36 33 61  	ld (iy+LTHCPY),%01100001		; Update Shadow Register with value written to FDC Control 		;40af	fd 36 33 61 	. 6 3 a
 381  40B3              ; -- Stepper Phase contains 4 bits values duplicated in high and low nibble
 382  40B3              ;    this way futher rotation operations used by StepIn and StepOut don't need any corrections
 383  40B3 FD 36 38 11  	ld (iy+PHASE),%00010001			; Stepper Phase 0001-0001										;40b3	fd 36 38 11 	. 6 8 .
 384  40B7
 385  40B7              ; -- set address of Sector Data as operation Buffer
 386  40B7 FD E5        	push iy							; iy - DOS base address											;40b7	fd e5 	. .
 387  40B9 E1           	pop hl							; copy to hl													;40b9	e1 	.
 388  40BA 11 4D 00     	ld de,SectorBuffer				; offset from DOS Base to Sector Buffer							;40ba	11 4d 00 	. M .
 389  40BD 19           	add hl,de						; hl - absolute address of Sector Data Buffer					;40bd	19 	.
 390  40BE FD 75 31     	ld (iy+DBFR),l					; store as Data Buffer (low byte)								;40be	fd 75 31 	. u 1
 391  40C1 FD 74 32     	ld (iy+DBFR+1),h				; store as Data Buffer (high byte)								;40c1	fd 74 32 	. t 2
 392  40C4
 393  40C4              ; -- fill Sector Header data with default values
 394  40C4              ; only 10 bytes of Sector Header ending sequence: GAP2 + IDAM ending
 395  40C4 11 F6 FF     	ld de,-10						; de = -10 														;40c4	11 f6 ff 	. . .
 396  40C7 19           	add hl,de						; hl - 10 bytes before sector buffer							;40c7	19 	.
 397  40C8 EB           	ex de,hl						; de - SectorHeader address 									;40c8	eb 	.
 398  40C9 21 5D 4D     	ld hl,SectorGAP2Data			; hl - default Sector Header ending sequence (source)			;40c9	21 5d 4d 	! ] M
 399  40CC 01 0A 00     	ld bc,10						; 10 bytes to copy												;40cc	01 0a 00 	. . .
 400  40CF ED B0        	ldir							; copy template data											;40cf	ed b0 	. .
 401  40D1
 402  40D1              ; --set address for Disk Allocation Map Buffer
 403  40D1 FD E5        	push iy							; iy - DOS base address											;40d1	fd e5 	. .
 404  40D3 E1           	pop hl							; copy to hl													;40d3	e1 	.
 405  40D4 11 E7 00     	ld de,MapBuffer					; offset from DOS base to Alloc Map Buffer area					;40d4	11 e7 00 	. . .
 406  40D7 19           	add hl,de						; hl - absolute address of Alloc Map Buffer						;40d7	19 	.
 407  40D8 FD 75 34     	ld (iy+MAPADR),l				; store low byte												;40d8	fd 75 34 	. u 4
 408  40DB FD 74 35     	ld (iy+MAPADR+1),h				; store high byte												;40db	fd 74 35 	. t 5
 409  40DE
 410  40DE              ; -- reset Head position in Floppy Drive 1 to Track 00
 411  40DE              ;    move Head 40 times so it will be on Track 00 no matter where it was when power off
 412  40DE CD 41 5F     	call PWRON						; Disk power ON													;40de	cd 41 5f 	. A _
 413  40E1 06 28        	ld b,40							; max 40 tracks to STEPOUT										;40e1	06 28 	. (
 414  40E3 CD 01 5F     	call STPOUT						; step out 40 times 											;40e3	cd 01 5f 	. . _
 415  40E6 CD 52 5F     	call PWROFF						; Disk power OFF												;40e6	cd 52 5f 	. R _
 416  40E9
 417  40E9              ; -- Hook Up BASIC parser (RST 10) to allow DOS Commands
 418  40E9 21 93 42     	ld hl,DOSCheckNextChar			; NextToken replace routine										;40e9	21 93 42 	! . B
 419  40EC 22 04 78     	ld (SysVecParse),hl				; set new jump address to intercept BASIC Parser				;40ec	22 04 78 	" . x
 420  40EF
 421  40EF              ; -- print DOS BASIC V1.2
 422  40EF 21 13 41     	ld hl,TxtDosBasic12				; text message "DOS BASIC V1.2"									;40ef	21 13 41 	! . A
 423  40F2 FB           	ei								; enable interrupt 												;40f2	fb 	.
 424  40F3 CD A7 28     	call SysMsgOut					; print message on screen via System routine					;40f3	cd a7 28 	. . (
 425  40F6
 426  40F6              ; -- check if another ROM is present - continue chain initialization
 427  40F6 21 00 60     	ld hl,$6000						; ROM address 													;40f6	21 00 60 	! . `
 428  40F9              ; -- test ROM sequence: AA 55 E7 18
 429  40F9 3E AA        	ld a,$aa						; a - 1st sequence byte											;40f9	3e aa 	> .
 430  40FB BE           	cp (hl)							; test if matches												;40fb	be 	.
 431  40FC 23           	inc hl							; hl - next ROM address											;40fc	23 	#
 432  40FD 20 10        	jr nz,.finish					; no - start BASIC												;40fd	20 10 	  .
 433  40FF 3E 55        	ld a,$55						; a - 2nd sequence byte											;40ff	3e 55 	> U
 434  4101 BE           	cp (hl)							; test if matches												;4101	be 	.
 435  4102 23           	inc hl							; hl - next ROM address											;4102	23 	#
 436  4103 20 0A        	jr nz,.finish					; no - start BASIC												;4103	20 0a 	  .
 437  4105 3E E7        	ld a,$e7						; a - 3rd sequence byte											;4105	3e e7 	> .
 438  4107 BE           	cp (hl)							; test if matches												;4107	be 	.
 439  4108 23           	inc hl							; hl - next ROM address											;4108	23 	#
 440  4109 20 04        	jr nz,.finish					; no - start BASIC												;4109	20 04 	  .
 441  410B 3E 18        	ld a,$18						; a - 4th sequence byte											;410b	3e 18 	> .
 442  410D BE           	cp (hl)							; test if matches												;410d	be 	.
 443  410E 23           	inc hl							; hl - next ROM address											;410e	23 	#
 444  410F              .finish:
 445  410F C2 19 1A     	jp nz,SysStartBASIC				; no - start BASIC --------------------------------------------	;410f	c2 19 1a 	. . .
 446  4112              ; -- if match found then start ROM init routine
 447  4112 E9           	jp (hl)							; jump to ROM Init ($6004) ------------------------------------	;4112	e9 	.
 448  4113
 449  4113
 450  4113
 451  4113              ; **************************************************************************************************
 452  4113              ; DOS Title Text
 453  4113              TxtDosBasic12:
 454  4113 1B 1B 44 4F  	db UP,UP,"DOS BASIC V1.2",CR,CR,0	;4113	1b 1b 44 4f 53 20 42 41 53 49 43 20 56 31 2e 32 0d 0d 00
 454  4117 53 20 42 41
 454  411B 53 49 43 20
 454  411F 56 31 2E 32
 454  4123 0D 0D 00
 455  4126
 456  4126
 457  4126
 458  4126              ; **************************************************************************************************
 459  4126              ; Table with addresses of Error Texts
 460  4126              ; Every entry contain absolute address of Error Text
 461  4126              ; Errors 0,1 and 17 are handled by ROM standard routines so there is no Texts in DOS ROM
 462  4126              ErrorsTable:
 463  4126              									; Error 00   NO ERROR (OK)
 464  4126              									; Error 01   SYNTAX ERROR
 465  4126 62 41        	dw ERR_FileAlreadyExists		; Error 02   FILE ALREADY EXISTS								;4126	62 41
 466  4128 77 41        	dw ERR_DirectoryFull			; Error 03   DIRECTORY FULL										;4128	77 41
 467  412A 87 41        	dw ERR_DiskWriteProtected		; Error 04   DISK WRITE PROTECTED								;412a	87 41
 468  412C 9D 41        	dw ERR_FileNotOpen				; Error 05   FILE NOT OPEN										;412c	9d 41
 469  412E AC 41        	dw ERR_DiskIOError				; Error 06   DISK I/O ERROR										;412e	ac 41
 470  4130 BC 41        	dw ERR_DiskFull					; Error 07   DISK FULL											;4130	bc 41
 471  4132 C7 41        	dw ERR_FileAlreadyOpen			; Error 08   FILE ALREADY OPEN									;4132	c7 41
 472  4134 AC 41        	dw ERR_DiskIOError				; Error 09   SECTOR NOT FOUND									;4134	ac 41
 473  4136 AC 41        	dw ERR_DiskIOError				; Error 10   CHECKSUM ERROR										;4136	ac 41
 474  4138 DA 41        	dw ERR_UnsupportedDevice		; Error 11   UNSUPPORTED DEVICE									;4138	da 41
 475  413A EE 41        	dw ERR_FileTypeMismatch			; Error 12   FILE TYPE MISMATCH									;413c	ee 41
 476  413C 02 42        	dw ERR_FileNotFound				; Error 13   FILE NOT FOUND										;413c	02 42
 477  413E 12 42        	dw ERR_DiskBufferFull			; Error 14   DISK BUFFER FULL									;413e	12 42
 478  4140 24 42        	dw ERR_IllegalRead				; Error 15   ILLEGAL READ										;4140	24 42
 479  4142 32 42        	dw ERR_IllegalWrite				; Error 16   ILLEGAL WRITE										;4142	32 42
 480  4144              									; Error 17   BREAK
 481  4144
 482  4144
 483  4144              ; **************************************************************************************************
 484  4144              ; Error Texts
 485  4144              ; Every text is terminated with byte 0 (NULL)
 486  4144              ERR_InsufficientMemoryForDOS:
 487  4144 3F 49 4E 53  	db "?INSUFFICIENT MEMORY FOR DOS",CR,0	;4144	3f 49 4e 53 55 46 46 49 43 49 45 4e 54 20 4d 45 4d 4f 52 59 20 46 4f 52 20 44 4f 53 0d 00
 487  4148 55 46 46 49
 487  414C 43 49 45 4E
 487  4150 54 20 4D 45
 487  4154 4D 4F 52 59
 487  4158 20 46 4F 52
 487  415C 20 44 4F 53
 487  4160 0D 00
 488  4162              ERR_FileAlreadyExists:
 489  4162 3F 46 49 4C  	db "?FILE ALREADY EXISTS",0				;4162	3f 46 49 4c 45 20 41 4c 52 45 41 44 59 20 45 58 49 53 54 53 00
 489  4166 45 20 41 4C
 489  416A 52 45 41 44
 489  416E 59 20 45 58
 489  4172 49 53 54 53
 489  4176 00
 490  4177              ERR_DirectoryFull:
 491  4177 3F 44 49 52  	db "?DIRECTORY FULL",0					;4177	3f 44 49 52 45 43 54 4f 52 59 20 46 55 4c 4c 00
 491  417B 45 43 54 4F
 491  417F 52 59 20 46
 491  4183 55 4C 4C 00
 492  4187              ERR_DiskWriteProtected:
 493  4187 3F 44 49 53  	db "?DISK WRITE PROTECTED",0			;4187	3f 44 49 53 4b 20 57 52 49 54 45 20 50 52 4f 54 45 43 54 45 44 00
 493  418B 4B 20 57 52
 493  418F 49 54 45 20
 493  4193 50 52 4F 54
 493  4197 45 43 54 45
 493  419B 44 00
 494  419D              ERR_FileNotOpen:
 495  419D 3F 46 49 4C  	db "?FILE NOT OPEN",0					;419d	3f 46 49 4c 45 20 4e 4f 54 20 4f 50 45 4e 00
 495  41A1 45 20 4E 4F
 495  41A5 54 20 4F 50
 495  41A9 45 4E 00
 496  41AC              ERR_DiskIOError:
 497  41AC 3F 44 49 53  	db "?DISK I/O ERROR",0					;41ac	3f 44 49 53 4b 20 49 2f 4f 20 45 52 52 4f 52 00
 497  41B0 4B 20 49 2F
 497  41B4 4F 20 45 52
 497  41B8 52 4F 52 00
 498  41BC              ERR_DiskFull:
 499  41BC 3F 44 49 53  	db "?DISK FULL",0						;41bc	3f 44 49 53 4b 20 46 55 4c 4c 00
 499  41C0 4B 20 46 55
 499  41C4 4C 4C 00
 500  41C7              ERR_FileAlreadyOpen:
 501  41C7 3F 46 49 4C  	db "?FILE ALREADY OPEN",0				;41c7	3f 46 49 4c 45 20 41 4c 52 45 41 44 59 20 4f 50 45 4e 00
 501  41CB 45 20 41 4C
 501  41CF 52 45 41 44
 501  41D3 59 20 4F 50
 501  41D7 45 4E 00
 502  41DA              ERR_UnsupportedDevice:
 503  41DA 3F 55 4E 53  	db "?UNSUPPORTED DEVICE",0				;41da	3f 55 4e 53 55 50 50 4f 52 54 45 44 20 44 45 56 49 43 45 00
 503  41DE 55 50 50 4F
 503  41E2 52 54 45 44
 503  41E6 20 44 45 56
 503  41EA 49 43 45 00
 504  41EE              ERR_FileTypeMismatch:
 505  41EE 3F 46 49 4C  	db "?FILE TYPE MISMATCH",0				;41ee	3f 46 49 4c 45 20 54 59 50 45 20 4d 49 53 4d 41 54 43 48 00
 505  41F2 45 20 54 59
 505  41F6 50 45 20 4D
 505  41FA 49 53 4D 41
 505  41FE 54 43 48 00
 506  4202              ERR_FileNotFound:
 507  4202 3F 46 49 4C  	db "?FILE NOT FOUND",0					;4202	3f 46 49 4c 45 20 4e 4f 54 20 46 4f 55 4e 44 00
 507  4206 45 20 4E 4F
 507  420A 54 20 46 4F
 507  420E 55 4E 44 00
 508  4212              ERR_DiskBufferFull:
 509  4212 3F 44 49 53  	db "?DISK BUFFER FULL",0				;4212	3f 44 49 53 4b 20 42 55 46 46 45 52 20 46 55 4c 4c 00
 509  4216 4B 20 42 55
 509  421A 46 46 45 52
 509  421E 20 46 55 4C
 509  4222 4C 00
 510  4224              ERR_IllegalRead:
 511  4224 3F 49 4C 4C  	db "?ILLEGAL READ",0					;4224	3f 49 4c 4c 45 47 41 4c 20 52 45 41 44 00
 511  4228 45 47 41 4C
 511  422C 20 52 45 41
 511  4230 44 00
 512  4232              ERR_IllegalWrite:
 513  4232 3F 49 4C 4C  	db "?ILLEGAL WRITE",0					;4232	3f 49 4c 4c 45 47 41 4c 20 57 52 49 54 45 00
 513  4236 45 47 41 4C
 513  423A 20 57 52 49
 513  423E 54 45 00
 514  4241
 515  4241
 516  4241
 517  4241              ;***************************************************************************************************
 518  4241              ; Error handling routine
 519  4241              ;---------------------------------------------------------------------------------------------------
 520  4241              ; Reads the content of register A and prints the .error message before going back to BASIC.
 521  4241              ; IN: A - Error Code (0..17)
 522  4241              ; OUT: Exit to BASIC
 523  4241              ;***************************************************************************************************
 524  4241              ERROR:
 525  4241              ; -- cleanup BASIC if  ???
 526  4241 F5           	push af							; save a - Error Code											;4241	f5 	.
 527  4242 FD 7E 39     	ld a,(iy+DCPYF)					; a - DCOPY flag 												;4242	fd 7e 39 	. ~ 9
 528  4245 B7           	or a							; is DCOPY command in progress?									;4245	b7 	.
 529  4246 C4 44 51     	call nz,ClearBASIC				; yes - Clear BASIC program and select drive D1					;4246	c4 44 51 	. D Q
 530  4249 F1           	pop af							; restore a - Error Code										;4249	f1 	.
 531  424A
 532  424A              ;***************************************************************************************************
 533  424A              ; Handle error:
 534  424A              ; * 0 - no error 					-> switch to BASIC
 535  424A              ; * 1 - Syntax Error 				-> handled by BASIC standard routine
 536  424A              ; * 2..16 - custom DOS error 		-> show error text and switch to BASIC
 537  424A              ; * 17 - Break Key pressed 			-> hadled by BASIC standard routine
 538  424A
 539  424A              ; -- check if No Error (Error Code = 0)
 540  424A B7           	or a							; check if 0 - No Error											;424a	b7
 541  424B 28 34        	jr z,.GotoBASICReady			; yes - switch to BASIC											;424b	28 34
 542  424D
 543  424D              ; -- check if Syntax Error (Error Code 1)
 544  424D FE 01        	cp 01							; check if Error Code = 1 (Syntax Error)						;424d	fe 01
 545  424F CA 97 19     	jp z,SysRaiseSyntaxError		; yes - use BASIC routine to handle Error						;424f	ca 97 19 	. . .
 546  4252
 547  4252              ; -- check if BREAK (Error Code 17)
 548  4252 FE 11        	cp 17							; check if Error Code = 17 (BREAK)								;4252	fe 11 	. .
 549  4254 CA 8A 42     	jp z,.GotoBASICBreak			; yes - switch to BASIC handler									;4254	ca 8a 42
 550  4257
 551  4257              ; -- Move Screen cursor to begin of next line
 552  4257 F5           	push af							; save a - Error Code											;4257	f5 	.
 553  4258 CD F9 20     	call SysNewLine					; call system routine to print CR 								;4258	cd f9 20 	. .
 554  425B F1           	pop af							; restore a - Error Code										;425b	f1 	.
 555  425C
 556  425C              ; -- calculate address of error text for Code
 557  425C              ;    ErrorsTable has addresses for errors 2..16 so shift begin by 2 entries 2 bytes each
 558  425C 21 22 41     	ld hl,ErrorsTable-4				; table with addr of error messages (minus 2 entries)			;425c	21 22 41 	! " A
 559  425F CB 27        	sla a							; a = Error Code x 2 bytes per entry							;425f	cb 27 	. '
 560  4261 85           	add a,l							; add to hl														;4261	85 	.
 561  4262 6F           	ld l,a																							;4262	6f 	o
 562  4263 3E 00        	ld a,0																							;4263	3e 00 	> .
 563  4265 8C           	adc a,h																							;4265	8c 	.
 564  4266 67           	ld h,a							; hl - points to entry in ErrorsTable for specyfic Error		;4266	67 	g
 565  4267 5E           	ld e,(hl)						; e - low byte of oddress of Error text							;4267	5e 	^
 566  4268 23           	inc hl							; next byte of address											;4268	23 	#
 567  4269 56           	ld d,(hl)						; de - address of Error text									;4269	56 	V
 568  426A EB           	ex de,hl						; hl - address of Error text									;426a	eb 	.
 569  426B
 570  426B              ; -- turn Disk Off and print error on screen
 571  426B CD 52 5F     	call PWROFF						; Turn Off Disk power 											;426b	cd 52 5f 	. R _
 572  426E CD A7 28     	call SysMsgOut					; print error text												;426e	cd a7 28 	. . (
 573  4271
 574  4271              ; -- set BASIC line number where Error was found
 575  4271 2A A2 78     	ld hl,(BasicLineNumber)			; hl - Current line being processed by BASIC or Command			;4271	2a a2 78 	* . x
 576  4274 22 EA 78     	ld (ErrorLineNumber),hl			; set BASIC Line where Error occoured							;4274	22 ea 78 	" . x
 577  4277 22 EC 78     	ld (EditLineNumber),hl			; BASIC Line currently edited									;4277	22 ec 78 	" . x
 578  427A
 579  427A              ; -- check if error was found in program line or wrote on screen as direct command (-1)
 580  427A 23           	inc hl							; hl will be 0 if outside of BASIC program						;427a	23 	#
 581  427B 7D           	ld a,l																							;427b	7d 	}
 582  427C B4           	or h							; check if hl not equal 0 (error in line)						;427c	b4 	.
 583  427D 2B           	dec hl							; hl - Basic line												;427d	2b 	+
 584  427E C4 A7 0F     	call nz,PrintMsg_IN_LINE		; yes - Print IN <line number from hl>							;427e	c4 a7 0f 	. . .
 585  4281
 586  4281              .GotoBASICReady:
 587  4281              ; -- transfer control to BASIC/ROM
 588  4281 01 19 1A     	ld bc,SysStartBASIC				; address of BASICReady entry point routune to execute			;4281	01 19 1a 	. . .
 589  4284 2A E8 78     	ld hl,(SYS_BACKSP_STACK)		; initial address of BASIC stack								;4284	2a e8 78 	* . x
 590  4287 C3 9A 1B     	jp SysBASICReset				; reset BASIC variables and go to BASIC Ready -----------------	;4287	c3 9a 1b 	. . .
 591  428A
 592  428A              .GotoBASICBreak:
 593  428A              ; -- transfer control to BASIC/ROM simulating BREAK Key Pressed
 594  428A CD 52 5F     	call PWROFF						; Disk power OFF												;428a	cd 52 5f 	. R _
 595  428D 3E 01        	ld a,1							; BREAK Key to simulate via BASIC								;428d	3e 01 	> .
 596  428F FB           	ei								; enable interrupts												;428f	fb 	.
 597  4290 C3 A0 1D     	jp SysBASICStop					; jump to BASIC STOP routine ----------------------------------	;4290	c3 a0 1d 	. . .
 598  4293
 599  4293
 600  4293
 601  4293
 602  4293
 603  4293              ;***************************************************************************************************
 604  4293              ; Routine called when BASIC parse next char/token
 605  4293              ; IN: hl - address of next char/token to parse
 606  4293              ;     [sp] - return address to calling routine
 607  4293              DOSCheckNextChar:
 608  4293              ; -- test if this code was called from specific ROM routine
 609  4293 D9           	exx								; save bc,de,hl to alteranate register set						;4293	d9 	.
 610  4294 21 5B 1D     	ld hl,$1d5b						; expected return address										;4294	21 5b 1d 	! [ .
 611  4297 D1           	pop de							; de - return address to calling routine						;4297	d1 	.
 612  4298 B7           	or a							; clear Carry flag												;4298	b7 	.
 613  4299 ED 52        	sbc hl,de						; is return address is eual to expected? 						;4299	ed 52 	. R
 614  429B D5           	push de							; push back original return address on stack					;429b	d5 	.
 615  429C D9           	exx								; restore bc,de,hl from alternate register set					;429c	d9 	.
 616  429D C2 78 1D     	jp nz,SysCheckNextChar			; not equal - jump to ROM original routine 						;429d	c2 78 1d 	. x .
 617  42A0
 618  42A0              ; -- this code was called from expected BASIC ROM routine
 619  42A0 E5           	push hl							; save hl - address of next char to parse						;42a0	e5 	.
 620  42A1 CD 78 1D     	call SysCheckNextChar			; call BASIC Parser Main routine first							;42a1	cd 78 1d 	. x .
 621  42A4 20 02        	jr nz,.startParse				; if not end of BASIC expression - try to parse					;42a4	20 02 	  .
 622  42A6
 623  42A6              ; -- end of expression (':') or end of BASIC line ('\0') found
 624  42A6              .exit:
 625  42A6 D1           	pop de							; restore stack pointer 										;42a6	d1 	.
 626  42A7 C9           	ret								; ---------------------- End of Proc --------------------------	;42a7	c9 	.
 627  42A8
 628  42A8              ;***************************************************************************************************
 629  42A8              ; Parse BASIC expression
 630  42A8              ; IN: hl - address of next char/token to parse
 631  42A8              ;     a - next char/token to parse
 632  42A8              ;---------------------------------------------------------------------------------------------------
 633  42A8              .startParse:
 634  42A8 B7           	or a							; is it BASIC token char (a >= 128)?							;42a8	b7 	.
 635  42A9 F2 EF 42     	jp p,ParseCmdText				; no - parse expression as text (command)						;42a9	f2 ef 42 	. . B
 636  42AC              ; -- command token
 637  42AC FE 8E        	cp $8e							; is it RUN command?											;42ac	fe 8e 	. .
 638  42AE 20 F6        	jr nz,.exit						; no - return to BASIC ----------------------------------------	;42ae	20 f6 	  .
 639  42B0
 640  42B0
 641  42B0
 642  42B0
 643  42B0              ;***************************************************************************************************
 644  42B0              ; DOS Command RUN
 645  42B0              ;---------------------------------------------------------------------------------------------------
 646  42B0              ; Syntax: RUN "filaname"
 647  42B0              ; Load one file specified by filename (which has the file type code "T") from a Floppy Disk
 648  42B0              ; and RUN it (execute). Filename may have no more than 8 characters. If user typed just RUN command
 649  42B0              ; without filename then standard BASIC 'RUN' command will be parsed and executed.
 650  42B0              .parse_RUN:
 651  42B0 23           	inc hl							; hl - next char or token										;42b0	23 	#
 652  42B1 7E           	ld a,(hl)						; a -  next char or token										;42b1	7e 	~
 653  42B2 B7           	or a							; is it '\0' - end of BASIC line								;42b2	b7 	.
 654  42B3 28 10        	jr z,.backToROM					; yes - just 'RUN' command - jump to ROM original routine -----	;42b3	28 10 	( .
 655  42B5
 656  42B5              ; -- skip trailing spaces
 657  42B5 FE 20        	cp ' '							; is it ' ' char?												;42b5	fe 20 	.
 658  42B7 28 F7        	jr z,.parse_RUN					; yes - ignore it - parse next char								;42b7	28 f7 	( .
 659  42B9
 660  42B9              ; -- expected name of file enclosed in double quote chars '"'
 661  42B9 FE 22        	cp '"'							; is it double quote char '"' ?									;42b9	fe 22 	. "
 662  42BB 20 08        	jr nz,.backToROM				; no - no filename after 'RUN' - jump to ROM original routine 	;42bb	20 08 	  .
 663  42BD
 664  42BD              ; -- found '"' char - expecting filename
 665  42BD D1           	pop de							; de - address of command start to parse 						;42bd	d1 	.
 666  42BE 01 DB 45     	ld bc,LoadAndRunFile			; bc - routine to load file and execute BASIC RUN command		;42be	01 db 45 	. . E
 667  42C1 2B           	dec hl							; hl - last char of filename									;42c1	2b 	+
 668  42C2 EB           	ex de,hl						; hl - start of command RUN, de - end of filename				;42c2	eb 	.
 669  42C3 18 61        	jr ExecDOSCmd					; execute LoadAndRunFile and return to BASIC ------------------	;42c3	18 61 	. a
 670  42C5
 671  42C5              .backToROM:
 672  42C5 E1           	pop hl							; restore hl - parse point 										;42c5	e1 	.
 673  42C6 C3 78 1D     	jp SysCheckNextChar				; jump to ROM original routine --------------------------------	;42c6	c3 78 1d 	. x .
 674  42C9
 675  42C9
 676  42C9              ;***************************************************************************************************
 677  42C9              ; There is a chance that 2 DOS commands will be tokenized "mixed" way: BRUN and DCOPY.
 678  42C9              ; Because standard BASCI already have commands RUN and COPY it can tokenize above DOS comands
 679  42C9              ; as 1 ASCII char and standard command token: 'B'+token of RUN and 'D'+token of COPY.
 680  42C9              ; This routine covers these two cases.
 681  42C9              TryParseMixedSyntax:
 682  42C9 E1           	pop hl							; restore hl - parse point 										;42c9	e1 	.
 683  42CA E5           	push hl							; save hl back - parse point									;42ca	e5 	.
 684  42CB
 685  42CB              ; -- check if it's stored as "mixed" BRUN (where 'B' is ASCII char and 'RUN' is a token $8e)
 686  42CB 23           	inc hl							; hl - point to next char of expression							;42cb	23 	#
 687  42CC 7E           	ld a,(hl)						; a - parsed char 												;42cc	7e 	~
 688  42CD FE 42        	cp 'B'							; is it 'B'?													;42cd	fe 42 	. B
 689  42CF 20 0B        	jr nz,.checkDCOPY				; no - check possible DCOPY Command								;42cf	20 0b 	  .
 690  42D1 23           	inc hl							; point to next char											;42d1	23 	#
 691  42D2 7E           	ld a,(hl)						; a - parsed char/token											;42d2	7e 	~
 692  42D3 FE 8E        	cp $8e							; is it BASIC 'RUN" token?										;42d3	fe 8e 	. .
 693  42D5 20 14        	jr nz,.backToROM				; no - transfer control to BASIC Parser Main routine			;42d5	20 14 	  .
 694  42D7 06 06        	ld b,6							; b - index of DOS 'BRUN' Command								;42d7	06 06 	. .
 695  42D9 C5           	push bc							; put bc on stack - DOS 'BRUN' Command							;42d9	c5 	.
 696  42DA 18 39        	jr ExecIdxDOSCmd				; execute DOS command determined by index in register b			;42da	18 39 	. 9
 697  42DC
 698  42DC              .checkDCOPY:
 699  42DC              ; -- check if it's stored as "mixed" DCOPY (where 'D' is ASCII char and 'COPY' is a token $96)
 700  42DC FE 44        	cp 'D'							; is it 'D'?													;42dc	fe 44 	. D
 701  42DE 20 0B        	jr nz,.backToROM				; no - transfer control to BASIC Parser Main routine			;42de	20 0b 	  .
 702  42E0 23           	inc hl							; point to next char											;42e0	23 	#
 703  42E1 7E           	ld a,(hl)						; a - parsed char/token											;42e1	7e 	~
 704  42E2 FE 96        	cp $96							; is it BASIC 'COPY" token?										;42e2	fe 96 	. .
 705  42E4 20 05        	jr nz,.backToROM				; no - transfer control to BASIC Parser Main routine			;42e4	20 05 	  .
 706  42E6 06 0E        	ld b,14							; b - index of DOS 'DCOPY' Command								;42e6	06 0e 	. .
 707  42E8 C5           	push bc							; put bc on stack - DOS 'DCOPY' Command							;42e8	c5 	.
 708  42E9 18 2A        	jr ExecIdxDOSCmd				; execute DOS command determined by index in register b			;42e9	18 2a 	. *
 709  42EB              .backToROM:
 710  42EB E1           	pop hl							; restore hl - parse point 										;42eb	e1 	.
 711  42EC C3 78 1D     	jp SysCheckNextChar				; jump to ROM original routine --------------------------------	;42ec	c3 78 1d 	. x .
 712  42EF
 713  42EF
 714  42EF
 715  42EF              ;***************************************************************************************************
 716  42EF              ; Parse and execute BASIC text expression as DOS command
 717  42EF              ; IN: hl - address of text expression
 718  42EF              ParseCmdText:
 719  42EF 11 2D 43     	ld de,DOSCmdNames-1				; de - table with all DOS commands text (will be incremented)	;42ef	11 2d 43 	. - C
 720  42F2 06 FF        	ld b,-1							; b - Command number 											;42f2	06 ff 	. .
 721  42F4
 722  42F4              .compareCmd:
 723  42F4 4E           	ld c,(hl)						; c - first char to check										;42f4	4e 	N
 724  42F5 EB           	ex de,hl						; hl - address in Commands Table, de - point to parsed char 	;42f5	eb 	.
 725  42F6
 726  42F6              .searchNext:
 727  42F6              ; -- find start of DOS command text (with bit 7 set)
 728  42F6 23           	inc hl							; point to next char in Commands Table							;42f6	23 	#
 729  42F7 B6           	or (hl)							; is 7th bit set?												;42f7	b6 	.
 730  42F8 F2 F6 42     	jp p,.searchNext				; no - keep search start of DOS Command							;42f8	f2 f6 42 	. . B
 731  42FB
 732  42FB              ; -- found start of command
 733  42FB 04           	inc b							; b - number of command (00..0d)								;42fb	04 	.
 734  42FC 7E           	ld a,(hl)						; a - 1st char of DOS Command									;42fc	7e 	~
 735  42FD E6 7F        	and %01111111					; clear 7th bit (convert to ascii) - end of table if was $80?	;42fd	e6 7f 	.
 736  42FF 28 C8        	jr z,TryParseMixedSyntax		; yes - try parse "mixed" format BRUN or DCOPY					;42ff	28 c8 	( .
 737  4301              ; -- compare 1st chars
 738  4301 B9           	cp c							; is 1st char of DOS command equal to parsed char?				;4301	b9 	.
 739  4302 20 F2        	jr nz,.searchNext				; no - keep search start of DOS command							;4302	20 f2 	  .
 740  4304
 741  4304              ; -- first char match
 742  4304 EB           	ex de,hl						; de - address in Commands Table, hl - point to parsed char		;4304	eb 	.
 743  4305 E5           	push hl							; save hl - point to parsed char								;4305	e5 	.
 744  4306              .compareNext:
 745  4306 13           	inc de							; point to next char in Commands Table							;4306	13 	.
 746  4307 1A           	ld a,(de)						; a - next char of DOS Command									;4307	1a 	.
 747  4308 B7           	or a							; is bit 7 set? (start of next command name)					;4308	b7 	.
 748  4309 FA 15 43     	jp m,ExecIdxDOSCmd				; yes - execute DOS command determined by index in register b	;4309	fa 15 43 	. . C
 749  430C
 750  430C              ; -- compare next chars
 751  430C 4F           	ld c,a							; c - char of Command from Commands Table						;430c	4f 	O
 752  430D 23           	inc hl							; point to next parsed char										;430d	23 	#
 753  430E 7E           	ld a,(hl)						; a - parsed char												;430e	7e 	~
 754  430F B9           	cp c							; is the same as char from Commands Table?						;430f	b9 	.
 755  4310 28 F4        	jr z,.compareNext				; yes - continue to compare next chars							;4310	28 f4 	( .
 756  4312              ; -- chars differs - try next entry from Commands Table
 757  4312 E1           	pop hl							; restore hl - start of parsed text								;4312	e1 	.
 758  4313 18 DF        	jr .compareCmd					; compare to next DOS Command ---------------------------------	;4313	18 df 	. .
 759  4315
 760  4315
 761  4315              ;***************************************************************************************************
 762  4315              ; Find entry point of DOS Command and Execute it
 763  4315              ; IN: b - index of DOS Command to execute
 764  4315              ExecIdxDOSCmd:
 765  4315 78           	ld a,b							; a - DOS Command index											;4315	78 	x
 766  4316              ; -- clean up stack
 767  4316 C1           	pop bc							; take out value - move CPU stack pointer						;4316	c1 	.
 768  4317 C1           	pop bc							; take out value - move CPU stack pointer						;4317	c1 	.
 769  4318 C1           	pop bc							; take out value - move CPU stack pointer						;4318	c1 	.
 770  4319
 771  4319              ; -- find address of code to execute for this command
 772  4319 CB 27        	sla a							; a - command index * 2 (every table entry has 16bit address) 	;4319	cb 27 	. '
 773  431B 4F           	ld c,a							; c - offset in DOS Command Pointers table						;431b	4f 	O
 774  431C 06 00        	ld b,0							; bc - offset in DOS Command Pointers table						;431c	06 00 	. .
 775  431E EB           	ex de,hl						; de - piont to parsed char										;431e	eb 	.
 776  431F 21 71 43     	ld hl,DOSCmdPointers			; hl - table with pointers for every DOS Command 				;431f	21 71 43 	! q C
 777  4322 09           	add hl,bc						; add offset for DOS Command									;4322	09 	.
 778  4323 4E           	ld c,(hl)						; c - LSB of code address 										;4323	4e 	N
 779  4324 23           	inc hl							; point to next byte with MSB									;4324	23 	#
 780  4325 46           	ld b,(hl)						; bc - address of code to execute for DOS Command				;4325	46 	F
 781  4326
 782  4326
 783  4326              ; IN: de - point to parsed char
 784  4326              ;     bc - address of routine to execute
 785  4326              ExecDOSCmd:
 786  4326 21 1E 1D     	ld hl,SysParseNextExpr			; hl address of System routine to continue run next expression	;4326	21 1e 1d 	! . .
 787  4329 E5           	push hl							; push on stack as return after executing DOS command			;4329	e5 	.
 788  432A EB           	ex de,hl						; hl - next parsed char											;432a	eb 	.
 789  432B 23           	inc hl							; hl - parse point												;432b	23 	#
 790  432C C5           	push bc							; push DOS Command routine address on stack						;432c	c5 	.
 791  432D C9           	ret								; execute code routine ----------------------------------------	;432d	c9 	.
 792  432E
 793  432E
 794  432E
 795  432E              ; **************************************************************************************************
 796  432E              ; DOS Commands Names for Parser
 797  432E              ; First byte of Name has bit 7 set to 1. End of table is marked with byte $80 (0 with 7th bit set).
 798  432E              DOSCmdNames:
 799  432E CC 4F 41 44  	defb 	$80|'L','OAD'			; 00 LOAD			; Load program file from Disk				;432e	cc 4f 41 44 	D
 800  4332 D3 41 56 45  	defb	$80|'S','AVE'			; 01 SAVE			; Save program file to Disk					;4332	d3 41 56 45 	E
 801  4336 CF 50 45 4E  	defb	$80|'O','PEN'			; 02 OPEN			; Open file on Disk to read or write		;4336	cf 50 45 4e 	N
 802  433A C3 4C 4F 53  	defb	$80|'C','LOSE'			; 03 CLOSE			; Close opened file							;433a	c3 4c 4f 53 45 	E
 802  433E 45
 803  433F C2 53 41 56  	defb	$80|'B','SAVE'			; 04 BSAVE			; Save binary file							;433f	c2 53 41 56 45 	E
 803  4343 45
 804  4344 C2 4C 4F 41  	defb	$80|'B','LOAD'			; 05 BLOAD			; Load binary file							;4344	c2 4c 4f 41 44 	D
 804  4348 44
 805  4349 C2 52 55 4E  	defb	$80|'B','RUN'			; 06 BRUN			; Load and Run binary program				;4349	c2 52 55 4e 	N
 806  434D C4 49 52     	defb	$80|'D','IR'			; 05 DIR			; Print Directory (list files)				;434d	c4 49 52 	. I R
 807  4350 C5 52 41     	defb	$80|'E','RA'			; 06 ERA			; Erase (delete) file from Disk				;4350	c5 52 41 	A
 808  4353 D2 45 4E     	defb	$80|'R','EN'			; 07 REN			; Rename file on Disk						;4353	d2 45 4e 	. E N
 809  4356 C9 4E 49 54  	defb	$80|'I','NIT'			; 08 INIT			; Initialize (format) Disk					;4356	c9 4e 49 54 	T
 810  435A C4 52 49 56  	defb	$80|'D','RIVE'			; 09 DRIVE			; Select active Drive						;435a	c4 52 49 56 45 	E
 810  435E 45
 811  435F C9 4E 23     	defb	$80|'I','N#'			; 0A IN#			; Read data from channel # 					;435f	c9 4e 23 	#
 812  4362 D0 52 23     	defb	$80|'P','R#'			; 0B PR#			; Print data to channel #					;4362	d0 52 23 	#
 813  4365 C4 43 4F 50  	defb	$80|'D','COPY'			; 0C DCOPY			; Disk copy									;4365	c4 43 4f 50 59 	Y
 813  4369 59
 814  436A D3 54 41 54  	defb	$80|'S','TATUS'			; 0D STATUS			; Print status of active Disk				;436a	d3 54 41 54 55 53 	S
 814  436E 55 53
 815  4370 80           	defb	$80						; -----------------	; End of Table marker ---------------------	;4370	80 	.
 816  4371
 817  4371              ; **************************************************************************************************
 818  4371              ; DOS Commands Execute Addresses
 819  4371              ; One 16bit address of code to execute per every DOS Command listed in DOSCmdNames Table
 820  4371              DOSCmdPointers:
 821  4371 91 43        	defw	DCmdLOAD				; 00 LOAD			; Load program file from Disk				;4371	91 43 	C
 822  4373 4E 44        	defw	DCmdSAVE				; 01 SAVE			; Save program file to Disk					;4373	4e 44 	D
 823  4375 F5 45        	defw	DCmdOPEN				; 02 OPEN			; Open file on Disk to read or write		;4375	f5 45 	E
 824  4377 DD 47        	defw	DCmdCLOSE				; 03 CLOSE			; Close opened file							;4377	dd 47 	. G 9
 825  4379 39 48        	defw	DCmdBSAVE				; 04 BSAVE			; Save binary file							;4379	39 48 	H
 826  437B C4 48        	defw	DCmdBLOAD				; 05 BLOAD			; Load binary file							;437b	c4 48  	. H .
 827  437D EF 48        	defw	DCmdBRUN				; 06 BRUN			; Load and Run binary program				;437d	ef 48 	H
 828  437F 06 49        	defw	DCmdDIR					; 05 DIR			; Print Directory (list files)				;437f	06 49 	. I
 829  4381 94 49        	defw	DCmdERA					; 06 ERA			; Erase (delete) file from Disk				;4381	94 49 	I
 830  4383 80 4A        	defw	DCmdREN					; 07 REN			; Rename file on Disk						;4383	80 4a 	J
 831  4385 08 4B        	defw	DCmdINIT				; 08 INIT			; Initialize (format) Disk					;4385	08 4b 	K
 832  4387 78 4D        	defw	DCmdDRIVE				; 09 DRIVE			; Select active Drive						;4387	78 4d 	M
 833  4389 92 4D        	defw	DCmdIN#					; 0A IN#			; Read data from channel # 					;4389	92 4d 	M
 834  438B 64 4E        	defw	DCmdPR#					; 0B PR#			; Print data to channel #					;438b	64 4e 	N
 835  438D FB 4F        	defw	DCmdDCOPY				; 0C DCOPY			; Disk copy									;438d	fb 4f 	O
 836  438F D5 52        	defw	DCmdSTATUS				; 0D STATUS			; Print status of active Disk				;438f	d5 52 	R
 837  4391
 838  4391
 839  4391              ;***************************************************************************************************
 840  4391              ; DOS Command LOAD
 841  4391              ; Syntax: LOAD "filaname"
 842  4391              ; -----------------------
 843  4391              ; Load file specified by filename (which has the file type code "T") from a Floppy Disk.
 844  4391              ; Filename may have no more than 8 characters.
 845  4391              ; IN: hl - parse point (just after 'LOAD' text)
 846  4391              DCmdLOAD:
 847  4391              ; -- expected required name of file enclosed with double quote chars
 848  4391              ;    and termianted with \0 or ':' char (end of BASIC expression)
 849  4391 CD 67 53     	call CSI						; parse filename and copy it to (iy+FNAM)						;4391	cd 67 53 	. g S
 850  4394 E5           	push hl							; save hl - parse point											;4394	e5 	.
 851  4395 B7           	or a							; was any Error?												;4395	b7 	.
 852  4396 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4396	c2 41 42 	. A B
 853  4399
 854  4399              ; -- set type of file as BASIC text ('T') and call DOS routine
 855  4399 FD 36 09 54  	ld (iy+TYPE),'T'				; set type of file as BASIC text ('T')							;4399	fd 36 09 54 	. 6 . T
 856  439D CD B1 43     	call LOAD						; Load a file from disk											;439d	cd b1 43 	. . C
 857  43A0 B7           	or a							; was any Error?												;43a0	b7 	.
 858  43A1 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;43a1	c2 41 42 	. A B
 859  43A4
 860  43A4              ; -- print 'READY' on screen
 861  43A4 21 29 19     	ld hl,TXT_READY					; hl - address of 'READY' text in ROM							;43a4	21 29 19 	! ) .
 862  43A7 CD A7 28     	call SysMsgOut					; display text on screen										;43a7	cd a7 28 	. . (
 863  43AA              ; -- push on Stack address of 1st BASIC line and run it
 864  43AA 2A A4 78     	ld hl,(SYS_BASIC_START_PTR)		; start of current BASIC Program 								;43aa	2a a4 78 	* . x
 865  43AD E5           	push hl							; push hl on stack as next thing to parse and run				;43ad	e5 	.
 866  43AE C3 E8 1A     	jp SysSetPrgReady				; Reset BASIC and set BASIC Program ready to run --------------	;43ae	c3 e8 1a 	. . .
 867  43B1
 868  43B1
 869  43B1
 870  43B1
 871  43B1              ;***************************************************************************************************
 872  43B1              ; Load the file specified in IY+FNAM to the memory.
 873  43B1              ;---------------------------------------------------------------------------------------------------
 874  43B1              ; NOTE: Aside from filename, file type, sector and track, directory entry for that file contains
 875  43B1              ; 16-bit addresses of start and end (excluded) of memory area where file will be loaded.
 876  43B1              ; IN: interrups disabled
 877  43B1              ;     (iy+FNAM) - name of the file to load
 878  43B1              ;     (iy+TYPE) - type of the file to load
 879  43B1              ; OUT: a - Error code
 880  43B1              ;      File loaded in memory
 881  43B1              ;***************************************************************************************************
 882  43B1              LOAD:
 883  43B1 F3           	di								; disable interrupts											;43b1	f3 	.
 884  43B2              ; -- turn onn drive and wait 50 ms
 885  43B2 CD 41 5F     	call PWRON						; Disk power ON													;43b2	cd 41 5f 	. A _
 886  43B5 C5           	push bc							; save bc														;43b5	c5 	.
 887  43B6 01 32 00     	ld bc,50						; number of miliseconds to delay								;43b6	01 32 00 	. 2 .
 888  43B9 CD BE 5E     	call DLY						; delay 50 ms													;43b9	cd be 5e 	. . ^
 889  43BC C1           	pop bc							; restore bc													;43bc	c1 	.
 890  43BD
 891  43BD              ; -- try to find file on disk
 892  43BD CD 13 59     	call SEARCH						; Search for file in disk directory								;43bd	cd 13 59 	. . Y
 893  43C0 FE 02        	cp 2							; was Error 02 - FILE ALREADY EXISTS?							;43c0	fe 02 	. .
 894  43C2 CA CA 43     	jp z,.verifyType				; yes - file found - continue and verify file type				;43c2	ca ca 43 	. . C
 895  43C5
 896  43C5              ; -- could be other Error
 897  43C5 B7           	or a							; is any Error?													;43c5	b7 	.
 898  43C6 C0           	ret nz							; yes - ------------- End of Proc (with Error) ----------------	;43c6	c0 	.
 899  43C7
 900  43C7              ; -- no errors means file not found
 901  43C7 3E 0D        	ld a,13							; a - Error 13 - FILE NOT FOUND									;43c7	3e 0d 	> .
 902  43C9 C9           	ret								; ------------------- End of Proc (with Error) ----------------	;43c9	c9 	.
 903  43CA
 904  43CA
 905  43CA              .verifyType:
 906  43CA              ; -- verify file types
 907  43CA FD 7E 09     	ld a,(iy+TYPE)					; a - requested file type										;43ca	fd 7e 09 	. ~ .
 908  43CD FD BE 0A     	cp (iy+TYPE+1)					; is the same as type of file just found?						;43cd	fd be 0a 	. . .
 909  43D0 3E 0C        	ld a,12							; a - Error 12 - FILE TYPE MISMATCH								;43d0	3e 0c 	> .
 910  43D2 C0           	ret nz							; no - ------------------ End of Proc (with Error) ------------	;43d2	c0 	.
 911  43D3
 912  43D3              ; --------------------------------------------------------------------------------------------------
 913  43D3              ; When SEARCH returns with Error 02 (FILE ALREADY EXISTS) it means we have found Directory Entry
 914  43D3              ; with that file. In this case registers are set as:
 915  43D3              ; de - address of file track number (next byte after filename in loaded Directory Entry)
 916  43D3
 917  43D3
 918  43D3              ;***************************************************************************************************
 919  43D3              ; Load program bytes from disk into memory.
 920  43D3              ; File must be type 'T' (BASIC) or 'B' (binary) and directory entry of file must be loaded into buffer.
 921  43D3              ; Directory entry contains: Track Number, Sector Number, Program Start address and Program End Address
 922  43D3              ; IN: de - address in directory entry just after filename (pointing to Track Number)
 923  43D3              LoadProgramData:
 924  43D3              ; -- set track number of Sector to read
 925  43D3 1A           	ld a,(de)						; a - Track Number of file										;43d3	1a 	.
 926  43D4 13           	inc de							; de - address of Sector Number in Directory Entry 				;43d4	13 	.
 927  43D5 FD 77 12     	ld (iy+TRCK),a					; set as requested Track Number									;43d5	fd 77 12 	. w .
 928  43D8
 929  43D8              ; -- set Sector Number of Sector to read
 930  43D8 1A           	ld a,(de)						; a - Sector Number of file										;43d8	1a 	.
 931  43D9 13           	inc de							; de - address of file Start/Load address						;43d9	13 	.
 932  43DA FD 77 11     	ld (iy+SCTR),a					; set as requested Sector Number								;43da	fd 77 11 	. w .
 933  43DD
 934  43DD              ; -- set boundary of memory where file must be loaded
 935  43DD EB           	ex de,hl						; hl - address of file Start/Load address						;43dd	eb 	.
 936  43DE 5E           	ld e,(hl)						; e - LSB of destination address								;43de	5e 	^
 937  43DF 23           	inc hl							; point to MSB of dectination address							;43df	23 	#
 938  43E0 56           	ld d,(hl)						; de - address of memory where load file						;43e0	56 	V
 939  43E1 23           	inc hl							; point to LSB of end of memory area							;43e1	23 	#
 940  43E2
 941  43E2              ; -- set destination address as BASIC program Start and DOS Buffer
 942  43E2 ED 53 A4 78  	ld (SYS_BASIC_START_PTR),de		; store destination program start as BASIC Program Start 		;43e2	ed 53 a4 78 	. S . x
 943  43E6 FD 73 0E     	ld (iy+UBFR),e					; store destination program start as buffer address				;43e6	fd 73 0e 	. s .
 944  43E9 FD 72 0F     	ld (iy+UBFR+1),d																				;43e9	fd 72 0f 	. r .
 945  43EC
 946  43EC              ; -- set end of destination address as BASIC program End
 947  43EC 5E           	ld e,(hl)						; e - LSB of memory address where loaded file ends 				;43ec	5e 	^
 948  43ED 23           	inc hl							; point to MSB of memory address								;43ed	23 	#
 949  43EE 56           	ld d,(hl)						; de - memory address where loaded file ends (excluded)			;43ee	56 	V
 950  43EF ED 53 F9 78  	ld (SYS_BASIC_END_PTR),de		; set address as BASIC Program End								;43ef	ed 53 f9 78 	. S . x
 951  43F3
 952  43F3              ;***************************************************************************************************
 953  43F3              ; File will be loaded chunk by chunk. Every chunk will be 126 bytes from Sector Data.
 954  43F3              ; Two last bytes contains Track and Sector Number of next chunk - next sector to read.
 955  43F3
 956  43F3              ; -- load data chunk
 957  43F3
 958  43F3              .loadFileChunk:
 959  43F3 CD 27 5B     	call READ						; Read a sector from disk										;43f3	cd 27 5b 	. ' [
 960  43F6 B7           	or a							; was it any Error?												;43f6	b7 	.
 961  43F7 C2 41 44     	jp nz,.exitError				; yes - cleanup BASIC addresses and exit with Error				;43f7	c2 41 44 	. A D
 962  43FA
 963  43FA              ; -- no error
 964  43FA FD 6E 31     	ld l,(iy+DBFR)					; 																;43fa	fd 6e 31 	. n 1
 965  43FD FD 66 32     	ld h,(iy+DBFR+1)				; hl - address of buffer with Sector data						;43fd	fd 66 32 	. f 2
 966  4400
 967  4400              ; -- setup track and sector number to read next
 968  4400 E5           	push hl							; save hl - address of Sector data								;4400	e5 	.
 969  4401 11 7E 00     	ld de,126						; only 126 bytes from Sector are File Data chunk				;4401	11 7e 00 	. ~ .
 970  4404 19           	add hl,de						; hl - points to Track Number of Sector with next data chunk	;4404	19 	.
 971  4405 7E           	ld a,(hl)						; a - Track Number of Sector with next data chunk				;4405	7e 	~
 972  4406 23           	inc hl							; hl - points to Number of Sector with next data chunk			;4406	23 	#
 973  4407 FD 77 12     	ld (iy+TRCK),a					; set Track Number to read next									;4407	fd 77 12 	. w .
 974  440A 7E           	ld a,(hl)						; a - Number of Sector with next data chunk						;440a	7e 	~
 975  440B FD 77 11     	ld (iy+SCTR),a					; set Sector Number to read next								;440b	fd 77 11 	. w .
 976  440E E1           	pop hl							; restore hl - address with Sector data							;440e	e1 	.
 977  440F
 978  440F              ; -- copy program chunk from Sector Buffer to destination memory
 979  440F FD 5E 0E     	ld e,(iy+UBFR)																					;440f	fd 5e 0e 	. ^ .
 980  4412 FD 56 0F     	ld d,(iy+UBFR+1)				; de - destination address to copy program chunk				;4412	fd 56 0f 	. V .
 981  4415 01 7E 00     	ld bc,126						; 126 bytes to copy	(full sector w/o linking to next data)		;4415	01 7e 00 	. ~ .
 982  4418
 983  4418              ; -- if next track and sector equals 0 than this is last sector
 984  4418              ; -- size of data in last sector can be smaller than 126 bytes
 985  4418 FD 7E 12     	ld a,(iy+TRCK)					; a - next Track Number											;4418	fd 7e 12 	. ~ .
 986  441B FD B6 11     	or (iy+SCTR)					; is track and sector numbers = 0?								;441b	fd b6 11 	. . .
 987  441E 28 10        	jr z,.loadLastChunk				; yes - need calculate how many bytes to copy					;441e	28 10 	( .
 988  4420
 989  4420              ; -- not last sector - copy data
 990  4420 ED B0        	ldir							; copy 126 bytes to memory										;4420	ed b0 	. .
 991  4422              ; -- update destination address for next program chunk
 992  4422 FD 73 0E     	ld (iy+UBFR),e					; store LSB of destination address								;4422	fd 73 0e 	. s .
 993  4425 FD 72 0F     	ld (iy+UBFR+1),d				; store MSB of destination address								;4425	fd 72 0f 	. r .
 994  4428
 995  4428              ; -- check if it was last sector (Z=1)
 996  4428 FD 7E 12     	ld a,(iy+TRCK)					; a - next Track number											;4428	fd 7e 12 	. ~ .
 997  442B FD B6 11     	or (iy+SCTR)					; is track and sector numbers both are 0?						;442b	fd b6 11 	. . .
 998  442E 18 C3        	jr .loadFileChunk				; red next file chunk from next sector ------------------------	;442e	18 c3 	. .
 999  4430
1000  4430
1001  4430              .loadLastChunk:
1002  4430              ; -- calculate how many bytes left in last sector
1003  4430 E5           	push hl							; save hl - address of loaded sector data						;4430	e5 	.
1004  4431 2A F9 78     	ld hl,(SYS_BASIC_END_PTR)		; hl - address of program end 									;4431	2a f9 78 	* . x
1005  4434 B7           	or a							; clear Carry flag												;4434	b7 	.
1006  4435 ED 52        	sbc hl,de						; subtract address of program chunk start, hl - data size 		;4435	ed 52 	. R
1007  4437 4D           	ld c,l							; copy hl to bc													;4437	4d 	M
1008  4438 44           	ld b,h							; bc - number of chunk bytes to copy							;4438	44 	D
1009  4439 E1           	pop hl							; restore hl - address of loaded sector data					;4439	e1 	.
1010  443A              ; -- copy bc bytes from memory pointed by hl to memory pointed by de
1011  443A ED B0        	ldir							; copy chunk of file											;443a	ed b0 	. .
1012  443C              ; -- file loaded - turn off Drive and return with No Error
1013  443C CD 52 5F     	call PWROFF						; Disk power OFF												;443c	cd 52 5f 	. R _
1014  443F AF           	xor a							; a - Error 0 - NO ERROR										;443f	af 	.
1015  4440 C9           	ret								; -------------------- End of Proc ----------------------------	;4440	c9 	.
1016  4441
1017  4441
1018  4441              ; -- Clear BASIC Program addresses and Exit with error in a register
1019  4441              .exitError:
1020  4441 2A A4 78     	ld hl,(SYS_BASIC_START_PTR)		; hl - start of BASIC Program									;4441	2a a4 78 	* . x
1021  4444              ; -- put 0000 as End of BASIC mark
1022  4444 36 00        	ld (hl),0						; store LSB of 0000												;4444	36 00 	6 .
1023  4446 23           	inc hl							; point to next byte											;4446	23 	#
1024  4447 36 00        	ld (hl),0						; store MSB of 0000												;4447	36 00 	6 .
1025  4449 23           	inc hl							; hl - next address after End of BASIC							;4449	23 	#
1026  444A 22 F9 78     	ld (SYS_BASIC_END_PTR),hl		; store as End of current BASIC Program address					;444a	22 f9 78 	" . x
1027  444D C9           	ret								; --------------- End of Proc (with Error) --------------------	;444d	c9 	.
1028  444E
1029  444E
1030  444E
1031  444E
1032  444E
1033  444E              ;***************************************************************************************************
1034  444E              ; DOS Command SAVE
1035  444E              ; Syntax: SAVE "filaname"
1036  444E              ; -----------------------
1037  444E              ; Save BASIC program from memory to one file specified by filename (which will have file type code "T")
1038  444E              ; on Disk. Filename may have no more than 8 characters.
1039  444E              ; IN: hl - parse point (just after 'SAVE' text)
1040  444E              DCmdSAVE:
1041  444E              ; -- expected required name of file enclosed with double quote chars and terminated with \0 or ':'
1042  444E CD 67 53     	call CSI						; parse filename and copy it to (iy+FNAM)						;444e	cd 67 53 	. g S
1043  4451 E5           	push hl							; save hl - parse point											;4451	e5 	.
1044  4452 B7           	or a							; was any Error?												;4452	b7 	.
1045  4453 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4453	c2 41 42 	. A B
1046  4456
1047  4456              ; -- turn on Disk Drive and wait 2 ms
1048  4456 CD 41 5F     	call PWRON						; Disk power ON													;4456	cd 41 5f 	. A _
1049  4459 C5           	push bc							; save bc 														;4459	c5 	.
1050  445A 01 02 00     	ld bc,2							; bc - 2 miliseconds to delay									;445a	01 02 00 	. . .
1051  445D CD BE 5E     	call DLY						; delay 2 ms 													;445d	cd be 5e 	. . ^
1052  4460 C1           	pop bc							; restore bc													;4460	c1 	.
1053  4461
1054  4461              ; -- check if Disk is not Write-Protected
1055  4461 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;4461	db 13 	. .
1056  4463 B7           	or a							; is bit 7 set? (write protected)								;4463	b7 	.
1057  4464 3E 04        	ld a,04							; a - Error 04 - DISK WRITE PROTECTED							;4464	3e 04 	> .
1058  4466 FA 41 42     	jp m,ERROR						; yes - go to Error handling routine --------------------------	;4466	fa 41 42 	. A B
1059  4469
1060  4469              ; -- set type of file as BASIC text ('T') and continue as DOS routine
1061  4469 FD 36 09 54  	ld (iy+TYPE),'T'				; set type of file as BASIC text ('T')							;4469	fd 36 09 54 	. 6 . T
1062  446D E1           	pop hl							; restore hl - parse point										;446d	e1 	.
1063  446E
1064  446E
1065  446E
1066  446E              ;***************************************************************************************************
1067  446E              ; Save program or memory to disk.
1068  446E              ;---------------------------------------------------------------------------------------------------
1069  446E              ; Program or menory block is sepcified by start address in (SYS_BASIC_START_PTR)
1070  446E              ; end end address in (SYS_BASIC_END_PTR).
1071  446E              ; It will be saved fo file specified by name in (iy+FNAM) and type in (iy+TYPE).
1072  446E              ; IN: (iy+FNAM) - filename to save
1073  446E              ;     (iy+TYPE) - type of file
1074  446E              ;     (SYS_BASIC_START_PTR) - memory address where program starts
1075  446E              ;     (SYS_BASIC_END_PTR) - memory address where program ends (excluded)
1076  446E              ; OUT: a - Error code
1077  446E              ;***************************************************************************************************
1078  446E              SAVE:
1079  446E              ; -- save start and end of Program for future restore
1080  446E ED 5B F9 78  	ld de,(SYS_BASIC_END_PTR)		; end of current BASIC Program 									;446e	ed 5b f9 78 	. [ . x
1081  4472 D5           	push de							; save de - end of Program										;4472	d5 	.
1082  4473 ED 5B A4 78  	ld de,(SYS_BASIC_START_PTR)		; start of current BASIC Program 								;4473	ed 5b a4 78 	. [ . x
1083  4477 D5           	push de							; save de - start of Program									;4477	d5 	.
1084  4478 E5           	push hl							; save hl - 													;4478	e5 	.
1085  4479
1086  4479              DoSaveFile:
1087  4479 F3           	di								; disable interrupts											;4479	f3 	.
1088  447A              ; -- delay 50 ms
1089  447A C5           	push bc							; save bc 														;447a	c5 	.
1090  447B 01 32 00     	ld bc,50						; bc - number of miliseconds to delay							;447b	01 32 00 	. 2 .
1091  447E CD BE 5E     	call DLY						; delay 50 ms													;447e	cd be 5e 	. . ^
1092  4481 C1           	pop bc							; restore bc													;4481	c1 	.
1093  4482
1094  4482              ; -- setup address of Program as data source
1095  4482 ED 5B A4 78  	ld de,(SYS_BASIC_START_PTR)		; de - start of current BASIC Program 							;4482	ed 5b a4 78 	. [ . x
1096  4486 FD 73 0E     	ld (iy+UBFR),e					; store LSB of address											;4486	fd 73 0e 	. s .
1097  4489 FD 72 0F     	ld (iy+UBFR+1),d				; set Program address as Copy Buffer (source)					;4489	fd 72 0f 	. r .
1098  448C
1099  448C              ; -- read Disk Allocation Map
1100  448C FD 36 12 00  	ld (iy+TRCK),0					; Track 0 contains Sector with Disk Map							;448c	fd 36 12 00 	. 6 . .
1101  4490 FD 36 11 0F  	ld (iy+SCTR),15					; Sector 15 (on track 0) contains Disk Map						;4490	fd 36 11 0f 	. 6 . .
1102  4494 CD 27 5B     	call READ						; Read Disk Map into Sector Buffer from disk					;4494	cd 27 5b 	. ' [
1103  4497 B7           	or a							; was any Error?												;4497	b7 	.
1104  4498 C2 9A 48     	jp nz,SAVE_ExitError			; yes -  exit with Error --------------------------------------	;4498	c2 9a 48 	. . H
1105  449B
1106  449B              ; -- no error - copy Disk Map from Sector Buffer to Map Buffer
1107  449B FD 5E 34     	ld e,(iy+MAPADR)																				;449b	fd 5e 34 	. ^ 4
1108  449E FD 56 35     	ld d,(iy+MAPADR+1)				; de - (dst) buffer for Disk Map								;449e	fd 56 35 	. V 5
1109  44A1 FD 6E 31     	ld l,(iy+DBFR)																					;44a1	fd 6e 31 	. n 1
1110  44A4 FD 66 32     	ld h,(iy+DBFR+1)				; hl - (src) buffer with sector data							;44a4	fd 66 32 	. f 2
1111  44A7 01 50 00     	ld bc,80						; bc - number of bytes to copy									;44a7	01 50 00 	. P .
1112  44AA ED B0        	ldir							; copy Disk Map 												;44aa	ed b0 	. .
1113  44AC              ; -- create Directory Entry for file
1114  44AC CD 7B 58     	call CREATE						; Create an entry in directory									;44ac	cd 7b 58 	. { X
1115  44AF B7           	or a							; was any Error?												;44af	b7 	.
1116  44B0 C2 9A 48     	jp nz,SAVE_ExitError			; yes -  exit with Error --------------------------------------	;44b0	c2 9a 48 	. . H
1117  44B3
1118  44B3              ; -- Directory Entry was created for this file
1119  44B3              ; NTRK and NSCT contains values for sector alloacated for chunk of file data
1120  44B3              ;
1121  44B3
1122  44B3              .writeNextChunk:
1123  44B3              ; -- check next Track and Sector - if 0 then last sector has been written
1124  44B3 FD 7E 16     	ld a,(iy+NTRK)					; a - track numer for first free sector							;44b3	fd 7e 16 	. ~ .
1125  44B6 FD B6 15     	or (iy+NSCT)					; track and sector numbers are 0? (no free sectors)				;44b6	fd b6 15 	. . .
1126  44B9 CA 7C 45     	jp z,.finalizeSave				; yes - finalize save (update dir entry, disk map, etc)			;44b9	ca 7c 45 	. | E
1127  44BC
1128  44BC              ; -- save track and sector numbers allocated for 1st chunk of file
1129  44BC FD 56 16     	ld d,(iy+NTRK)					; d - Track Number for chunk of file 							;44bc	fd 56 16 	. V .
1130  44BF FD 5E 15     	ld e,(iy+NSCT)					; e - Sector Number for chunk of file 							;44bf	fd 5e 15 	. ^ .
1131  44C2
1132  44C2              ; -- check if there is free space on Disk for next sector
1133  44C2 CD BF 58     	call MAP						; search for empty sector in Disk Map							;44c2	cd bf 58 	. . X
1134  44C5 FE 07        	cp 7							; was Error 07 - DISK FULL?										;44c5	fe 07 	. .
1135  44C7 20 19        	jr nz,.checkOtherError			; no - check if other error										;44c7	20 19 	  .
1136  44C9
1137  44C9              ; -- disk full
1138  44C9 CD 13 59     	call SEARCH						; Search for file in directory									;44c9	cd 13 59 	. . Y
1139  44CC FE 02        	cp 2							; is Error 02 - FILE ALREADY EXISTS?							;44cc	fe 02 	. .
1140  44CE 3E 06        	ld a,6							; a - Error 6 - DISK I/O ERROR									;44ce	3e 06 	> .
1141  44D0 C2 9A 48     	jp nz,SAVE_ExitError			; no - exit with Error 06 -------------------------------------	;44d0	c2 9a 48 	. . H
1142  44D3
1143  44D3              ; -- disk full but file exists on Disk - mark it as deleted
1144  44D3 EB           	ex de,hl						; hl - address in Directory Entry (after filename)				;44d3	eb 	.
1145  44D4 11 F6 FF     	ld de,-10						; de - 10 bytes to begin of Dir Entry (filetype byte)			;44d4	11 f6 ff 	. . .
1146  44D7 19           	add hl,de						; hl - address of FileType byte in Dir Entry					;44d7	19 	.
1147  44D8 36 01        	ld (hl),1						; set FileType as deleted										;44d8	36 01 	6 .
1148  44DA CD A1 59     	call WRITE						; Write a sector with Directory to disk							;44da	cd a1 59 	. . Y
1149  44DD 3E 07        	ld a,7							; a - Error 07 - DISK FULL										;44dd	3e 07 	> .
1150  44DF C3 9A 48     	jp SAVE_ExitError				; exit with Error 07 ------------------------------------------	;44df	c3 9a 48 	. . H
1151  44E2
1152  44E2              .checkOtherError:
1153  44E2 B7           	or a							; was any Error (after Find Empty Sector)?						;44e2	b7 	.
1154  44E3 C2 9A 48     	jp nz,SAVE_ExitError			; yes - exit with Error ---------------------------------------	;44e3	c2 9a 48 	. . H
1155  44E6
1156  44E6              ; -- setup destination sector to write file chunk
1157  44E6 FD 72 12     	ld (iy+TRCK),d					; set Track Number												;44e6	fd 72 12 	. r .
1158  44E9 FD 73 11     	ld (iy+SCTR),e					; set Sector Number												;44e9	fd 73 11 	. s .
1159  44EC
1160  44EC              ; -- prepare sector buffer
1161  44EC FD 6E 31     	ld l,(iy+DBFR)					; 																;44ec	fd 6e 31 	. n 1
1162  44EF FD 66 32     	ld h,(iy+DBFR+1)				; hl - address of Sector buffer									;44ef	fd 66 32 	. f 2
1163  44F2 E5           	push hl							; save hl - address of Sector Buffer							;44f2	e5 	.
1164  44F3              ; -- fill with 0 bytes
1165  44F3 5D           	ld e,l							; copy hl to de													;44f3	5d 	]
1166  44F4 54           	ld d,h							; de - address of buffer 										;44f4	54 	T
1167  44F5 13           	inc de							; start from 2nd byte											;44f5	13 	.
1168  44F6 36 00        	ld (hl),0						; store 0 in 1st byte											;44f6	36 00 	6 .
1169  44F8 01 80 00     	ld bc,128						; 128 bytes to clear 											;44f8	01 80 00 	. . .
1170  44FB ED B0        	ldir							; fill buffer with 0 values										;44fb	ed b0 	. .
1171  44FD
1172  44FD              ; -- get address of data chunk
1173  44FD FD 6E 0E     	ld l,(iy+UBFR)					; hl - address of data chunk to write on Disk					;44fd	fd 6e 0e 	. n .
1174  4500 FD 66 0F     	ld h,(iy+UBFR+1)				; 																;4500	fd 66 0f 	. f .
1175  4503 E5           	push hl							; save hl - address of data chunk								;4503	e5 	.
1176  4504              ; -- determine chunk length
1177  4504 ED 5B F9 78  	ld de,(SYS_BASIC_END_PTR)		; de - address of Program end 									;4504	ed 5b f9 78 	. [ . x
1178  4508 B7           	or a							; clear Carry flag												;4508	b7 	.
1179  4509 ED 52        	sbc hl,de						; hl - negative offset from end of data to write				;4509	ed 52 	. R
1180  450B D2 3A 45     	jp nc,.writeLastSector			; if it's positive or 0? (start >= end)							;450b	d2 3a 45 	. : E
1181  450E
1182  450E              ; -- maximum 126 bytes per sector
1183  450E 11 7E 00     	ld de,126						; 126 bytes can be write to one sector 							;450e	11 7e 00 	. ~ .
1184  4511 19           	add hl,de						; add 126 to negative offset - negative offset for next chunk	;4511	19 	.
1185  4512 DA 76 45     	jp c,.partialSector				; if positive then less than 126 bytes to write					;4512	da 76 45 	. v E
1186  4515
1187  4515              ; -- full sector with 126 bytes of data
1188  4515              ; -- store start of next chunk
1189  4515 ED 5B F9 78  	ld de,(SYS_BASIC_END_PTR)		; end of data to write											;4515	ed 5b f9 78 	. [ . x
1190  4519 19           	add hl,de						; add negative offset - address of next chunk of data			;4519	19 	.
1191  451A FD 75 0E     	ld (iy+UBFR),l					; store address of next chunk of data							;451a	fd 75 0e 	. u .
1192  451D FD 74 0F     	ld (iy+UBFR+1),h																				;451d	fd 74 0f 	. t .
1193  4520
1194  4520              ; -- copy 126 bytes of program to Sector Buffer
1195  4520 E1           	pop hl							; hl - address of data block to write							;4520	e1 	.
1196  4521 D1           	pop de							; de - address of Sector Buffer									;4521	d1 	.
1197  4522 01 7E 00     	ld bc,126						; bc - 126 bytes to copy										;4522	01 7e 00 	. ~ .
1198  4525 ED B0        	ldir							; copy program data to sector buffer							;4525	ed b0 	. .
1199  4527              ; -- store link - next Track and Sector Number into last 2 bytes of sector
1200  4527 FD 7E 16     	ld a,(iy+NTRK)					; a - Track Number of sector for next chunk of file 			;4527	fd 7e 16 	. ~ .
1201  452A 12           	ld (de),a						; store Track number as 127th byte of sector					;452a	12 	.
1202  452B 13           	inc de							; de - points to 128th byte of sector							;452b	13 	.
1203  452C FD 7E 15     	ld a,(iy+NSCT)					; a - Sector NUmber for next chunk of file						;452c	fd 7e 15 	. ~ .
1204  452F 12           	ld (de),a						; store Sector NUmber as 128th byte of sector					;452f	12 	.
1205  4530
1206  4530              .flushSector:
1207  4530 CD A1 59     	call WRITE						; Write a sector to disk										;4530	cd a1 59 	. . Y
1208  4533 B7           	or a							; was any Error?												;4533	b7 	.
1209  4534 C2 9A 48     	jp nz,SAVE_ExitError			; yes - exit with Error ---------------------------------------	;4534	c2 9a 48 	. . H
1210  4537 C3 B3 44     	jp .writeNextChunk				; no - write next chunk of data -------------------------------	;4537	c3 b3 44 	. . D
1211  453A
1212  453A
1213  453A              .writeLastSector:
1214  453A E5           	push hl							; save hl - number of bytes to write 							;453a	e5 	.
1215  453B              ; -- get Disk Map address
1216  453B FD 6E 34     	ld l,(iy+MAPADR)																				;453b	fd 6e 34 	. n 4
1217  453E FD 66 35     	ld h,(iy+MAPADR+1)				; hl - address of Disk Map 										;453e	fd 66 35 	. f 5
1218  4541              ; -- calculate byte offset
1219  4541 FD 7E 16     	ld a,(iy+NTRK)					; a - Track Number of sector for next chunk of file				;4541	fd 7e 16 	. ~ .
1220  4544 3D           	dec a							; a = a -1 (Disk Map covers sectors from track 1)				;4544	3d 	=
1221  4545 CB 27        	sla a							; track * 2 (2 bytes in Map covers 1 track)						;4545	cb 27 	. '
1222  4547 5F           	ld e,a							; e - offset in Disk Map for Track								;4547	5f 	_
1223  4548 16 00        	ld d,0							; de - offset in Disk Map for Track								;4548	16 00 	. .
1224  454A FD 7E 15     	ld a,(iy+NSCT)					; a - Sector number for next chunk of file						;454a	fd 7e 15 	. ~ .
1225  454D FE 08        	cp 8							; set Carry flag if Sector < 8 									;454d	fe 08 	. .
1226  454F 3F           	ccf								; invert Carry - will be 1 if Sector >= 8 						;454f	3f 	?
1227  4550 ED 5A        	adc hl,de						; hl - address in Disk Map of bitmask with this sector			;4550	ed 5a 	. Z
1228  4552              ; -- calculate bit number
1229  4552 E6 07        	and %0111						; a - bit number for this sector								;4552	e6 07 	. .
1230  4554 3C           	inc a							; preincrement for number of rotates 1..8						;4554	3c 	<
1231  4555 47           	ld b,a							; b - how many times to rotate bitmask							;4555	47 	G
1232  4556              ; -- reset bit for this sector (not used)
1233  4556 4E           	ld c,(hl)						; c - bitmask with this sector									;4556	4e 	N
1234  4557 CB 01        	rlc c							; pre-rotate left (set Carry from 7th bit)						;4557	cb 01 	. .
1235  4559              .loop1:
1236  4559 CB 09        	rrc c							; rotate right bitmask											;4559	cb 09 	. .
1237  455B 10 FC        	djnz .loop1						; keep rotate until bit is at position 0						;455b	10 fc 	. .
1238  455D CB 81        	res 0,c							; clear bit for this sector										;455d	cb 81 	. .
1239  455F 47           	ld b,a							; b - number of rotates to do									;455f	47 	G
1240  4560 CB 09        	rrc c							; pre-rotate right (set Carry from 0th bit)						;4560	cb 09 	. .
1241  4562              .loop2:
1242  4562 CB 01        	rlc c							; rotate left bitmask											;4562	cb 01 	. .
1243  4564 10 FC        	djnz .loop2						; keep rotate until bit returns to its original position		;4564	10 fc 	. .
1244  4566 71           	ld (hl),c						; store updated byte to Disk Map								;4566	71 	q
1245  4567              ; -- copy last chunk of data into sector buffer
1246  4567 C1           	pop bc							; bc - number of bytes to copy									;4567	c1 	.
1247  4568 E1           	pop hl							; hl - address of last chunk of data							;4568	e1 	.
1248  4569 D1           	pop de							; de - sector buffer address									;4569	d1 	.
1249  456A ED B0        	ldir							; copy last chunk of data to Sector buffer						;456a	ed b0 	. .
1250  456C              ; -- set it was last chunk of file
1251  456C FD 36 16 00  	ld (iy+NTRK),0					; set next track to 0 (no next sector)							;456c	fd 36 16 00 	. 6 . .
1252  4570 FD 36 15 00  	ld (iy+NSCT),0					; set next sectro to 0 (no next sector)							;4570	fd 36 15 00 	. 6 . .
1253  4574 18 BA        	jr .flushSector					; write sector to Disk and continue ---------------------------	;4574	18 ba 	. .
1254  4576
1255  4576
1256  4576              .partialSector:
1257  4576 EB           	ex de,hl						; de - bytes above end of data, hl - chunk length (126)			;4576	eb 	.
1258  4577 B7           	or a							; clear Carry Flag												;4577	b7 	.
1259  4578 ED 52        	sbc hl,de						; hl - length of partial chunk (less than 126)					;4578	ed 52 	. R
1260  457A 18 BE        	jr .writeLastSector				; write as last sector (126 bytes or less)						;457a	18 be 	. .
1261  457C
1262  457C
1263  457C              ; -- all data stored on Disk
1264  457C              .finalizeSave:
1265  457C CD 13 59     	call SEARCH						; Search for file in directory									;457c	cd 13 59 	. . Y
1266  457F FE 02        	cp 2							; was Error 2 - FILE ALREADY EXISTS								;457f	fe 02 	. .
1267  4581 C2 9A 48     	jp nz,SAVE_ExitError			; no - exit with Error ----------------------------------------	;4581	c2 9a 48 	. . H
1268  4584
1269  4584              ; -- file found - update Directory Entry
1270  4584 13           	inc de							; skip track number	byte 										;4584	13 	.
1271  4585 13           	inc de							; skip sector number byte										;4585	13 	.
1272  4586              ; -- update program start address
1273  4586 2A A4 78     	ld hl,(SYS_BASIC_START_PTR)		; hk - start of current BASIC Program							;4586	2a a4 78 	* . x
1274  4589 EB           	ex de,hl						; de - program start, hl - address in Directory Entry 			;4589	eb 	.
1275  458A 73           	ld (hl),e						; store LSB of program start									;458a	73 	s
1276  458B 23           	inc hl							; point to MSB													;458b	23 	#
1277  458C 72           	ld (hl),d						; store MSB of program start									;458c	72 	r
1278  458D 23           	inc hl							; point to program end in Directory Entry						;458d	23 	#
1279  458E              ; -- update program end address
1280  458E EB           	ex de,hl						; exchange de and hl											;458e	eb 	.
1281  458F 2A F9 78     	ld hl,(SYS_BASIC_END_PTR)		; hl - end of current BASIC Program 							;458f	2a f9 78 	* . x
1282  4592 EB           	ex de,hl						; de - program end, hl - address in Directory Entry 			;4592	eb 	.
1283  4593 73           	ld (hl),e						; store LSB of program end										;4593	73 	s
1284  4594 23           	inc hl							; point to MSB													;4594	23 	#
1285  4595 72           	ld (hl),d						; store MSB of program end										;4595	72 	r
1286  4596              ; -- write directory entry to Disk
1287  4596 CD A1 59     	call WRITE						; Write a sector with Directory to Disk							;4596	cd a1 59 	. . Y
1288  4599 B7           	or a							; was any Error?												;4599	b7 	.
1289  459A C2 9A 48     	jp nz,SAVE_ExitError			; yes - exit with Error ---------------------------------------	;459a	c2 9a 48 	. . H
1290  459D
1291  459D              ; -- update Disk Map sector
1292  459D
1293  459D              ; -- clear data buffer (fill with 0 bytes)
1294  459D FD 6E 31     	ld l,(iy+DBFR)					; hl - address of data buffer									;459d	fd 6e 31 	. n 1
1295  45A0 FD 66 32     	ld h,(iy+DBFR+1)																				;45a0	fd 66 32 	. f 2
1296  45A3 E5           	push hl							; save hl - address of data buffer								;45a3	e5 	.
1297  45A4 5D           	ld e,l							; copy hl to de (destination)									;45a4	5d 	]
1298  45A5 54           	ld d,h																							;45a5	54 	T
1299  45A6 13           	inc de							; de - points to 2nd byte of buffer								;45a6	13 	.
1300  45A7 36 00        	ld (hl),0						; store 0 in 1st byte of buffer									;45a7	36 00 	6 .
1301  45A9 01 80 00     	ld bc,128						; bc - 128 bytes to fill										;45a9	01 80 00 	. . .
1302  45AC ED B0        	ldir							; fill data buffer with 0										;45ac	ed b0 	. .
1303  45AE              ; -- copy disk Map into data buffer
1304  45AE E1           	pop hl							; restore hl - address of data buffer							;45ae	e1 	.
1305  45AF FD 5E 34     	ld e,(iy+MAPADR)				; de - address of Disk Map data									;45af	fd 5e 34 	. ^ 4
1306  45B2 FD 56 35     	ld d,(iy+MAPADR+1)																				;45b2	fd 56 35 	. V 5
1307  45B5 EB           	ex de,hl						; de - data buffer (dst), hl - Disk Map data (src)				;45b5	eb 	.
1308  45B6 01 50 00     	ld bc,80						; bc - 80 bytes to copy											;45b6	01 50 00 	. P .
1309  45B9 ED B0        	ldir							; copy Disk Map into data buffer								;45b9	ed b0 	. .
1310  45BB              ; -- write Disk Map into Disk
1311  45BB FD 36 12 00  	ld (iy+TRCK),0					; set Track Number 0											;45bb	fd 36 12 00 	. 6 . .
1312  45BF FD 36 11 0F  	ld (iy+SCTR),15					; set Sector Number 15											;45bf	fd 36 11 0f 	. 6 . .
1313  45C3 CD A1 59     	call WRITE						; Write a sector to disk										;45c3	cd a1 59 	. . Y
1314  45C6              ; -- turn off disk drive
1315  45C6 F5           	push af							; save a - error code after Write Sector						;45c6	f5 	.
1316  45C7 CD 52 5F     	call PWROFF						; Disk power OFF												;45c7	cd 52 5f 	. R _
1317  45CA F1           	pop af							; restore a - error code after Write Sector						;45ca	f1 	.
1318  45CB
1319  45CB              ; -- restore BASIC variables
1320  45CB E1           	pop hl							; restore hl - 													;45cb	e1 	.
1321  45CC D1           	pop de							; restore de - BASIC Program Start								;45cc	d1 	.
1322  45CD ED 53 A4 78  	ld (SYS_BASIC_START_PTR),de		; store into start of current BASIC Program variable			;45cd	ed 53 a4 78 	. S . x
1323  45D1 D1           	pop de							; restore de - BASIC Program End								;45d1	d1 	.
1324  45D2 ED 53 F9 78  	ld (SYS_BASIC_END_PTR),de		; store into end of current BASIC Program variable				;45d2	ed 53 f9 78 	. S . x
1325  45D6              ; -- exit
1326  45D6 B7           	or a							; was any Error after Write Disk Map to Disk?					;45d6	b7 	.
1327  45D7 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine							;45d7	c2 41 42 	. A B
1328  45DA C9           	ret								; ----------------- End of Proc -------------------------------	;45da	c9 	.
1329  45DB
1330  45DB
1331  45DB
1332  45DB              LoadAndRunFile:
1333  45DB CD 67 53     	call CSI						; Parse filename typed by user									;45db	cd 67 53 	. g S
1334  45DE E5           	push hl							; save hl - next char after filename (parser pointer)			;45de	e5 	.
1335  45DF B7           	or a							; was any error?												;45df	b7 	.
1336  45E0 C2 41 42     	jp nz,ERROR						; yes - goto Error handling routine	---------------------------	;45e0	c2 41 42 	. A B
1337  45E3              ; -- valid filename detected
1338  45E3 FD 36 09 54  	ld (iy+TYPE),'T'				; set File Type 'T' - BASIC text program						;45e3	fd 36 09 54 	. 6 . T
1339  45E7 CD B1 43     	call LOAD					; Load a file from disk											;45e7	cd b1 43 	. . C
1340  45EA B7           	or a							; was any Error?												;45ea	b7 	.
1341  45EB C2 41 42     	jp nz,ERROR						; yes - goto Error handling routine	---------------------------	;45eb	c2 41 42 	. A B
1342  45EE ED 5B A4 78  	ld de,(SYS_BASIC_START_PTR)		; de - start of current BASIC Program 							;45ee	ed 5b a4 78 	. [ . x
1343  45F2 C3 E9 36     	jp SysExecRUN					; Execute BASIC RUN command - start from address in de --------	;45f2	c3 e9 36 	. . 6
1344  45F5
1345  45F5
1346  45F5
1347  45F5              ;***************************************************************************************************
1348  45F5              ; DOS Command OPEN
1349  45F5              ; Syntax: OPEN "filaname",mode
1350  45F5              ;         mode - 0 read, 1 - write
1351  45F5              ; ----------------------------
1352  45F5              ; Open file specified by "filename" (which has the file type code "D") for Read or Write.
1353  45F5              ; Argument mode must be 0 (for read) or 1 (for write). After open file is ready to read from
1354  45F5              ; via DOS command 'IN#' or to write to via DOS command 'PR#'
1355  45F5              ; NOTE: This command must always be used from inside BASIC program.
1356  45F5              ; IN: hl - parse point
1357  45F5              DCmdOPEN:
1358  45F5              ; -- throw ILLEGAL DIRECT Error if current BASIC line <> FFFF
1359  45F5 CD 28 28     	call SysCheckIllegalDirect		; verify command used from BASIC program 						;45f5	cd 28 28 	. ( (
1360  45F8
1361  45F8              ; -- parse first argument - filename
1362  45F8 CD 78 53     	call ParseFilename				; Verify syntax and copy filename to DOS Filename Buffer		;45f8	cd 78 53 	. x S
1363  45FB E5           	push hl							; save hl - points to next char after filename					;45fb	e5 	.
1364  45FC B7           	or a							; was any Error?												;45fc	b7 	.
1365  45FD C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine							;45fd	c2 41 42 	. A B
1366  4600 F1           	pop af							; take value from CPU stack - adjust CPU Stack Pointer			;4600	f1 	.
1367  4601
1368  4601              ; -- parse next char - must be ','
1369  4601 CF           	rst 8							; verify this char is ',' (comma) and point hl to next			;4601	cf 	.
1370  4602 2C           	defb ','						; expected char													;4602	2c 	,
1371  4603
1372  4603              ; -- parse next argument - accrss mode
1373  4603 CD 1C 2B     	call SysEvalByteExpr			; a - parsed integer value										;4603	cd 1c 2b 	. . +
1374  4606 B7           	or a							; is it 0? (open file to read)									;4606	b7 	.
1375  4607 28 05        	jr z,.continue					; yes - set Access mode flag and continue						;4607	28 05 	( .
1376  4609 FE 02        	cp 2							; is it 2 or greater? (invalid mode)							;4609	fe 02 	. .
1377  460B D2 4A 1E     	jp nc,SysErrRaiseFuncCode		; yes - Raise BASIC FUNCTION CODE Error							;460b	d2 4a 1e 	. J .
1378  460E
1379  460E              ; -- open to read
1380  460E              .continue:
1381  460E FD 77 0C     	ld (iy+RQST),a					; store access type (read or write) 							;460e	fd 77 0c 	. w .
1382  4611 E5           	push hl							; save hl -  points to next char after mode 					;4611	e5 	.
1383  4612              ; -- check if file is already opened
1384  4612 CD 78 47     	call FindFCBForOpen				; Find FCB Block to use or get one if file already opened		;4612	cd 78 47 	. x G
1385  4615 FE 05        	cp 05							; was Error 05   FILE NOT OPEN? (means OK)						;4615	fe 05 	. .
1386  4617              ; -- File is already opened or both FCB are used
1387  4617 C2 41 42     	jp nz,ERROR						; no - go to Error handling routine	---------------------------	;4617	c2 41 42 	. A B
1388  461A
1389  461A              ; -- flush sector data if any FCB has file Opened for Write
1390  461A E5           	push hl							; save hl - address of File Control Block to use				;461a	e5 	.
1391  461B CD A5 4F     	call FlushSectorData			; Flush Sector Data to disk from both FCBs 						;461b	cd a5 4f 	. . O
1392  461E E1           	pop hl							; restore hl - FCB to use										;461e	e1 	.
1393  461F
1394  461F              ; -- set FCB is used
1395  461F 36 01        	ld (hl),1						; set FCB flag - used but file not active						;461f	36 01 	6 .
1396  4621 23           	inc hl							; hl - address of Access type field								;4621	23 	#
1397  4622              ; -- set Access type (read/write)
1398  4622 FD 7E 0C     	ld a,(iy+RQST)					; a - requested access type (read.write)						;4622	fd 7e 0c 	. ~ .
1399  4625 77           	ld (hl),a						; set Access type in FCB										;4625	77 	w
1400  4626 23           	inc hl							; hl - address of Filename field 								;4626	23 	#
1401  4627              ; -- set Filename (FNAM)
1402  4627 FD E5        	push iy							; iy - DOS base address											;4627	fd e5 	. .
1403  4629 D1           	pop de							; copy to de													;4629	d1 	.
1404  462A 13           	inc de							; de - address of FNAM in DOS Structure							;462a	13 	.
1405  462B EB           	ex de,hl						; de - FNAM field in FCB, hl - FNAM field in DOS structure 		;462b	eb 	.
1406  462C 01 08 00     	ld bc,8							; bc - 8 chars of filename 										;462c	01 08 00 	. . .
1407  462F ED B0        	ldir							; copy filename to FCB											;462f	ed b0 	. .
1408  4631              ; --
1409  4631 D5           	push de							; save de - address of TRK# field in FCB						;4631	d5 	.
1410  4632 F3           	di								; disable interrupts											;4632	f3 	.
1411  4633
1412  4633              ; -- turn Disk power ON
1413  4633 CD 41 5F     	call PWRON						; Disk power ON													;4633	cd 41 5f 	. A _
1414  4636 C5           	push bc							; save bc														;4636	c5 	.
1415  4637 01 32 00     	ld bc,50						; bc - number of miliseconds to delay							;4637	01 32 00 	. 2 .
1416  463A CD BE 5E     	call DLY						; delay 50 ms													;463a	cd be 5e 	. . ^
1417  463D C1           	pop bc							; restore bc													;463d	c1 	.
1418  463E
1419  463E              ; -- check if file exists
1420  463E CD 13 59     	call SEARCH						; Search for file in directory									;463e	cd 13 59 	. . Y
1421  4641 FE 02        	cp 02							; file found? (Error 02 - FILE ALREADY EXISTS?) 				;4641	fe 02 	. .
1422  4643 C2 6B 46     	jp nz,.fileNotExists			; no - create if mode=Write, error if mode=read					;4643	c2 6b 46 	. k F
1423  4646
1424  4646              ; -- file exists already - must be 'D' type (data)
1425  4646 FD 7E 0A     	ld a,(iy+TYPE+1)				; a - file type of found file									;4646	fd 7e 0a 	. ~ .
1426  4649 FE 44        	cp 'D'							; is it type 'D' (data)?										;4649	fe 44 	. D
1427  464B 3E 0C        	ld a,12							; a - Error 12   FILE TYPE MISMATCH								;464b	3e 0c 	> .
1428  464D C2 41 42     	jp nz,ERROR						; no - go to Error handling routine								;464d	c2 41 42 	. A B
1429  4650
1430  4650              ; -- file exists and is type 'D' - fill 1st sector data in FCB
1431  4650 E1           	pop hl							; pop hl - address of TRK# field in FCB							;4650	e1 	.
1432  4651              ; -- set Track from Directory Entry of found file
1433  4651 1A           	ld a,(de)						; a - Track Number from disk Directory Entry 					;4651	1a 	.
1434  4652 77           	ld (hl),a						; set as Track Number in FCB									;4652	77 	w
1435  4653 FD 77 12     	ld (iy+TRCK),a					; set as Track Number in DOS Structure							;4653	fd 77 12 	. w .
1436  4656 13           	inc de							; de - address of Sector Number in Directory Entry				;4656	13 	.
1437  4657 23           	inc hl							; hl - address of Sector Number in FCB							;4657	23 	#
1438  4658              ; -- set Sector from Directory Entry of found file
1439  4658 1A           	ld a,(de)						; a - Sector Number from disk Directory Entry 					;4658	1a 	.
1440  4659 77           	ld (hl),a						; set as Sector Number in FCB									;4659	77 	w
1441  465A FD 77 11     	ld (iy+SCTR),a					; set as Sector Number in DOS Structure							;465a	fd 77 11 	. w .
1442  465D              ; -- set Byte-in-Sector Index (PTR)
1443  465D AF           	xor a							; a - index of current byte in Sector = 0						;465d	af 	.
1444  465E 23           	inc hl							; hl - address of PTR field in FCB								;465e	23 	#
1445  465F 77           	ld (hl),a						; set Index (PTR) to 0											;465f	77 	w
1446  4660
1447  4660              ; -- if mode = read we are done, if mode = write we have to read whole file and find end of data
1448  4660 FD 7E 0C     	ld a,(iy+RQST)					; a - requested access type (mode) (read/write)					;4660	fd 7e 0c 	. ~ .
1449  4663 B7           	or a							; is it 0 (read)?												;4663	b7 	.
1450  4664 20 53        	jr nz,.seekEndOfFile			; no - seek End of file and setup point of write				;4664	20 53 	  S
1451  4666
1452  4666              ; -- file is ready to read from - turn driive power off and exit
1453  4666 CD 52 5F     	call PWROFF						; Disk power OFF												;4666	cd 52 5f 	. R _
1454  4669 E1           	pop hl							; restore hl - address of next char in BASIC					;4669	e1 	.
1455  466A C9           	ret								; -------------------- End of Proc ----------------------------	;466a	c9 	.
1456  466B
1457  466B
1458  466B              .fileNotExists:
1459  466B              ; -- file not exists - error if mode=read
1460  466B 4F           	ld c,a							; save a - previous error code (FILE NOT EXISTS)				;466b	4f 	O
1461  466C FD 7E 0C     	ld a,(iy+RQST)					; requested access type (read/write)							;466c	fd 7e 0c 	. ~ .
1462  466F B7           	or a							; is it 0 (read)?												;466f	b7 	.
1463  4670 79           	ld a,c							; a - restore previous error code								;4670	79 	y
1464  4671 CA A8 46     	jp z,.exitError						; yes - release FCB and exit with Error 						;4671	ca a8 46 	. . F
1465  4674
1466  4674              ; -- mode=write - need to create file - check if Disk is not Write-Protected
1467  4674 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;4674	db 13 	. .
1468  4676 B7           	or a							; is bit 7 set? (write protected)								;4676	b7 	.
1469  4677 0E 04        	ld c,04							; c - Error 04 - DISK WRITE PROTECTED							;4677	0e 04 	. .
1470  4679 FA A8 46     	jp m,.exitError						; yes - release FCB and exit with Error 						;4679	fa a8 46 	. . F
1471  467C
1472  467C              ; -- create file type 'D'
1473  467C CD 17 47     	call RDMAP						; Read the allocation map of the disk							;467c	cd 17 47 	. . G
1474  467F FD 36 09 44  	ld (iy+TYPE),'D'				; set file type 'D' (data)										;467f	fd 36 09 44 	. 6 . D
1475  4683 CD 7B 58     	call CREATE						; Create an entry in directory									;4683	cd 7b 58 	. { X
1476  4686 B7           	or a							; was any error?												;4686	b7 	.
1477  4687 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4687	c2 41 42 	. A B
1478  468A
1479  468A              ; -- file created update - properities of allocated 1st Sector
1480  468A E1           	pop hl							; restore hl - address of TRK# field in FCB						;468a	e1 	.
1481  468B FD 7E 16     	ld a,(iy+NTRK)					; a - Track number of allocated Sector							;468b	fd 7e 16 	. ~ .
1482  468E FD 77 12     	ld (iy+TRCK),a					; set as Track Number in DOS structure							;468e	fd 77 12 	. w .
1483  4691 77           	ld (hl),a						; set as Track Number in FCB									;4691	77 	w
1484  4692 23           	inc hl							; hl - address of SCTR# field in FCB							;4692	23 	#
1485  4693 FD 7E 15     	ld a,(iy+NSCT)					; a - Sector Number of allocated Sector							;4693	fd 7e 15 	. ~ .
1486  4696 FD 77 11     	ld (iy+SCTR),a					; set as Sector Number in DOS structure							;4696	fd 77 11 	. w .
1487  4699 77           	ld (hl),a						; set as Sector Number in FCB									;4699	77 	w
1488  469A 23           	inc hl							; hl - address of PTR field in FCB								;469a	23 	#
1489  469B 36 00        	ld (hl),0						; set Byte-in-Sector Index (PTR) to 0							;469b	36 00 	6 .
1490  469D              ; -- clear Sector buffer and write it to Disk
1491  469D CD 49 47     	call CLEAR						; Clear a sector of the disk									;469d	cd 49 47 	. I G
1492  46A0              ; -- update Disk Allocation Map
1493  46A0 CD 54 47     	call SVMAP						; Save allocation Map to the disk								;46a0	cd 54 47 	. T G
1494  46A3
1495  46A3              ; -- file is ready to write to - turn driive power off and exit
1496  46A3 CD 52 5F     	call PWROFF						; Disk power OFF												;46a3	cd 52 5f 	. R _
1497  46A6 E1           	pop hl							; restore hl - address of next char in BASIC					;46a6	e1 	.
1498  46A7 C9           	ret								; -------------------- End of Proc ----------------------------	;46a7	c9 	.
1499  46A8
1500  46A8
1501  46A8              .exitError:
1502  46A8              ; -- release FCB (set flag to "not used"
1503  46A8 E1           	pop hl							; restore hl - address of TRK# field in FCB						;46a8	e1 	.
1504  46A9 11 F6 FF     	ld de,-10						; de - offset to FCB Open flag from TRK# field					;46a9	11 f6 ff 	. . .
1505  46AC 19           	add hl,de						; hl - address of FCB Open flag									;46ac	19 	.
1506  46AD 36 00        	ld (hl),0						; set Flag to 0 - FCB not used									;46ad	36 00 	6 .
1507  46AF              ; -- exit with previous error (if was any)
1508  46AF 79           	ld a,c							; a - previous Error code										;46af	79 	y
1509  46B0 B7           	or a							; was any error?												;46b0	b7 	.
1510  46B1 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	; Error handling routine	;46b1	c2 41 42 	. A B
1511  46B4
1512  46B4              ; -- no previous code - exit with Error 13 - FILE NOT FOUND
1513  46B4 3E 0D        	ld a,13							; a - Error 13 - FILE NOT FOUND									;46b4	3e 0d 	> .
1514  46B6 C3 41 42     	jp ERROR						; go to Error handling routine --------------------------------	;46b6	c3 41 42 	. A B
1515  46B9
1516  46B9
1517  46B9              .seekEndOfFile:
1518  46B9              ; -- file exists and requested mode=write - read sector into buffer
1519  46B9 E5           	push hl							; save hl - address of PTR field in FCB							;46b9	e5 	.
1520  46BA              .readNextSector:
1521  46BA CD 27 5B     	call READ						; Read a sector from disk										;46ba	cd 27 5b 	. ' [
1522  46BD B7           	or a							; was any error?												;46bd	b7 	.
1523  46BE C2 41 42     	jp nz,ERROR						; yes - goto Error handling routine								;46be	c2 41 42 	. A B
1524  46C1              ; -- get next sector params from file
1525  46C1 FD 6E 31     	ld l,(iy+DBFR)					; hl - address of sector data buffer							;46c1	fd 6e 31 	. n 1
1526  46C4 FD 66 32     	ld h,(iy+DBFR+1)																				;46c4	fd 66 32 	. f 2
1527  46C7 11 7E 00     	ld de,126						; de - offset in sector to next track/sector data				;46c7	11 7e 00 	. ~ .
1528  46CA 19           	add hl,de						; hl - address of Next Track Number of file						;46ca	19 	.
1529  46CB 7E           	ld a,(hl)						; a - Next Track Number											;46cb	7e 	~
1530  46CC B7           	or a							; is it 0? (it was last sector of this file)?					;46cc	b7 	.
1531  46CD 28 0A        	jr z,.lastSecFound				; yes - find end of data in this sector 						;46cd	28 0a 	( .
1532  46CF              ; -- set next sector params to read
1533  46CF 23           	inc hl							; hl - address of Next Sector Number of file					;46cf	23 	#
1534  46D0 FD 77 12     	ld (iy+TRCK),a					; set Track NUmber to read next									;46d0	fd 77 12 	. w .
1535  46D3 7E           	ld a,(hl)						; a - Next Sector Number 										;46d3	7e 	~
1536  46D4 FD 77 11     	ld (iy+SCTR),a					; set Sector Number to read next								;46d4	fd 77 11 	. w .
1537  46D7 18 E1        	jr .readNextSector				; read next sector --------------------------------------------	;46d7	18 e1 	. .
1538  46D9
1539  46D9              .lastSecFound:
1540  46D9              ; -- check how many bytes are used in this sector
1541  46D9 06 7E        	ld b,126						; b - 126 bytes of data in buffer								;46d9	06 7e 	. ~
1542  46DB FD 6E 31     	ld l,(iy+DBFR)					; hl - address of buffer with sector data						;46db	fd 6e 31 	. n 1
1543  46DE FD 66 32     	ld h,(iy+DBFR+1)																				;46de	fd 66 32 	. f 2
1544  46E1              .nextByte:
1545  46E1 7E           	ld a,(hl)						; a - data byte from last sector								;46e1	7e 	~
1546  46E2 23           	inc hl							; hl - address of next byte										;46e2	23 	#
1547  46E3 B7           	or a							; is daba byte = 0? (end of data)?								;46e3	b7 	.
1548  46E4 28 1D        	jr z,.updateFCBexit				; yes - update FCB with this sector params and exit				;46e4	28 1d 	( .
1549  46E6 10 F9        	djnz .nextByte					; no - check all 126 bytes ------------------------------------	;46e6	10 f9 	. .
1550  46E8
1551  46E8              ; -- all 126 bytes are used - need to create 1 more sector
1552  46E8 CD 17 47     	call RDMAP						; Read disk allocation Map										;46e8	cd 17 47 	. . G
1553  46EB CD BF 58     	call MAP						; Search for empty sector and alloacte it						;46eb	cd bf 58 	. . X
1554  46EE B7           	or a							; was any error?												;46ee	b7 	.
1555  46EF C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;46ef	c2 41 42 	. A B
1556  46F2              ; -- no error - set new sector track and Sector Number
1557  46F2 FD 7E 16     	ld a,(iy+NTRK)					; a - Track Number of new sector								;46f2	fd 7e 16 	. ~ .
1558  46F5 FD 77 12     	ld (iy+TRCK),a					; set as Track Number in DOS structure							;46f5	fd 77 12 	. w .
1559  46F8 FD 7E 15     	ld a,(iy+NSCT)					; a - Sector Number of new sector								;46f8	fd 7e 15 	. ~ .
1560  46FB FD 77 11     	ld (iy+SCTR),a					; set as Sector Number in DOS structure							;46fb	fd 77 11 	. w .
1561  46FE              ; -- clear buffer and write empty sector to disk
1562  46FE CD 49 47     	call CLEAR						; Clear a sector of the disk									;46fe	cd 49 47 	. I G
1563  4701
1564  4701 06 7E        	ld b,126						; b - 126 free bytes in this sector								;4701	06 7e 	. ~
1565  4703              .updateFCBexit:
1566  4703 3E 7E        	ld a,126						; a - total 126 bytes can be stored in one sector				;4703	3e 7e 	> ~
1567  4705 90           	sub b							; subtract number of free bytes (index of 1st byte to use)		;4705	90 	.
1568  4706 E1           	pop hl							; restore hl - address of PTR field in FCB						;4706	e1 	.
1569  4707 77           	ld (hl),a						; set as Byte-inSector Index (PTR) in FCB						;4707	77 	w
1570  4708 2B           	dec hl							; hl - address of Sector Number (SCTR#) in FCB					;4708	2b 	+
1571  4709 FD 7E 11     	ld a,(iy+SCTR)					; a - Sector Number from DOS Structure							;4709	fd 7e 11 	. ~ .
1572  470C 77           	ld (hl),a						; set as Sector Number in FCB									;470c	77 	w
1573  470D 2B           	dec hl							; hl - address of Track Number (TRK#) in FCB					;470d	2b 	+
1574  470E FD 7E 12     	ld a,(iy+TRCK)					; a - Track Number from DOS Structure							;470e	fd 7e 12 	. ~ .
1575  4711 77           	ld (hl),a						; set as Track Number in FCB									;4711	77 	w
1576  4712              ; -- file is ready to write to - turn driive power off and exit
1577  4712 CD 52 5F     	call PWROFF						; Disk power OFF												;4712	cd 52 5f 	. R _
1578  4715 E1           	pop hl							; restore hl - address of next char in BASIC					;4715	e1 	.
1579  4716 C9           	ret								; -------------------- End of Proc ----------------------------	;4716	c9 	.
1580  4717
1581  4717
1582  4717
1583  4717              ;***************************************************************************************************
1584  4717              ; Read Sector Allocation Map.
1585  4717              ;---------------------------------------------------------------------------------------------------
1586  4717              ; The sectors allocation map is loaded from sector 15 of track 0 from the disk
1587  4717              ; into the memory pointed by adress stored in iy+MAPADR
1588  4717              ; IN: Disabled interrupts
1589  4717              ; OUT: a - error code or 0 if no error
1590  4717              ;***************************************************************************************************
1591  4717              RDMAP:
1592  4717              ; -- read sector 15 on track 0
1593  4717 FD 36 12 00  	ld (iy+TRCK),0					; Track number 0												;4717	fd 36 12 00 	. 6 . .
1594  471B FD 36 11 0F  	ld (iy+SCTR),15					; Sector Number 15												;471b	fd 36 11 0f 	. 6 . .
1595  471F CD 27 5B     	call READ						; Read a sector from disk into Sector Buffer					;471f	cd 27 5b 	. ' [
1596  4722 B7           	or a							; check if error (a != 0)										;4722	b7 	.
1597  4723 C2 41 42     	jp nz,ERROR						; yes - jump to Error handling routine							;4723	c2 41 42 	. A B
1598  4726              ; -- copy map data from read buffer into MapData
1599  4726 FD 5E 34     	ld e,(iy+MAPADR)																				;4726	fd 5e 34 	. ^ 4
1600  4729 FD 56 35     	ld d,(iy+MAPADR+1)				; dst - de - Allocation Map Address 							;4729	fd 56 35 	. V 5
1601  472C FD 6E 31     	ld l,(iy+DBFR)																					;472c	fd 6e 31 	. n 1
1602  472F FD 66 32     	ld h,(iy+DBFR+1)				; src - hl - Data Buffer										;472f	fd 66 32 	. f 2
1603  4732 01 50 00     	ld bc,80						; 80 bytes to copy (1 bit for Sector -> 640 sectors)			;4732	01 50 00 	. P .
1604  4735 ED B0        	ldir							; copy bytes													;4735	ed b0 	. .
1605  4737 C9           	ret								; ------------------------- End of Proc -----------------------	;4737	c9 	.
1606  4738
1607  4738
1608  4738
1609  4738              ;***************************************************************************************************
1610  4738              ; Fill Data Buffer with value 0
1611  4738              ; IN: none
1612  4738              ; OUT: none
1613  4738              ;***************************************************************************************************
1614  4738              ClearDataBuffer:
1615  4738 FD 6E 31     	ld l,(iy+DBFR)																					;4738	fd 6e 31 	. n 1
1616  473B FD 66 32     	ld h,(iy+DBFR+1)				; src - hl - Data Buffer address								;473b	fd 66 32 	. f 2
1617  473E 36 00        	ld (hl),0						; set first byte to 0											;473e	36 00 	6 .
1618  4740 5D           	ld e,l																							;4740	5d 	]
1619  4741 54           	ld d,h							; dst - de - Data Buffer address								;4741	54 	T
1620  4742 13           	inc de							; dst - de - address of next byte 								;4742	13 	.
1621  4743 01 80 00     	ld bc,128						; 128 bytes to clear											;4743	01 80 00 	. . .
1622  4746 ED B0        	ldir							; fill buffer with 0 											;4746	ed b0 	. .
1623  4748 C9           	ret								; -------------------------- End of Proc ----------------------	;4748	c9 	.
1624  4749
1625  4749
1626  4749
1627  4749              ;***************************************************************************************************
1628  4749              ; Clear a sector of the disk
1629  4749              ; IN: Disabled interrupts
1630  4749              ;     IY+TRCK - track number
1631  4749              ;     IY+SCTR - sector number
1632  4749              ;     IY+DRVS - drive selected
1633  4749              ; OUT: a - error code or 0 if no error
1634  4749              ;***************************************************************************************************
1635  4749              CLEAR:
1636  4749 CD 38 47     	call ClearDataBuffer			; clear 128 bytes in Data Buffer								;4749	cd 38 47 	. 8 G
1637  474C CD A1 59     	call WRITE						; Write a sector to disk										;474c	cd a1 59 	. . Y
1638  474F B7           	or a							; check if error (a != 0)										;474f	b7 	.
1639  4750 C2 41 42     	jp nz,ERROR						; yes - jump to Error handling routine							;4750	c2 41 42 	. A B
1640  4753 C9           	ret								; -------------------------- End of Proc ----------------------	;4753	c9 	.
1641  4754
1642  4754
1643  4754
1644  4754              ;***************************************************************************************************
1645  4754              ; Save the track map pointed by iy+MAPADR to the disk (track 0, sector 15)
1646  4754              ;---------------------------------------------------------------------------------------------------
1647  4754              ; IN: Disabled interrupts
1648  4754              ;     IY+DRVS - drive selected
1649  4754              ;	  IY+MAPADR - pointer to updated Sector Allocation Map
1650  4754              ;	  The corresponding drive must be switched on.
1651  4754              ; OUT: a - error code or 0 if no error
1652  4754              ;***************************************************************************************************
1653  4754              SVMAP:
1654  4754              ; -- clear sector buffer
1655  4754 CD 38 47     	call ClearDataBuffer			; clear 128 bytes in Data Buffer								;4754	cd 38 47 	. 8 G
1656  4757
1657  4757              ; -- setup parameters (track=0,sector=15)
1658  4757 FD 36 12 00  	ld (iy+TRCK),0					; Track number 0												;4757	fd 36 12 00 	. 6 . .
1659  475B FD 36 11 0F  	ld (iy+SCTR),15					; Sector number 15												;475b	fd 36 11 0f 	. 6 . .
1660  475F
1661  475F              ; -- copy Sector Map data into Sector Data Buffer
1662  475F FD 5E 31     	ld e,(iy+DBFR)																					;475f	fd 5e 31 	. ^ 1
1663  4762 FD 56 32     	ld d,(iy+DBFR+1)				; dst - de - address of Data Buffer								;4762	fd 56 32 	. V 2
1664  4765 FD 6E 34     	ld l,(iy+MAPADR)																				;4765	fd 6e 34 	. n 4
1665  4768 FD 66 35     	ld h,(iy+MAPADR+1)				; src - hl - address of MapData									;4768	fd 66 35 	. f 5
1666  476B 01 50 00     	ld bc,80						; 80 bytes to copy (rest of sector is already cleared to 0)		;476b	01 50 00 	. P .
1667  476E ED B0        	ldir							; copy bytes do Data Buffer										;476e	ed b0 	. .
1668  4770              ; -- write buffer to Disk Sector
1669  4770 CD A1 59     	call WRITE						; Write a sector to disk										;4770	cd a1 59 	. . Y
1670  4773 B7           	or a							; check if error (a != 0)										;4773	b7 	.
1671  4774 C2 41 42     	jp nz,ERROR						; yes - jump to Error handling routine							;4774	c2 41 42 	. A B
1672  4777 C9           	ret								; -------------------------- End of Proc ----------------------	;4777	c9 	.
1673  4778
1674  4778
1675  4778              ;***************************************************************************************************
1676  4778              ; Find File Control Block for Open file
1677  4778              ; If file already open it returns FCB for that file, if not returns free FCB to use.
1678  4778              ; If both FCBs are used by another files then returns Error 14 - DISK BUFFER FULL
1679  4778              ; IN: hl - parse point
1680  4778              ;     (iy+FNAM) - filename to close
1681  4778              ; OUT: a - error/status codes: 8 - FILE ALREADY OPEN or 5 - FILE NOT OPEN
1682  4778              ;      de - address of FCB (if file is Opened)
1683  4778              ;      hl - address of FCB to use (if file is not Opened)
1684  4778              FindFCBForOpen:
1685  4778 FD E5        	push iy							; iy - DOS base address											;4778	fd e5 	. .
1686  477A E1           	pop hl							; copy to hl													;477a	e1 	.
1687  477B
1688  477B              ; -- check if file is open and use FCB Block 1
1689  477B FD 36 00 00  	ld (iy+FILNO),0					; set File # to 0 - current used FCB Block 1					;477b	fd 36 00 00 	. 6 . .
1690  477F 11 17 00     	ld de,FCB1						; de - offset to 1st FCB Block									;477f	11 17 00 	. . .
1691  4782 19           	add hl,de						; hl - address of FCB Block	1									;4782	19 	.
1692  4783 7E           	ld a,(hl)						; a - Open Flag 												;4783	7e 	~
1693  4784 B7           	or a							; is file Opened in FCB 1?												;4784	b7 	.
1694  4785 28 09        	jr z,.checkFCB2					; no - check FCB Block 2 --------------------------------------	;4785	28 09 	( .
1695  4787
1696  4787              ; -- check if FCB Block 1 handles this file
1697  4787 CD BF 47     	call FCBHandlesFile				; check if filenames in FCB and (iy+FNAM) match					;4787	cd bf 47 	. . G
1698  478A FE 08        	cp 8							; is Error 8 - FILE ALREADY OPEN ?								;478a	fe 08 	. .
1699  478C C8           	ret z							; yes - ------------------ End Of Proc ------------------------	;478c	c8 	.
1700  478D
1701  478D              ; -- set FCB 2 is used
1702  478D FD 34 00     	inc (iy+FILNO)					; set File # to 1 - current used FCB Block 2					;478d	fd 34 00 	. 4 .
1703  4790              .checkFCB2:
1704  4790              ; -- check if file is open and use FCB Block 2
1705  4790 11 0D 00     	ld de,13						; de - size of FCB Block structure								;4790	11 0d 00 	. . .
1706  4793 19           	add hl,de						; hl - address of FCB Block	2									;4793	19 	.
1707  4794 7E           	ld a,(hl)						; a - Open Flag 												;4794	7e 	~
1708  4795 B7           	or a							; is file Opened using FCB 2?									;4795	b7 	.
1709  4796 20 14        	jr nz,l47ach					; yes - check if FCB Block 2 handles this file ----------------	;4796	20 14 	  .
1710  4798
1711  4798              ; -- file is not Open - return FILE NOT OPEN
1712  4798              ;    de - will contain free FCB to use
1713  4798 FD E5        	push iy							; iy - DOS base address											;4798	fd e5 	. .
1714  479A E1           	pop hl							; copy to hl													;479a	e1 	.
1715  479B 11 17 00     	ld de,FCB1						; de - offset to 1st FCB Block									;479b	11 17 00 	. . .
1716  479E 19           	add hl,de						; hl - address of FCB Block	1									;479e	19 	.
1717  479F FD 7E 00     	ld a,(iy+FILNO)					; a - FCB block used											;479f	fd 7e 00 	. ~ .
1718  47A2 B7           	or a							; is it FCB block 1?											;47a2	b7 	.
1719  47A3 28 04        	jr z,.exitError					; yes - hl has address of FCB 1 - return with error				;47a3	28 04 	( .
1720  47A5              ; -- used FCB 2
1721  47A5 11 0D 00     	ld de,13						; de - offset from FCB1 to FCB2									;47a5	11 0d 00 	. . .
1722  47A8 19           	add hl,de						; hl has address of FCB 2 - return with error					;47a8	19 	.
1723  47A9              .exitError:
1724  47A9              ; -- return Error 5 - FILE NOT OPEN
1725  47A9 3E 05        	ld a,5							; set Error 5 - FILE NOT OPEN									;47a9	3e 05 	> .
1726  47AB C9           	ret								; ---------------------- End of Proc --------------------------	;47ab	c9 	.
1727  47AC
1728  47AC              l47ach:
1729  47AC              ; -- check if FCB Block 2 handles this file
1730  47AC CD BF 47     	call FCBHandlesFile				; check if filenames in FCB and (iy+FNAM) match					;47ac	cd bf 47 	. . G
1731  47AF FE 08        	cp 8							; is Error 8 - FILE ALREADY OPEN ?								;47af	fe 08 	. .
1732  47B1 C8           	ret z							; yes - ------------------ End Of Proc ------------------------	;47b1	c8 	.
1733  47B2
1734  47B2              ; -- FCB 2 used by another file - check FCB 1 can be used?
1735  47B2 B7           	or a							; clear Carry flag												;47b2	b7 	.
1736  47B3 ED 52        	sbc hl,de						; hl - address of FCB 1 										;47b3	ed 52 	. R
1737  47B5 FD 7E 17     	ld a,(iy+FCB1)					; a - FCB1 Open flag											;47b5	fd 7e 17 	. ~ .
1738  47B8 B7           	or a							; can FCB 1 be used? (Open FLAG != 0)							;47b8	b7 	.
1739  47B9 3E 0E        	ld a,14							; set Error 14 - DISK BUFFER FULL								;47b9	3e 0e 	> .
1740  47BB C0           	ret nz							; no - ------------------- End of Proc (with Error) ----------	;47bb	c0 	.
1741  47BC
1742  47BC              ; -- return Error 5 - FILE NOT OPEN - FCB1 can be used
1743  47BC 3E 05        	ld a,5							; set Error 5 - FILE NOT OPEN									;47bc	3e 05 	> .
1744  47BE C9           	ret								; ---------------------- End of Proc --------------------------	;47be	c9 	.
1745  47BF
1746  47BF
1747  47BF              ;***************************************************************************************************
1748  47BF              ; Check if FCB specified by hl handles filename specified in iy+FNAM
1749  47BF              ; IN: hl - address of FCB (File Control Block)
1750  47BF              ;     (iy+FNAM) - filename to close
1751  47BF              ; OUT: a - error/status codes: 8 - FILE ALREADY OPEN or 5 - FILE NOT OPEN
1752  47BF              ;	   Z flag - 1 - filenames match, 0 - filenames are different
1753  47BF              ;      de - (if fileanmes match) address of FCB
1754  47BF              ;      hl - (if fileanmes match) points to next char after filename (track number in FCB)
1755  47BF              FCBHandlesFile:
1756  47BF FD E5        	push iy							; save iy - DOS base											;47bf	fd e5 	. .
1757  47C1 E5           	push hl							; save hl - FCB structure										;47c1	e5 	.
1758  47C2 06 08        	ld b,8							; b - 8 chars of filename										;47c2	06 08 	. .
1759  47C4 23           	inc hl							; skip Status byte												;47c4	23 	#
1760  47C5 23           	inc hl							; hl - filename in FCB											;47c5	23 	#
1761  47C6              .nextChar:
1762  47C6 FD 7E 01     	ld a,(iy+FNAM)					; a - char of filename to compare								;47c6	fd 7e 01 	. ~ .
1763  47C9 BE           	cp (hl)							; is it the same in FCB?										;47c9	be 	.
1764  47CA 23           	inc hl							; hl - next char of filename in FCB								;47ca	23 	#
1765  47CB FD 23        	inc iy							; iy - next char of filename in DOS structure					;47cb	fd 23 	. #
1766  47CD 20 08        	jr nz,.returnNotOpen			; not match - return with Error FILE NOT OPEN -----------------	;47cd	20 08 	  .
1767  47CF 10 F5        	djnz .nextChar					; continue to compare all 8 chars -----------------------------	;47cf	10 f5 	. .
1768  47D1 3E 08        	ld a,8							; a - Error 5 - FILE ALREADY OPEN								;47d1	3e 08 	> .
1769  47D3 D1           	pop de							; restore de - FCB Structure									;47d3	d1 	.
1770  47D4 FD E1        	pop iy							; restore iy - DOS base											;47d4	fd e1 	. .
1771  47D6 C9           	ret								; ----------------- End of Proc -------------------------------	;47d6	c9 	.
1772  47D7              .returnNotOpen:
1773  47D7 E1           	pop hl							; restore hl - FCB Structure									;47d7	e1 	.
1774  47D8 FD E1        	pop iy							; restore iy - DOS base											;47d8	fd e1 	. .
1775  47DA 3E 05        	ld a,5							; a - Error 5 - FILE NOT OPEN									;47da	3e 05 	> .
1776  47DC C9           	ret								; ----------------- End of Proc -------------------------------	;47dc	c9 	.
1777  47DD
1778  47DD
1779  47DD              ;***************************************************************************************************
1780  47DD              ; DOS Command CLOSE
1781  47DD              ; Syntax: CLOSE "filaname"
1782  47DD              ; ------------------------
1783  47DD              ; Close file specified by "filename" (which has the file type code "D") previously opened by OPEN.
1784  47DD              ; Filename may have no more than 8 characters.
1785  47DD              ; IN: hl - parse point (just after 'CLOSE' text)
1786  47DD              DCmdCLOSE:
1787  47DD              ; -- parse required filename (must be terminated with 0 or ':')
1788  47DD CD 67 53     	call CSI						; parse filename and copy it to (iy+FNAM)						;47dd	cd 67 53 	. g S
1789  47E0 B7           	or a							; was any Error?												;47e0	b7 	.
1790  47E1 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;47e1	c2 41 42 	. A B
1791  47E4 E5           	push hl							; save hl - address of next character in BASIC					;47e4	e5 	.
1792  47E5
1793  47E5              ; -- test if command is called from BASIC program or direct
1794  47E5 2A A2 78     	ld hl,(BasicLineNumber)			; hl - Current line being processed by BASIC					;47e5	2a a2 78 	* . x
1795  47E8 23           	inc hl							; if was -1 (oxffff) then now will be 0							;47e8	23 	#
1796  47E9 7C           	ld a,h																							;47e9	7c 	|
1797  47EA B5           	or l							; is hl = 0 (called as direct command)?							;47ea	b5 	.
1798  47EB 20 0A        	jr nz,.fromBasicProg			; no - continue 												;47eb	20 0a 	  .
1799  47ED
1800  47ED              ; -- called from direct command
1801  47ED CD 78 47     	call FindFCBForOpen				; Find FCB Block used by this file if file already opened		;47ed	cd 78 47 	. x G
1802  47F0 E1           	pop hl							; restore hl - address of next character in BASIC				;47f0	e1 	.
1803  47F1 FE 08        	cp 08							; is file Opened? (Error 08   FILE ALREADY OPEN)				;47f1	fe 08 	. .
1804  47F3 C0           	ret nz							; no ------------------- End of Proc --------------------------	;47f3	c0 	.
1805  47F4              ; -- file was Opened - release FCB
1806  47F4 AF           	xor a							; a - error code 00 - OK (and also FCB not used flag)			;47f4	af 	.
1807  47F5 12           	ld (de),a						; set FCB Open flag as "not used"								;47f5	12 	.
1808  47F6 C9           	ret								; --------------------- End of Proc --------------------------	;47f6	c9 	.
1809  47F7
1810  47F7              ; -- called from BASIC Program - needs extra cleanup
1811  47F7              .fromBasicProg:
1812  47F7 CD 78 47     	call FindFCBForOpen				; Find FCB Block used by this file if file already opened		;47f7	cd 78 47 	. x G
1813  47FA E1           	pop hl							; restore hl - address of next character in BASIC				;47fa	e1 	.
1814  47FB FE 08        	cp 08							; is file Opened? (Error 08   FILE ALREADY OPEN)				;47fb	fe 08 	. .
1815  47FD C0           	ret nz							; no ------------------- End of Proc --------------------------	;47fd	c0 	.
1816  47FE
1817  47FE              ; -- file was Opened - release FCB
1818  47FE 1A           	ld a,(de)						; a - FCB Open flag												;47fe	1a 	.
1819  47FF FE 02        	cp 2							; is file opened and active?									;47ff	fe 02 	. .
1820  4801 3E 00        	ld a,0							; a - "not used" value 											;4801	3e 00 	> .
1821  4803 12           	ld (de),a						; set as FCB Open flag (release FCB)							;4803	12 	.
1822  4804 C0           	ret nz							; no ------------------- End of Proc --------------------------	;4804	c0 	.
1823  4805
1824  4805              ; -- file is opened and active (data in sector buffer)
1825  4805 13           	inc de							; de - address of Access type (read/write) in FCB				;4805	13 	.
1826  4806 1A           	ld a,(de)						; a - access type (read/write)									;4806	1a 	.
1827  4807 B7           	or a							; is it 0 (read)?												;4807	b7 	.
1828  4808 C8           	ret z							; yes ------------------ End of Proc --------------------------	;4808	c8 	.
1829  4809
1830  4809              ; -- file was opened to write - need to flush data from buffer to disk
1831  4809 E5           	push hl							; save hl - address of next character in BASIC					;4809	e5 	.
1832  480A EB           	ex de,hl						; hl - address of Access type (read/write) in FCB				;480a	eb 	.
1833  480B 11 09 00     	ld de,9							; de - offset from Access field to TRK# field in FCB			;480b	11 09 00 	. . .
1834  480E 19           	add hl,de						; hl - address of Track Number (TRK#) in FCB					;480e	19 	.
1835  480F 7E           	ld a,(hl)						; a - Track Number from FCB										;480f	7e 	~
1836  4810 23           	inc hl							; hl - address of Sector Number (TRK#) in FCB					;4810	23 	#
1837  4811 FD 77 12     	ld (iy+TRCK),a					; set as Track Number to write									;4811	fd 77 12 	. w .
1838  4814 7E           	ld a,(hl)						; a - Sector Number from FCB									;4814	7e 	~
1839  4815 FD 77 11     	ld (iy+SCTR),a					; set as Sector Number to write									;4815	fd 77 11 	. w .
1840  4818
1841  4818              ; -- write data from sector buffer to disk
1842  4818 F3           	di								; enable interrupts												;4818	f3 	.
1843  4819
1844  4819              ; -- turn on Disk Drive and wait 50 ms
1845  4819 CD 41 5F     	call PWRON						; Disk power ON													;4819	cd 41 5f 	. A _
1846  481C C5           	push bc							; save bc 														;481c	c5 	.
1847  481D 01 32 00     	ld bc,50						; bc - number of miliseconds to delay							;481d	01 32 00 	. 2 .
1848  4820 CD BE 5E     	call DLY						; delay 50 ms													;4820	cd be 5e 	. . ^
1849  4823 C1           	pop bc							; restore bc													;4823	c1 	.
1850  4824
1851  4824              ; -- check if Disk is not Write-Protected
1852  4824 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;4824	db 13 	. .
1853  4826 B7           	or a							; is bit 7 set? (write protected)								;4826	b7 	.
1854  4827 3E 04        	ld a,04							; a - Error 04 - DISK WRITE PROTECTED							;4827	3e 04 	> .
1855  4829 FA 41 42     	jp m,ERROR						; yes - go to Error handling routine --------------------------	;4829	fa 41 42 	. A B
1856  482C
1857  482C              ; -- write sector to disk
1858  482C CD A1 59     	call WRITE						; Write a sector to disk										;482c	cd a1 59 	. . Y
1859  482F B7           	or a							; was any error?												;482f	b7 	.
1860  4830 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4830	c2 41 42 	. A B
1861  4833
1862  4833              ; -- no error - power off and exit
1863  4833 FB           	ei								; enable interrupts												;4833	fb 	.
1864  4834 CD 52 5F     	call PWROFF						; Disk power OFF												;4834	cd 52 5f 	. R _
1865  4837 E1           	pop hl							; restore hl - address of next character in BASIC				;4837	e1 	.
1866  4838 C9           	ret								; ---------------------- End of Proc --------------------------	;4838	c9 	.
1867  4839
1868  4839
1869  4839
1870  4839
1871  4839              ;***************************************************************************************************
1872  4839              ; DOS Command BSAVE
1873  4839              ; Syntax: BSAVE "filename", SSSS, EEEE
1874  4839              ; ------------------------------------
1875  4839              ; Save part of memory to file specified by "filename" to Disk as file Type 'B'.
1876  4839              ; Memory part is defined as all bytes from address SSSS (included) to address EEEE (included).
1877  4839              ; Filename may have no more than 8 characters. Both addresses SSSS and EEEE must be provided
1878  4839              ; as hexadecimal 16bit number.
1879  4839              ; IN: hl - parse point (just after 'LOAD' text)
1880  4839              DCmdBSAVE:
1881  4839              ; -- expected required name of file enclosed with double quote chars
1882  4839 CD 78 53     	call ParseFilename				; Verify syntax and copy filename to DOS Filename Buffer		;4839	cd 78 53 	. x S
1883  483C E5           	push hl							; save hl - parse point											;483c	e5 	.
1884  483D B7           	or a							; was any Error?												;483d	b7 	.
1885  483E C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;483e	c2 41 42 	. A B
1886  4841
1887  4841              ; -- expected ',' char
1888  4841 E1           	pop hl							; restore hl - parse point										;4841	e1 	.
1889  4842 CF           	rst $08							; Assert next char is ','										;4842	cf 	.
1890  4843 2C           	defb ','						; next char must be ','											;4843	2c 	,
1891  4844
1892  4844              ; -- save current addresses of BASIC program on stack
1893  4844 ED 5B F9 78  	ld de,(SYS_BASIC_END_PTR)		; end of current BASIC Program 									;4844	ed 5b f9 78 	. [ . x
1894  4848 D5           	push de							; save de - end of program 										;4848	d5 	.
1895  4849 ED 5B A4 78  	ld de,(SYS_BASIC_START_PTR)		; start of current BASIC Program 								;4849	ed 5b a4 78 	. [ . x
1896  484D D5           	push de							; save de - start of programm									;484d	d5 	.
1897  484E
1898  484E              ; -- convert hex text (4 chars) into 16bit address - start of memory to save
1899  484E CD B9 53     	call HEX						; de - 16bit address from 4 chars of Hex text					;484e	cd b9 53 	. . S
1900  4851 3E 01        	ld a,1							; a - Error 01 - SYNTAX ERROR									;4851	3e 01 	> .
1901  4853 DA B7 48     	jp c,BS_ExitError				; if parse hex error - exit with Error 01 ---------------------	;4853	da b7 48 	. . H
1902  4856 ED 53 A4 78  	ld (SYS_BASIC_START_PTR),de		; no error - save as start of memory to save 					;4856	ed 53 a4 78 	. S . x
1903  485A
1904  485A              ; -- expected ',' char
1905  485A CF           	rst $08							; Assert next char is ','										;485a	cf 	.
1906  485B 2C           	defb ','						; next char must be ','											;485b	2c 	,
1907  485C
1908  485C              ; -- convert hex text (4 chars) into 16bit address - end of memory to save
1909  485C CD B9 53     	call HEX						; de - 16bit address from 4 chars of Hex text					;485c	cd b9 53 	. . S
1910  485F 3E 01        	ld a,1							; a - Error 01 - SYNTAX ERROR									;485f	3e 01 	> .
1911  4861 DA B7 48     	jp c,BS_ExitError				; if parse hex error - exit with Error 01 ---------------------	;4861	da b7 48 	. . H
1912  4864 13           	inc de							; de - next address after last byte to save						;4864	13 	.
1913  4865 ED 53 F9 78  	ld (SYS_BASIC_END_PTR),de		; save end of current BASIC Program 							;4865	ed 53 f9 78 	. S . x
1914  4869
1915  4869              ; -- verify syntax - must be end of line ('\0') or end of expression ':'
1916  4869 7E           	ld a,(hl)						; a - next parsed char											;4869	7e 	~
1917  486A B7           	or a							; is it \0 ? (end of BASIC line)								;486a	b7 	.
1918  486B 28 07        	jr z,.continue					; yes - continue												;486b	28 07 	( .
1919  486D FE 3A        	cp ':'							; is it ':' (end of expression)?								;486d	fe 3a 	. :
1920  486F 3E 01        	ld a,1							; a - Error 01 - SYNTAX ERROR									;486f	3e 01 	> .
1921  4871 C2 B7 48     	jp nz,BS_ExitError				; if not \0 nor ':' - exit with Error 01 ----------------------	;4871	c2 b7 48 	. . H
1922  4874
1923  4874              .continue:
1924  4874              ; -- set type of file as Binary Program ('B')
1925  4874 FD 36 09 42  	ld (iy+TYPE),'B'				; set type of file as Binary Program ('B')						;4874	fd 36 09 42 	. 6 . B
1926  4878 E5           	push hl							; save hl - parse point											;4878	e5 	.
1927  4879
1928  4879              ; -- verify start addres is smaller than end address
1929  4879 2A A4 78     	ld hl,(SYS_BASIC_START_PTR)		; hl - start of memory area to save, de - end of area 							;4879	2a a4 78 	* . x
1930  487C B7           	or a							; clear Carry flag												;487c	b7 	.
1931  487D ED 52        	sbc hl,de						; difference - is hl >= de ? 									;487d	ed 52 	. R
1932  487F 3E 01        	ld a,1							; a - Error 01 - SYNTAX ERROR									;487f	3e 01 	> .
1933  4881 D2 9A 48     	jp nc,SAVE_ExitError			; if hl >= de - exit with Error 01 ----------------------------	;4881	d2 9a 48 	. . H
1934  4884
1935  4884              ; -- no error - turn on Disk Drive and wait 2ms
1936  4884 CD 41 5F     	call PWRON						; Disk power ON													;4884	cd 41 5f 	. A _
1937  4887 C5           	push bc							; save bc														;4887	c5 	.
1938  4888 01 02 00     	ld bc,2							; bc - 2 miliseconds to delay									;4888	01 02 00 	. . .
1939  488B CD BE 5E     	call DLY						; delay 2 ms 													;488b	cd be 5e 	. . ^
1940  488E C1           	pop bc							; restore bc													;488e	c1 	.
1941  488F
1942  488F              ; -- check if Disk is not Write-Protected
1943  488F DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;488f	db 13 	. .
1944  4891 B7           	or a							; is bit 7 set? (write protected)								;4891	b7 	.
1945  4892 3E 04        	ld a,04							; a - Error 04 - DISK WRITE PROTECTED							;4892	3e 04 	> .
1946  4894 FA 9A 48     	jp m,SAVE_ExitError				; yes - go to Error handling routine --------------------------	;4894	fa 9a 48 	. . H
1947  4897 C3 79 44     	jp DoSaveFile					; continue reusing part of 'SAVEFILE' DOS routine -------------	;4897	c3 79 44 	. y D
1948  489A
1949  489A
1950  489A              SAVE_ExitError:
1951  489A              ; -- was it canceled by user pressing BREAK?
1952  489A FE 11        	cp 17							; is it Error 17 - BREAK by user 								;489a	fe 11 	. .
1953  489C 20 18        	jr nz,.exitWithError			; no - exit with other error									;489c	20 18 	  .
1954  489E
1955  489E              ; --
1956  489E CD 13 59     	call SEARCH						; Search for file in directory									;489e	cd 13 59 	. . Y
1957  48A1 FE 02        	cp 2							; was Error 2 - FILE ALREADY EXISTS ?							;48a1	fe 02 	. .
1958  48A3 3E 11        	ld a,17							; set Error 17 - BREAK by user									;48a3	3e 11 	> .
1959  48A5 20 0F        	jr nz,.exitWithError			; file not found - ;48a5	20 0f 	  .
1960  48A7
1961  48A7              ; -- there is Directory Entry for this file - mark as deleted
1962  48A7 EB           	ex de,hl						; hl - address of byte in Dir Entry (just after filename)		;48a7	eb 	.
1963  48A8 11 F6 FF     	ld de,-10						; 10 bytes from start of Directory Entry						;48a8	11 f6 ff 	. . .
1964  48AB 19           	add hl,de						; hl - start of Dir Entry - File Type byte						;48ab	19 	.
1965  48AC 36 01        	ld (hl),1						; mark file in Directory Entry as deleted 						;48ac	36 01 	6 .
1966  48AE CD A1 59     	call WRITE						; Write sector with Directory to Disk							;48ae	cd a1 59 	. . Y
1967  48B1 B7           	or a							; was any Error?												;48b1	b7 	.
1968  48B2 20 02        	jr nz,.exitWithError			; yes - pass it through 										;48b2	20 02 	  .
1969  48B4 3E 11        	ld a,17							; no - set Error 17 - BREAK by user								;48b4	3e 11 	> .
1970  48B6              .exitWithError:
1971  48B6 E1           	pop hl							; restore hl - BASIC Parser Pointer (???)						;48b6	e1 	.
1972  48B7
1973  48B7              ;***************************************************************************************************
1974  48B7              ; Restore BASIC Program addresses from Stack and go o DOS Error handler
1975  48B7              ; IN: a - Error code
1976  48B7              BS_ExitError:
1977  48B7 D1           	pop de							; restore de - start of program									;48b7	d1 	.
1978  48B8 ED 53 A4 78  	ld (SYS_BASIC_START_PTR),de		; store to start of current BASIC Program variable				;48b8	ed 53 a4 78 	. S . x
1979  48BC D1           	pop de							; restore de - end of program									;48bc	d1 	.
1980  48BD ED 53 F9 78  	ld (SYS_BASIC_END_PTR),de		; store to end of current BASIC Program variable				;48bd	ed 53 f9 78 	. S . x
1981  48C1 C3 41 42     	jp ERROR						; got Error handling routine ----------------------------------	;48c1	c3 41 42 	. A B
1982  48C4
1983  48C4
1984  48C4
1985  48C4
1986  48C4              ;***************************************************************************************************
1987  48C4              ; DOS Command BLOAD
1988  48C4              ; Syntax: BLOAD "filename"
1989  48C4              ; ------------------------
1990  48C4              ; Load file specified by filename (which has the file type code "B") from a Floppy Disk.
1991  48C4              ; The address where file will be loaded is already defined on Disk (after saving via BSAVE command).
1992  48C4              ; Filename may have no more than 8 characters.
1993  48C4              ; IN: hl - parse point (just after 'BLOAD' text)
1994  48C4              DCmdBLOAD:
1995  48C4              ; -- expected required name of file enclosed with double quote chars
1996  48C4 CD 67 53     	call CSI						; parse filename and copy it to (iy+FNAM)						;48c4	cd 67 53 	. g S
1997  48C7 E5           	push hl							; save hl - parse point											;48c7	e5 	.
1998  48C8 B7           	or a							; was any Error?												;48c8	b7 	.
1999  48C9 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;48c9	c2 41 42 	. A B
2000  48CC
2001  48CC              ; -- set type of file as Binary Program ('B')
2002  48CC FD 36 09 42  	ld (iy+TYPE),'B'				; set type of file as Binary Program ('B')						;48cc	fd 36 09 42 	. 6 . B
2003  48D0
2004  48D0              ; -- save current Program start and end addresses
2005  48D0 E1           	pop hl							; restore hl - parse point										;48d0	e1 	.
2006  48D1 ED 5B F9 78  	ld de,(SYS_BASIC_END_PTR)		; de - end of current Program 									;48d1	ed 5b f9 78 	. [ . x
2007  48D5 D5           	push de							; save de - end of current Program								;48d5	d5 	.
2008  48D6 ED 5B A4 78  	ld de,(SYS_BASIC_START_PTR)		; de - start of current Program 								;48d6	ed 5b a4 78 	. [ . x
2009  48DA D5           	push de							; save de - start of current Program							;48da	d5 	.
2010  48DB E5           	push hl							; save hl - parse point											;48db	e5 	.
2011  48DC
2012  48DC              ; -- call DOS routine
2013  48DC CD B1 43     	call LOAD					; Load a file from disk											;48dc	cd b1 43 	. . C
2014  48DF
2015  48DF              ; -- restore current Program start and end addresses
2016  48DF E1           	pop hl							; restore hl - parse point										;48df	e1 	.
2017  48E0 D1           	pop de							; restore de - saved start of current Program					;48e0	d1 	.
2018  48E1 ED 53 A4 78  	ld (SYS_BASIC_START_PTR),de		; set as Start of current Program 								;48e1	ed 53 a4 78 	. S . x
2019  48E5 D1           	pop de							; restore de - saved end of current Program						;48e5	d1 	.
2020  48E6 ED 53 F9 78  	ld (SYS_BASIC_END_PTR),de		; set as End of current Program 								;48e6	ed 53 f9 78 	. S . x
2021  48EA              ; -- now check if was any Error
2022  48EA B7           	or a							; was any Error?												;48ea	b7 	.
2023  48EB C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;48eb	c2 41 42 	. A B
2024  48EE C9           	ret								; no ----------------- End of Proc ----------------------------	;48ee	c9 	.
2025  48EF
2026  48EF
2027  48EF
2028  48EF              ;***************************************************************************************************
2029  48EF              ; DOS Command BRUN
2030  48EF              ; Syntax: BRUN "filename"
2031  48EF              ; -----------------------
2032  48EF              ; Load file specified by filename (which has the file type code "B") from a Floppy Disk and execute it.
2033  48EF              ; The address where file will be loaded is already defined on Disk (after saving via BSAVE command).
2034  48EF              ; Filename may have no more than 8 characters.
2035  48EF              ; IN: hl - parse point (just after 'BRUN' text)
2036  48EF              DCmdBRUN:
2037  48EF              ; -- expected required name of file enclosed with double quote chars
2038  48EF CD 67 53     	call CSI						; parse filename and copy it to (iy+FNAM)						;48ef	cd 67 53 	. g S
2039  48F2 E5           	push hl							; save hl - parse point											;48f2	e5 	.
2040  48F3 B7           	or a							; was any Error?												;48f3	b7 	.
2041  48F4 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;48f4	c2 41 42 	. A B
2042  48F7
2043  48F7              ; -- set type of file as Binary Program ('B') and call DOS routine
2044  48F7 FD 36 09 42  	ld (iy+TYPE),'B'				; set type of file as Binary Program ('B')						;48f7	fd 36 09 42 	. 6 . B
2045  48FB CD B1 43     	call LOAD					; Load a file from disk											;48fb	cd b1 43 	. . C
2046  48FE B7           	or a							; was any Error?												;48fe	b7 	.
2047  48FF C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	; Error handling routine	;48ff	c2 41 42 	. A B
2048  4902
2049  4902              ; -- execute loaded code from 1st byte
2050  4902 2A A4 78     	ld hl,(SYS_BASIC_START_PTR)		; hl - start of loaded Program 									;4902	2a a4 78 	* . x
2051  4905 E9           	jp (hl)							; execute loaded Program --------------------------------------	;4905	e9 	.
2052  4906
2053  4906
2054  4906
2055  4906              ;***************************************************************************************************
2056  4906              ; DOS Command DIR
2057  4906              ; Syntax: DIR
2058  4906              ; -----------
2059  4906              ; Display list of all files on Disk. For every file the file Type will be printed as well.
2060  4906              ; For example: T:MYFILE
2061  4906              ; File Types: 'T' - BASIC text file, 'B' - binary program, 'D' - data file which should be handled
2062  4906              ; by DOS commands like 'IN#' and 'PR#'
2063  4906              ; IN: hl - parse point (just after 'BRUN' text)
2064  4906              DCmdDIR:
2065  4906 E5           	push hl							; save hl - parse point											;4906	e5 	.
2066  4907 F3           	di								; disable interrupts											;4907	f3 	.
2067  4908
2068  4908              ; -- turn on Disk Drive and wait 50 ms
2069  4908 CD 41 5F     	call PWRON						; Disk power ON													;4908	cd 41 5f 	. A _
2070  490B C5           	push bc							; save bc														;490b	c5 	.
2071  490C 01 32 00     	ld bc,50						; bc - 50 miliseconds to delay									;490c	01 32 00 	. 2 .
2072  490F CD BE 5E     	call DLY						; delay 50 ms													;490f	cd be 5e 	. . ^
2073  4912 C1           	pop bc							; restore bc													;4912	c1 	.
2074  4913
2075  4913              ; -- set 1st sector with Directory Entries to read
2076  4913 FD 36 12 00  	ld (iy+TRCK),0					; set Track Number 0											;4913	fd 36 12 00 	. 6 . .
2077  4917 FD 36 11 00  	ld (iy+SCTR),0					; set Sector Number 0											;4917	fd 36 11 00 	. 6 . .
2078  491B
2079  491B              .nextSector:
2080  491B              ; -- read Sector with Directory Entries
2081  491B F3           	di								; disable interrupts											;491b	f3 	.
2082  491C CD 27 5B     	call READ						; Read sector from disk											;491c	cd 27 5b 	. ' [
2083  491F B7           	or a							; was any Error?												;491f	b7 	.
2084  4920 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4920	c2 41 42 	. A B
2085  4923
2086  4923              ; -- setup for 1st Directory Entry on this Sector
2087  4923 FD 6E 31     	ld l,(iy+DBFR)					; hl - address of data from Sector								;4923	fd 6e 31 	. n 1
2088  4926 FD 66 32     	ld h,(iy+DBFR+1)																				;4926	fd 66 32 	. f 2
2089  4929 11 06 00     	ld de,6							; de - 6 bytes to skip after filename in Directory Entry		;4929	11 06 00 	. . .
2090  492C 0E 08        	ld c,8							; c - 8 entries per Sector										;492c	0e 08 	. .
2091  492E
2092  492E              .printDirEntry:
2093  492E              ; -- check 1st char of Directory Entry - file type, file deleted or end of Directory List
2094  492E 7E           	ld a,(hl)						; a - file type 												;492e	7e 	~
2095  492F B7           	or a							; is it 0? (end of Directory List)								;492f	b7 	.
2096  4930 28 5D        	jr z,.exit						; yes - turn off Disk and exit --------------------------------	;4930	28 5d 	( ]
2097  4932 FE 01        	cp 1							; is it 1? (deleted entry)										;4932	fe 01 	. .
2098  4934 20 08        	jr nz,.printFilename			; no - print 10 chars of entry (filename) on screen 			;4934	20 08 	  .
2099  4936
2100  4936              ; -- entry deleted - skip 10 chars (without printing on screen)
2101  4936 C5           	push bc							; save bc														;4936	c5 	.
2102  4937 01 0A 00     	ld bc,10						; bc - 10 chars to skip											;4937	01 0a 00 	. . .
2103  493A 09           	add hl,bc						; hl - point to byte just after filename						;493a	09 	.
2104  493B C1           	pop bc							; restore bc													;493b	c1 	.
2105  493C 18 0E        	jr .testSPACEPress				; skip printing code and continue -----------------------------	;493c	18 0e 	. .
2106  493E
2107  493E              .printFilename:
2108  493E              ; -- print on screen 10 chars from Directory Entry (filetype,';', and filename)
2109  493E 06 0A        	ld b,10							; b - 10 chars to print on screen								;493e	06 0a 	. .
2110  4940              .printNextChar:
2111  4940 7E           	ld a,(hl)						; a - char from Driectory Entry									;4940	7e 	~
2112  4941 CD 2A 03     	call SysPrintChar				; call ROM routine to print char on screen						;4941	cd 2a 03 	. * .
2113  4944 23           	inc hl							; hl - next char												;4944	23 	#
2114  4945 10 F9        	djnz .printNextChar				; keep printing all 10 chars ----------------------------------	;4945	10 f9 	. .
2115  4947              ; -- move cursor to next line
2116  4947 3E 0D        	ld a,CR							; a - new line character										;4947	3e 0d 	> .
2117  4949 CD 2A 03     	call SysPrintChar				; call ROM routine to move cursor to next line					;4949	cd 2a 03 	. * .
2118  494C
2119  494C              .testSPACEPress:
2120  494C              ; -- test if SPACE key pressed - to PAUSE printing
2121  494C F3           	di								; disable interrupts											;494c	f3 	.
2122  494D 3A EF 68     	ld a,(SpaceKeyRow)				; a - read Keyboard row with SPACE key							;494d	3a ef 68 	: . h
2123  4950 CB 67        	bit SpaceKeyCol,a				; is SPACE key pressed?											;4950	cb 67 	. g
2124  4952 20 2D        	jr nz,.moveToNextEntry			; no - continue listing Directory Entries ---------------------	;4952	20 2d 	  -
2125  4954              ; -- SPACE key is pressed - delay 20 ms
2126  4954 C5           	push bc							; save bc														;4954	c5 	.
2127  4955 01 14 00     	ld bc,20						; bc - 20 miliseconds to delay									;4955	01 14 00 	. . .
2128  4958 CD BE 5E     	call DLY						; delay 20 ms													;4958	cd be 5e 	. . ^
2129  495B C1           	pop bc							; restore bc													;495b	c1 	.
2130  495C              .waitKeyReleased:
2131  495C              ; -- wait for SPACE Key to be released
2132  495C 3A EF 68     	ld a,(SpaceKeyRow)				; a - read Keyboard row with SPACE key							;495c	3a ef 68 	: . h
2133  495F CB 67        	bit SpaceKeyCol,a				; is SPACE key pressed?											;495f	cb 67 	. g
2134  4961 28 F9        	jr z,.waitKeyReleased			; yes - wait until released -----------------------------------	;4961	28 f9 	( .
2135  4963              ; -- SPACE key is released - delay 20 ms
2136  4963 C5           	push bc							; save bc														;4963	c5 	.
2137  4964 01 14 00     	ld bc,20						; bc - 20 miliseconds to delay									;4964	01 14 00 	. . .
2138  4967 CD BE 5E     	call DLY						; delay 20 ms													;4967	cd be 5e 	. . ^
2139  496A C1           	pop bc							; restore bc													;496a	c1 	.
2140  496B
2141  496B
2142  496B              .waitKeyPressed:
2143  496B              ; -- test if SPACE key pressed - to RESUME printing
2144  496B 3A EF 68     	ld a,(SpaceKeyRow)				; a - read Keyboard row with SPACE key							;496b	3a ef 68 	: . h
2145  496E CB 67        	bit SpaceKeyCol,a				; is SPACE key pressed?											;496e	cb 67 	. g
2146  4970 20 F9        	jr nz,.waitKeyPressed			; no - wait until pressed -------------------------------------	;4970	20 f9 	  .
2147  4972              ; -- SPACE key is pressed - delay 20 ms
2148  4972 C5           	push bc							; save bc														;4972	c5 	.
2149  4973 01 14 00     	ld bc,20						; bc - 20 miliseconds to delay									;4973	01 14 00 	. . .
2150  4976 CD BE 5E     	call DLY						; delay 20 ms													;4976	cd be 5e 	. . ^
2151  4979 C1           	pop bc							; restore bc													;4979	c1 	.
2152  497A              .waitKeyRelAgain:
2153  497A              ; -- wait for SPACE Key to be released
2154  497A 3A EF 68     	ld a,(SpaceKeyRow)				; a - read Keyboard row with SPACE key							;497a	3a ef 68 	: . h
2155  497D CB 67        	bit SpaceKeyCol,a				; is SPACE key pressed?											;497d	cb 67 	. g
2156  497F 28 F9        	jr z,.waitKeyRelAgain			; yes - wait until released -----------------------------------	;497f	28 f9 	( .
2157  4981
2158  4981              .moveToNextEntry:
2159  4981              ; -- update pointer to next Directory Entry to read
2160  4981 19           	add hl,de						; hl - begin of next Entry (skip 6 bytes)						;4981	19 	.
2161  4982 0D           	dec c							; are 8 entries already printed from this Sector?				;4982	0d 	.
2162  4983 20 A9        	jr nz,.printDirEntry			; no - print next Directory Entry -----------------------------	;4983	20 a9 	  .
2163  4985
2164  4985              ; -- 8 entries been read - setup next Sector to read
2165  4985 FD 34 11     	inc (iy+SCTR)					; increment Sector Number										;4985	fd 34 11 	. 4 .
2166  4988 FD 7E 11     	ld a,(iy+SCTR)					; a - number of next Sector to read								;4988	fd 7e 11 	. ~ .
2167  498B FE 0F        	cp 15							; all 14 sectors already read?									;498b	fe 0f 	. .
2168  498D 20 8C        	jr nz,.nextSector				; no - read next Sector ---------------------------------------	;498d	20 8c 	  .
2169  498F
2170  498F              .exit:
2171  498F CD 52 5F     	call PWROFF						; Disk power OFF												;498f	cd 52 5f 	. R _
2172  4992 E1           	pop hl							; restore hl - parse point										;4992	e1 	.
2173  4993 C9           	ret								; -------------------- End of Proc ----------------------------	;4993	c9 	.
2174  4994
2175  4994
2176  4994
2177  4994              ;***************************************************************************************************
2178  4994              ; DOS Command ERA
2179  4994              ; Syntax: ERA "filename"
2180  4994              ; ----------------------
2181  4994              ; Deleted file specified by filename from Disk.
2182  4994              ; Filename may have no more than 8 characters.
2183  4994              ; IN: hl - parse point (just after 'ERA' text)
2184  4994              DCmdERA:
2185  4994              ; -- expected required name of file enclosed with double quote chars
2186  4994 CD 67 53     	call CSI						; parse filename and copy it to (iy+FNAM)						;4994	cd 67 53 	. g S
2187  4997 E5           	push hl							; save hl - parse point											;4997	e5 	.
2188  4998 B7           	or a							; was any Error?												;4998	b7 	.
2189  4999 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4999	c2 41 42 	. A B
2190  499C
2191  499C              ; -- turn on Disk Drive and wait 50 ms
2192  499C F3           	di								; disable interrupts											;499c	f3 	.
2193  499D CD 41 5F     	call PWRON						; Disk power ON													;499d	cd 41 5f 	. A _
2194  49A0 C5           	push bc							; save bc														;49a0	c5 	.
2195  49A1 01 32 00     	ld bc,50						; bc - 50 miliseconds to delay									;49a1	01 32 00 	. 2 .
2196  49A4 CD BE 5E     	call DLY						; delay 50 ms													;49a4	cd be 5e 	. . ^
2197  49A7 C1           	pop bc							; restore bc													;49a7	c1 	.
2198  49A8
2199  49A8              ; -- check if Disk is not Write-Protected
2200  49A8 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;49a8	db 13 	. .
2201  49AA B7           	or a							; is bit 7 set? (write protected)								;49aa	b7 	.
2202  49AB 3E 04        	ld a,04							; a - Error 04 - DISK WRITE PROTECTED							;49ab	3e 04 	> .
2203  49AD FA 41 42     	jp m,ERROR						; yes - go to Error handling routine --------------------------	;49ad	fa 41 42 	. A B
2204  49B0
2205  49B0              ; -- find Directory Entry for this file
2206  49B0 CD 13 59     	call SEARCH						; Search for file in directory									;49b0	cd 13 59 	. . Y
2207  49B3 FE 02        	cp 02							; was Error 2 - FILE ALREADY EXISTS	?							;49b3	fe 02 	. .
2208  49B5 28 09        	jr z,.fileFound					; yes - continue deleting file --------------------------------	;49b5	28 09 	( .
2209  49B7              ; -- other error or No Error
2210  49B7 B7           	or a							; other error?													;49b7	b7 	.
2211  49B8 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;49b8	c2 41 42 	. A B
2212  49BB              ; -- No Error - means there are no requested file on Disk
2213  49BB 3E 0D        	ld a,13							; a - Error 13 - FILE NOT FOUND									;49bb	3e 0d 	> .
2214  49BD C3 41 42     	jp ERROR						; go to Error handling routine --------------------------------	;49bd	c3 41 42 	. A B
2215  49C0
2216  49C0              ; -- in FINDFILE routine de is set to address of 10th byte of Directory Entry - file Track number
2217  49C0              .fileFound:
2218  49C0              ; -- set track and sector numbers for 1st sector of file
2219  49C0 1A           	ld a,(de)						; a - Track number of 1st file sector 							;49c0	1a 	.
2220  49C1 13           	inc de							; de - point to Sector Number									;49c1	13 	.
2221  49C2 FD 77 16     	ld (iy+NTRK),a					; set Track Number for Sector to delete 						;49c2	fd 77 16 	. w .
2222  49C5 1A           	ld a,(de)						; a - Sector Number of 1st file sector							;49c5	1a 	.
2223  49C6 FD 77 15     	ld (iy+NSCT),a					; set Sector Number fo Sector to delete							;49c6	fd 77 15 	. w .
2224  49C9
2225  49C9              ; -- mark file's Directory Entry as deleted
2226  49C9 EB           	ex de,hl						; hl - address in Directory Entry								;49c9	eb 	.
2227  49CA 11 F5 FF     	ld de,-11						; de - 11 bytes back will be start of Directory Entry 			;49ca	11 f5 ff 	. . .
2228  49CD 19           	add hl,de						; hl - start of Directory Entry - file type						;49cd	19 	.
2229  49CE 36 01        	ld (hl),1						; set file type byte to 1 - entry deleted						;49ce	36 01 	6 .
2230  49D0 CD A1 59     	call WRITE						; Write sector with Directory to disk							;49d0	cd a1 59 	. . Y
2231  49D3 B7           	or a							; was any Error?												;49d3	b7 	.
2232  49D4 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;49d4	c2 41 42 	. A B
2233  49D7
2234  49D7              ; -- read Disk Map Sector from Disk
2235  49D7 FD 36 12 00  	ld (iy+TRCK),0					; set Track Number 0 											;49d7	fd 36 12 00 	. 6 . .
2236  49DB FD 36 11 0F  	ld (iy+SCTR),15					; set Sector Number 15											;49db	fd 36 11 0f 	. 6 . .
2237  49DF CD 27 5B     	call READ						; Read Disk Map sector from disk								;49df	cd 27 5b 	. ' [
2238  49E2 B7           	or a							; was any Error?												;49e2	b7 	.
2239  49E3 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;49e3	c2 41 42 	. A B
2240  49E6              ; -- copy sector data to Disk Map buffer
2241  49E6 FD 5E 34     	ld e,(iy+MAPADR)				; de - (dst) address of Disk Map buffer							;49e6	fd 5e 34 	. ^ 4
2242  49E9 FD 56 35     	ld d,(iy+MAPADR+1)																				;49e9	fd 56 35 	. V 5
2243  49EC FD 6E 31     	ld l,(iy+DBFR)					; hl - (src) address of Sector data read from Disk				;49ec	fd 6e 31 	. n 1
2244  49EF FD 66 32     	ld h,(iy+DBFR+1)																				;49ef	fd 66 32 	. f 2
2245  49F2 01 50 00     	ld bc,80						; bc - 80 bytes to copy											;49f2	01 50 00 	. P .
2246  49F5 ED B0        	ldir							; copy Disk Map data 											;49f5	ed b0 	. .
2247  49F7
2248  49F7              ; -- get all sectors for this file and mark them as unused in Disk Map
2249  49F7              .nextFileSector:
2250  49F7              ; -- read file sector
2251  49F7 FD 7E 16     	ld a,(iy+NTRK)					; a - Track  Number to read										;49f7	fd 7e 16 	. ~ .
2252  49FA B7           	or a							; is it 0? (no more sectors used by file)						;49fa	b7 	.
2253  49FB CA 4F 4A     	jp z,.saveDiskMap				; yes - ;49fb	ca 4f 4a 	. O J
2254  49FE FD 77 12     	ld (iy+TRCK),a					; set as Track Number of sector to read							;49fe	fd 77 12 	. w .
2255  4A01 FD 7E 15     	ld a,(iy+NSCT)					; a - Sector Number												;4a01	fd 7e 15 	. ~ .
2256  4A04 FD 77 11     	ld (iy+SCTR),a					; set as Sector Number of sector to read						;4a04	fd 77 11 	. w .
2257  4A07 CD 27 5B     	call READ						; Read a sector from disk										;4a07	cd 27 5b 	. ' [
2258  4A0A B7           	or a							; was any Error?												;4a0a	b7 	.
2259  4A0B C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4a0b	c2 41 42 	. A B
2260  4A0E              ; -- read last 2 bytes to get next sector number and track number
2261  4A0E FD 6E 31     	ld l,(iy+DBFR)					; hl - address of Sector data 									;4a0e	fd 6e 31 	. n 1
2262  4A11 FD 66 32     	ld h,(iy+DBFR+1)																				;4a11	fd 66 32 	. f 2
2263  4A14 11 7E 00     	ld de,126						; de - offset from begin of sector data buffer					;4a14	11 7e 00 	. ~ .
2264  4A17 19           	add hl,de						; hl - points to next Track Number								;4a17	19 	.
2265  4A18 7E           	ld a,(hl)						; a - track number of next sector								;4a18	7e 	~
2266  4A19 FD 77 16     	ld (iy+NTRK),a					; store as next Track Number									;4a19	fd 77 16 	. w .
2267  4A1C 23           	inc hl							; hl - points to next Sector Number								;4a1c	23 	#
2268  4A1D 7E           	ld a,(hl)						; a - sector number of next sector								;4a1d	7e 	~
2269  4A1E FD 77 15     	ld (iy+NSCT),a					; stor as next Sector Number									;4a1e	fd 77 15 	. w .
2270  4A21
2271  4A21              ; -- get Disk Map address
2272  4A21 FD 6E 34     	ld l,(iy+MAPADR)				; hl - address of Disk Map buffer								;4a21	fd 6e 34 	. n 4
2273  4A24 FD 66 35     	ld h,(iy+MAPADR+1)																				;4a24	fd 66 35 	. f 5
2274  4A27              ; -- calculate byte offset
2275  4A27 FD 7E 12     	ld a,(iy+TRCK)					; a - Track Number of sector for next chunk of file				;4a27	fd 7e 12 	. ~ .
2276  4A2A 3D           	dec a							; a = a -1 (Disk Map covers sectors from track 1)				;4a2a	3d 	=
2277  4A2B CB 27        	sla a							; track * 2 (2 bytes in Map covers 1 track)						;4a2b	cb 27 	. '
2278  4A2D 5F           	ld e,a							; e - offset in Disk Map for Track								;4a2d	5f 	_
2279  4A2E 16 00        	ld d,0							; de - offset in Disk Map for Track								;4a2e	16 00 	. .
2280  4A30 FD 7E 11     	ld a,(iy+SCTR)					; a - Sector number for next chunk of file						;4a30	fd 7e 11 	. ~ .
2281  4A33 FE 08        	cp 8							; set Carry flag if Sector < 8 									;4a33	fe 08 	. .
2282  4A35 3F           	ccf								; invert Carry - will be 1 if Sector >= 8 						;4a35	3f 	?
2283  4A36 ED 5A        	adc hl,de						; hl - address in Disk Map of bitmask with this sector			;4a36	ed 5a 	. Z
2284  4A38              ; -- calculate bit number
2285  4A38 E6 07        	and %0111						; a - bit number for this sector								;4a38	e6 07 	. .
2286  4A3A 3C           	inc a							; preincrement for number of rotates 1..8						;4a3a	3c 	<
2287  4A3B 47           	ld b,a							; b - how many times to rotate bitmask							;4a3b	47 	G
2288  4A3C              ; -- reset bit for this sector (not used)
2289  4A3C 4E           	ld c,(hl)						; c - bitmask with this sector									;4a3c	4e 	N
2290  4A3D CB 01        	rlc c							; pre-rotate left (set Carry from 7th bit)						;4a3d	cb 01 	. .
2291  4A3F              .loop1:
2292  4A3F CB 09        	rrc c							; rotate right bitmask											;4a3f	cb 09 	. .
2293  4A41 10 FC        	djnz .loop1						; keep rotate until bit is at position 0						;4a41	10 fc 	. .
2294  4A43 CB 81        	res 0,c							; clear bit for this sector										;4a43	cb 81 	. .
2295  4A45 47           	ld b,a							; b - number of rotates to do									;4a45	47 	G
2296  4A46 CB 09        	rrc c							; pre-rotate right (set Carry from 0th bit)						;4a46	cb 09 	. .
2297  4A48              .loop2:
2298  4A48 CB 01        	rlc c							; rotate left bitmask											;4a48	cb 01 	. .
2299  4A4A 10 FC        	djnz .loop2						; keep rotate until bit returns to its original position		;4a4a	10 fc 	. .
2300  4A4C 71           	ld (hl),c						; store updated byte to Disk Map								;4a4c	71 	q
2301  4A4D 18 A8        	jr .nextFileSector				; get next Sector of file and mark it as unused ---------------	;4a4d	18 a8 	. .
2302  4A4F
2303  4A4F              .saveDiskMap:
2304  4A4F              ; -- clear Sector Buffer
2305  4A4F FD 6E 31     	ld l,(iy+DBFR)					; hl - (src) address of Sector Buffer							;4a4f	fd 6e 31 	. n 1
2306  4A52 FD 66 32     	ld h,(iy+DBFR+1)																				;4a52	fd 66 32 	. f 2
2307  4A55 E5           	push hl							; save hl - address of Sector Buffer							;4a55	e5 	.
2308  4A56 36 00        	ld (hl),0						; set 1st byte to 0												;4a56	36 00 	6 .
2309  4A58 5D           	ld e,l							; copy hl to de													;4a58	5d 	]
2310  4A59 54           	ld d,h							; de - address of Sector Buffer 								;4a59	54 	T
2311  4A5A 13           	inc de							; de - (dst) address of 2db byte in Sector Buffer				;4a5a	13 	.
2312  4A5B 01 7F 00     	ld bc,127						; bc - 125 bytes to clear										;4a5b	01 7f 00 	.  .
2313  4A5E ED B0        	ldir							; clear (copy byte 0) Sector Buffer								;4a5e	ed b0 	. .
2314  4A60              ; -- copy 80 bytes of Disk Map to Sector Buffer
2315  4A60 D1           	pop de							; restore de - (dst) address of Sector Buffer					;4a60	d1 	.
2316  4A61 FD 6E 34     	ld l,(iy+MAPADR)				; hl - (src) address of Disk Map buffer							;4a61	fd 6e 34 	. n 4
2317  4A64 FD 66 35     	ld h,(iy+MAPADR+1)																				;4a64	fd 66 35 	. f 5
2318  4A67 01 50 00     	ld bc,80						; bc - 80 bytes to copy											;4a67	01 50 00 	. P .
2319  4A6A ED B0        	ldir							; copy Disk Map to Sector Buffer								;4a6a	ed b0 	. .
2320  4A6C              ; -- save Disk Map to Disk
2321  4A6C FD 36 12 00  	ld (iy+TRCK),0					; set Track Number 0											;4a6c	fd 36 12 00 	. 6 . .
2322  4A70 FD 36 11 0F  	ld (iy+SCTR),15					; set Sector Number 15											;4a70	fd 36 11 0f 	. 6 . .
2323  4A74 CD A1 59     	call WRITE						; Write Disk Map to sector on Disk								;4a74	cd a1 59 	. . Y
2324  4A77 B7           	or a							; was any Error?												;4a77	b7 	.
2325  4A78 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4a78	c2 41 42 	. A B
2326  4A7B              ; -- file deleted
2327  4A7B CD 52 5F     	call PWROFF						; Disk power OFF												;4a7b	cd 52 5f 	. R _
2328  4A7E E1           	pop hl							; restore hl - parse point										;4a7e	e1 	.
2329  4A7F C9           	ret								; ----------------- End of Proc -------------------------------	;4a7f	c9 	.
2330  4A80
2331  4A80
2332  4A80
2333  4A80              ;***************************************************************************************************
2334  4A80              ; DOS Command REN
2335  4A80              ; Syntax: REN "oldfilename", "newfilename"
2336  4A80              ; ----------------------------------------
2337  4A80              ; Change name of the file specified by oldfilename to newfilename on Disk.
2338  4A80              ; Both filenames may have no more than 8 characters. File Type stays unchanged.
2339  4A80              ; IN: hl - parse point (just after 'REN' text)
2340  4A80              DCmdREN:
2341  4A80              ; -- expected required name of old file enclosed with double quote chars
2342  4A80 E5           	push hl							; save hl - parse point											;4a80	e5 	.
2343  4A81 CD 78 53     	call ParseFilename				; Verify syntax and copy old filename to DOS Filename Buffer	;4a81	cd 78 53 	. x S
2344  4A84 B7           	or a							; was any Error?												;4a84	b7 	.
2345  4A85 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4a85	c2 41 42 	. A B
2346  4A88              ; -- expected ',' char
2347  4A88 CF           	rst $08							; Assert next char is ','										;4a88	cf 	.
2348  4A89 2C           	defb ','						; next char must be ','											;4a89	2c 	,
2349  4A8A              ; -- expected required name of new file enclosed with double quote chars
2350  4A8A CD 67 53     	call CSI						; parse new filename and copy it to (iy+FNAM)					;4a8a	cd 67 53 	. g S
2351  4A8D B7           	or a							; was any Error?												;4a8d	b7 	.
2352  4A8E C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4a8e	c2 41 42 	. A B
2353  4A91              ; --
2354  4A91 E1           	pop hl							; restore hl - parse point										;4a91	e1 	.
2355  4A92 E5           	push hl							; save hl - parse point (just after 'REN')						;4a92	e5 	.
2356  4A93 CD 78 53     	call ParseFilename				; hl - parse point just after '"' char							;4a93	cd 78 53 	. x S
2357  4A96 23           	inc hl							; skip comma ',' char											;4a96	23 	#
2358  4A97 E5           	push hl							; save hl - start of new filename text (1st '"' char)			;4a97	e5 	.
2359  4A98
2360  4A98              ; -- turn on Disk Drive and wait 50 ms
2361  4A98 F3           	di								; disable interrupts											;4a98	f3 	.
2362  4A99 CD 41 5F     	call PWRON						; Disk power ON													;4a99	cd 41 5f 	. A _
2363  4A9C C5           	push bc							; save bc														;4a9c	c5 	.
2364  4A9D 01 32 00     	ld bc,50						; bc - 50 miliseconds to delay									;4a9d	01 32 00 	. 2 .
2365  4AA0 CD BE 5E     	call DLY						; delay 50 ms													;4aa0	cd be 5e 	. . ^
2366  4AA3 C1           	pop bc							; restore bc 													;4aa3	c1 	.
2367  4AA4
2368  4AA4              ; -- check if Disk is not Write-Protected
2369  4AA4 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;4aa4	db 13 	. .
2370  4AA6 B7           	or a							; is bit 7 set? (write protected)								;4aa6	b7 	.
2371  4AA7 3E 04        	ld a,04							; a - Error 04 - DISK WRITE PROTECTED							;4aa7	3e 04 	> .
2372  4AA9 FA 41 42     	jp m,ERROR						; yes - go to Error handling routine --------------------------	;4aa9	fa 41 42 	. A B
2373  4AAC
2374  4AAC              ; -- find Directory Entry for this file
2375  4AAC CD 13 59     	call SEARCH						; Search for old filename in directory							;4aac	cd 13 59 	. . Y
2376  4AAF FE 02        	cp 02							; was Error 2 - FILE ALREADY EXISTS	?							;4aaf	fe 02 	. .
2377  4AB1 CA BD 4A     	jp z,.oldFilenameFound			; yes - continue renaming file --------------------------------	;4ab1	ca bd 4a 	. . J
2378  4AB4
2379  4AB4              ; -- other error or No Error
2380  4AB4 B7           	or a							; other error?													;4ab4	b7 	.
2381  4AB5 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4ab5	c2 41 42 	. A B
2382  4AB8
2383  4AB8              ; -- No Error - means there are no requested file on Disk
2384  4AB8 3E 0D        	ld a,13							; a - Error 13 - FILE NOT FOUND									;4ab8	3e 0d 	> .
2385  4ABA C3 41 42     	jp ERROR						; go to Error handling routine --------------------------------	;4aba	c3 41 42 	. A B
2386  4ABD
2387  4ABD              .oldFilenameFound:
2388  4ABD E1           	pop hl							; restore hl - start of new filename text						;4abd	e1 	.
2389  4ABE CD 67 53     	call CSI						; parse new filename and copy it to (iy+FNAM)					;4abe	cd 67 53 	. g S
2390  4AC1 E3           	ex (sp),hl						; save hl - parse point (after whole command)					;4ac1	e3 	.
2391  4AC2 E5           	push hl							; save hl - parse point (just after 'REN')						;4ac2	e5 	.
2392  4AC3
2393  4AC3              ; -- check if already exists file with new filename in Directory Entry
2394  4AC3 CD 13 59     	call SEARCH						; Search for new filename in directory							;4ac3	cd 13 59 	. . Y
2395  4AC6 FE 0D        	cp 13							; was Error 13 - FILE NOT FOUND ?								;4ac6	fe 0d 	. .
2396  4AC8 28 04        	jr z,.newFilenameNotFound		; yes - continue renaming 										;4ac8	28 04 	( .
2397  4ACA
2398  4ACA              ; -- other error or No Error
2399  4ACA B7           	or a							; any other Error?												;4aca	b7 	.
2400  4ACB C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4acb	c2 41 42 	. A B
2401  4ACE
2402  4ACE              .newFilenameNotFound:
2403  4ACE              ; -- get sector wit directory Entry for file to rename
2404  4ACE E1           	pop hl							; restore hl - parse point (just after 'REN')					;4ace	e1 	.
2405  4ACF CD 78 53     	call ParseFilename				; copy old filename to DOS Filename Buffer						;4acf	cd 78 53 	. x S
2406  4AD2 23           	inc hl							; skip ',' char													;4ad2	23 	#
2407  4AD3 E5           	push hl							; save hl - start of new filename								;4ad3	e5 	.
2408  4AD4 CD 13 59     	call SEARCH						; find Directory Entry for old filename							;4ad4	cd 13 59 	. . Y
2409  4AD7 FE 02        	cp 02							; was Error 2 - FILE ALREADY EXISTS ?							;4ad7	fe 02 	. .
2410  4AD9 C2 41 42     	jp nz,ERROR						; no - go to Error handling routine ---------------------------	;4ad9	c2 41 42 	. A B
2411  4ADC
2412  4ADC              ; -- save hl and de registers (end of filename in DOS buffer and Directory Entry buffer)
2413  4ADC C1           	pop bc							; bc - start of new filename									;4adc	c1 	.
2414  4ADD E5           	push hl							; save hl - end of old filename in (iy+FNAM)					;4add	e5 	.
2415  4ADE D5           	push de							; save de - end of old filename in Dir Entry Buffer				;4ade	d5 	.
2416  4ADF              ; -- copy given new filename to DOS buffer
2417  4ADF 69           	ld l,c							; copy bc to hl													;4adf	69 	i
2418  4AE0 60           	ld h,b							; hl - start of new filename									;4ae0	60 	`
2419  4AE1 CD 67 53     	call CSI						; parse new filename and copy it to (iy+FNAM)					;4ae1	cd 67 53 	. g S
2420  4AE4              ; -- restore hl and de pointers and move them to begin of filename in DOS buffer and Dir Entry
2421  4AE4 D1           	pop de							; restore de - end of old filename in Dir Entry Buffer			;4ae4	d1 	.
2422  4AE5 E1           	pop hl							; restore hl - end of now new filename in (iy+FNAM)				;4ae5	e1 	.
2423  4AE6 01 F8 FF     	ld bc,-8						; bc - 8 bytes of name to move back pointer						;4ae6	01 f8 ff 	. . .
2424  4AE9 09           	add hl,bc						; hl - start of new filename in DOS Buffer						;4ae9	09 	.
2425  4AEA EB           	ex de,hl						; de - start of new filename in DOS buffer						;4aea	eb 	.
2426  4AEB 09           	add hl,bc						; hl - start of old filename in Dir Entry Buffer				;4aeb	09 	.
2427  4AEC
2428  4AEC              ; -- fill Directory Entry with new file type and name
2429  4AEC 2B           	dec hl							; move back hl													;4aec	2b 	+
2430  4AED 2B           	dec hl							; hl - points to File Type char in Dir Entry					;4aed	2b 	+
2431  4AEE              ; -- copy FileType
2432  4AEE FD 7E 0A     	ld a,(iy+TYPE+1)				; a - new file Type												;4aee	fd 7e 0a 	. ~ .
2433  4AF1 77           	ld (hl),a						; store in Directory Entry										;4af1	77 	w
2434  4AF2 23           	inc hl							; hl - points to separator char in Dir Entry					;4af2	23 	#
2435  4AF3              ; -- copy separator
2436  4AF3 36 3A        	ld (hl),':'						; store separator char ':'										;4af3	36 3a 	6 :
2437  4AF5 23           	inc hl							; hl - start of filename in Dir Entry							;4af5	23 	#
2438  4AF6              ; -- copy 8 chars of filename
2439  4AF6 EB           	ex de,hl						; de - (dst) Dir entry, hl - (src) DOS buffer					;4af6	eb 	.
2440  4AF7 01 08 00     	ld bc,8							; bc - 8 chars to copy											;4af7	01 08 00 	. . .
2441  4AFA ED B0        	ldir							; copy new filename to Directory Entry							;4afa	ed b0 	. .
2442  4AFC CD A1 59     	call WRITE						; Write sector with Directory to disk							;4afc	cd a1 59 	. . Y
2443  4AFF B7           	or a							; was any Error?												;4aff	b7 	.
2444  4B00 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4b00	c2 41 42 	. A B
2445  4B03              ; -- no error - turn off DIsk and return
2446  4B03 CD 52 5F     	call PWROFF						; Disk power OFF												;4b03	cd 52 5f 	. R _
2447  4B06 E1           	pop hl							; restore hl - parse point (after whole command)				;4b06	e1 	.
2448  4B07 C9           	ret								; ------------------- End of Proc -----------------------------	;4b07	c9 	.
2449  4B08
2450  4B08
2451  4B08
2452  4B08
2453  4B08              ;***************************************************************************************************
2454  4B08              ; DOS Command INIT
2455  4B08              ; Syntax: INIT
2456  4B08              ; ----------------
2457  4B08              ; Initialize the disk (format)
2458  4B08              ; Used also from DOS jump Table
2459  4B08              ; IN: IY+DK - selected Drive
2460  4B08              ; OUT: none
2461  4B08              ;***************************************************************************************************
2462  4B08              DCmdINIT:
2463  4B08              INIT:
2464  4B08              ; -- turn on disk drive
2465  4B08 F3           	di								; disable interrupts											;4b08	f3 	.
2466  4B09 CD 41 5F     	call PWRON						; Disk power ON													;4b09	cd 41 5f 	. A _
2467  4B0C
2468  4B0C              ; -- wait 1 sek to have Disk Drive ready
2469  4B0C C5           	push bc							; save bc 														;4b0c	c5 	.
2470  4B0D 01 E8 03     	ld bc,1000						; 1000 ms delay													;4b0d	01 e8 03 	. . .
2471  4B10 CD BE 5E     	call DLY						; wait 1000 ms 		 											;4b10	cd be 5e 	. . ^
2472  4B13 C1           	pop bc							; restore bc													;4b13	c1 	.
2473  4B14
2474  4B14              ; -- check if disk is write protected and raise Error 04 if it's the case
2475  4B14 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;4b14	db 13 	. .
2476  4B16 B7           	or a							; check if bit 7 is set 										;4b16	b7 	.
2477  4B17 3E 04        	ld a,04							; Error Code 4 - "?DISK WRITE PROTECTED"						;4b17	3e 04 	> .
2478  4B19 FA 41 42     	jp m,ERROR						; yes - go to Error handling routine --------------------------	;4b19	fa 41 42 	. A B
2479  4B1C
2480  4B1C              ; -- prepeare sector data to copy on disk
2481  4B1C E5           	push hl							; save hl 														;4b1c	e5 	.
2482  4B1D FD E5        	push iy							; iy - DOS base address											;4b1d	fd e5 	. .
2483  4B1F E1           	pop hl							; copy to hl													;4b1f	e1 	.
2484  4B20 11 4D 00     	ld de,SectorBuffer				; offset to Sector Buffer										;4b20	11 4d 00 	. M .
2485  4B23 19           	add hl,de						; hl - address of Sector Buffer									;4b23	19 	.
2486  4B24 FD 36 12 00  	ld (iy+TRCK),0					; set Track Number 0											;4b24	fd 36 12 00 	. 6 . .
2487  4B28 FD 36 11 00  	ld (iy+SCTR),0					; set Sector Number 0											;4b28	fd 36 11 00 	. 6 . .
2488  4B2C FD 75 0E     	ld (iy+UBFR),l					; set Sector buffer as address to copy from						;4b2c	fd 75 0e 	. u .
2489  4B2F FD 74 0F     	ld (iy+UBFR+1),h																				;4b2f	fd 74 0f 	. t .
2490  4B32
2491  4B32              ; -- copy Template of sector header into Sector Buffer
2492  4B32 EB           	ex de,hl						; dst - de - address of Sector Buffer							;4b32	eb 	.
2493  4B33 21 4F 4D     	ld hl,SecHeaderInitData			; src - hl - sector init data template							;4b33	21 4f 4d 	! O M
2494  4B36 01 18 00     	ld bc,24						; Sector Header has 24 bytes to copy							;4b36	01 18 00 	. . .
2495  4B39 ED B0        	ldir							; copy 24 bytes to Sector Buffer								;4b39	ed b0 	. .
2496  4B3B
2497  4B3B              ; clear 128 bytes (sector data) + 2 bytes (checksum)
2498  4B3B 62           	ld h,d						; src - hl - 1st byte of Sector Data Area							;4b3b	62 	b
2499  4B3C 6B           	ld l,e																							;4b3c	6b 	k
2500  4B3D 36 00        	ld (hl),0						; clear 1st byte 												;4b3d	36 00 	6 .
2501  4B3F 13           	inc de							; dst - de - naxt byte in buffer								;4b3f	13 	.
2502  4B40 01 82 00     	ld bc,128+2						; 130 bytes to clear (data+checksum)							;4b40	01 82 00 	. . .
2503  4B43 ED B0        	ldir							; clear 130 bytes in buffer										;4b43	ed b0 	. .
2504  4B45
2505  4B45              ; -- move drive Head to track 0
2506  4B45 FD 36 38 11  	ld (iy+PHASE),%00010001			; set Step Motor to 0001-0001 									;4b45	fd 36 38 11 	. 6 8 .
2507  4B49 06 28        	ld b,40							; max 40 tracks to StepOut										;4b49	06 28 	. (
2508  4B4B CD 01 5F     	call STPOUT						; execute Track Step Out 										;4b4b	cd 01 5f 	. . _
2509  4B4E              ; -- wait 400ms
2510  4B4E C5           	push bc							; save bc														;4b4e	c5 	.
2511  4B4F 01 90 01     	ld bc,400						; 400 ms delay													;4b4f	01 90 01 	. . .
2512  4B52 CD BE 5E     	call DLY						; wait 400 ms Delay												;4b52	cd be 5e 	. . ^
2513  4B55 C1           	pop bc							; restore bc													;4b55	c1 	.
2514  4B56
2515  4B56              ; -- set registers hl,de,bc to adresses in buffer for Trk#,Sect#,TSCRC
2516  4B56 FD 6E 0E     	ld l,(iy+UBFR)					; hl - address of Copy buffer									;4b56	fd 6e 0e 	. n .
2517  4B59 FD 66 0F     	ld h,(iy+UBFR+1)																				;4b59	fd 66 0f 	. f .
2518  4B5C 11 0B 00     	ld de,11						; offset to byte with Track number value						;4b5c	11 0b 00 	. . .
2519  4B5F 19           	add hl,de						; hl - address of Track Number in Sector Buffer					;4b5f	19 	.
2520  4B60 54           	ld d,h							; de = hl														;4b60	54 	T
2521  4B61 5D           	ld e,l							; de - address of Track Number in Sector Buffer					;4b61	5d 	]
2522  4B62 13           	inc de							; de - address of Sector Number in Sector Buffer				;4b62	13 	.
2523  4B63 42           	ld b,d							; bc = de														;4b63	42 	B
2524  4B64 4B           	ld c,e							; bc - address of Sector Number in Sector Buffer				;4b64	4b 	K
2525  4B65 03           	inc bc							; bc - address of Track+Sector CRC in Sector Buffer				;4b65	03 	.
2526  4B66 D9           	exx								; save bc,de,hl into alt registers								;4b66	d9 	.
2527  4B67
2528  4B67
2529  4B67              DI_WriteTrack:
2530  4B67              ; -- wait 100 ms delay
2531  4B67 C5           	push bc							; save bc 														;4b67	c5 	.
2532  4B68 01 64 00     	ld bc,100						; 100 ms Delay													;4b68	01 64 00 	. d .
2533  4B6B CD BE 5E     	call DLY						; wait 100 ms Delay 											;4b6b	cd be 5e 	. . ^
2534  4B6E C1           	pop bc							; restore bc													;4b6e	c1 	.
2535  4B6F
2536  4B6F              ; -- send Write Request to drive
2537  4B6F FD 7E 33     	ld a,(iy+LTHCPY)				; a - last value sent to FLCtrl									;4b6f	fd 7e 33 	. ~ 3
2538  4B72 CB B7        	res 6,a							; clear bit 6 - Write Request (active LOW)						;4b72	cb b7 	. .
2539  4B74 FD 77 33     	ld (iy+LTHCPY),a				; store FLCtrl to shadow register								;4b74	fd 77 33 	. w 3
2540  4B77 D3 10        	out (FLCTRL),a					; set Flopy Control byte										;4b77	d3 10 	. .
2541  4B79
2542  4B79              ; -- wait 100 ms delay
2543  4B79 C5           	push bc							; save bc 														;4b79	c5 	.
2544  4B7A 01 64 00     	ld bc,100						; 100 ms Delay													;4b7a	01 64 00 	. d .
2545  4B7D CD BE 5E     	call DLY						; wait 100 ms Delay 											;4b7d	cd be 5e 	. . ^
2546  4B80 C1           	pop bc							; restore bc													;4b80	c1 	.
2547  4B81              ; --
2548  4B81 DD 21 67 4D  	ld ix,SectorsSequence			; ix - table of Sectors on Track interlave sequence				;4b81	dd 21 67 4d 	. ! g M
2549  4B85
2550  4B85              DI_WriteSector:
2551  4B85 FD 6E 0E     	ld l,(iy+UBFR)					; hl - address of Copy buffer 									;4b85	fd 6e 0e 	. n .
2552  4B88 FD 66 0F     	ld h,(iy+UBFR+1)																				;4b88	fd 66 0f 	. f .
2553  4B8B FD 56 33     	ld d,(iy+LTHCPY)				; d - last value sent to FLCtrl									;4b8b	fd 56 33 	. V 3
2554  4B8E
2555  4B8E              ; -- write copy buffer to drive bit by bit
2556  4B8E 06 9A        	ld b,24+128+2					; 154 bytes to send per sector									;4b8e	06 9a 	. .
2557  4B90
2558  4B90              ; --------------------------------------------------------------------------------------------------
2559  4B90              ; IN: b - number of bytes to write
2560  4B90              ;     d - backed up value sent to FDC Control Register
2561  4B90              ;     hl - pointer to current byte in Copy Buffer
2562  4B90              ;     Initial Write Data Bit = 1
2563  4B90              DI_WriteByte:
2564  4B90              ; -- send 1 bit at the time
2565  4B90 4E           	ld c,(hl)						; c - byte from Copy buffer to send 							;4b90	4e 	N
2566  4B91
2567  4B91              ; -- write bit 7 of data byte
2568  4B91 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;4b91	3e 20 	>
2569  4B93 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;4b93	aa 	.
2570  4B94              ; -- set CY flag to bit 7 of data byte
2571  4B94 CB 11        	rl c							; Carry flag = bit 7 of data byte - is it 1?					;4b94	cb 11 	. .
2572  4B96 D2 A4 4B     	jp nc,.writeBit7_0				; no - write cell with data bit = 0								;4b96	d2 a4 4b 	. . K
2573  4B99              .writeBit7_1:
2574  4B99              ; -- write cell with bit=1 - 0-1 or 1-0
2575  4B99 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4b99	d3 10 	. .
2576  4B9B EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;4b9b	ee 20 	.
2577  4B9D 57           	ld d,a							; save as last value sent to FLCTRL								;4b9d	57 	W
2578  4B9E 2B           	dec hl							; delay 6 cycles												;4b9e	2b 	+
2579  4B9F D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4b9f	d3 10 	. .
2580  4BA1 C3 AF 4B     	jp .contBit7					; continue with next bit 6										;4ba1	c3 af 4b 	. . K
2581  4BA4              .writeBit7_0:
2582  4BA4              ; -- write cell with bit=0 - 0-0 or 1-1
2583  4BA4 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4ba4	d3 10 	. .
2584  4BA6 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;4ba6	ee 00 	. .
2585  4BA8 57           	ld d,a							; save as last value sent to FLCTRL								;4ba8	57 	W
2586  4BA9 2B           	dec hl							; delay 6 cycles												;4ba9	2b 	+
2587  4BAA D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;4baa	d3 10 	. .
2588  4BAC C3 AF 4B     	jp .contBit7					; continue with next bit 6										;4bac	c3 af 4b 	. . K
2589  4BAF              .contBit7:
2590  4BAF 23           	inc hl							; delay 6 cycles												;4baf	23 	#
2591  4BB0 C3 B3 4B     	jp .delayBit7					; delay 10 cycles												;4bb0	c3 b3 4b 	. . K
2592  4BB3              .delayBit7:
2593  4BB3 C3 B6 4B     	jp .writeBit6Cell				; delay 10 cycles												;4bb3	c3 b6 4b 	. . K
2594  4BB6
2595  4BB6              .writeBit6Cell:
2596  4BB6              ; -- write bit 6 of data byte
2597  4BB6 DB 12        	in a,(FLPOOL)					; send clock to drive controller								;4bb6	db 12 	. .
2598  4BB8 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;4bb8	3e 20 	>
2599  4BBA AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;4bba	aa 	.
2600  4BBB              ; -- set CY flag to bit 6 of data byte
2601  4BBB CB 11        	rl c							; Carry flag = bit 6 of data byte - is it 1?					;4bbb	cb 11 	. .
2602  4BBD D2 CB 4B     	jp nc,.writeBit6_0				; no - write cell with data bit = 0								;4bbd	d2 cb 4b 	. . K
2603  4BC0              .writeBit6_1:
2604  4BC0              ; -- write cell with bit=1 - 0-1 or 1-0
2605  4BC0 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4bc0	d3 10 	. .
2606  4BC2 EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;4bc2	ee 20 	.
2607  4BC4 57           	ld d,a							; save as last value sent to FLCTRL								;4bc4	57 	W
2608  4BC5 2B           	dec hl							; delay 6 cycles												;4bc5	2b 	+
2609  4BC6 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4bc6	d3 10 	. .
2610  4BC8 C3 D6 4B     	jp .contBit6					; continue with next bit 5										;4bc8	c3 d6 4b 	. . K
2611  4BCB              .writeBit6_0:
2612  4BCB              ; -- write cell with bit=0 - 0-0 or 1-1
2613  4BCB D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4bcb	d3 10 	. .
2614  4BCD EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;4bcd	ee 00 	. .
2615  4BCF 57           	ld d,a							; save as last value sent to FLCTRL								;4bcf	57 	W
2616  4BD0 2B           	dec hl							; delay 6 cycles												;4bd0	2b 	+
2617  4BD1 D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;4bd1	d3 10 	. .
2618  4BD3 C3 D6 4B     	jp .contBit6					; continue with next bit 5										;4bd3	c3 d6 4b 	. . K
2619  4BD6              .contBit6:
2620  4BD6 23           	inc hl							; delay 6 cycles												;4bd6	23 	#
2621  4BD7 C3 DA 4B     	jp .delayBit6					; delay 10 cycles												;4bd7	c3 da 4b 	. . K
2622  4BDA              .delayBit6:
2623  4BDA C3 DD 4B     	jp .writeBit5Cell				; delay 10 cycles												;4bda	c3 dd 4b 	. . K
2624  4BDD              .writeBit5Cell:
2625  4BDD              ; -- write bit 5 of data byte
2626  4BDD DB 12        	in a,(FLPOOL)					; send clock to drive controller								;4bdd	db 12 	. .
2627  4BDF 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;4bdf	3e 20 	>
2628  4BE1 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;4be1	aa 	.
2629  4BE2              ; -- set CY flag to bit 5 of data byte
2630  4BE2 CB 11        	rl c							; Carry flag = bit 5 of data byte - is it 1?					;4be2	cb 11 	. .
2631  4BE4 D2 F2 4B     	jp nc,.writeBit5_0				; no - write cell with data bit = 0								;4be4	d2 f2 4b 	. . K
2632  4BE7              .writeBit5_1:
2633  4BE7              ; -- write cell with bit=1 - 0-1 or 1-0
2634  4BE7 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4be7	d3 10 	. .
2635  4BE9 EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;4be9	ee 20 	.
2636  4BEB 57           	ld d,a							; save as last value sent to FLCTRL								;4beb	57 	W
2637  4BEC 2B           	dec hl							; delay 6 cycles												;4bec	2b 	+
2638  4BED D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4bed	d3 10 	. .
2639  4BEF C3 FD 4B     	jp .contBit5					; continue with next bit 4										;4bef	c3 fd 4b 	. . K
2640  4BF2              .writeBit5_0:
2641  4BF2              ; -- write cell with bit=0 - 0-0 or 1-1
2642  4BF2 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4bf2	d3 10 	. .
2643  4BF4 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;4bf4	ee 00 	. .
2644  4BF6 57           	ld d,a							; save as last value sent to FLCTRL								;4bf6	57 	W
2645  4BF7 2B           	dec hl							; delay 6 cycles												;4bf7	2b 	+
2646  4BF8 D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;4bf8	d3 10 	. .
2647  4BFA C3 FD 4B     	jp .contBit5					; continue with next bit 4										;4bfa	c3 fd 4b 	. . K
2648  4BFD              .contBit5:
2649  4BFD 23           	inc hl							; delay 6 cycles												;4bfd	23 	#
2650  4BFE C3 01 4C     	jp .delayBit5					; delay 10 cycles												;4bfe	c3 01 4c 	. . L
2651  4C01              .delayBit5:
2652  4C01 C3 04 4C     	jp .writeBit4Cell				; delay 10 cycles												;4c01	c3 04 4c 	. . L
2653  4C04
2654  4C04              .writeBit4Cell:
2655  4C04              ; -- write bit 4 of data byte
2656  4C04 DB 12        	in a,(FLPOOL)					; send clock to drive controller								;4c04	db 12 	. .
2657  4C06 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;4c06	3e 20 	>
2658  4C08 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;4c08	aa 	.
2659  4C09              ; -- set CY flag to bit 4 of data byte
2660  4C09 CB 11        	rl c							; Carry flag = bit 4 of data byte - is it 1?					;4c09	cb 11 	. .
2661  4C0B D2 19 4C     	jp nc,.writeBit4_0				; no - write cell with data bit = 0								;4c0b	d2 19 4c 	. . L
2662  4C0E              .writeBit4_1:
2663  4C0E              ; -- write cell with bit=1 - 0-1 or 1-0
2664  4C0E D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c0e	d3 10 	. .
2665  4C10 EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;4c10	ee 20 	.
2666  4C12 57           	ld d,a							; save as last value sent to FLCTRL								;4c12	57 	W
2667  4C13 2B           	dec hl							; delay 6 cycles												;4c13	2b 	+
2668  4C14 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c14	d3 10 	. .
2669  4C16 C3 24 4C     	jp .contBit4					; continue with next bit 3										;4c16	c3 24 4c 	. $ L
2670  4C19              .writeBit4_0:
2671  4C19              ; -- write cell with bit=0 - 0-0 or 1-1
2672  4C19 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c19	d3 10 	. .
2673  4C1B EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;4c1b	ee 00 	. .
2674  4C1D 57           	ld d,a							; save as last value sent to FLCTRL									;4c1d	57 	W
2675  4C1E 2B           	dec hl							; delay 6 cycles												;4c1e	2b 	+
2676  4C1F D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;4c1f	d3 10 	. .
2677  4C21 C3 24 4C     	jp .contBit4					; continue with next bit 3										;4c21	c3 24 4c 	. $ L
2678  4C24              .contBit4:
2679  4C24 23           	inc hl							; delay 6 cycles												;4c24	23 	#
2680  4C25 C3 28 4C     	jp .delayBit4					; delay 10 cycles												;4c25	c3 28 4c 	. ( L
2681  4C28              .delayBit4:
2682  4C28 C3 2B 4C     	jp .writeBit3Cell				; delay 10 cycles												;4c28	c3 2b 4c 	. + L
2683  4C2B
2684  4C2B              .writeBit3Cell:
2685  4C2B              ; -- write bit 3 of data byte
2686  4C2B DB 12        	in a,(FLPOOL)					; send clock to drive controller								;4c2b	db 12 	. .
2687  4C2D 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;4c2d	3e 20 	>
2688  4C2F AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;4c2f	aa 	.
2689  4C30              ; -- set CY flag to bit 3 of data byte
2690  4C30 CB 11        	rl c							; Carry flag = bit 3 of data byte - is it 1?					;4c30	cb 11 	. .
2691  4C32 D2 40 4C     	jp nc,.writeBit3_0				; no - write cell with data bit = 0								;4c32	d2 40 4c 	. @ L
2692  4C35              .writeBit3_1:
2693  4C35              ; -- write cell with bit=1 - 0-1 or 1-0
2694  4C35 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c35	d3 10 	. .
2695  4C37 EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;4c37	ee 20 	.
2696  4C39 57           	ld d,a							; save as last value sent to FLCTRL								;4c39	57 	W
2697  4C3A 2B           	dec hl							; delay 6 cycles												;4c3a	2b 	+
2698  4C3B D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c3b	d3 10 	. .
2699  4C3D C3 4B 4C     	jp .contBit3					; continue with next bit 2										;4c3d	c3 4b 4c 	. K L
2700  4C40              .writeBit3_0:
2701  4C40              ; -- write cell with bit=0 - 0-0 or 1-1
2702  4C40 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c40	d3 10 	. .
2703  4C42 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;4c42	ee 00 	. .
2704  4C44 57           	ld d,a							; save as last value sent to FLCTRL								;4c44	57 	W
2705  4C45 2B           	dec hl							; delay 6 cycles												;4c45	2b 	+
2706  4C46 D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;4c46	d3 10 	. .
2707  4C48 C3 4B 4C     	jp .contBit3					; continue with next bit 2										;4c48	c3 4b 4c 	. K L
2708  4C4B              .contBit3:
2709  4C4B 23           	inc hl							; delay 6 cycles												;4c4b	23 	#
2710  4C4C C3 4F 4C     	jp .delayBit3					; delay 10 cycles												;4c4c	c3 4f 4c 	. O L
2711  4C4F              .delayBit3:
2712  4C4F C3 52 4C     	jp .writeBit2Cell				; delay 10 cycles												;4c4f	c3 52 4c 	. R L
2713  4C52
2714  4C52              .writeBit2Cell:
2715  4C52              ; -- write bit 2 of data byte
2716  4C52 DB 12        	in a,(FLPOOL)					; send clock to drive controller								;4c52	db 12 	. .
2717  4C54 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;4c54	3e 20 	>
2718  4C56 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;4c56	aa 	.
2719  4C57              ; -- set CY flag to bit 2 of data byte
2720  4C57 CB 11        	rl c							; Carry flag = bit 2 of data byte - is it 1?					;4c57	cb 11 	. .
2721  4C59 D2 67 4C     	jp nc,.writeBit2_0				; no - write cell with data bit = 0								;4c59	d2 67 4c 	. g L
2722  4C5C              .writeBit2_1:
2723  4C5C              ; -- write cell with bit=1 - 0-1 or 1-0
2724  4C5C D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c5c	d3 10 	. .
2725  4C5E EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;4c5e	ee 20 	.
2726  4C60 57           	ld d,a							; save as last value sent to FLCTRL								;4c60	57 	W
2727  4C61 2B           	dec hl							; delay 6 cycles												;4c61	2b 	+
2728  4C62 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c62	d3 10 	. .
2729  4C64 C3 72 4C     	jp .contBit2					; continue with next bit 1										;4c64	c3 72 4c 	. r L
2730  4C67              .writeBit2_0:
2731  4C67              ; -- write cell with bit=0 - 0-0 or 1-1
2732  4C67 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c67	d3 10 	. .
2733  4C69 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;4c69	ee 00 	. .
2734  4C6B 57           	ld d,a							; save as last value sent to FLCTRL								;4c6b	57 	W
2735  4C6C 2B           	dec hl							; delay 6 cycles												;4c6c	2b 	+
2736  4C6D D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;4c6d	d3 10 	. .
2737  4C6F C3 72 4C     	jp .contBit2					; continue with next bit 1										;4c6f	c3 72 4c 	. r L
2738  4C72              .contBit2:
2739  4C72 23           	inc hl							; delay 6 cycles												;4c72	23 	#
2740  4C73 C3 76 4C     	jp .delayBit2					; delay 10 cycles												;4c73	c3 76 4c 	. v L
2741  4C76              .delayBit2:
2742  4C76 C3 79 4C     	jp .writeBit1Cell				; continue 														;4c76	c3 79 4c 	. y L
2743  4C79
2744  4C79              .writeBit1Cell:
2745  4C79              ; -- write bit 1 of data byte
2746  4C79 DB 12        	in a,(FLPOOL)					; send clock to drive controller								;4c79	db 12 	. .
2747  4C7B 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;4c7b	3e 20 	>
2748  4C7D AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;4c7d	aa 	.
2749  4C7E              ; -- set CY flag to bit 1 of data byte
2750  4C7E CB 11        	rl c							; Carry flag = bit 1 of data byte - is it 1?					;4c7e	cb 11 	. .
2751  4C80 D2 8E 4C     	jp nc,.writeBit1_0				; no - write cell with data bit = 0								;4c80	d2 8e 4c 	. . L
2752  4C83              .writeBit1_1:
2753  4C83              ; -- write cell with bit=1 - 0-1 or 1-0
2754  4C83 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c83	d3 10 	. .
2755  4C85 EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;4c85	ee 20 	.
2756  4C87 57           	ld d,a							; save as last value sent to FLCTRL								;4c87	57 	W
2757  4C88 2B           	dec hl							; delay 6 cycles												;4c88	2b 	+
2758  4C89 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c89	d3 10 	. .
2759  4C8B C3 99 4C     	jp .contBit1					; continue with next bit 0										;4c8b	c3 99 4c 	. . L
2760  4C8E              .writeBit1_0:
2761  4C8E              ; -- write cell with bit=0 - 0-0 or 1-1
2762  4C8E D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4c8e	d3 10 	. .
2763  4C90 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;4c90	ee 00 	. .
2764  4C92 57           	ld d,a							; save as last value sent to FLCTRL								;4c92	57 	W
2765  4C93 2B           	dec hl							; delay 6 cycles												;4c93	2b 	+
2766  4C94 D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;4c94	d3 10 	. .
2767  4C96 C3 99 4C     	jp .contBit1					; continue with next bit 0										;4c96	c3 99 4c 	. . L
2768  4C99              .contBit1:
2769  4C99 23           	inc hl							; delay 6 cycles												;4c99	23 	#
2770  4C9A C3 9D 4C     	jp .delayBit1					; delay 10 cycles												;4c9a	c3 9d 4c 	. . L
2771  4C9D              .delayBit1:
2772  4C9D C3 A0 4C     	jp .writeBit0Cell				; delay 10 cycles												;4c9d	c3 a0 4c 	. . L
2773  4CA0
2774  4CA0              .writeBit0Cell:
2775  4CA0              ; -- write bit 0 of data byte
2776  4CA0 DB 12        	in a,(FLPOOL)					; send clock to drive controller								;4ca0	db 12 	. .
2777  4CA2 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;4ca2	3e 20 	>
2778  4CA4 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;4ca4	aa 	.
2779  4CA5              ; -- set CY flag to bit 0 of data byte
2780  4CA5 CB 11        	rl c							; Carry flag = bit 0 of data byte - is it 1?					;4ca5	cb 11 	. .
2781  4CA7 D2 B5 4C     	jp nc,.writeBit0_0				; no - write cell with data bit = 0								;4ca7	d2 b5 4c 	. . L
2782  4CAA              .writeBit0_1:
2783  4CAA              ; -- write cell with bit=1 - 0-1 or 1-0
2784  4CAA D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4caa	d3 10 	. .
2785  4CAC EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;4cac	ee 20 	.
2786  4CAE 57           	ld d,a							; save as last value sent to FLCTRL								;4cae	57 	W
2787  4CAF 2B           	dec hl							; delay 6 cycles												;4caf	2b 	+
2788  4CB0 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4cb0	d3 10 	. .
2789  4CB2 C3 C0 4C     	jp .nextByte					; continue with next byte										;4cb2	c3 c0 4c 	. . L
2790  4CB5              .writeBit0_0:
2791  4CB5              ; -- write cell with bit=0 - 0-0 or 1-1
2792  4CB5 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;4cb5	d3 10 	. .
2793  4CB7 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;4cb7	ee 00 	. .
2794  4CB9 57           	ld d,a							; save as last value sent to FLCTRL								;4cb9	57 	W
2795  4CBA 2B           	dec hl							; delay 6 cycles												;4cba	2b 	+
2796  4CBB D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;4cbb	d3 10 	. .
2797  4CBD C3 C0 4C     	jp .nextByte					; continue with next byte										;4cbd	c3 c0 4c 	. . L
2798  4CC0
2799  4CC0              .nextByte:
2800  4CC0 23           	inc hl							; hl was decremented previously									;4cc0	23 	#
2801  4CC1 23           	inc hl							; hl - address of next byte in buffer							;4cc1	23 	#
2802  4CC2 00           	nop								; delay 4 cycles												;4cc2	00 	.
2803  4CC3 05           	dec b							; decrement bytes-to-send counter								;4cc3	05 	.
2804  4CC4 C2 90 4B     	jp nz,DI_WriteByte				; continue to write all 154 bytes do Disk						;4cc4	c2 90 4b 	. . K
2805  4CC7
2806  4CC7
2807  4CC7              ; -- update FLCtrl shadow
2808  4CC7 FD 72 33     	ld (iy+LTHCPY),d				; store value as last sent to FLCtrl							;4cc7	fd 72 33 	. r 3
2809  4CCA
2810  4CCA              ; -- update next Sector Number and calculate checksum
2811  4CCA D9           	exx								; restore hl,de,bc -> Trk#, Sect#, TSCRC						;4cca	d9 	.
2812  4CCB DD 7E 01     	ld a,(ix+1)						; a - next Sector Number										;4ccb	dd 7e 01 	. ~ .
2813  4CCE DD 23        	inc ix							; increment ix ready for next round								;4cce	dd 23 	. #
2814  4CD0 12           	ld (de),a						; set Sector Number	to next value from inteleave sequence		;4cd0	12 	.
2815  4CD1 86           	add a,(hl)						; add Track number 												;4cd1	86 	.
2816  4CD2 02           	ld (bc),a						; set as checksum value											;4cd2	02 	.
2817  4CD3 1A           	ld a,(de)						; a - sector number to check									;4cd3	1a 	.
2818  4CD4 D9           	exx								; exchange hl,de,bc with alt registers							;4cd4	d9 	.
2819  4CD5 FE FF        	cp $ff							; check if all sectors written for this track 					;4cd5	fe ff 	. .
2820  4CD7 C2 85 4B     	jp nz,DI_WriteSector			; no - write next Sector										;4cd7	c2 85 4b 	. . K
2821  4CDA
2822  4CDA              ; -- next Track
2823  4CDA D9           	exx								; restore hl,de,bc -> Trk#, Sect#, TSCRC						;4cda	d9 	.
2824  4CDB AF           	xor a							; a - sector number = 0											;4cdb	af 	.
2825  4CDC 12           	ld (de),a						; set Sector Number to 0										;4cdc	12 	.
2826  4CDD 7E           	ld a,(hl)						; a - current Track number										;4cdd	7e 	~
2827  4CDE 3C           	inc a							; increment track												;4cde	3c 	<
2828  4CDF 77           	ld (hl),a						; set new track number											;4cdf	77 	w
2829  4CE0 02           	ld (bc),a						; set as checksum (valid because Sector Number = 0)				;4ce0	02 	.
2830  4CE1 D9           	exx								; exchange hl,de,bc with alt registers							;4ce1	d9 	.
2831  4CE2 FE 28        	cp 40							; check if all 40 tracks written								;4ce2	fe 28 	. (
2832  4CE4 CA F9 4C     	jp z,DI_VerifyDisk				; yes - verify written disk										;4ce4	ca f9 4c 	. . L
2833  4CE7
2834  4CE7              ; -- turn off Write Request
2835  4CE7 FD 7E 33     	ld a,(iy+LTHCPY)				; a - FLCtrl value from shadow register							;4ce7	fd 7e 33 	. ~ 3
2836  4CEA F6 40        	or FL_WRITE_REQ					; turn off Write Request										;4cea	f6 40 	. @
2837  4CEC FD 77 33     	ld (iy+LTHCPY),a				; store FLCtrl to shadow register								;4cec	fd 77 33 	. w 3
2838  4CEF D3 10        	out (FLCTRL),a					; set Flopy Control byte										;4cef	d3 10 	. .
2839  4CF1
2840  4CF1              ; -- advance to next track
2841  4CF1 06 01        	ld b,1							; 1 track to step in											;4cf1	06 01 	. .
2842  4CF3 CD CE 5E     	call STPIN						; move Read/Write Head in drive									;4cf3	cd ce 5e 	. . ^
2843  4CF6 C3 67 4B     	jp DI_WriteTrack				; write next track												;4cf6	c3 67 4b 	. g K
2844  4CF9
2845  4CF9
2846  4CF9              DI_VerifyDisk:
2847  4CF9              ; -- turn off Write Request
2848  4CF9 FD 7E 33     	ld a,(iy+LTHCPY)				; a - FLCtrl value												;4cf9	fd 7e 33 	. ~ 3
2849  4CFC F6 40        	or FL_WRITE_REQ					; turn off Write Request										;4cfc	f6 40 	. @
2850  4CFE FD 77 33     	ld (iy+LTHCPY),a				; store FLCtrl to shadow register								;4cfe	fd 77 33 	. w 3
2851  4D01 D3 10        	out (FLCTRL),a					; set Flopy Control byte										;4d01	d3 10 	. .
2852  4D03
2853  4D03              ; -- move drive Head to track 0, sector 0
2854  4D03 06 27        	ld b,39							; 39 tracks to step out											;4d03	06 27 	. '
2855  4D05 CD 01 5F     	call STPOUT						; move Read/Write Head in drive									;4d05	cd 01 5f 	. . _
2856  4D08 FD 36 12 00  	ld (iy+TRCK),0					; set Track Number to 0											;4d08	fd 36 12 00 	. 6 . .
2857  4D0C FD 36 11 00  	ld (iy+SCTR),0					; set Sector Number to 0										;4d0c	fd 36 11 00 	. 6 . .
2858  4D10
2859  4D10              DI_VerifyTrack:
2860  4D10 DD 21 67 4D  	ld ix,SectorsSequence			; ix - table of Sectors on Track interlave sequence				;4d10	dd 21 67 4d 	. ! g M
2861  4D14
2862  4D14              DI_VerifySector:
2863  4D14              ; -- try read IDAM for given Track and Sector (only IDAM start, TrackNo, SectorNo and verify Checksum of those two)
2864  4D14 CD EA 53     	call IDAM			; Read identification address mark (IDAM) 						;4d14	cd ea 53 	. . S
2865  4D17 20 2C        	jr nz,DI_ExitError				; jump if Error	09 - SECTOR NOT FOUND							;4d17	20 2c 	  ,
2866  4D19
2867  4D19              ; -- sector found
2868  4D19 DD 7E 01     	ld a,(ix+1)						; a - next Sector Number										;4d19	dd 7e 01 	. ~ .
2869  4D1C DD 23        	inc ix							; increment ix ready for next round								;4d1c	dd 23 	. #
2870  4D1E FD 77 11     	ld (iy+SCTR),a					; set Sector Number	to next seq value							;4d1e	fd 77 11 	. w .
2871  4D21 FE FF        	cp $ff							; check if all sectors for this track 							;4d21	fe ff 	. .
2872  4D23 20 EF        	jr nz,DI_VerifySector			; no - read next Sector											;4d23	20 ef 	  .
2873  4D25              ; -- next track
2874  4D25 AF           	xor a							; sector number 0												;4d25	af 	.
2875  4D26 FD 77 11     	ld (iy+SCTR),a					; set Sector Number to 0										;4d26	fd 77 11 	. w .
2876  4D29 FD 7E 12     	ld a,(iy+TRCK)					; a - current Track number										;4d29	fd 7e 12 	. ~ .
2877  4D2C 3C           	inc a							; increment track												;4d2c	3c 	<
2878  4D2D FD 77 12     	ld (iy+TRCK),a					; set next track number											;4d2d	fd 77 12 	. w .
2879  4D30 FE 28        	cp 40							; check if all 40 tracks written								;4d30	fe 28 	. (
2880  4D32 28 07        	jr z,DI_ExitOK					; yes - exit with no error										;4d32	28 07 	( .
2881  4D34              ; -- more tracks to verify
2882  4D34 06 01        	ld b,1							; 1 track to step in											;4d34	06 01 	. .
2883  4D36 CD CE 5E     	call STPIN						; move R/W Head to next track									;4d36	cd ce 5e 	. . ^
2884  4D39 18 D5        	jr DI_VerifyTrack				; verify next track												;4d39	18 d5 	. .
2885  4D3B
2886  4D3B              ; -- all 40 tracks verified
2887  4D3B              DI_ExitOK:
2888  4D3B              ; -- move Head back on Track 00
2889  4D3B 06 27        	ld b,39							; 39 tracks to Step Out											;4d3b	06 27 	. '
2890  4D3D CD 01 5F     	call STPOUT						; Track step out												;4d3d	cd 01 5f 	. . _
2891  4D40 CD 52 5F     	call PWROFF						; Disk power OFF												;4d40	cd 52 5f 	. R _
2892  4D43 E1           	pop hl							; restore hl 													;4d43	e1 	.
2893  4D44 C9           	ret								; ------------- End of Proc -----------------------------------	;4d44	c9 	.
2894  4D45              DI_ExitError:
2895  4D45 FE 11        	cp 17							; is it Error 17 (BREAK)										;4d45	fe 11 	. .
2896  4D47 CA 41 42     	jp z,ERROR						; yes - jump to Error handling routine							;4d47	ca 41 42 	. A B
2897  4D4A 3E 06        	ld a,6							; no - set Error 6 (DISK I/O ERROR)								;4d4a	3e 06 	> .
2898  4D4C C3 41 42     	jp ERROR						; jump to Error handling routine ------------------------------ ;4d4c	c3 41 42 	. A B
2899  4D4F
2900  4D4F              SecHeaderInitData:
2901  4D4F 80 80 80 80  	db $80,$80,$80,$80,$80,$80,$00	; GAP 1 bytes													;4d4f	80 80 80 80 80 80 00
2901  4D53 80 80 00
2902  4D56 FE E7 18 C3  	db $fe,$e7,$18,$c3				; IDAM signature 												;4d56	fe e7 18 c3
2903  4D5A 00           	db $00							; Track number													;4d5a	00 	.
2904  4D5B 00           	db $00							; Sector number													;4d5b	00
2905  4D5C 00           	db $00							; Header checksum												;4d5c	00
2906  4D5D
2907  4D5D              SectorGAP2Data:
2908  4D5D 80 80 80 80  	db $80,$80,$80,$80,$80,$00		; GAP 2 bytes													;4d5d	80 80 80 80 80 00
2908  4D61 80 00
2909  4D63 C3 18 E7 FE  	db $c3,$18,$e7,$fe				; IDAM (reversed) signature										;4d63	c3 18 e7 fe
2910  4D67
2911  4D67              SectorsSequence:
2912  4D67 00 0B 06 01  	db 0,11,6, 1,12,7, 2,13,8, 3,14,9, 4,15,10, 5		;4d67	00 0b 06 01 0c 07 02 0d 08 03 0e 09 04 0f 0a 05 	.
2912  4D6B 0C 07 02 0D
2912  4D6F 08 03 0E 09
2912  4D73 04 0F 0A 05
2913  4D77 FF           	db $ff												;4d77	ff 	.
2914  4D78
2915  4D78
2916  4D78
2917  4D78              ;***************************************************************************************************
2918  4D78              ; DOS Command DRIVE
2919  4D78              ; Syntax: DRIVE number
2920  4D78              ; --------------------
2921  4D78              ; Activate Drive 1 or Drive 2. All DOS operations will be performed on Active Drive.
2922  4D78              ; Only '1' or '2' is accepted as Drive number
2923  4D78              DCmdDRIVE:
2924  4D78
2925  4D78              ; -- parse argument - drive number
2926  4D78 CD 1C 2B     	call SysEvalByteExpr			; a - parsed integer value										;4d78	cd 1c 2b 	. . +
2927  4D7B B7           	or a							; is it 0? (invalid Drive number)								;4d7b	b7 	.
2928  4D7C CA 4A 1E     	jp z,SysErrRaiseFuncCode		; yes - Raise BASIC FUNCTION CODE Error							;4d7c	ca 4a 1e 	. J .
2929  4D7F FE 03        	cp 3							; is it 3 or greater? (invalid Drive number)					;4d7f	fe 03 	. .
2930  4D81 D2 4A 1E     	jp nc,SysErrRaiseFuncCode		; yes - Raise BASIC FUNCTION CODE Error							;4d81	d2 4a 1e 	. J .
2931  4D84
2932  4D84
2933  4D84              ;***************************************************************************************************
2934  4D84              ; Set selected Drive (1 or 2)
2935  4D84              ; IN: a - drive to select
2936  4D84              SelectDriveNo:
2937  4D84 FE 01        	cp 1							; is it Drive 1 to select?										;4d84	fe 01 	. .
2938  4D86 20 05        	jr nz,.selectDrive2				; no - set Drive 2 selected										;4d86	20 05 	  .
2939  4D88 FD 36 0B 10  	ld (iy+DK),$10					; set Drive 1 selected 											;4d88	fd 36 0b 10 	. 6 . .
2940  4D8C C9           	ret								; ---------------------- End of Proc --------------------------	;4d8c	c9 	.
2941  4D8D              .selectDrive2:
2942  4D8D FD 36 0B 80  	ld (iy+DK),$80					; set Drive 2 selected 											;4d8d	fd 36 0b 80 	. 6 . .
2943  4D91 C9           	ret								; ---------------------- End of Proc --------------------------	;4d91	c9 	.
2944  4D92
2945  4D92
2946  4D92              ;***************************************************************************************************
2947  4D92              ; DOS Command IN#
2948  4D92              ; Syntax: IN# "filaname", var1, var2, ...
2949  4D92              ; ----------------------------------------
2950  4D92              ; Load data from file specified by filename (which has the file type code "D") into specified variables.
2951  4D92              ; File must be previously opened by 'OPEN' command. Variables var1, var2, ... are BASIC variable names.
2952  4D92              ; Variables can be string or numeric and must match types saved by PR# command.
2953  4D92              ; Filename may have no more than 8 characters
2954  4D92              ; NOTE: This command must always be used from inside BASIC program.
2955  4D92              DCmdIN#:
2956  4D92              ; -- throw ILLEGAL DIRECT Error if current BASIC line <> FFFF
2957  4D92 CD 28 28     	call SysCheckIllegalDirect		; verify command used from BASIC program 						;4d92	cd 28 28 	. ( (
2958  4D95
2959  4D95              ; -- parse first argument - filename
2960  4D95 CD 78 53     	call ParseFilename				; Verify syntax and copy filename to DOS Filename Buffer		;4d95	cd 78 53 	. x S
2961  4D98 B7           	or a							; was any Error?												;4d98	b7 	.
2962  4D99 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine							;4d99	c2 41 42 	. A B
2963  4D9C
2964  4D9C              ; -- parse next char - must be ','
2965  4D9C CF           	rst 8							; verify this char is ',' (comma) and point hl to next			;4d9c	cf 	.
2966  4D9D 2C           	defb ','						; expected char													;4d9d	2c 	,
2967  4D9E E5           	push hl							; save hl - next char in BASIC program							;4d9e	e5 	.
2968  4D9F
2969  4D9F              ; -- get File Control Block used to open this file
2970  4D9F CD 78 47     	call FindFCBForOpen				; Find FCB Block to use or get one if file already opened		;4d9f	cd 78 47 	. x G
2971  4DA2 FE 08        	cp 08							; was it Error 08   FILE ALREADY OPEN (means OK)?				;4da2	fe 08 	. .
2972  4DA4 3E 05        	ld a,05							; a - Error 05   FILE NOT OPEN for return						;4da4	3e 05 	> .
2973  4DA6 C2 41 42     	jp nz,ERROR						; no (was other error) go to Error handling routine				;4da6	c2 41 42 	. A B
2974  4DA9
2975  4DA9              ; -- check if file is opened for read
2976  4DA9 13           	inc de							; de - address of Accress field in FCB							;4da9	13 	.
2977  4DAA 1A           	ld a,(de)						; a - Open Access mode (read/write)								;4daa	1a 	.
2978  4DAB B7           	or a							; is it 0 (read)?												;4dab	b7 	.
2979  4DAC 3E 0F        	ld a,15							; a - Error 15   ILLEGAL READ									;4dac	3e 0f 	> .
2980  4DAE C2 41 42     	jp nz,ERROR						; no - go to Error handling routine	---------------------------	;4dae	c2 41 42 	. A B
2981  4DB1
2982  4DB1              ; -- check if data from file already loaded into buffer
2983  4DB1 1B           	dec de							; de - address of Open flag in FCB								;4db1	1b 	.
2984  4DB2 1A           	ld a,(de)						; a - open flag (file active/inactive)							;4db2	1a 	.
2985  4DB3 FE 02        	cp 2							; is it active (sector already loaded to buffer)?				;4db3	fe 02 	. .
2986  4DB5 28 2B        	jr z,.readyToRead				; yes - skip loading sector into buffer							;4db5	28 2b 	( +
2987  4DB7
2988  4DB7              ; -- flush data from buffers to disk if needed
2989  4DB7 CD A5 4F     	call FlushSectorData			; Flush Sector Data to disk from both FCBs 						;4db7	cd a5 4f 	. . O
2990  4DBA
2991  4DBA              ; -- set open flag as file opened and active
2992  4DBA 3E 02        	ld a,2							; a - open flag "active" value									;4dba	3e 02 	> .
2993  4DBC 12           	ld (de),a						; set as Open flag in FCB										;4dbc	12 	.
2994  4DBD
2995  4DBD              ; -- set Track and Sector Number to read
2996  4DBD EB           	ex de,hl						; hl - address of FCB											;4dbd	eb 	.
2997  4DBE 11 0A 00     	ld de,10						; de - offset to Track Number (TRK#) field in FCB				;4dbe	11 0a 00 	. . .
2998  4DC1 19           	add hl,de						; hl - address of Track Number (TRK#) field in FCB				;4dc1	19 	.
2999  4DC2 7E           	ld a,(hl)						; a - Track Number from FCB										;4dc2	7e 	~
3000  4DC3 23           	inc hl							; hl - address of Sector Number (SCTR#) field in FCB			;4dc3	23 	#
3001  4DC4 FD 77 12     	ld (iy+TRCK),a					; set as Track Number to read									;4dc4	fd 77 12 	. w .
3002  4DC7 7E           	ld a,(hl)						; a - Sector Number from FCB									;4dc7	7e 	~
3003  4DC8 FD 77 11     	ld (iy+SCTR),a					; set as Sector Number to read									;4dc8	fd 77 11 	. w .
3004  4DCB
3005  4DCB              ; -- disable interrupt and read Sector into buffer
3006  4DCB F3           	di								; disable interrupts											;4dcb	f3 	.
3007  4DCC
3008  4DCC              ; -- turn on Disk Drive and wait 50 ms
3009  4DCC CD 41 5F     	call PWRON						; Disk power ON													;4dcc	cd 41 5f 	. A _
3010  4DCF C5           	push bc							; save bc														;4dcf	c5 	.
3011  4DD0 01 32 00     	ld bc,50						; bc - number of miliseconds to delay							;4dd0	01 32 00 	. 2 .
3012  4DD3 CD BE 5E     	call DLY						; delay 50 ms													;4dd3	cd be 5e 	. . ^
3013  4DD6 C1           	pop bc							; restore bc													;4dd6	c1 	.
3014  4DD7
3015  4DD7              ; -- read Sector
3016  4DD7 CD 27 5B     	call READ						; Read a sector from disk										;4dd7	cd 27 5b 	. ' [
3017  4DDA B7           	or a							; was any error?												;4dda	b7 	.
3018  4DDB C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4ddb	c2 41 42 	. A B
3019  4DDE
3020  4DDE              ; -- enable interrupts and turn Disk Power Off
3021  4DDE FB           	ei								; enable interrupts												;4dde	fb 	.
3022  4DDF CD 52 5F     	call PWROFF						; Disk power OFF												;4ddf	cd 52 5f 	. R _
3023  4DE2
3024  4DE2
3025  4DE2              .readyToRead:
3026  4DE2 06 C7        	ld b,199						; b - max length of string to read from disk 					;4de2	06 c7 	. .
3027  4DE4 2A A7 78     	ld hl,(BasicLineBufPtr)			; hl - address of BASIC Line buffer								;4de4	2a a7 78 	* . x
3028  4DE7              .nextChar:
3029  4DE7 CD F9 4D     	call .getCharFromFile			; read char from file											;4de7	cd f9 4d 	. . M
3030  4DEA 77           	ld (hl),a						; store char into BASIC line buffer								;4dea	77 	w
3031  4DEB 23           	inc hl							; hl - address in BASIC line Buffer for next char				;4deb	23 	#
3032  4DEC FE 0D        	cp CR							; is it end of data ?		 									;4dec	fe 0d 	. .
3033  4DEE 28 02        	jr z,.evalExprToVariable		; yes - terminate string and convert to value via BASIC proc	;4dee	28 02 	( .
3034  4DF0 10 F5        	djnz .nextChar					; read chars until CR or max length ---------------------------	;4df0	10 f5 	. .
3035  4DF2
3036  4DF2              .evalExprToVariable:
3037  4DF2 AF           	xor a							; a - Source flag for BASIC DATA/INPUT command					;4df2	af 	.
3038  4DF3 32 A9 78     	ld (CmdINPUTSrcFlag),a			; set BASIC Source flag as stream								;4df3	32 a9 78 	2 . x
3039  4DF6 C3 BD 21     	jp SysExecINPUTProc				; Execute part of BASIC INPUT cmd to evaluate Variable value	;4df6	c3 bd 21 	. . !
3040  4DF9
3041  4DF9
3042  4DF9              .getCharFromFile:
3043  4DF9              ; -- save registers
3044  4DF9 E5           	push hl							; save hl														;4df9	e5 	.
3045  4DFA D5           	push de							; save de														;4dfa	d5 	.
3046  4DFB C5           	push bc							; save bc														;4dfb	c5 	.
3047  4DFC
3048  4DFC              ; -- get File Control Block
3049  4DFC CD 78 47     	call FindFCBForOpen				; Find FCB Block used for this file 							;4dfc	cd 78 47 	. x G
3050  4DFF
3051  4DFF              ; -- get index of current byte in sector
3052  4DFF 21 0C 00     	ld hl,12						; hl - offset to Byte-in-Sector index (PTR) in FCB				;4dff	21 0c 00 	! . .
3053  4E02 EB           	ex de,hl						; hl - address of FCB, de - offset to PTR						;4e02	eb 	.
3054  4E03 19           	add hl,de						; hl - address of Byte-in-Sector index (PTR) in FCB				;4e03	19 	.
3055  4E04 7E           	ld a,(hl)						; a - index to current byte in sector							;4e04	7e 	~
3056  4E05
3057  4E05              ; -- calculate absolute addres of byte
3058  4E05 EB           	ex de,hl						; de - address of Byte-in-Sector index (PTR) in FCB				;4e05	eb 	.
3059  4E06 FD 6E 31     	ld l,(iy+DBFR)					; hl - address of buffer with Sector data						;4e06	fd 6e 31 	. n 1
3060  4E09 FD 66 32     	ld h,(iy+DBFR+1)																				;4e09	fd 66 32 	. f 2
3061  4E0C 85           	add a,l							; add index to LSB of buffer addres								;4e0c	85 	.
3062  4E0D 6F           	ld l,a							; store back LSB												;4e0d	6f 	o
3063  4E0E 3E 00        	ld a,0							; a - 0 (MSB of index)											;4e0e	3e 00 	> .
3064  4E10 8C           	adc a,h							; add Carry to MSB of buffer address							;4e10	8c 	.
3065  4E11 67           	ld h,a							; store back MSB												;4e11	67 	g
3066  4E12
3067  4E12              ; -- get byte - check if end of data (0)
3068  4E12 7E           	ld a,(hl)						; a - data byte from file										;4e12	7e 	~
3069  4E13 B7           	or a							; is it 0 (end of data)?										;4e13	b7 	.
3070  4E14 20 04        	jr nz,.continue					; no - advance FCB state to read next char						;4e14	20 04 	  .
3071  4E16 0E 0D        	ld c,CR							; c - End of Line char as result								;4e16	0e 0d 	. .
3072  4E18 18 40        	jr .returnByte					; return CR char as end of data 								;4e18	18 40 	. @
3073  4E1A
3074  4E1A
3075  4E1A              .continue:
3076  4E1A 4F           	ld c,a							; c - data byte from file										;4e1a	4f 	O
3077  4E1B              ; -- increment byte-in-sector index
3078  4E1B 1A           	ld a,(de)						; a - index														;4e1b	1a 	.
3079  4E1C 3C           	inc a							; increment by 1												;4e1c	3c 	<
3080  4E1D 12           	ld (de),a						; store back to PTR field in FCB								;4e1d	12 	.
3081  4E1E              ; -- check if all 126 bytes from sector consumed
3082  4E1E FE 7E        	cp 126							; is it end of sector data?										;4e1e	fe 7e 	. ~
3083  4E20 20 38        	jr nz,.returnByte				; no - return byte saved in c									;4e20	20 38 	  8
3084  4E22
3085  4E22              ; -- all sector data consumed - need to read next sector of file
3086  4E22 AF           	xor a							; a - byte in sector index = 0									;4e22	af 	.
3087  4E23 12           	ld (de),a						; update new PTR value in FCB									;4e23	12 	.
3088  4E24
3089  4E24              ; -- determine next sector of file
3090  4E24 FD 6E 31     	ld l,(iy+DBFR)					; hl - address of buffer with current Sector data				;4e24	fd 6e 31 	. n 1
3091  4E27 FD 66 32     	ld h,(iy+DBFR+1)																				;4e27	fd 66 32 	. f 2
3092  4E2A D5           	push de							; save de - address of PTR field in FCB							;4e2a	d5 	.
3093  4E2B 11 7E 00     	ld de,126						; de - offset in sector to next Track Number					;4e2b	11 7e 00 	. ~ .
3094  4E2E 19           	add hl,de						; hl - address of next Track Number								;4e2e	19 	.
3095  4E2F D1           	pop de							; restore de - address of PTR field in FCB						;4e2f	d1 	.
3096  4E30 7E           	ld a,(hl)						; a - next Track Number											;4e30	7e 	~
3097  4E31 B7           	or a							; is it 0? (no more sectors in this file)?						;4e31	b7 	.
3098  4E32 28 2B        	jr z,.returnLastByte			; yes - set PTR to 127 and return (end of data)					;4e32	28 2b 	( +
3099  4E34
3100  4E34              ; -- we can read 1 more sector - setup DOS structure and update FCB
3101  4E34 FD 77 12     	ld (iy+TRCK),a					; set Track Number in DOS structure								;4e34	fd 77 12 	. w .
3102  4E37 1B           	dec de							; de - address of Sector Number (SCTR#) field in FCB			;4e37	1b 	.
3103  4E38 1B           	dec de							; de - address of Track Number (TRK#) field in FCB				;4e38	1b 	.
3104  4E39 12           	ld (de),a						; set new Track Number in FCB									;4e39	12 	.
3105  4E3A 23           	inc hl							; hl - address of byte with next Sector Number					;4e3a	23 	#
3106  4E3B 7E           	ld a,(hl)						; a - next Sector Number										;4e3b	7e 	~
3107  4E3C FD 77 11     	ld (iy+SCTR),a					; set Sector Number in DOS structure							;4e3c	fd 77 11 	. w .
3108  4E3F 13           	inc de							; de - address of Sector Number (SCTR#) field in FCB			;4e3f	13 	.
3109  4E40 12           	ld (de),a						; set new Sector Number in FCB									;4e40	12 	.
3110  4E41
3111  4E41              ; -- disable interrupt and read Sector from Disk into buffer
3112  4E41 F3           	di								; disable interrupts											;4e41	f3 	.
3113  4E42
3114  4E42              ; -- turn disk power ON and wait 50 ms
3115  4E42 CD 41 5F     	call PWRON						; Disk power ON													;4e42	cd 41 5f 	. A _
3116  4E45 C5           	push bc							; save bc														;4e45	c5 	.
3117  4E46 01 32 00     	ld bc,50						; bc - number of miliseconds to delay							;4e46	01 32 00 	. 2 .
3118  4E49 CD BE 5E     	call DLY						; delay 50 ms 													;4e49	cd be 5e 	. . ^
3119  4E4C C1           	pop bc							; restore bc 													;4e4c	c1 	.
3120  4E4D
3121  4E4D              ; -- read Sector from disk
3122  4E4D C5           	push bc							; save bc 														;4e4d	c5 	.
3123  4E4E CD 27 5B     	call READ						; Read a sector from disk										;4e4e	cd 27 5b 	. ' [
3124  4E51 C1           	pop bc							; restore bc													;4e51	c1 	.
3125  4E52 B7           	or a							; was any error?												;4e52	b7 	.
3126  4E53 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4e53	c2 41 42 	. A B
3127  4E56
3128  4E56              ; -- turn disk power off and enable interrupts
3129  4E56 CD 52 5F     	call PWROFF						; Disk power OFF												;4e56	cd 52 5f 	. R _
3130  4E59 FB           	ei								; enable interrupts												;4e59	fb 	.
3131  4E5A
3132  4E5A              .returnByte:
3133  4E5A 79           	ld a,c							; a - byte from file											;4e5a	79 	y
3134  4E5B              ; -- restore registers
3135  4E5B C1           	pop bc							; restore bc													;4e5b	c1 	.
3136  4E5C D1           	pop de							; restore de													;4e5c	d1 	.
3137  4E5D E1           	pop hl							; restore hl													;4e5d	e1 	.
3138  4E5E C9           	ret								; ----------------------- End of Proc -------------------------	;4e5e	c9 	.
3139  4E5F
3140  4E5F              .returnLastByte:
3141  4E5F              ; -- set Byte-in-sector index to 127 - next read will be 0 (since next Track is 0)
3142  4E5F 3E 7F        	ld a,127						; a - index 127 (pointing to 0)									;4e5f	3e 7f 	> 
3143  4E61 12           	ld (de),a						; set byte-in-sector index (PTR) field in FCB					;4e61	12 	.
3144  4E62 18 F6        	jr .returnByte					; return last byte -------------------------------------------- ;4e62	18 f6 	. .
3145  4E64
3146  4E64
3147  4E64              ;***************************************************************************************************
3148  4E64              ; DOS Command PR#
3149  4E64              ; Syntax: PR# "filaname", D1, D2, ...
3150  4E64              ; -----------------------------------
3151  4E64              ; Send data to file specified by filename (which has the file type code "D") and was previously
3152  4E64              ; opened by 'OPEN' command. Data D1, D2, ... are data to be saved and can be string or numeric.
3153  4E64              ; Filename may have no more than 8 characters
3154  4E64              ; NOTE: This command must always be used from inside BASIC program.
3155  4E64              DCmdPR#:
3156  4E64              ; -- throw ILLEGAL DIRECT Error if current BASIC line <> FFFF
3157  4E64 CD 28 28     	call SysCheckIllegalDirect		; verify command used from BASIC program 						;4e64	cd 28 28 	. ( (
3158  4E67
3159  4E67              ; -- parse first argument - filename
3160  4E67 CD 78 53     	call ParseFilename				; Verify syntax and copy filename to DOS Filename Buffer		;4e67	cd 78 53 	. x S
3161  4E6A B7           	or a							; was any Error?												;4e6a	b7 	.
3162  4E6B C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4e6b	c2 41 42 	. A B
3163  4E6E
3164  4E6E              ; -- get File Control Block used to open this file
3165  4E6E E5           	push hl							; save hl - address of next char in BASIC expression			;4e6e	e5 	.
3166  4E6F CD 78 47     	call FindFCBForOpen				; Find FCB Block to use or get one if file already opened		;4e6f	cd 78 47 	. x G
3167  4E72 FE 08        	cp 08							; was it Error 08   FILE ALREADY OPEN (means OK)?				;4e72	fe 08 	. .
3168  4E74 3E 05        	ld a,05							; a - Error 05   FILE NOT OPEN for return						;4e74	3e 05 	> .
3169  4E76 C2 41 42     	jp nz,ERROR						; no (was other error) go to Error handling routine				;4e76	c2 41 42 	. A B
3170  4E79 E1           	pop hl							; restore hl - address of next char in BASIC expression			;4e79	e1 	.
3171  4E7A
3172  4E7A              ; -- parse next char - must be ','
3173  4E7A CF           	rst 8							; verify this char is ',' (commx) and point hl to next			;4e7a	cf 	.
3174  4E7B 2C           	defb ','						; expected char													;4e7b	2c 	,
3175  4E7C
3176  4E7C              .nextExpression:
3177  4E7C 2B           	dec hl							; hl - addres before variable/value expression 					;4e7c	2b 	+
3178  4E7D D7           	rst $10							; call system NextToken routine - check expression				;4e7d	d7 	.
3179  4E7E CC AC 4E     	call z,.writeCR					; if no more expressions - write CR to file 					;4e7e	cc ac 4e 	. . N
3180  4E81              .nextOrExit:
3181  4E81 C8           	ret z							; if no more expression ------- End of Proc ------------------- ;4e81	c8 	.
3182  4E82
3183  4E82              ; -- check if next char in statement is separator
3184  4E82 E5           	push hl							; save hl - address of next BASIC char							;4e82	e5 	.
3185  4E83 FE 2C        	cp ','							; is it ',' (variable/value separator)?							;4e83	fe 2c 	. ,
3186  4E85 CA B3 4E     	jp z,.writeComma				; yes - write ',' char to data file continue with next char		;4e85	ca b3 4e 	. . N
3187  4E88 FE 3A        	cp ':'							; is it ':' (end of this PR# command)?							;4e88	fe 3a 	. :
3188  4E8A 28 2B        	jr z,.parseNextChar				; yes - dont write anything to file - parse next char			;4e8a	28 2b 	( +
3189  4E8C C1           	pop bc							; restore bc - address of next BASIC char						;4e8c	c1 	.
3190  4E8D
3191  4E8D              ; -- calculate value from given BASIC expression
3192  4E8D CD 37 23     	call SysEvalBasicExpr			; evaluate BASIC expression and place result in ACC				;4e8d	cd 37 23 	. 7 #
3193  4E90              ; -- test variable type stored in ACC
3194  4E90 E5           	push hl							; save hl - address of next BASIC char							;4e90	e5 	.
3195  4E91 E7           	rst $20							; test type of variable in ACC (NTF)							;4e91	e7 	.
3196  4E92 28 12        	jr z,.writeStringFromACC		; jump if it is STRING variable	(write to file as it is)		;4e92	28 12 	( .
3197  4E94
3198  4E94              ; -- numeric variable - convert to string
3199  4E94 CD BD 0F     	call SysNumToStr				; convert numeric value from ACC to String (hl points to start)	;4e94	cd bd 0f 	. . .
3200  4E97 CD 65 28     	call SysStrToACC				; Create String Vector from (hl) and store in ACC				;4e97	cd 65 28 	. e (
3201  4E9A 2A 21 79     	ld hl,(SYS_ACC)					; hl - string value from BASIC Accumulator	(ACC)				;4e9a	2a 21 79 	* ! y
3202  4E9D CD BA 4E     	call WriteStrToDataFile			; write string from ACC to data file							;4e9d	cd ba 4e 	. . N
3203  4EA0 3E 20        	ld a,' '						; a - space char												;4ea0	3e 20 	>
3204  4EA2 CD CA 4E     	call WriteCharToDataFile		; write ' ' to file												;4ea2	cd ca 4e 	. . N
3205  4EA5 B7           	or a							; always non-zero to skip next WriteStrToDataFile call			;4ea5	b7 	.
3206  4EA6              .writeStringFromACC:
3207  4EA6 CC BA 4E     	call z,WriteStrToDataFile		; write string to file 											;4ea6	cc ba 4e 	. . N
3208  4EA9 E1           	pop hl							; restore hl - address of next BASIC char						;4ea9	e1 	.
3209  4EAA 18 D0        	jr .nextExpression		;4eaa	18 d0 	. .
3210  4EAC
3211  4EAC
3212  4EAC              .writeCR:
3213  4EAC 3E 0D        	ld a,CR							; a - CR char (end of record)									;4eac	3e 0d 	> .
3214  4EAE CD CA 4E     	call WriteCharToDataFile		; write CR do file												;4eae	cd ca 4e 	. . N
3215  4EB1 AF           	xor a							; a = 0 (end of BASIC statement/line) 							;4eb1	af 	.
3216  4EB2 C9           	ret								; ---------------- End of Proc --------------------------------	;4eb2	c9 	.
3217  4EB3
3218  4EB3
3219  4EB3              .writeComma:
3220  4EB3 CD CA 4E     	call WriteCharToDataFile		; write char to file											;4eb3	cd ca 4e 	. . N
3221  4EB6 E1           	pop hl							; restore hl - address of next BASIC char						;4eb6	e1 	.
3222  4EB7              .parseNextChar:
3223  4EB7 D7           	rst $10							; call system NextToken routine - check expression				;4eb7	d7 	.
3224  4EB8 18 C7        	jr .nextOrExit					; continure to write next expressions or exit if no more		;4eb8	18 c7 	. .
3225  4EBA
3226  4EBA
3227  4EBA              ;***************************************************************************************************
3228  4EBA              ; Write String to Data File
3229  4EBA              ; IN: ACC - string variable to write
3230  4EBA              WriteStrToDataFile:
3231  4EBA              ; -- get VARPTR of string stored in ACC
3232  4EBA CD DA 29     	call SysGetStrVarPtr			; get VARPTR of string stored in ACC							;4eba	cd da 29 	. . )
3233  4EBD              ; -- get string address and length
3234  4EBD CD C4 09     	call SysStrVarToBCD				; Copy String Variable to BCD (BC=chars address, D=length)		;4ebd	cd c4 09 	. . .
3235  4EC0 14           	inc d							; preincrement char-to-write counter							;4ec0	14 	.
3236  4EC1              .next:
3237  4EC1 15           	dec d							; decrement chars-to-write counter - all was written?			;4ec1	15 	.
3238  4EC2 C8           	ret z							; yes -------------------- End of Proc ------------------------	;4ec2	c8 	.
3239  4EC3              ; -- write one char to data file
3240  4EC3 0A           	ld a,(bc)						; a - next char of string  to write								;4ec3	0a 	.
3241  4EC4 CD CA 4E     	call WriteCharToDataFile		; write char to file											;4ec4	cd ca 4e 	. . N
3242  4EC7 03           	inc bc							; bc - address of next char										;4ec7	03 	.
3243  4EC8 18 F7        	jr .next						; write next char if any left ---------------------------------	;4ec8	18 f7 	. .
3244  4ECA
3245  4ECA
3246  4ECA              ;***************************************************************************************************
3247  4ECA              ; Write Char to Data File
3248  4ECA              ; IN: a - char to write
3249  4ECA              WriteCharToDataFile:
3250  4ECA              ; -- save registers
3251  4ECA E5           	push hl							; save hl														;4eca	e5 	.
3252  4ECB D5           	push de							; save de														;4ecb	d5 	.
3253  4ECC C5           	push bc							; save bc														;4ecc	c5 	.
3254  4ECD F5           	push af							; save af														;4ecd	f5 	.
3255  4ECE
3256  4ECE              ; -- get File Control Block used for this file
3257  4ECE CD 78 47     	call FindFCBForOpen				; Find FCB Block to use or get one if file already opened		;4ece	cd 78 47 	. x G
3258  4ED1 EB           	ex de,hl						; hl - address of FCB											;4ed1	eb 	.
3259  4ED2
3260  4ED2              ; -- throw Error 16 ILLEGAL WRITE if file is open for read
3261  4ED2 23           	inc hl							; hl - address of Access (read/write) field of FCB 				;4ed2	23 	#
3262  4ED3 7E           	ld a,(hl)						; a - Access mode used 											;4ed3	7e 	~
3263  4ED4 B7           	or a							; is it 0 (read)?												;4ed4	b7 	.
3264  4ED5 3E 10        	ld a,16							; a - Error 16   ILLEGAL WRITE									;4ed5	3e 10 	> .
3265  4ED7 CA 41 42     	jp z,ERROR						; yes - go to Error handling routine --------------------------	;4ed7	ca 41 42 	. A B
3266  4EDA
3267  4EDA              ; --
3268  4EDA 2B           	dec hl							; hl - address of Open flag in FCB								;4eda	2b 	+
3269  4EDB 7E           	ld a,(hl)						; a - Open flag													;4edb	7e 	~
3270  4EDC FE 02        	cp 2							; is it 2? (open and active - sector data in buffer)			;4edc	fe 02 	. .
3271  4EDE 28 2C        	jr z,.writeByte					; yes - skip read sector into buffer							;4ede	28 2c 	( ,
3272  4EE0
3273  4EE0              ; -- flush data from buffers to disk before load new sector
3274  4EE0 CD A5 4F     	call FlushSectorData			; Flush Sector Data to disk from both FCBs 						;4ee0	cd a5 4f 	. . O
3275  4EE3
3276  4EE3              ; -- set Track and Sector Number to read
3277  4EE3 11 0A 00     	ld de,10						; de - offset to Track Number in FCB							;4ee3	11 0a 00 	. . .
3278  4EE6 19           	add hl,de						; hl - address of Track Number in FCB							;4ee6	19 	.
3279  4EE7 7E           	ld a,(hl)						; a - Track Number from FCB										;4ee7	7e 	~
3280  4EE8 23           	inc hl							; hl - address of Sector Number in FCB							;4ee8	23 	#
3281  4EE9 FD 77 12     	ld (iy+TRCK),a					; set Track Number of Sector to read							;4ee9	fd 77 12 	. w .
3282  4EEC 7E           	ld a,(hl)						; a - Sector Number from FCB									;4eec	7e 	~
3283  4EED 23           	inc hl							; hl - address of Index (PTR) field in FCB						;4eed	23 	#
3284  4EEE FD 77 11     	ld (iy+SCTR),a					; set Sector Number of Sectr to read							;4eee	fd 77 11 	. w .
3285  4EF1
3286  4EF1              ; -- disable interrupt and read data from sector into buffer
3287  4EF1 F3           	di								; disable interrupts											;4ef1	f3 	.
3288  4EF2
3289  4EF2              ; -- turn on Disk Drive
3290  4EF2 CD 41 5F     	call PWRON						; Disk power ON													;4ef2	cd 41 5f 	. A _
3291  4EF5
3292  4EF5              ; -- check if Disk is not Write-Protected
3293  4EF5 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;4ef5	db 13 	. .
3294  4EF7 B7           	or a							; is bit 7 set? (write protected)								;4ef7	b7 	.
3295  4EF8 3E 04        	ld a,04							; a - Error 04 - DISK WRITE PROTECTED							;4ef8	3e 04 	> .
3296  4EFA FA 41 42     	jp m,ERROR						; yes - go to Error handling routine --------------------------	;4efa	fa 41 42 	. A B
3297  4EFD
3298  4EFD              ; -- read data from sector
3299  4EFD E5           	push hl							; save hl - address of Index (PTR) field in FCB					;4efd	e5 	.
3300  4EFE CD 27 5B     	call READ						; Read a sector from disk										;4efe	cd 27 5b 	. ' [
3301  4F01 B7           	or a							; was any error?												;4f01	b7 	.
3302  4F02 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4f02	c2 41 42 	. A B
3303  4F05
3304  4F05              ; -- update FCB Open flag - sector data in buffer
3305  4F05 E1           	pop hl							; restore hl - address of Index (PTR) field in FCB				;4f05	e1 	.
3306  4F06 11 F4 FF     	ld de,-12						; de - offset to Open flag in FCB								;4f06	11 f4 ff 	. . .
3307  4F09 19           	add hl,de						; hl - address of Open flag in FCB								;4f09	19 	.
3308  4F0A 36 02        	ld (hl),2						; set Open flag - file opened and active						;4f0a	36 02 	6 .
3309  4F0C
3310  4F0C              .writeByte:
3311  4F0C              ;-- increment byte-in-sector index (PTR))
3312  4F0C 11 0C 00     	ld de,12						; de - offset to Index (PTR) field in FCB						;4f0c	11 0c 00 	. . .
3313  4F0F 19           	add hl,de						; de - address of Index (PTR) field in FCB						;4f0f	19 	.
3314  4F10 5E           	ld e,(hl)						; e - index of first not used byte in Sector 					;4f10	5e 	^
3315  4F11 34           	inc (hl)						; increment index (for next use)								;4f11	34 	4
3316  4F12 16 00        	ld d,0							; de - offset to first not used byte in Sector					;4f12	16 00 	. .
3317  4F14
3318  4F14              ; -- store given byte into sector buffer
3319  4F14 FD 6E 31     	ld l,(iy+DBFR)					; hl - address of sector buffer									;4f14	fd 6e 31 	. n 1
3320  4F17 FD 66 32     	ld h,(iy+DBFR+1)																				;4f17	fd 66 32 	. f 2
3321  4F1A 19           	add hl,de						; hl - address of first not used byte in sector					;4f1a	19 	.
3322  4F1B F1           	pop af							; restore a - given byte to write								;4f1b	f1 	.
3323  4F1C F5           	push af							; save af														;4f1c	f5 	.
3324  4F1D 77           	ld (hl),a						; store byte in sector buffer									;4f1d	77 	w
3325  4F1E
3326  4F1E              ; -- check if all 126 data bytes of sector are used already
3327  4F1E 7B           	ld a,e							; a - index of byte we just used								;4f1e	7b 	{
3328  4F1F 3C           	inc a							; increment by 1												;4f1f	3c 	<
3329  4F20 FE 7E        	cp 126							; is it 126 (all bytes used)?									;4f20	fe 7e 	. ~
3330  4F22 20 78        	jr nz,.exit						; no - restre registers and return								;4f22	20 78 	  x
3331  4F24
3332  4F24              ; -- whole sector used - create new one
3333  4F24 F3           	di								; disable interrupts											;4f24	f3 	.
3334  4F25
3335  4F25              ; -- turn on Disk Drive and wait 2 ms
3336  4F25 CD 41 5F     	call PWRON						; Disk power ON													;4f25	cd 41 5f 	. A _
3337  4F28 C5           	push bc							; save bc 														;4f28	c5 	.
3338  4F29 01 02 00     	ld bc,2							; bc - number of miliseconds to delay							;4f29	01 02 00 	. . .
3339  4F2C CD BE 5E     	call DLY						; delay 2 ms													;4f2c	cd be 5e 	. . ^
3340  4F2F C1           	pop bc							; restore bc													;4f2f	c1 	.
3341  4F30
3342  4F30              ; -- check if Disk is not Write-Protected
3343  4F30 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;4f30	db 13 	. .
3344  4F32 B7           	or a							; is bit 7 set? (write protected)								;4f32	b7 	.
3345  4F33 3E 04        	ld a,04							; a - Error 04 - DISK WRITE PROTECTED							;4f33	3e 04 	> .
3346  4F35 FA 41 42     	jp m,ERROR						; yes - go to Error handling routine --------------------------	;4f35	fa 41 42 	. A B
3347  4F38
3348  4F38              ; -- write sector data from buffer to disk
3349  4F38 FD 5E 11     	ld e,(iy+SCTR)					; e - Sector Number												;4f38	fd 5e 11 	. ^ .
3350  4F3B FD 56 12     	ld d,(iy+TRCK)					; d - Track Number												;4f3b	fd 56 12 	. V .
3351  4F3E D5           	push de							; save de - Track and Sector Numbers							;4f3e	d5 	.
3352  4F3F CD A1 59     	call WRITE						; Write a sector to disk										;4f3f	cd a1 59 	. . Y
3353  4F42 B7           	or a							; was any error?												;4f42	b7 	.
3354  4F43 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4f43	c2 41 42 	. A B
3355  4F46
3356  4F46              ; -- read Sector Allocation Map
3357  4F46 CD 17 47     	call RDMAP						; Read disk allocation Map										;4f46	cd 17 47 	. . G
3358  4F49 B7           	or a							; was any error?												;4f49	b7 	.
3359  4F4A C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4f4a	c2 41 42 	. A B
3360  4F4D
3361  4F4D              ; -- Allocate new Sector
3362  4F4D CD BF 58     	call MAP						; Search for empty sector and allocate it						;4f4d	cd bf 58 	. . X
3363  4F50 B7           	or a							; was any error?												;4f50	b7 	.
3364  4F51 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4f51	c2 41 42 	. A B
3365  4F54 CD 54 47     	call SVMAP						; Save the track map to the disk								;4f54	cd 54 47 	. T G
3366  4F57
3367  4F57              ; -- read again old sector we just used for update links to new sector
3368  4F57 D1           	pop de							; restore de - Track and Sector Number							;4f57	d1 	.
3369  4F58 FD 73 11     	ld (iy+SCTR),e					; set Sector Number to read										;4f58	fd 73 11 	. s .
3370  4F5B FD 72 12     	ld (iy+TRCK),d					; set Track Number to read										;4f5b	fd 72 12 	. r .
3371  4F5E CD 27 5B     	call READ						; Read a sector from disk										;4f5e	cd 27 5b 	. ' [
3372  4F61 B7           	or a							; was any error?												;4f61	b7 	.
3373  4F62 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4f62	c2 41 42 	. A B
3374  4F65
3375  4F65              ; -- update sector buffer with next Track and Sector of this file
3376  4F65 FD 6E 31     	ld l,(iy+DBFR)					; hl - address of sector buffer									;4f65	fd 6e 31 	. n 1
3377  4F68 FD 66 32     	ld h,(iy+DBFR+1)																				;4f68	fd 66 32 	. f 2
3378  4F6B 11 7E 00     	ld de,126						; de - offset to Next Track byte in Sector						;4f6b	11 7e 00 	. ~ .
3379  4F6E 19           	add hl,de						; hl - address of Next Track byte in Sector						;4f6e	19 	.
3380  4F6F FD 7E 16     	ld a,(iy+NTRK)					; a - Next Track of sector allocated by MAP routine				;4f6f	fd 7e 16 	. ~ .
3381  4F72 77           	ld (hl),a						; store Next Track Number in buffer								;4f72	77 	w
3382  4F73 23           	inc hl							; hl - address of Next Sector byte in Sector					;4f73	23 	#
3383  4F74 FD 7E 15     	ld a,(iy+NSCT)					; a - Next Sector NUmber of sector allocated by MAP routine		;4f74	fd 7e 15 	. ~ .
3384  4F77 77           	ld (hl),a						; store Next Sector Number in buffer							;4f77	77 	w
3385  4F78              ; -- write back sector to disk
3386  4F78 CD A1 59     	call WRITE						; Write a sector to disk										;4f78	cd a1 59 	. . Y
3387  4F7B B7           	or a							; was any error?												;4f7b	b7 	.
3388  4F7C C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4f7c	c2 41 42 	. A B
3389  4F7F
3390  4F7F              ; -- update FCB and DOS structure with properties of new Sector
3391  4F7F CD 78 47     	call FindFCBForOpen				; Find FCB Block to use or get one if file already opened		;4f7f	cd 78 47 	. x G
3392  4F82 EB           	ex de,hl						; hl - address of FCB											;4f82	eb 	.
3393  4F83 11 0A 00     	ld de,10						; de - offset to Track Number (TRK#) field in FCB				;4f83	11 0a 00 	. . .
3394  4F86 19           	add hl,de						; hl - address of Track Number (TRK#) field in FCB				;4f86	19 	.
3395  4F87 FD 7E 16     	ld a,(iy+NTRK)					; a - Track Number of sector allocated by MAP routine			;4f87	fd 7e 16 	. ~ .
3396  4F8A FD 77 12     	ld (iy+TRCK),a					; set as current Track Number in DOS structure					;4f8a	fd 77 12 	. w .
3397  4F8D 77           	ld (hl),a						; set as current Track Number in FCB							;4f8d	77 	w
3398  4F8E 23           	inc hl							; hl - address of Sector Number (SCTR#) field in FCB			;4f8e	23 	#
3399  4F8F FD 7E 15     	ld a,(iy+NSCT)					; a - Sector Number of sector allocated by MAP routine			;4f8f	fd 7e 15 	. ~ .
3400  4F92 FD 77 11     	ld (iy+SCTR),a					; set as current Sector Number in DOS structure					;4f92	fd 77 11 	. w .
3401  4F95 77           	ld (hl),a						; set as current Sector Number in FCB							;4f95	77 	w
3402  4F96 23           	inc hl							; hl - address of Byte-in-Sector Index (PTR) field in FCB		;4f96	23 	#
3403  4F97 AF           	xor a							; a - 0 - index 												;4f97	af 	.
3404  4F98 77           	ld (hl),a						; set as index to first not used byte in sector					;4f98	77 	w
3405  4F99              ; -- clear sector buffer - fill with 0
3406  4F99 CD 49 47     	call CLEAR						; Clear a sector of the disk									;4f99	cd 49 47 	. I G
3407  4F9C              .exit:
3408  4F9C              ; -- turn disk power off and enable interrupts
3409  4F9C CD 52 5F     	call PWROFF						; Disk power OFF												;4f9c	cd 52 5f 	. R _
3410  4F9F FB           	ei								; enable interrupts												;4f9f	fb 	.
3411  4FA0              ; -- restore registers and exit
3412  4FA0 F1           	pop af							; restore af													;4fa0	f1 	.
3413  4FA1 C1           	pop bc							; restore bc													;4fa1	c1 	.
3414  4FA2 D1           	pop de							; restore de													;4fa2	d1 	.
3415  4FA3 E1           	pop hl							; restore hl													;4fa3	e1 	.
3416  4FA4 C9           	ret								; -------------------- End of Proc ----------------------------	;4fa4	c9 	.
3417  4FA5
3418  4FA5
3419  4FA5              ;***************************************************************************************************
3420  4FA5              ; Flush Sector Data to disk from both File Control Blocks
3421  4FA5              FlushSectorData:
3422  4FA5              ; -- save registers
3423  4FA5 E5           	push hl							; save hl  													;4fa5	e5 	.
3424  4FA6 D5           	push de							; save de 													;4fa6	d5 	.
3425  4FA7              ; -- calculate address of FCB1
3426  4FA7 FD E5        	push iy							; iy - DOS base address										;4fa7	fd e5 	. .
3427  4FA9 E1           	pop hl							; copy to hl												;4fa9	e1 	.
3428  4FAA 11 17 00     	ld de,FCB1						; de - offset to File Control Block 1						;4faa	11 17 00 	. . .
3429  4FAD 19           	add hl,de						; hl - address of File Control Block 1						;4fad	19 	.
3430  4FAE
3431  4FAE              ; -- flush sector data used by FCB1
3432  4FAE CD BB 4F     	call .flushSector				; flush sector data if file is opened to write				;4fae	cd bb 4f 	. . O
3433  4FB1              ; -- calculate address of FCB2
3434  4FB1 11 0D 00     	ld de,13						; de - size of FCB - offset to FCB2 from FCB1				;4fb1	11 0d 00 	. . .
3435  4FB4 19           	add hl,de						; hl - address of File Control Block 2						;4fb4	19 	.
3436  4FB5
3437  4FB5              ; -- flush sector data used by FCB2
3438  4FB5 CD BB 4F     	call .flushSector				; flush sector data if file is opened to write				;4fb5	cd bb 4f 	. . O
3439  4FB8              ; -- restore registers and exit
3440  4FB8 D1           	pop de							; restore de												;4fb8	d1 	.
3441  4FB9 E1           	pop hl							; restore hl 												;4fb9	e1 	.
3442  4FBA C9           	ret								; ------------------------- End Of Proc -------------------	;4fba	c9 	.
3443  4FBB
3444  4FBB
3445  4FBB              .flushSector:
3446  4FBB              ; -- check if FCB is used
3447  4FBB 7E           	ld a,(hl)						; a - FCB Open flag												;4fbb	7e 	~
3448  4FBC B7           	or a							; is FCB used?													;4fbc	b7 	.
3449  4FBD C8           	ret z							; no ---------------------- End Of Proc -----------------------	;4fbd	c8 	.
3450  4FBE              ; -- return if FCB is used but file is not currently active (1)
3451  4FBE FE 02        	cp 2							; is FCB used and file active?									;4fbe	fe 02 	. .
3452  4FC0 C0           	ret nz							; no ---------------------- End Of Proc -----------------------	;4fc0	c0 	.
3453  4FC1              ; -- return if file open and active but for read only
3454  4FC1 36 01        	ld (hl),1						; set FCB used but file is not active							;4fc1	36 01 	6 .
3455  4FC3 23           	inc hl							; hl - point to Access type field								;4fc3	23 	#
3456  4FC4 7E           	ld a,(hl)						; a - access type												;4fc4	7e 	~
3457  4FC5 B7           	or a							; is it opened for read?										;4fc5	b7 	.
3458  4FC6 2B           	dec hl							; hl - address of FCB											;4fc6	2b 	+
3459  4FC7 C8           	ret z							; yes --------------------- End Of Proc -----------------------	;4fc7	c8 	.
3460  4FC8
3461  4FC8              ; -- set Track and Sector Number to Write Sector
3462  4FC8 11 0A 00     	ld de,10						; de - offset to Track Number (in FCB)							;4fc8	11 0a 00 	. . .
3463  4FCB 19           	add hl,de						; hl - address of Track Number 									;4fcb	19 	.
3464  4FCC 7E           	ld a,(hl)						; a - Track Number												;4fcc	7e 	~
3465  4FCD FD 77 12     	ld (iy+TRCK),a					; set as Track Number for write									;4fcd	fd 77 12 	. w .
3466  4FD0 23           	inc hl							; hl - address of Sector NUmber (in FCB)						;4fd0	23 	#
3467  4FD1 7E           	ld a,(hl)						; a - Sector Number												;4fd1	7e 	~
3468  4FD2 FD 77 11     	ld (iy+SCTR),a					; set as Sector Number for Write								;4fd2	fd 77 11 	. w .
3469  4FD5
3470  4FD5              ; -- disable interrupt and write Sector data to Disk
3471  4FD5 F3           	di								; disable interrupts											;4fd5	f3 	.
3472  4FD6
3473  4FD6              ; -- turn on Disk Drive and wait 50 ms
3474  4FD6 CD 41 5F     	call PWRON						; Disk power ON													;4fd6	cd 41 5f 	. A _
3475  4FD9 C5           	push bc							; save bc 														;4fd9	c5 	.
3476  4FDA 01 32 00     	ld bc,50						; bc - number of miliseconds to delay							;4fda	01 32 00 	. 2 .
3477  4FDD CD BE 5E     	call DLY						; delay 50 ms													;4fdd	cd be 5e 	. . ^
3478  4FE0 C1           	pop bc							; restore bc													;4fe0	c1 	.
3479  4FE1
3480  4FE1              ; -- check if Disk is not Write-Protected
3481  4FE1 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;4fe1	db 13 	. .
3482  4FE3 B7           	or a							; is bit 7 set? (write protected)								;4fe3	b7 	.
3483  4FE4 3E 04        	ld a,04							; a - Error 04 - DISK WRITE PROTECTED							;4fe4	3e 04 	> .
3484  4FE6 FA 41 42     	jp m,ERROR						; yes - go to Error handling routine --------------------------	;4fe6	fa 41 42 	. A B
3485  4FE9
3486  4FE9              ; -- flush sector to Disk
3487  4FE9 E5           	push hl							; save hl														;4fe9	e5 	.
3488  4FEA CD A1 59     	call WRITE						; Write a sector to disk										;4fea	cd a1 59 	. . Y
3489  4FED E1           	pop hl							; restore hl													;4fed	e1 	.
3490  4FEE B7           	or a							; was any Error?												;4fee	b7 	.
3491  4FEF C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;4fef	c2 41 42 	. A B
3492  4FF2              ; -- restore address of FCB in register hl
3493  4FF2 11 F5 FF     	ld de,-11						; de - offset back to FCB flag 									;4ff2	11 f5 ff 	. . .
3494  4FF5 19           	add hl,de						; hl - address of FCB											;4ff5	19 	.
3495  4FF6              ; -- turn drive power off and exit
3496  4FF6 CD 52 5F     	call PWROFF						; Disk power OFF												;4ff6	cd 52 5f 	. R _
3497  4FF9 FB           	ei								; enable interrupts												;4ff9	fb 	.
3498  4FFA C9           	ret								; ------------------------- End Of Proc -----------------------	;4ffa	c9 	.
3499  4FFB
3500  4FFB
3501  4FFB
3502  4FFB
3503  4FFB              ;***************************************************************************************************
3504  4FFB              ; DOS Command DCOPY
3505  4FFB              ; Syntax: DCOPY "filaname"
3506  4FFB              ;         DCOPY
3507  4FFB              ; ------------------------
3508  4FFB              ; Transfer a single file (specified by filename) or all the files in a diskette from one to another.
3509  4FFB              ; To transfer all files type DCOPY without filename argument.
3510  4FFB              ; Filename may have no more than 8 characters
3511  4FFB              DCmdDCOPY:
3512  4FFB              ; -- check if invoked as direct command
3513  4FFB ED 5B A2 78  	ld de,(BasicLineNumber)			; de - current line number (ffff if direct command)				;4ffb	ed 5b a2 78 	. [ . x
3514  4FFF 13           	inc de							; de - 0 if direct command, non zero if BASIC program			;4fff	13 	.
3515  5000 7A           	ld a,d							; a - LSB of result												;5000	7a 	z
3516  5001 B3           	or e							; is de 0000? (direct command)?									;5001	b3 	.
3517  5002 1E 16        	ld e,$16						; e - BASIC Error 16 - ILLEGAL DIRECT							;5002	1e 16 	. .
3518  5004 C2 A2 19     	jp nz,SysRaiseError				; no - raise BASIC Error --------------------------------------	;5004	c2 a2 19 	. . .
3519  5007
3520  5007              ; -- set DCOPY command in progress flag
3521  5007 FD 36 39 01  	ld (iy+DCPYF),1					; set DCOPY flag - command in progress							;5007	fd 36 39 01 	. 6 9 .
3522  500B
3523  500B              ; -- check command variant - with or without "filename"
3524  500B 2B           	dec hl							; decrement parser pointer										;500b	2b 	+
3525  500C D7           	rst $10							; call system NextToken routine - is it end ? (no params)?		;500c	d7 	.
3526  500D 28 4E        	jr z,.copyWholeDisk				; yes - copy all files from one disk to another					;500d	28 4e 	( N
3527  500F
3528  500F              ; -- command with parameter - must be filename as only param
3529  500F CD 67 53     	call CSI						; parse filename and copy it to (iy+FNAM)						;500f	cd 67 53 	. g S
3530  5012 B7           	or a							; was any error?												;5012	b7 	.
3531  5013 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;5013	c2 41 42 	. A B
3532  5016
3533  5016              ;    --------------------------------
3534  5016              ; -- copy one file from disk to disk
3535  5016              ;    --------------------------------
3536  5016
3537  5016 E5           	push hl							; save hl - address of next char after filename (parser point)	;5016	e5 	.
3538  5017 CD 68 51     	call AskUserForSrcAndDst		; Ask user to choose source and destination disk number			;5017	cd 68 51 	. h Q
3539  501A CD 19 52     	call sub_5219h		;501a	cd 19 52 	. . R
3540  501D
3541  501D              ; -- turn disk power on and wait 50 ms
3542  501D F3           	di								; disable interrupts											;501d	f3 	.
3543  501E CD 41 5F     	call PWRON						; Disk power ON													;501e	cd 41 5f 	. A _
3544  5021 C5           	push bc							; save bc 														;5021	c5 	.
3545  5022 01 32 00     	ld bc,50						; bc - number of miliseconds to delay							;5022	01 32 00 	. 2 .
3546  5025 CD BE 5E     	call DLY						; delay 50 ms													;5025	cd be 5e 	. . ^
3547  5028 C1           	pop bc							; restore bc													;5028	c1 	.
3548  5029
3549  5029              ; -- search for file on disk
3550  5029 CD 13 59     	call SEARCH						; Search for file in directory									;5029	cd 13 59 	. . Y
3551  502C FE 02        	cp 02							; was Error 02 - FILE ALREADY EXISTS? (means OK)				;502c	fe 02 	. .
3552  502E 28 09        	jr z,.fileFound					; yes - continue												;502e	28 09 	( .
3553  5030              ; -- file not found or other error
3554  5030 B7           	or a							; was any other error?											;5030	b7 	.
3555  5031 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine --------------------------	;5031	c2 41 42 	. A B
3556  5034 3E 0D        	ld a,13							; a - Error 13   FILE NOT FOUND									;5034	3e 0d 	> .
3557  5036 C3 41 42     	jp ERROR						; go to Error handling routine --------------------------------	;5036	c3 41 42 	. A B
3558  5039
3559  5039              .fileFound:
3560  5039              ; -- copy file type and verify it is 'B' (binary) or 'T' (BASIC)
3561  5039 FD 7E 0A     	ld a,(iy+TYPE+1)				; a - type of found file 										;5039	fd 7e 0a 	. ~ .
3562  503C FD 77 09     	ld (iy+TYPE),a					; set as destination file type									;503c	fd 77 09 	. w .
3563  503F FE 44        	cp 'D'							; is it type 'D' (data file)?									;503f	fe 44 	. D
3564  5041 3E 0C        	ld a,12							; a - Error 12   FILE TYPE MISMATCH								;5041	3e 0c 	> .
3565  5043 CA 41 42     	jp z,ERROR						; yes - go to Error handling routine --------------------------	;5043	ca 41 42 	. A B
3566  5046
3567  5046              ; -- load file as program into RAM
3568  5046 CD D3 43     	call LoadProgramData			; load program file into memory as normal						;5046	cd d3 43 	. . C
3569  5049 B7           	or a							; was any error?												;5049	b7 	.
3570  504A C2 62 51     	jp nz,ClearAndError				; yes - Clear BASIC Program and raise Error -------------------	;504a	c2 62 51 	. b Q
3571  504D
3572  504D              ; --
3573  504D CD 75 52     	call SelectDstDrive		;504d	cd 75 52 	. u R
3574  5050              ; -- save BASIC program from memory to disk
3575  5050 CD 41 5F     	call PWRON						; Disk power ON													;5050	cd 41 5f 	. A _
3576  5053 CD 6E 44     	call SAVE						; Save program  to disk											;5053	cd 6e 44 	. n D
3577  5056 B7           	or a							; was any error?												;5056	b7 	.
3578  5057 C2 62 51     	jp nz,ClearAndError				; yes - Clear BASIC Program and raise Error -------------------	;5057	c2 62 51 	. b Q
3579  505A C3 37 51     	jp .cleanAndExit		;505a	c3 37 51 	. 7 Q
3580  505D
3581  505D
3582  505D              ;    --------------------------------
3583  505D              ; -- copy disk to another disk
3584  505D              ;    --------------------------------
3585  505D
3586  505D
3587  505D              .copyWholeDisk:
3588  505D E5           	push hl							; save hl - address of next char after filename (parser point)	;505d	e5 	.
3589  505E              ; -- allocate memory area for buffer + 58 extra bytes
3590  505E 21 C6 FF     	ld hl,-58						; hl - 58 bytes to reserve on stack								;505e	21 c6 ff 	! . .
3591  5061 39           	add hl,sp						; allocate 58 bytes on CPU stack								;5061	39 	9
3592  5062 11 E9 7A     	ld de,SYS_BASIC_PRG				; address of first byte of BASIC program 						;5062	11 e9 7a 	. . z
3593  5065 B7           	or a							; clear Carry flag												;5065	b7 	.
3594  5066 ED 52        	sbc hl,de						; hl - number of bytes free above program and below CPU Stack	;5066	ed 52 	. R
3595  5068              ; -- allocate memory buffer for X tracks
3596  5068              ;    1 track = 16 sectors  x 128 bytes = 8 memory pages = 2kB
3597  5068 CB 3C        	srl h							; h - number of memory pages x 2								;5068	cb 3c 	. <
3598  506A CB 3C        	srl h							; h - number of memory pages x 4								;506a	cb 3c 	. <
3599  506C CB 3C        	srl h							; h - number of memory pages x 8								;506c	cb 3c 	. <
3600  506E FD 74 36     	ld (iy+TRKCNT),h				; set as number of tracks we can load into memory at once		;506e	fd 74 36 	. t 6
3601  5071 FD 36 37 00  	ld (iy+TRKPTR),0				; set 0 as number of tracks loaded								;5071	fd 36 37 00 	. 6 7 .
3602  5075
3603  5075              ; -- copying starts from Track 0 Sector 0
3604  5075 FD 36 12 00  	ld (iy+TRCK),0					; set Track Number to 0											;5075	fd 36 12 00 	. 6 . .
3605  5079 FD 36 11 00  	ld (iy+SCTR),0					; set Sector Number to 0										;5079	fd 36 11 00 	. 6 . .
3606  507D CD A5 4F     	call FlushSectorData			; Flush Sector Data to disk from both FCBs 						;507d	cd a5 4f 	. . O
3607  5080 CD 68 51     	call AskUserForSrcAndDst		; Ask user to choose source and destination disk number			;5080	cd 68 51 	. h Q
3608  5083
3609  5083              .readTracks:
3610  5083 11 E9 7A     	ld de,SYS_BASIC_PRG				; de - address first byte of free memory (Buffer) 				;5083	11 e9 7a 	. . z
3611  5086 ED 53 A4 78  	ld (SYS_BASIC_START_PTR),de		; set as current pointer 										;5086	ed 53 a4 78 	. S . x
3612  508A CD 19 52     	call sub_5219h		;508a	cd 19 52 	. . R
3613  508D
3614  508D              ; -- load whole track (16 sectors) into memory
3615  508D F3           	di								; disable interrupts											;508d	f3 	.
3616  508E CD 41 5F     	call PWRON						; Disk power ON													;508e	cd 41 5f 	. A _
3617  5091              .readNextSector:
3618  5091              ; -- read one sector
3619  5091 CD 27 5B     	call READ						; Read a sector from disk										;5091	cd 27 5b 	. ' [
3620  5094 B7           	or a							; was any error?												;5094	b7 	.
3621  5095 C2 62 51     	jp nz,ClearAndError				; yes - Clear BASIC Program and raise Error -------------------	;5095	c2 62 51 	. b Q
3622  5098              ; -- copy sector buffer to copy buffer
3623  5098 FD 6E 31     	ld l,(iy+DBFR)					; hl - address of Sector Buffer (source)						;5098	fd 6e 31 	. n 1
3624  509B FD 66 32     	ld h,(iy+DBFR+1)																				;509b	fd 66 32 	. f 2
3625  509E ED 5B A4 78  	ld de,(SYS_BASIC_START_PTR)		; de - address in allocated Track buffer (destination) 			;509e	ed 5b a4 78 	. [ . x
3626  50A2 01 80 00     	ld bc,128						; bc - 128 bytes to copy (sector data)							;50a2	01 80 00 	. . .
3627  50A5 ED B0        	ldir							; copy data														;50a5	ed b0 	. .
3628  50A7
3629  50A7              ; -- advance destination pointer and sector number
3630  50A7 ED 53 A4 78  	ld (SYS_BASIC_START_PTR),de		; update current pointer in Track Buffer 						;50a7	ed 53 a4 78 	. S . x
3631  50AB FD 34 11     	inc (iy+SCTR)					; increment Sector Number by 1									;50ab	fd 34 11 	. 4 .
3632  50AE FD 7E 11     	ld a,(iy+SCTR)					; a - next Sector Number										;50ae	fd 7e 11 	. ~ .
3633  50B1 FE 10        	cp 16							; is it 16? (all 16 sectors loaded into memory)					;50b1	fe 10 	. .
3634  50B3 20 DC        	jr nz,.readNextSector					; no - read next sector ---------------------------------------	;50b3	20 dc 	  .
3635  50B5
3636  50B5              ; -- advance track number
3637  50B5 FD 36 11 00  	ld (iy+SCTR),0					; set Sector Number to 0										;50b5	fd 36 11 00 	. 6 . .
3638  50B9 FD 34 12     	inc (iy+TRCK)					; increment Track number by 1									;50b9	fd 34 12 	. 4 .
3639  50BC FD 7E 12     	ld a,(iy+TRCK)					; a - next Track Number											;50bc	fd 7e 12 	. ~ .
3640  50BF FE 28        	cp 40							; is it 40? (end of disk)										;50bf	fe 28 	. (
3641  50C1 28 08        	jr z,.writeTracks				; yes - write track from memory to destination disk				;50c1	28 08 	( .
3642  50C3              ; --
3643  50C3 FD 96 37     	sub (iy+TRKPTR)					; subtract number of tracks already written 					;50c3	fd 96 37 	. . 7
3644  50C6 FD 96 36     	sub (iy+TRKCNT)					; subtract max number of tracks can be loaded - 0 left?			;50c6	fd 96 36 	. . 6
3645  50C9 20 C6        	jr nz,.readNextSector			; no - read next sector ---------------------------------------	;50c9	20 c6 	  .
3646  50CB
3647  50CB              .writeTracks:
3648  50CB              ; -- set Track number to write
3649  50CB FD 7E 37     	ld a,(iy+TRKPTR)				; a - first track loaded in memory								;50cb	fd 7e 37 	. ~ 7
3650  50CE FD 77 12     	ld (iy+TRCK),a					; set as current track to write									;50ce	fd 77 12 	. w .
3651  50D1              ; -- turn disk power off and select destination drive
3652  50D1 CD 52 5F     	call PWROFF						; Disk power OFF												;50d1	cd 52 5f 	. R _
3653  50D4 CD 75 52     	call SelectDstDrive				; select destination drive (ask user if the same as source)		;50d4	cd 75 52 	. u R
3654  50D7
3655  50D7              ; -- write all tracks from memory to destination Disk
3656  50D7 F3           	di								; disable interrupts											;50d7	f3 	.
3657  50D8
3658  50D8              ; -- turn on Disk Drive and wait 2 ms
3659  50D8 CD 41 5F     	call PWRON						; Disk power ON													;50d8	cd 41 5f 	. A _
3660  50DB C5           	push bc							; save bc 														;50db	c5 	.
3661  50DC 01 02 00     	ld bc,2							; bc - number of miliseconds to delay							;50dc	01 02 00 	. . .
3662  50DF CD BE 5E     	call DLY						; delay 2 ms													;50df	cd be 5e 	. . ^
3663  50E2 C1           	pop bc							; restore bc													;50e2	c1 	.
3664  50E3
3665  50E3              ; -- check if Disk is not Write-Protected
3666  50E3 DB 13        	in a,(FLWRPROT)					; a - read Write Protected flag from FDC						;50e3	db 13 	. .
3667  50E5 B7           	or a							; is bit 7 set? (write protected)								;50e5	b7 	.
3668  50E6 3E 04        	ld a,04							; a - Error 04 - DISK WRITE PROTECTED							;50e6	3e 04 	> .
3669  50E8 FA 62 51     	jp m,ClearAndError				; yes - Clear BASIC Program and raise Error						;50e8	fa 62 51 	. b Q
3670  50EB
3671  50EB              ; -- reset buffer pointer
3672  50EB 21 E9 7A     	ld hl,SYS_BASIC_PRG				; hl - address of first byte of free memory (buffer) 			;50eb	21 e9 7a 	! . z
3673  50EE 22 A4 78     	ld (SYS_BASIC_START_PTR),hl		; set as current pointer 										;50ee	22 a4 78 	" . x
3674  50F1
3675  50F1              .writeNextSector:
3676  50F1              ; -- copy sector data from Tracks Buffer (memory) to Sector Buffer
3677  50F1 2A A4 78     	ld hl,(SYS_BASIC_START_PTR)		; hl - address in allocated Track buffer (source)	 			;50f1	2a a4 78 	* . x
3678  50F4 FD 5E 31     	ld e,(iy+DBFR)					; de - address of Sector BUffer (destination)					;50f4	fd 5e 31 	. ^ 1
3679  50F7 FD 56 32     	ld d,(iy+DBFR+1)																				;50f7	fd 56 32 	. V 2
3680  50FA 01 80 00     	ld bc,128						; bc - 128 bytes to copy (sector data)							;50fa	01 80 00 	. . .
3681  50FD ED B0        	ldir							; copy data														;50fd	ed b0 	. .
3682  50FF
3683  50FF              ; -- advance source pointer
3684  50FF 22 A4 78     	ld (SYS_BASIC_START_PTR),hl		; update current pointer in Track Buffer 						;50ff	22 a4 78 	" . x
3685  5102              ; -- write sector
3686  5102 CD A1 59     	call WRITE						; Write a sector to disk										;5102	cd a1 59 	. . Y
3687  5105 B7           	or a							; was any error?												;5105	b7 	.
3688  5106 20 5A        	jr nz,ClearAndError				; yes - Clear BASIC Program and raise Error ------------------- ;5106	20 5a 	  Z
3689  5108
3690  5108              ; -- advance destination sector number
3691  5108 FD 34 11     	inc (iy+SCTR)					; increment Sector Number by 1									;5108	fd 34 11 	. 4 .
3692  510B FD 7E 11     	ld a,(iy+SCTR)					; a - next Sector Number										;510b	fd 7e 11 	. ~ .
3693  510E FE 10        	cp 16							; is it 16? (all 16 sectors written to disk)					;510e	fe 10 	. .
3694  5110 20 DF        	jr nz,.writeNextSector			; no - write next sector --------------------------------------	;5110	20 df 	  .
3695  5112
3696  5112              ; -- advance track number
3697  5112 FD 36 11 00  	ld (iy+SCTR),0					; set Sector Number to 0										;5112	fd 36 11 00 	. 6 . .
3698  5116 FD 34 12     	inc (iy+TRCK)					; increment Track Number by 1									;5116	fd 34 12 	. 4 .
3699  5119 FD 7E 12     	ld a,(iy+TRCK)					; a - next Track Number											;5119	fd 7e 12 	. ~ .
3700  511C FE 28        	cp 40							; is it 40?  (end of disk)										;511c	fe 28 	. (
3701  511E 28 17        	jr z,.cleanAndExit				; yes - cleanup and exit to BASIC								;511e	28 17 	( .
3702  5120
3703  5120              ; -- check if there is free space in buffer for next track
3704  5120 FD 96 37     	sub (iy+TRKPTR)					; subtract number of tracks already written 					;5120	fd 96 37 	. . 7
3705  5123 FD 96 36     	sub (iy+TRKCNT)					; subtract max number of tracks stored in buffer - 0 left?		;5123	fd 96 36 	. . 6
3706  5126 20 C9        	jr nz,.writeNextSector			; no - write next sector										;5126	20 c9 	  .
3707  5128
3708  5128              ; -- advance tracks-written counter
3709  5128 FD 7E 36     	ld a,(iy+TRKCNT)				; a - number of tracks in Buffer								;5128	fd 7e 36 	. ~ 6
3710  512B FD 86 37     	add a,(iy+TRKPTR)				; add number of tracks already written							;512b	fd 86 37 	. . 7
3711  512E FD 77 37     	ld (iy+TRKPTR),a				; store as new number of tracks already written to disk			;512e	fd 77 37 	. w 7
3712  5131
3713  5131              ; -- turn disk power OFF and continue copy remaining tracks
3714  5131 CD 52 5F     	call PWROFF						; Disk power OFF												;5131	cd 52 5f 	. R _
3715  5134 C3 83 50     	jp .readTracks					; continue copy remaining tracks ------------------------------	;5134	c3 83 50 	. . P
3716  5137
3717  5137              .cleanAndExit:
3718  5137              ; -- cleanup BASIC memory and exit to BASIC
3719  5137 CD 52 5F     	call PWROFF						; Disk power OFF												;5137	cd 52 5f 	. R _
3720  513A CD 44 51     	call ClearBASIC					; clean BASIC variables											;513a	cd 44 51 	. D Q
3721  513D 01 19 1A     	ld bc,SysStartBASIC				; bc - address of BASIC start routine to take control			;513d	01 19 1a 	. . .
3722  5140 C5           	push bc							; push routine addres on stack									;5140	c5 	.
3723  5141 C3 4D 1B     	jp SysBASICDeletePrg			; Wipe out BASIC variables and set BASIC Ready					;5141	c3 4d 1b 	. M .
3724  5144
3725  5144
3726  5144
3727  5144              ;***************************************************************************************************
3728  5144              ; Clear BASIC Program and select D1 drive
3729  5144              ClearBASIC:
3730  5144              ; -- clear BASIC program
3731  5144 21 E9 7A     	ld hl,SYS_BASIC_PRG				; address of first byte of BASIC program 						;5144	21 e9 7a 	! . z
3732  5147 22 A4 78     	ld (SYS_BASIC_START_PTR),hl		; store it as start of current BASIC Program 					;5147	22 a4 78 	" . x
3733  514A              ; -- store two 00 bytes as "end of BASIC" sequence
3734  514A 36 00        	ld (hl),0						; 0 as low byte of address										;514a	36 00 	6 .
3735  514C 23           	inc hl							; next address in memory										;514c	23 	#
3736  514D 36 00        	ld (hl),0						; store 0000 as address of next BASIC line						;514d	36 00 	6 .
3737  514F 23           	inc hl							; next addres after BASIC Program								;514f	23 	#
3738  5150              ; -- set end of BASIC area (including 0 bytes allocated for DIM variables)
3739  5150 22 F9 78     	ld (SYS_BASIC_END_PTR),hl		; store it as end of current BASIC Program 						;5150	22 f9 78 	" . x
3740  5153 22 FB 78     	ld (SYS_ARR_START_PTR),hl		; store it as start of area for BASIC arrays					;5153	22 fb 78 	" . x
3741  5156 22 FD 78     	ld (SYS_ARR_END_PTR),hl			; store it as end of area for BASIC arrays						;5156	22 fd 78 	" . x
3742  5159              ; -- select drive D1
3743  5159 FD 36 0B 10  	ld (iy+DK),$10					; set Drive 1 selected											;5159	fd 36 0b 10 	. 6 . .
3744  515D FD 36 39 00  	ld (iy+DCPYF),0					; clear DCOPY flag												;515d	fd 36 39 00 	. 6 9 .
3745  5161 C9           	ret								; --------------------- End of Proc ---------------------------	;5161	c9 	.
3746  5162
3747  5162
3748  5162              ;***************************************************************************************************
3749  5162              ; Clear BASIC Program and raise Error
3750  5162              ClearAndError:
3751  5162 CD 44 51     	call ClearBASIC					; clear BASIC Program from memory								;5162	cd 44 51 	. D Q
3752  5165 C3 41 42     	jp ERROR						; go to Error handling routine --------------------------------	;5165	c3 41 42 	. A B
3753  5168
3754  5168
3755  5168              ;***************************************************************************************************
3756  5168              ; Ask user to choose source and destination disk number
3757  5168              AskUserForSrcAndDst:
3758  5168              ; -- print input string for Source Disk
3759  5168 21 EC 51     	ld hl,TXT_ASKSOURCEDISK			; hl - text "SOURCE DISK(1/2)? " 								;5168	21 ec 51 	! . Q
3760  516B CD A7 28     	call SysMsgOut					; print text on screen											;516b	cd a7 28 	. . (
3761  516E
3762  516E              ; --
3763  516E CD 92 51     	call GetDriveNoInput		;516e	cd 92 51 	. . Q
3764  5171              ; -- echo back user choice
3765  5171 79           	ld a,c							; a - char from user											;5171	79 	y
3766  5172 CD 2A 03     	call SysPrintChar				; print char on screen											;5172	cd 2a 03 	. * .
3767  5175              ; -- store source disk number
3768  5175 E6 03        	and %0011						; convert from ASCII (31 -> 1, 32 -> 2)							;5175	e6 03 	. .
3769  5177 FD 77 0D     	ld (iy+SOURCE),a				; set source Drive number (1 or 2) 								;5177	fd 77 0d 	. w .
3770  517A
3771  517A              ; -- print input string for Destination Disk
3772  517A 21 00 52     	ld hl,TXT_ASKDESTDISK			; hl - text "DESTINATION DISK(1/2)? " 							;517a	21 00 52 	! . R
3773  517D CD A7 28     	call SysMsgOut					; print text on screen											;517d	cd a7 28 	. . (
3774  5180              ; --
3775  5180 CD 92 51     	call GetDriveNoInput		;5180	cd 92 51 	. . Q
3776  5183              ; -- echo back user choice
3777  5183 79           	ld a,c							; a - char from user											;5183	79 	y
3778  5184 CD 2A 03     	call SysPrintChar				; print char on screen											;5184	cd 2a 03 	. * .
3779  5187              ; -- store destination disk number
3780  5187 E6 03        	and %0011						; convert from ASCII (31 -> 1, 32 -> 2)							;5187	e6 03 	. .
3781  5189 FD 77 10     	ld (iy+DESTIN),a				; set destination Drive number (1 or 2) 						;5189	fd 77 10 	. w .
3782  518C
3783  518C              ; -- print CR and exit
3784  518C 3E 0D        	ld a,CR							; a - CR char 													;518c	3e 0d 	> .
3785  518E CD 2A 03     	call SysPrintChar				; print char on screen											;518e	cd 2a 03 	. * .
3786  5191 C9           	ret								; --------------------- End of Proc ---------------------------	;5191	c9 	.
3787  5192
3788  5192              ;***************************************************************************************************
3789  5192              ; Get Drive Number from User (only 1 or 2)
3790  5192              ; User can press Ctrl+Break to cancel DCOPY command
3791  5192              ; OUT: c - char pressed by user ('1' or '2')
3792  5192              GetDriveNoInput:
3793  5192 3A AF 7A     	ld a,(EditBufCounter)			; a - number of characters in Edit Buffer left to process		;5192	3a af 7a 	: . z
3794  5195 B7           	or a							; is it 0 (buffer empty)?										;5195	b7 	.
3795  5196 20 FA        	jr nz,GetDriveNoInput			; no - wait until all are processed ---------------------------	;5196	20 fa 	  .
3796  5198
3797  5198              ; -- disable System keyboard handler
3798  5198 F3           	di								; disable interrupts											;5198	f3 	.
3799  5199              ; -- setup to provide Cursor blinking on Screen
3800  5199 1E 10        	ld e,16							; e - inverse char under Cursor every 16 frames 				;5199	1e 10 	. .
3801  519B 53           	ld d,e							; d - frame counter												;519b	53 	S
3802  519C 2A 20 78     	ld hl,(SysCursorAddr)			; hl - address of Cursor position on Screen 					;519c	2a 20 78 	*   x
3803  519F              .waitForINT:
3804  519F              ; -- wait for interrupt (end of frame)
3805  519F 3A 00 68     	ld a,(SYS_INT_STATE)			; read hardware INT line										;519f	3a 00 68 	: . h
3806  51A2 B7           	or a							; is INT line 0? (end of video frame)							;51a2	b7 	.
3807  51A3 FA 9F 51     	jp m,.waitForINT				; no - wait for INT line low ----------------------------------	;51a3	fa 9f 51 	. . Q
3808  51A6
3809  51A6              ; -- check frame counter for Cursor blink
3810  51A6 15           	dec d							; decrement frame counter - is 16 counted?						;51a6	15 	.
3811  51A7 20 05        	jr nz,.waitForINTEnd			; no - read key from user -------------------------------------	;51a7	20 05 	  .
3812  51A9              ; -- reset counter and blink Cursor
3813  51A9 53           	ld d,e							; reset frame counter to 16										;51a9	53 	S
3814  51AA 3E 40        	ld a,$40						; a - bit 6 to toggle in char code (inverse)					;51aa	3e 40 	> @
3815  51AC AE           	xor (hl)						; inverse char under Cursor on screen							;51ac	ae 	.
3816  51AD 77           	ld (hl),a						; put char on screen											;51ad	77 	w
3817  51AE
3818  51AE              .waitForINTEnd:
3819  51AE              ; -- wait for end of interrupt (start new frame)
3820  51AE 3A 00 68     	ld a,(SYS_INT_STATE)			; read hardware INT line										;51ae	3a 00 68 	: . h
3821  51B1 B7           	or a							; is INT line 1? (start of video frame)							;51b1	b7 	.
3822  51B2 F2 AE 51     	jp p,.waitForINTEnd				; no - wait for INT line high ---------------------------------	;51b2	f2 ae 51 	. . Q
3823  51B5
3824  51B5              ; -- check if user pressed Ctrl+BREAK
3825  51B5 3A DF 68     	ld a,(BreakKeybRow)				; read Keyboard Row with BREAK key								;51b5	3a df 68 	: . h
3826  51B8 CB 57        	bit BreakKeyCol,a				; test only BREAK key - is it 0? (key is pressed)				;51b8	cb 57 	. W
3827  51BA 20 0F        	jr nz,.l51cbh					; no - test if user pressed '1' or '2'							;51ba	20 0f 	  .
3828  51BC 3A FD 68     	ld a,(CtrlKeyRow)		;51bc	3a fd 68 	: . h
3829  51BF CB 57        	bit 2,a		;51bf	cb 57 	. W
3830  51C1 20 08        	jr nz,.l51cbh		;51c1	20 08 	  .
3831  51C3 CD 44 51     	call ClearBASIC		;51c3	cd 44 51 	. D Q
3832  51C6 3E 11        	ld a,011h		;51c6	3e 11 	> .
3833  51C8 C3 41 42     	jp ERROR		; Error handling routine	;51c8	c3 41 42 	. A B
3834  51CB              .l51cbh:
3835  51CB 3A F7 68     	ld a,(068f7h)		;51cb	3a f7 68 	: . h
3836  51CE CB 67        	bit 4,a		;51ce	cb 67 	. g
3837  51D0 0E 31        	ld c,031h		;51d0	0e 31 	. 1
3838  51D2 28 06        	jr z,l51dah		;51d2	28 06 	( .
3839  51D4 CB 4F        	bit 1,a		;51d4	cb 4f 	. O
3840  51D6 0E 32        	ld c,032h		;51d6	0e 32 	. 2
3841  51D8 20 C5        	jr nz,.waitForINT		;51d8	20 c5 	  .
3842  51DA              l51dah:
3843  51DA              ; -- wait 100 ms delay
3844  51DA C5           	push bc							; save bc														;51da	c5 	.
3845  51DB 01 64 00     	ld bc,100						; bc - number of miliseconds to delay							;51db	01 64 00 	. d .
3846  51DE CD BE 5E     	call DLY						; delay 100 ms													;51de	cd be 5e 	. . ^
3847  51E1 C1           	pop bc							; restore bc													;51e1	c1 	.
3848  51E2              .waitKeysReleased:
3849  51E2              ; -- wait for all keys released
3850  51E2 3A 00 68     	ld a,(AllKeyRows)				; read all keys at once 										;51e2	3a 00 68 	: . h
3851  51E5 F6 80        	or %10000000					; set bit 7 to ignore INT line									;51e5	f6 80 	. .
3852  51E7 3C           	inc a							; was it $FF? (no keys pressed)									;51e7	3c 	<
3853  51E8 20 F8        	jr nz,.waitKeysReleased			; no - wait for all keys released -----------------------------	;51e8	20 f8 	  .
3854  51EA              ; -- enable interrupts and return
3855  51EA FB           	ei								; enable interrupts												;51ea	fb 	.
3856  51EB C9           	ret								; ---------------------- End of Proc --------------------------	;51eb	c9 	.
3857  51EC
3858  51EC
3859  51EC              TXT_ASKSOURCEDISK:
3860  51EC 0D 53 4F 55  	defm	CR,"SOURCE DISK(1/2)? ",0 			;51ec	0d 53 4f 55 52 43 45 20 44 49 53 4b 28 31 2f 32 29 3f 20 00 	  .
3860  51F0 52 43 45 20
3860  51F4 44 49 53 4B
3860  51F8 28 31 2F 32
3860  51FC 29 3F 20 00
3861  5200              TXT_ASKDESTDISK:
3862  5200 0D 44 45 53  	defm	CR,"DESTINATION DISK(1/2)? ", 0		;5200	0d 44 45 53 54 49 4e 41 54 49 4f 4e 20 44 49 53 4b 28 31 2f 32 29 3f 20 00 	  .
3862  5204 54 49 4E 41
3862  5208 54 49 4F 4E
3862  520C 20 44 49 53
3862  5210 4B 28 31 2F
3862  5214 32 29 3F 20
3862  5218 00
3863  5219
3864  5219              sub_5219h:
3865  5219 FD 7E 0D     	ld a,(iy+SOURCE)				; a - source drive (1 or 2) 									;5219	fd 7e 0d 	. ~ .
3866  521C CD 84 4D     	call SelectDriveNo				; Set selected Drive (1 or 2)									;521c	cd 84 4d 	. . M
3867  521F FD BE 10     	cp (iy+DESTIN)					; is the same as destination Drive 								;521f	fd be 10 	. . .
3868  5222 C0           	ret nz							; no - no need to ask user to exchange disks ------------------	;5222	c0 	.
3869  5223              ; -- prompt user to insert proper disk
3870  5223 21 84 52     	ld hl,TXT_INSERTSRCDISK			; hl - text "INSERT SOURCE DISKETTE"							;5223	21 84 52 	! . R
3871  5226              WaitUserReady:
3872  5226 CD A7 28     	call SysMsgOut					; print text on screen											;5226	cd a7 28 	. . (
3873  5229 21 9D 52     	ld hl,TXT_PRESSSPACEREADY		; hl - text "(PRESS SPACE WHEN READY)"							;5229	21 9d 52 	! . R
3874  522C CD A7 28     	call SysMsgOut					; print text on screen											;522c	cd a7 28 	. . (
3875  522F              .wait:
3876  522F              ; -- wait for system Edit Buffer is empty
3877  522F 3A AF 7A     	ld a,(EditBufCounter)			; a - number of chars in Edit Buffer left to process			;522f	3a af 7a 	: . z
3878  5232 B7           	or a							; is it 0? (buffer empty)										;5232	b7 	.
3879  5233 20 FA        	jr nz,.wait						; no - wait for all characters in Edit Buffer be processed		;5233	20 fa 	  .
3880  5235
3881  5235              ; -- disable System keyboard handler
3882  5235 F3           	di								; disable interrupts											;5235	f3 	.
3883  5236              ; -- setup to provide Cursor blinking on Screen
3884  5236 1E 10        	ld e,16							; e - inverse char under Cursor every 16 frames 				;5236	1e 10 	. .
3885  5238 53           	ld d,e							; d - frame counter												;5238	53 	S
3886  5239 2A 20 78     	ld hl,(SysCursorAddr)			; hl - address of Cursor position on Screen 					;5239	2a 20 78 	*   x
3887  523C              l523ch:
3888  523C 3A 00 68     	ld a,(SYS_INT_STATE)			; read hardware INT line										;523c	3a 00 68 	: . h
3889  523F B7           	or a			;523f	b7 	.
3890  5240 FA 3C 52     	jp m,l523ch		;5240	fa 3c 52 	. < R
3891  5243 15           	dec d			;5243	15 	.
3892  5244 20 05        	jr nz,l524bh		;5244	20 05 	  .
3893  5246 53           	ld d,e			;5246	53 	S
3894  5247 3E 40        	ld a,040h		;5247	3e 40 	> @
3895  5249 AE           	xor (hl)			;5249	ae 	.
3896  524A 77           	ld (hl),a			;524a	77 	w
3897  524B              l524bh:
3898  524B 3A 00 68     	ld a,(SYS_INT_STATE)			; read hardware INT line										;524b	3a 00 68 	: . h
3899  524E B7           	or a			;524e	b7 	.
3900  524F F2 4B 52     	jp p,l524bh		;524f	f2 4b 52 	. K R
3901  5252 3A DF 68     	ld a,(BreakKeybRow)		;5252	3a df 68 	: . h
3902  5255 CB 57        	bit BreakKeyCol,a		;5255	cb 57 	. W
3903  5257 20 0F        	jr nz,l5268h		;5257	20 0f 	  .
3904  5259 3A FD 68     	ld a,(CtrlKeyRow)		;5259	3a fd 68 	: . h
3905  525C CB 57        	bit 2,a		;525c	cb 57 	. W
3906  525E 20 08        	jr nz,l5268h		;525e	20 08 	  .
3907  5260 CD 44 51     	call ClearBASIC		;5260	cd 44 51 	. D Q
3908  5263 3E 11        	ld a,011h		;5263	3e 11 	> .
3909  5265 C3 41 42     	jp ERROR		; Error handling routine	;5265	c3 41 42 	. A B
3910  5268              l5268h:
3911  5268 3A EF 68     	ld a,(SpaceKeyRow)		;5268	3a ef 68 	: . h
3912  526B CB 67        	bit SpaceKeyCol,a		;526b	cb 67 	. g
3913  526D 20 CD        	jr nz,l523ch		;526d	20 cd 	  .
3914  526F 3A 3C 78     	ld a,(0783ch)		;526f	3a 3c 78 	: < x
3915  5272 77           	ld (hl),a			;5272	77 	w
3916  5273 FB           	ei			;5273	fb 	.
3917  5274 C9           	ret			;5274	c9 	.
3918  5275
3919  5275
3920  5275              SelectDstDrive:
3921  5275              ; -- select destination drive
3922  5275 FD 7E 10     	ld a,(iy+DESTIN)				; a - destination Drive (1 or 2) 								;5275	fd 7e 10 	. ~ .
3923  5278 CD 84 4D     	call SelectDriveNo				; Set selected Drive (1 or 2)									;5278	cd 84 4d 	. . M
3924  527B              ; -- check if only one drive used and user must insert destination disk
3925  527B FD BE 0D     	cp (iy+SOURCE)					; is the same as source drive? 									;527b	fd be 0d 	. . .
3926  527E C0           	ret nz							; no - 2 drive mode - no needs to ask user to put dest disk		;527e	c0 	.
3927  527F              ; -- wait for user to insert destination diskette
3928  527F 21 B7 52     	ld hl,TXT_INSERTDSTDISK			; hl - text "INSERT DESTINATION DISKETTE"						;527f	21 b7 52 	! . R
3929  5282 18 A2        	jr WaitUserReady				; wait until user press SPACE --------------------------------- ;5282	18 a2 	. .
3930  5284
3931  5284
3932  5284              TXT_INSERTSRCDISK:
3933  5284 0D 49 4E 53  	defm	CR,"INSERT SOURCE DISKETTE",CR,0  		;5284	0d 49 4e 53 45 52 54 20 53 4f 55 52 43 45 20 44 49 53 4b 45 54 54 45 0d 00 	.
3933  5288 45 52 54 20
3933  528C 53 4F 55 52
3933  5290 43 45 20 44
3933  5294 49 53 4B 45
3933  5298 54 54 45 0D
3933  529C 00
3934  529D              TXT_PRESSSPACEREADY:
3935  529D 28 50 52 45  	defm	"(PRESS SPACE WHEN READY)",CR,0			;529d	28 50 52 45 53 53 20 53 50 41 43 45 20 57 48 45 4e 20 52 45 41 44 59 29 0d 00 	.
3935  52A1 53 53 20 53
3935  52A5 50 41 43 45
3935  52A9 20 57 48 45
3935  52AD 4E 20 52 45
3935  52B1 41 44 59 29
3935  52B5 0D 00
3936  52B7              TXT_INSERTDSTDISK:
3937  52B7 0D 49 4E 53  	defm 	CR,"INSERT DESTINATION DISKETTE",CR,0	;52b7	0d 49 4e 53 45 52 54 20 44 45 53 54 49 4e 41 54 49 4f 4e 20 44 49 53 4b 45 54 54 45 0d 00 	.
3937  52BB 45 52 54 20
3937  52BF 44 45 53 54
3937  52C3 49 4E 41 54
3937  52C7 49 4F 4E 20
3937  52CB 44 49 53 4B
3937  52CF 45 54 54 45
3937  52D3 0D 00
3938  52D5
3939  52D5
3940  52D5
3941  52D5
3942  52D5              ;***************************************************************************************************
3943  52D5              ; DOS Command STATUS
3944  52D5              ; Syntax: STATUS
3945  52D5              ; ------------------
3946  52D5              ; Display free space left on Disk as number of free sectors and free space in kilobytes.
3947  52D5              ; For Example:
3948  52D5              ;  	624 RECORDS FREE
3949  52D5              ;  	78.0K BYTES FREE
3950  52D5              DCmdSTATUS:
3951  52D5 E5           	push hl			;52d5	e5 	.
3952  52D6 F3           	di			;52d6	f3 	.
3953  52D7 CD 41 5F     	call PWRON		; Disk power ON			;52d7	cd 41 5f 	. A _
3954  52DA C5           	push bc			;52da	c5 	.
3955  52DB 01 32 00     	ld bc,50		; bc - number of miliseconds to delay							;52db	01 32 00 	. 2 .
3956  52DE CD BE 5E     	call DLY		; delay 50 ms 								;52de	cd be 5e 	. . ^
3957  52E1 C1           	pop bc			;52e1	c1 	.
3958  52E2 FD 36 12 00  	ld (iy+TRCK),0		;52e2	fd 36 12 00 	. 6 . .
3959  52E6 FD 36 11 0F  	ld (iy+SCTR),15		;52e6	fd 36 11 0f 	. 6 . .
3960  52EA CD 27 5B     	call READ		; Read a sector from disk						;52ea	cd 27 5b 	. ' [
3961  52ED B7           	or a			;52ed	b7 	.
3962  52EE C2 41 42     	jp nz,ERROR		; Error handling routine	;52ee	c2 41 42 	. A B
3963  52F1 CD 52 5F     	call PWROFF		; Disk power OFF		;52f1	cd 52 5f 	. R _
3964  52F4 FD 6E 31     	ld l,(iy+DBFR)		;52f4	fd 6e 31 	. n 1
3965  52F7 FD 66 32     	ld h,(iy+DBFR+1)		;52f7	fd 66 32 	. f 2
3966  52FA 1E 00        	ld e,000h		;52fa	1e 00 	. .
3967  52FC 16 00        	ld d,000h		;52fc	16 00 	. .
3968  52FE 0E 4E        	ld c,04eh		;52fe	0e 4e 	. N
3969  5300              l5300h:
3970  5300 06 08        	ld b,008h		;5300	06 08 	. .
3971  5302              l5302h:
3972  5302 7E           	ld a,(hl)			;5302	7e 	~
3973  5303              l5303h:
3974  5303 CB 0F        	rrc a		;5303	cb 0f 	. .
3975  5305 38 01        	jr c,l5308h		;5305	38 01 	8 .
3976  5307 13           	inc de			;5307	13 	.
3977  5308              l5308h:
3978  5308 10 F9        	djnz l5303h		;5308	10 f9 	. .
3979  530A 23           	inc hl			;530a	23 	#
3980  530B 0D           	dec c			;530b	0d 	.
3981  530C 20 F2        	jr nz,l5300h		;530c	20 f2 	  .
3982  530E 6B           	ld l,e			;530e	6b 	k
3983  530F 62           	ld h,d			;530f	62 	b
3984  5310              l5310h:
3985  5310 E5           	push hl			;5310	e5 	.
3986  5311 CD AF 0F     	call 00fafh		;5311	cd af 0f 	. . .
3987  5314 21 4A 53     	ld hl,MSG_RecordsFree		;5314	21 4a 53 	! J S
3988  5317 CD A7 28     	call SysMsgOut		;5317	cd a7 28 	. . (
3989  531A E1           	pop hl			;531a	e1 	.
3990  531B E5           	push hl			;531b	e5 	.
3991  531C CB 3C        	srl h		;531c	cb 3c 	. <
3992  531E CB 1D        	rr l		;531e	cb 1d 	. .
3993  5320 CB 3C        	srl h		;5320	cb 3c 	. <
3994  5322 CB 1D        	rr l		;5322	cb 1d 	. .
3995  5324 CB 3C        	srl h		;5324	cb 3c 	. <
3996  5326 CB 1D        	rr l		;5326	cb 1d 	. .
3997  5328 CD AF 0F     	call 00fafh		;5328	cd af 0f 	. . .
3998  532B 3E 2E        	ld a,02eh		;532b	3e 2e 	> .
3999  532D CD 2A 03     	call SysPrintChar		;532d	cd 2a 03 	. * .
4000  5330 E1           	pop hl			;5330	e1 	.
4001  5331 3E 07        	ld a,007h		;5331	3e 07 	> .
4002  5333 A5           	and l			;5333	a5 	.
4003  5334 3C           	inc a			;5334	3c 	<
4004  5335 47           	ld b,a			;5335	47 	G
4005  5336 21 83 FF     	ld hl,0ff83h		;5336	21 83 ff 	! . .
4006  5339 11 7D 00     	ld de,0007dh		;5339	11 7d 00 	. } .
4007  533C              l533ch:
4008  533C 19           	add hl,de			;533c	19 	.
4009  533D 10 FD        	djnz l533ch		;533d	10 fd 	. .
4010  533F CD AF 0F     	call 00fafh		;533f	cd af 0f 	. . .
4011  5342 21 59 53     	ld hl,MSG_KBytesFree		;5342	21 59 53 	! Y S
4012  5345 CD A7 28     	call SysMsgOut		;5345	cd a7 28 	. . (
4013  5348 E1           	pop hl			;5348	e1 	.
4014  5349 C9           	ret			;5349	c9 	.
4015  534A
4016  534A              MSG_RecordsFree:
4017  534A 20 52 45 43  	db " RECORDS FREE",CR,0		;534a	20 52 45 43 4f 52 44 53 20 46 52 45 45 0d 00
4017  534E 4F 52 44 53
4017  5352 20 46 52 45
4017  5356 45 0D 00
4018  5359              MSG_KBytesFree:
4019  5359 4B 20 42 59  	db "K BYTES FREE",CR,0		;5359	4b 20 42 59 54 45 53 20 46 52 45 45 0d 00
4019  535D 54 45 53 20
4019  5361 46 52 45 45
4019  5365 0D 00
4020  5367
4021  5367
4022  5367
4023  5367
4024  5367              ;***************************************************************************************************
4025  5367              ; Command string interpreter
4026  5367              ; This subroutine reads the user specified filename and puts into IY+FNAM if the syntax is correct.
4027  5367              ; IN: hl - Input text typed by user enclosed with '"' chars
4028  5367              ;          Text must be terminated with 0 (end of BASIC line) or ':' (end of BASIC statement)
4029  5367              ; OUT: a - Error code
4030  5367              ;     hl - address of next char after filename
4031  5367              ;***************************************************************************************************
4032  5367              CSI:
4033  5367 CD 78 53     	call ParseFilename				; verify syntax and copy filename to DOS Filename Buffer		;5367	cd 78 53 	. x S
4034  536A B7           	or a							; is Error 0? - No Error										;536a	b7 	.
4035  536B C2 41 42     	jp nz,ERROR						; no - jump to Error handling routine -------------------------	;536b	c2 41 42 	. A B
4036  536E              ; -- filename is copied - hl points to next char after filename
4037  536E 7E           	ld a,(hl)						; a - next char in command or BASIC line						;536e	7e 	~
4038  536F B7           	or a							; is it 0? - end of cmd/BASIC line?								;536f	b7 	.
4039  5370 C8           	ret z							; yes - ------------ End of Proc ------------------------------ ;5370	c8 	.
4040  5371              ; -- inside BASIC line ':' char separates statements
4041  5371 FE 3A        	cp ':'							; is it ':' char? - end of BASIC statement?						;5371	fe 3a 	. :
4042  5373 C2 97 19     	jp nz,SysRaiseSyntaxError		; no -  Raise BASIC Syntax Error routine ----------------------	;5373	c2 97 19 	. . .
4043  5376              ; -- correct statement - return with No Error
4044  5376 AF           	xor a							; a - Error Code 00 - No Error									;5376	af 	.
4045  5377 C9           	ret								; ----------------- End of Proc -------------------------------	;5377	c9 	.
4046  5378
4047  5378
4048  5378
4049  5378
4050  5378              ;***************************************************************************************************
4051  5378              ; Parse Filename
4052  5378              ; Verify syntax and copy filename to DOS Filename Buffer
4053  5378              ; IN: iy - DOS base address
4054  5378              ;     hl - filename text enclosed with '"' chars
4055  5378              ; OUT: a - Error code
4056  5378              ParseFilename:
4057  5378              ; -- fill DOS Filename buffer (8 chars) with ' ' char
4058  5378 FD E5        	push iy							; save iy - DOS base address									;5378	fd e5 	. .
4059  537A 06 08        	ld b,8							; filename is 8 chars length 									;537a	06 08 	. .
4060  537C              .next:
4061  537C FD 36 01 20  	ld (iy+FNAM),' '				; store space char into Filename Buffor							;537c	fd 36 01 20 	. 6 .
4062  5380 FD 23        	inc iy							; increment pointer for next char								;5380	fd 23 	. #
4063  5382 10 F8        	djnz .next						; fill all 8 bytes with ' ' char	 							;5382	10 f8 	. .
4064  5384 FD E1        	pop iy							; restore iy - DOS base address									;5384	fd e1 	. .
4065  5386
4066  5386              ; -- skip trailing spaces
4067  5386              .skipSpaces:
4068  5386 7E           	ld a,(hl)						; a - char typed by user										;5386	7e 	~
4069  5387 23           	inc hl							; increment for next char										;5387	23 	#
4070  5388 FE 20        	cp  ' '							; is it space char?												;5388	fe 20 	.
4071  538A 28 FA        	jr z,.skipSpaces				; yes - keep skipping											;538a	28 fa 	( .
4072  538C              ; -- char other than ' '
4073  538C 2B           	dec hl							; point hl to this char (other than ' ')						;538c	2b 	+
4074  538D CF           	rst 8							; verify this char is '"' (double quote) and point hl to next	;538d	cf 	.
4075  538E 22           	defb '"'						; expected char													;538e	22
4076  538F 06 08        	ld b,8							; filename has no more than 8 chars max							;538f	06 08 	" . .
4077  5391              ; -- test if filename is empty - Syntax Error
4078  5391 7E           	ld a,(hl)						; a - next char typed by user									;5391	7e 	~
4079  5392 FE 22        	cp '"'							; is it also '"' (double quote)?								;5392	fe 22 	. "
4080  5394 20 03        	jr nz,.copyChars				; no - copy filename to DOS filename buffer						;5394	20 03 	  .
4081  5396              .exitSyntaxError:
4082  5396 3E 01        	ld a,1							; a - Error Code 01 - SYNTAX ERROR								;5396	3e 01 	> .
4083  5398 C9           	ret								; --------------- End of Proc (with Error 1) ------------------	;5398	c9 	.
4084  5399
4085  5399              .copyChars:
4086  5399              ; -- copy filename (max 8 chars) to DOS Filename Buffer
4087  5399 FD E5        	push iy							; save iy - DOS base address									;5399	fd e5 	. .
4088  539B              .copyNext:
4089  539B 7E           	ld a,(hl)						; a - char of filename typed by user							;539b	7e 	~
4090  539C 23           	inc hl							; point to next char											;539c	23 	#
4091  539D FE 22        	cp '"'							; is it '"' (double quote) char? - end of filename text			;539d	fe 22 	. "
4092  539F 28 14        	jr z,.exitNoErrPopIY			; yes - return with No Error (0) - No Error -------------------	;539f	28 14 	( .
4093  53A1 FD 77 01     	ld (iy+FNAM),a					; store filename char in DOS Filename Buffer					;53a1	fd 77 01 	. w .
4094  53A4 FD 23        	inc iy							; increment for next byte in filename Buffer					;53a4	fd 23 	. #
4095  53A6 10 F3        	djnz .copyNext					; copy next char if the max length (8 char) is not exceeded		;53a6	10 f3 	. .
4096  53A8
4097  53A8              ; -- ignore any following chars until closing '"' char or 0 terminator
4098  53A8 FD E1        	pop iy							; restore iy - DOS base address									;53a8	fd e1 	. .
4099  53AA              .checkNext:
4100  53AA 7E           	ld a,(hl)						; a - char of filename typed by user							;53aa	7e 	~
4101  53AB 23           	inc hl							; point to nextt char											;53ab	23 	#
4102  53AC B7           	or a							; is it 0? - end of text w/o closing '"' char					;53ac	b7 	.
4103  53AD 28 E7        	jr z,.exitSyntaxError			; yes - return with Error 01 - SYNTAX ERROR	-------------------	;53ad	28 e7 	( .
4104  53AF FE 22        	cp '"'							; is it '"' (double quote) closing char?						;53af	fe 22 	. "
4105  53B1 28 04        	jr z,.exitNoError				; yes - return with No Error (0) - No Error -------------------	;53b1	28 04 	( .
4106  53B3 18 F5        	jr .checkNext					; other char - continue skipping chars							;53b3	18 f5 	. .
4107  53B5              .exitNoErrPopIY:
4108  53B5 FD E1        	pop iy							; restore iy - DOS base address									;53b5	fd e1 	. .
4109  53B7              .exitNoError:
4110  53B7 AF           	xor a							; a - Error 00 - No Error										;53b7	af 	.
4111  53B8 C9           	ret								; ------------------ End of Proc ------------------------------	;53b8	c9 	.
4112  53B9
4113  53B9
4114  53B9
4115  53B9              ;*******************************************************************************************************************
4116  53B9              ; Convert ASCII to HEX
4117  53B9              ; This subroutine converts 4 bytes of ASCII pointed to by HL into DE reg pair.
4118  53B9              ; IN: hl - address of 4 ASCII chars
4119  53B9              ; OUT: CY flag - 1 if Error, 0 if no error
4120  53B9              ;      de - converted value (2 bytes/4 nibbles)
4121  53B9              ;	   hl - address of next byte after sequence
4122  53B9              ;*******************************************************************************************************************
4123  53B9              HEX:
4124  53B9 CD C1 53     	call .conv2Chars				; e - converted 2 chars 										;53b9	cd c1 53 	. . S
4125  53BC D8           	ret c							; return if Error												;53bc	d8 	.
4126  53BD 53           	ld d,e							; move converted value to high byte								;53bd	53 	S
4127  53BE C3 C1 53     	jp .conv2Chars					; e - covvert 2 chars and return								;53be	c3 c1 53 	. . S
4128  53C1
4129  53C1              ; -- convert 2 chars into 1 byte with value
4130  53C1              .conv2Chars:
4131  53C1              ; -- take first char and convert it to 4 bit value
4132  53C1 7E           	ld a,(hl)						; a - char to convert											;53c1	7e 	~
4133  53C2 23           	inc hl							; hl - address of next char										;53c2	23 	#
4134  53C3 CD D5 53     	call .conv1Char					; convert char into low 4 bits of a								;53c3	cd d5 53 	. . S
4135  53C6 D8           	ret c							; return if Error												;53c6	d8 	.
4136  53C7              ; -- move 4 bits to high nibble of byte
4137  53C7 17           	rla								; shift bits 3..0 to 7..4										;53c7	17 	.
4138  53C8 17           	rla																								;53c8	17 	.
4139  53C9 17           	rla																								;53c9	17 	.
4140  53CA 17           	rla																								;53ca	17 	.
4141  53CB 5F           	ld e,a							; store converted to e											;53cb	5f 	_
4142  53CC              ; -- take second char and convert it to 4 bit value
4143  53CC 7E           	ld a,(hl)						; a - next char to convert										;53cc	7e 	~
4144  53CD 23           	inc hl							; hl - address of next char										;53cd	23 	#
4145  53CE CD D5 53     	call .conv1Char					; convert char into low 4 bits of a								;53ce	cd d5 53 	. . S
4146  53D1 D8           	ret c							; return if Error												;53d1	d8 	.
4147  53D2              ; -- combine low and high nibbles into 1 byte
4148  53D2 B3           	or e							; add stored bits 7..4 											;53d2	b3 	.
4149  53D3 5F           	ld e,a							; e - 2 chars converted											;53d3	5f 	_
4150  53D4 C9           	ret								; -------------------- End of Proc ----------------------------	;53d4	c9 	.
4151  53D5              .conv1Char:
4152  53D5              ; -- chars '0'..'9'
4153  53D5 FE 30        	cp '0'							; check if less than '0' (illegal char)							;53d5	fe 30 	. 0
4154  53D7 D8           	ret c							; yes - return with Error										;53d7	d8 	.
4155  53D8 FE 3A        	cp '9'+1						; check if greater than '9' - can be 'A'..'F'					;53d8	fe 3a 	. :
4156  53DA 30 03        	jr nc,.tryAtoF					; yes - try 'A'..'F'											;53da	30 03 	0 .
4157  53DC              ; -- chars '0'..'9' contain its numeric value in low nibble
4158  53DC E6 0F        	and %00001111					; mask 4 lower bits -> ('0' becomes 0, '1'->1,etc)				;53dc	e6 0f 	. .
4159  53DE C9           	ret								; -------------------- End of Proc ----------------------------	;53de	c9 	.
4160  53DF              .tryAtoF:
4161  53DF              ; -- chars 'A'..'F'
4162  53DF FE 41        	cp 'A'							; check if less than 'A' (illegal char)							;53df	fe 41 	. A
4163  53E1 D8           	ret c							; yes - return with Error										;53e1	d8 	.
4164  53E2 FE 47        	cp 'F'+1						; check if greater than 'F' (illegal char)						;53e2	fe 47 	. G
4165  53E4 30 02        	jr nc,.exit						; yes - set Carry Flag (error) and return						;53e4	30 02 	0 .
4166  53E6              ; -- chars 'A'..'F' can be convert by substract 'A' (65) and add 10
4167  53E6 C6 C9        	add a,-55						; convert 'A'->10 ($A), 'B'->11 ($B), etc						;53e6	c6 c9 	. .
4168  53E8              ; -- since above operation sets CY flag, below inversion will clear it - No Error
4169  53E8              .exit:
4170  53E8 3F           	ccf								; invert CY flag 												;53e8	3f 	?
4171  53E9 C9           	ret								; -------------------- End of Proc ----------------------------	;53e9	c9 	.
4172  53EA
4173  53EA
4174  53EA
4175  53EA
4176  53EA              ;***************************************************************************************************
4177  53EA              ; Search for identification address mark (IDAM) of the disk
4178  53EA              ; IN: (iy+TRCK) - requested track
4179  53EA              ;     (iy+SCTR)	- requested sector
4180  53EA              ; OUT: a - Error Code (0 - Success)
4181  53EA              ;***************************************************************************************************
4182  53EA              IDAM:
4183  53EA 26 A5        	ld h,165						; set Sector Try Counter - try to find Sector 165 times			;53ea	26 a5 	& .
4184  53EC 2E 0A        	ld l,10							; set Try Counter - try to read 10 times						;53ec	2e 0a 	. .
4185  53EE 18 0B        	jr IDAM_SetTrack				; set requested Track on Drive and start read					;53ee	18 0b 	. .
4186  53F0              ResetTrackTo0:
4187  53F0 2E 0A        	ld l,10							; set Try Counter - try to read 10 times						;53f0	2e 0a 	. .
4188  53F2 FD 36 38 11  	ld (iy+PHASE),%00010001			; reset Step Motor lines to 0001-0001 							;53f2	fd 36 38 11 	. 6 8 .
4189  53F6              ; -- move Head to Track 00
4190  53F6 06 28        	ld b,40							; max 40 tracks to Step Out										;53f6	06 28 	. (
4191  53F8 CD 01 5F     	call STPOUT						; Track step out												;53f8	cd 01 5f 	. . _
4192  53FB
4193  53FB
4194  53FB              ;***************************************************************************************************
4195  53FB              ; Setup Floppy Drive to Read requested Track
4196  53FB              IDAM_SetTrack:
4197  53FB FD 7E 12     	ld a,(iy+TRCK)					; a - requested track number									;53fb	fd 7e 12 	. ~ .
4198  53FE FD 96 14     	sub (iy+DTRCK)					; calculate difference (tracks to step in/out)					;53fe	fd 96 14 	. . .
4199  5401 28 1A        	jr z,IDAM_TrackIsSet			; no difference - track is already set							;5401	28 1a 	( .
4200  5403 F2 11 54     	jp p,IDAM_NeedStepIn			; reqested track is greater - need to Step In 					;5403	f2 11 54 	. . T
4201  5406              ; -- requested track is less than current - need to Step Out
4202  5406 ED 44        	neg								; get positive value of difference								;5406	ed 44 	. D
4203  5408 47           	ld b,a							; b - number of tracks to Step Out								;5408	47 	G
4204  5409 CD 01 5F     	call STPOUT						; move R/W Head on drive to req track							;5409	cd 01 5f 	. . _
4205  540C 18 0F        	jr IDAM_TrackIsSet				; track is set - calculate T+S checksum and start read	 		;540c	18 0f 	. .
4206  540E
4207  540E              IDAM_BreakExit:
4208  540E C3 A4 5E     	jp WaitBreakKeyReleased			; Wait for Break key released									;540e	c3 a4 5e 	. . ^
4209  5411              IDAM_NeedStepIn:
4210  5411              ; -- reqested track is greater than current - need to Step In
4211  5411 47           	ld b,a							; b - number of tracks to Step In								;5411	47 	G
4212  5412 CD CE 5E     	call STPIN						; move R/W Head on drive to req track							;5412	cd ce 5e 	. . ^
4213  5415              ; -- wait delay 100 ms
4214  5415 C5           	push bc							; save bc														;5415	c5 	.
4215  5416 01 64 00     	ld bc,100						; 100 ms to delay												;5416	01 64 00 	. d .
4216  5419 CD BE 5E     	call DLY						; delay 100 ms													;5419	cd be 5e 	. . ^
4217  541C C1           	pop bc							; restore bc													;541c	c1 	.
4218  541D              IDAM_TrackIsSet:
4219  541D 0E 12        	ld c,FLPOOL						; I/O Port address to pool clock		 						;541d	0e 12 	. .
4220  541F              ; -- calculate expected checksum (track number + sector number)
4221  541F FD 7E 12     	ld a,(iy+TRCK)					; a - track number												;541f	fd 7e 12 	. ~ .
4222  5422 FD 86 11     	add a,(iy+SCTR)					; add - sector number											;5422	fd 86 11 	. . .
4223  5425 57           	ld d,a							; d = checksum													;5425	57 	W
4224  5426 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register)				;5426	db 11 	. .
4225  5428              .wait:
4226  5428              ; -- wait for FDC Clock Pulse
4227  5428 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5428	ed 78 	. x
4228  542A F2 28 54     	jp p,.wait						; wait until Clock BIt = 1										;542a	f2 28 54 	. ( T
4229  542D 00           	nop								; spare 16 clock cycles - short delay							;542d	00 	.
4230  542E 00           	nop																								;542e	00 	.
4231  542F 00           	nop																								;542f	00 	.
4232  5430 00           	nop																								;5430	00 	.
4233  5431
4234  5431
4235  5431              ;***************************************************************************************************
4236  5431              ; Find GAP1
4237  5431              ; Read incomming bistream from Floppy Disk until $80 value is found or BREAK key pressed
4238  5431              ; NOTE: In order to read 1 byte from FDC we have to read FLDATA register 8 times (bit by bit)
4239  5431              ;       FLDATA hardware register will be shifted every time we read it.
4240  5431
4241  5431              ; ---------- [1] --- read bits from Disk until $80 received
4242  5431              IDAM_WaitFor80:
4243  5431              ; -- test if BREAK key is pressed
4244  5431 3A DF 68     	ld a,(BreakKeybRow)				; read Keyboard Row with BREAK key								;5431	3a df 68 	: . h
4245  5434 E6 04        	and BreakKeybMask				; mask only BREAK key - if 0 -> key is pressed					;5434	e6 04 	. .
4246  5436 28 D6        	jr z,IDAM_BreakExit				; yes - exit reading											;5436	28 d6 	( .
4247  5438
4248  5438              ; -- read data (bit)
4249  5438 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register)				;5438	db 11 	. .
4250  543A 47           	ld b,a							; b - store byte 												;543a	47 	G
4251  543B              .waitClockBit:
4252  543B              ; -- wait for FDC Clock Pulse
4253  543B ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;543b	ed 78 	. x
4254  543D F2 3B 54     	jp p,.waitClockBit				; wait until Clock BIt = 1										;543d	f2 3b 54 	. ; T
4255  5440              ; -- test if we have $80 received
4256  5440 78           	ld a,b							; byte being received											;5440	78 	x
4257  5441 FE 80        	cp $80							; is this $80 - GAP1 start sequence								;5441	fe 80 	. .
4258  5443 C2 31 54     	jp nz,IDAM_WaitFor80			; no - keep reding until $80 received (or BREAK key pressed)	;5443	c2 31 54 	. 1 T
4259  5446
4260  5446              ; -- we have $80 received - next byte can be:
4261  5446              ; $80 - still GAP1 byte -> keep reading
4262  5446              ; other - end of GAP1 -> go to IDAM sequence read
4263  5446              .readByte:
4264  5446 00           	nop								; delay 4 clock cycles											;5446	00 	.
4265  5447 00           	nop								; delay 4 clock cycles											;5447	00 	.
4266  5448 00           	nop								; delay 4 clock cycles											;5448	00 	.
4267  5449 3E 00        	ld a,0							; delay 7 clock cycles											;5449	3e 00 	> .
4268  544B 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;544b	3e 00 	> .
4269  544D DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;544d	db 11 	. .
4270  544F              .waitClockBit1:
4271  544F              ; -- wait for FDC Clock Pulse
4272  544F ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;544f	ed 78 	. x
4273  5451 F2 4F 54     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5451	f2 4f 54 	. O T
4274  5454 2B           	dec hl							; delay 6 clock cycles											;5454	2b 	+
4275  5455 23           	inc hl							; delay 6 clock cycles											;5455	23 	#
4276  5456 2B           	dec hl							; delay 6 clock cycles											;5456	2b 	+
4277  5457 23           	inc hl							; delay 6 clock cycles											;5457	23 	#
4278  5458 2B           	dec hl							; delay 6 clock cycles											;5458	2b 	+
4279  5459 23           	inc hl							; delay 6 clock cycles											;5459	23 	#
4280  545A 00           	nop								; delay 4 clock cycles											;545a	00 	.
4281  545B 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;545b	3e 00 	> .
4282  545D DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;545d	db 11 	. .
4283  545F              .waitClockBit2:
4284  545F              ; -- wait for FDC Clock Pulse
4285  545F ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;545f	ed 78 	. x
4286  5461 F2 5F 54     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5461	f2 5f 54 	. _ T
4287  5464 2B           	dec hl							; delay 6 clock cycles											;5464	2b 	+
4288  5465 23           	inc hl							; delay 6 clock cycles											;5465	23 	#
4289  5466 2B           	dec hl							; delay 6 clock cycles											;5466	2b 	+
4290  5467 23           	inc hl							; delay 6 clock cycles											;5467	23 	#
4291  5468 2B           	dec hl							; delay 6 clock cycles											;5468	2b 	+
4292  5469 23           	inc hl							; delay 6 clock cycles											;5469	23 	#
4293  546A 00           	nop								; delay 4 clock cycles											;546a	00 	.
4294  546B 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;546b	3e 00 	> .
4295  546D DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;546d	db 11 	. .
4296  546F              .waitClockBit3:
4297  546F              ; -- wait for FDC Clock Pulse
4298  546F ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;546f	ed 78 	. x
4299  5471 F2 6F 54     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5471	f2 6f 54 	. o T
4300  5474 2B           	dec hl							; delay 6 clock cycles											;5474	2b 	+
4301  5475 23           	inc hl							; delay 6 clock cycles											;5475	23 	#
4302  5476 2B           	dec hl							; delay 6 clock cycles											;5476	2b 	+
4303  5477 23           	inc hl							; delay 6 clock cycles											;5477	23 	#
4304  5478 2B           	dec hl							; delay 6 clock cycles											;5478	2b 	+
4305  5479 23           	inc hl							; delay 6 clock cycles											;5479	23 	#
4306  547A 00           	nop								; delay 4 clock cycles											;547a	00 	.
4307  547B 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;547b	3e 00 	> .
4308  547D DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;547d	db 11 	. .
4309  547F              .waitClockBit4:
4310  547F              ; -- wait for FDC Clock Pulse
4311  547F ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;547f	ed 78 	. x
4312  5481 F2 7F 54     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5481	f2 7f 54 	.  T
4313  5484 2B           	dec hl							; delay 6 clock cycles											;5484	2b 	+
4314  5485 23           	inc hl							; delay 6 clock cycles											;5485	23 	#
4315  5486 2B           	dec hl							; delay 6 clock cycles											;5486	2b 	+
4316  5487 23           	inc hl							; delay 6 clock cycles											;5487	23 	#
4317  5488 2B           	dec hl							; delay 6 clock cycles											;5488	2b 	+
4318  5489 23           	inc hl							; delay 6 clock cycles											;5489	23 	#
4319  548A 00           	nop								; delay 6 clock cycles											;548a	00 	.
4320  548B 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;548b	3e 00 	> .
4321  548D DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;548d	db 11 	. .
4322  548F              .waitClockBit5:
4323  548F              ; -- wait for FDC Clock Pulse
4324  548F ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;548f	ed 78 	. x
4325  5491 F2 8F 54     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5491	f2 8f 54 	. . T
4326  5494 2B           	dec hl							; delay 6 clock cycles											;5494	2b 	+
4327  5495 23           	inc hl							; delay 6 clock cycles											;5495	23 	#
4328  5496 2B           	dec hl							; delay 6 clock cycles											;5496	2b 	+
4329  5497 23           	inc hl							; delay 6 clock cycles											;5497	23 	#
4330  5498 2B           	dec hl							; delay 6 clock cycles											;5498	2b 	+
4331  5499 23           	inc hl							; delay 6 clock cycles											;5499	23 	#
4332  549A 00           	nop								; delay 4 clock cycles											;549a	00 	.
4333  549B 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;549b	3e 00 	> .
4334  549D DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;549d	db 11 	. .
4335  549F              .waitClockBit6:
4336  549F              ; -- wait for FDC Clock Pulse
4337  549F ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;549f	ed 78 	. x
4338  54A1 F2 9F 54     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;54a1	f2 9f 54 	. . T
4339  54A4 2B           	dec hl							; delay 6 clock cycles											;54a4	2b 	+
4340  54A5 23           	inc hl							; delay 6 clock cycles											;54a5	23 	#
4341  54A6 2B           	dec hl							; delay 6 clock cycles											;54a6	2b 	+
4342  54A7 23           	inc hl							; delay 6 clock cycles											;54a7	23 	#
4343  54A8 2B           	dec hl							; delay 6 clock cycles											;54a8	2b 	+
4344  54A9 23           	inc hl							; delay 6 clock cycles											;54a9	23 	#
4345  54AA 00           	nop								; delay 4 clock cycles											;54aa	00 	.
4346  54AB 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;54ab	3e 00 	> .
4347  54AD DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;54ad	db 11 	. .
4348  54AF              .waitClockBit7:
4349  54AF              ; -- wait for FDC Clock Pulse
4350  54AF ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;54af	ed 78 	. x
4351  54B1 F2 AF 54     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;54b1	f2 af 54 	. . T
4352  54B4 2B           	dec hl							; delay 6 clock cycles											;54b4	2b 	+
4353  54B5 23           	inc hl							; delay 6 clock cycles											;54b5	23 	#
4354  54B6 2B           	dec hl							; delay 6 clock cycles											;54b6	2b 	+
4355  54B7 23           	inc hl							; delay 6 clock cycles											;54b7	23 	#
4356  54B8 2B           	dec hl							; delay 6 clock cycles											;54b8	2b 	+
4357  54B9 23           	inc hl							; delay 6 clock cycles											;54b9	23 	#
4358  54BA 00           	nop								; delay 4 clock cycles											;54ba	00 	.
4359  54BB 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;54bb	3e 00 	> .
4360  54BD DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;54bd	db 11 	. .
4361  54BF 47           	ld b,a							; store for compare												;54bf	47 	G
4362  54C0              .waitClockBit8:
4363  54C0              ; -- wait for FDC Clock Pulse
4364  54C0 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;54c0	ed 78 	. x
4365  54C2 F2 C0 54     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;54c2	f2 c0 54 	. . T
4366  54C5
4367  54C5
4368  54C5
4369  54C5              ; -- We have 1 byte read - if 80 then still reading GAP1
4370  54C5 78           	ld a,b							; a - byte from Floppy Disk										;54c5	78 	x
4371  54C6 FE 80        	cp $80							; is it still $80 - GAP1 sequence byte?							;54c6	fe 80 	. .
4372  54C8 CA 46 54     	jp z,.readByte					; yes - read next byte from disk								;54c8	ca 46 54 	. F T
4373  54CB
4374  54CB              ; -- byte from disk is NOT $80 (expected 00 but not verified)
4375  54CB
4376  54CB
4377  54CB              ;***************************************************************************************************
4378  54CB              ;
4379  54CB              ; Read IDAM sequence 1st byte - $fe
4380  54CB              ;
4381  54CB
4382  54CB              ; ---------- [2] --- read byte FE - fist in IDAM sequence
4383  54CB
4384  54CB              IDAM_Read_FE:
4385  54CB 00           	nop								; delay 4 clock cycles											;54cb	00 	.
4386  54CC 00           	nop								; delay 4 clock cycles											;54cc	00 	.
4387  54CD 00           	nop								; delay 4 clock cycles											;54cd	00 	.
4388  54CE 3E 00        	ld a,0							; delay 7 clock cycles											;54ce	3e 00 	> .
4389  54D0 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;54d0	3e 00 	> .
4390  54D2 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;54d2	db 11 	. .
4391  54D4              .waitClockBit1:
4392  54D4              ; -- wait for FDC Clock Pulse
4393  54D4 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;54d4	ed 78 	. x
4394  54D6 F2 D4 54     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;54d6	f2 d4 54 	. . T
4395  54D9 2B           	dec hl							; delay 6 clock cycles											;54d9	2b 	+
4396  54DA 23           	inc hl							; delay 6 clock cycles											;54da	23 	#
4397  54DB 2B           	dec hl							; delay 6 clock cycles											;54db	2b 	+
4398  54DC 23           	inc hl							; delay 6 clock cycles											;54dc	23 	#
4399  54DD 2B           	dec hl							; delay 6 clock cycles											;54dd	2b 	+
4400  54DE 23           	inc hl							; delay 6 clock cycles											;54de	23 	#
4401  54DF 00           	nop								; delay 4 clock cycles											;54df	00 	.
4402  54E0 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;54e0	3e 00 	> .
4403  54E2 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;54e2	db 11 	. .
4404  54E4              .waitClockBit2:
4405  54E4              ; -- wait for FDC Clock Pulse
4406  54E4 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;54e4	ed 78 	. x
4407  54E6 F2 E4 54     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;54e6	f2 e4 54 	. . T
4408  54E9 2B           	dec hl							; delay 6 clock cycles											;54e9	2b 	+
4409  54EA 23           	inc hl							; delay 6 clock cycles											;54ea	23 	#
4410  54EB 2B           	dec hl							; delay 6 clock cycles											;54eb	2b 	+
4411  54EC 23           	inc hl							; delay 6 clock cycles											;54ec	23 	#
4412  54ED 2B           	dec hl							; delay 6 clock cycles											;54ed	2b 	+
4413  54EE 23           	inc hl							; delay 6 clock cycles											;54ee	23 	#
4414  54EF 00           	nop								; delay 4 clock cycles											;54ef	00 	.
4415  54F0 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;54f0	3e 00 	> .
4416  54F2 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;54f2	db 11 	. .
4417  54F4              .waitClockBit3:
4418  54F4              ; -- wait for FDC Clock Pulse
4419  54F4 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;54f4	ed 78 	. x
4420  54F6 F2 F4 54     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;54f6	f2 f4 54 	. . T
4421  54F9 2B           	dec hl							; delay 6 clock cycles											;54f9	2b 	+
4422  54FA 23           	inc hl							; delay 6 clock cycles											;54fa	23 	#
4423  54FB 2B           	dec hl							; delay 6 clock cycles											;54fb	2b 	+
4424  54FC 23           	inc hl							; delay 6 clock cycles											;54fc	23 	#
4425  54FD 2B           	dec hl							; delay 6 clock cycles											;54fd	2b 	+
4426  54FE 23           	inc hl							; delay 6 clock cycles											;54fe	23 	#
4427  54FF 00           	nop								; delay 4 clock cycles											;54ff	00 	.
4428  5500 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5500	3e 00 	> .
4429  5502 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5502	db 11 	. .
4430  5504              .waitClockBit4:
4431  5504              ; -- wait for FDC Clock Pulse
4432  5504 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5504	ed 78 	. x
4433  5506 F2 04 55     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5506	f2 04 55 	. . U
4434  5509 2B           	dec hl							; delay 6 clock cycles											;5509	2b 	+
4435  550A 23           	inc hl							; delay 6 clock cycles											;550a	23 	#
4436  550B 2B           	dec hl							; delay 6 clock cycles											;550b	2b 	+
4437  550C 23           	inc hl							; delay 6 clock cycles											;550c	23 	#
4438  550D 2B           	dec hl							; delay 6 clock cycles											;550d	2b 	+
4439  550E 23           	inc hl							; delay 6 clock cycles											;550e	23 	#
4440  550F 00           	nop								; delay 4 clock cycles											;550f	00 	.
4441  5510 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5510	3e 00 	> .
4442  5512 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5512	db 11 	. .
4443  5514              .waitClockBit5:
4444  5514              ; -- wait for FDC Clock Pulse
4445  5514 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5514	ed 78 	. x
4446  5516 F2 14 55     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5516	f2 14 55 	. . U
4447  5519 2B           	dec hl							; delay 6 clock cycles											;5519	2b 	+
4448  551A 23           	inc hl							; delay 6 clock cycles											;551a	23 	#
4449  551B 2B           	dec hl							; delay 6 clock cycles											;551b	2b 	+
4450  551C 23           	inc hl							; delay 6 clock cycles											;551c	23 	#
4451  551D 2B           	dec hl							; delay 6 clock cycles											;551d	2b 	+
4452  551E 23           	inc hl							; delay 6 clock cycles											;551e	23 	#
4453  551F 00           	nop								; delay 4 clock cycles											;551f	00 	.
4454  5520 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5520	3e 00 	> .
4455  5522 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;5522	db 11 	. .
4456  5524              .waitClockBit6:
4457  5524              ; -- wait for FDC Clock Pulse
4458  5524 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5524	ed 78 	. x
4459  5526 F2 24 55     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;5526	f2 24 55 	. $ U
4460  5529 2B           	dec hl							; delay 6 clock cycles											;5529	2b 	+
4461  552A 23           	inc hl							; delay 6 clock cycles											;552a	23 	#
4462  552B 2B           	dec hl							; delay 6 clock cycles											;552b	2b 	+
4463  552C 23           	inc hl							; delay 6 clock cycles											;552c	23 	#
4464  552D 2B           	dec hl							; delay 6 clock cycles											;552d	2b 	+
4465  552E 23           	inc hl							; delay 6 clock cycles											;552e	23 	#
4466  552F 00           	nop								; delay 4 clock cycles											;552f	00 	.
4467  5530 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5530	3e 00 	> .
4468  5532 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;5532	db 11 	. .
4469  5534              .waitClockBit7:
4470  5534              ; -- wait for FDC Clock Pulse
4471  5534 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5534	ed 78 	. x
4472  5536 F2 34 55     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;5536	f2 34 55 	. 4 U
4473  5539 2B           	dec hl							; delay 6 clock cycles											;5539	2b 	+
4474  553A 23           	inc hl							; delay 6 clock cycles											;553a	23 	#
4475  553B 2B           	dec hl							; delay 6 clock cycles											;553b	2b 	+
4476  553C 23           	inc hl							; delay 6 clock cycles											;553c	23 	#
4477  553D 2B           	dec hl							; delay 6 clock cycles											;553d	2b 	+
4478  553E 23           	inc hl							; delay 6 clock cycles											;553e	23 	#
4479  553F 00           	nop								; delay 4 clock cycles											;553f	00 	.
4480  5540 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5540	3e 00 	> .
4481  5542 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;5542	db 11 	. .
4482  5544 47           	ld b,a							; store for compare												;5544	47 	G
4483  5545              .waitClockBit8:
4484  5545              ; -- wait for FDC Clock Pulse
4485  5545 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5545	ed 78 	. x
4486  5547 F2 45 55     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;5547	f2 45 55 	. E U
4487  554A
4488  554A              ; -- We have 1st byte read (expected $fe)
4489  554A 78           	ld a,b							; a - byte from Floppy Disk										;554a	78 	x
4490  554B FE FE        	cp $fe							; is it FE (first byte of IDAM)?								;554b	fe fe 	. .
4491  554D C2 31 54     	jp nz,IDAM_WaitFor80			; no - start over and find byte = $80							;554d	c2 31 54 	. 1 T
4492  5550
4493  5550              ;***************************************************************************************************
4494  5550              ;
4495  5550              ; Read IDAM sequence 2nd byte - $e7
4496  5550              ;
4497  5550
4498  5550              ; ---------- [3] --- read byte E7 - second in IDAM sequence
4499  5550
4500  5550              IDAM_Read_E7:
4501  5550 00           	nop								; delay 4 clock cycles											;5550	00 	.
4502  5551 00           	nop								; delay 4 clock cycles											;5551	00 	.
4503  5552 00           	nop								; delay 4 clock cycles											;5552	00 	.
4504  5553 3E 00        	ld a,0							; delay 7 clock cycles											;5553	3e 00 	> .
4505  5555 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;5555	3e 00 	> .
4506  5557 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5557	db 11 	. .
4507  5559              .waitClockBit1:
4508  5559              ; -- wait for FDC Clock Pulse
4509  5559 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5559	ed 78 	. x
4510  555B F2 59 55     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;555b	f2 59 55 	. Y U
4511  555E 2B           	dec hl							; delay 6 clock cycles											;555e	2b 	+
4512  555F 23           	inc hl							; delay 6 clock cycles											;555f	23 	#
4513  5560 2B           	dec hl							; delay 6 clock cycles											;5560	2b 	+
4514  5561 23           	inc hl							; delay 6 clock cycles											;5561	23 	#
4515  5562 2B           	dec hl							; delay 6 clock cycles											;5562	2b 	+
4516  5563 23           	inc hl							; delay 6 clock cycles											;5563	23 	#
4517  5564 00           	nop								; delay 4 clock cycles											;5564	00 	.
4518  5565 3E 00        	ld a,0							; delay 7 clock cycles (47 in total)							;5565	3e 00 	> .
4519  5567 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;5567	db 11 	. .
4520  5569              .waitClockBit2:
4521  5569              ; -- wait for FDC Clock Pulse
4522  5569 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5569	ed 78 	. x
4523  556B F2 69 55     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;556b	f2 69 55 	. i U
4524  556E 2B           	dec hl							; delay 6 clock cycles											;556e	2b 	+
4525  556F 23           	inc hl							; delay 6 clock cycles											;556f	23 	#
4526  5570 2B           	dec hl							; delay 6 clock cycles											;5570	2b 	+
4527  5571 23           	inc hl							; delay 6 clock cycles											;5571	23 	#
4528  5572 2B           	dec hl							; delay 6 clock cycles											;5572	2b 	+
4529  5573 23           	inc hl							; delay 6 clock cycles											;5573	23 	#
4530  5574 00           	nop								; delay 4 clock cycles											;5574	00 	.
4531  5575 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5575	3e 00 	> .
4532  5577 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5577	db 11 	. .
4533  5579              .waitClockBit3:
4534  5579              ; -- wait for FDC Clock Pulse
4535  5579 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5579	ed 78 	. x
4536  557B F2 79 55     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;557b	f2 79 55 	. y U
4537  557E 2B           	dec hl							; delay 6 clock cycles											;557e	2b 	+
4538  557F 23           	inc hl							; delay 6 clock cycles											;557f	23 	#
4539  5580 2B           	dec hl							; delay 6 clock cycles											;5580	2b 	+
4540  5581 23           	inc hl							; delay 6 clock cycles											;5581	23 	#
4541  5582 2B           	dec hl							; delay 6 clock cycles											;5582	2b 	+
4542  5583 23           	inc hl							; delay 6 clock cycles											;5583	23 	#
4543  5584 00           	nop								; delay 4 clock cycles											;5584	00 	.
4544  5585 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5585	3e 00 	> .
4545  5587 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5587	db 11 	. .
4546  5589              .waitClockBit4:
4547  5589              ; -- wait for FDC Clock Pulse
4548  5589 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5589	ed 78 	. x
4549  558B F2 89 55     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;558b	f2 89 55 	. . U
4550  558E 2B           	dec hl							; delay 6 clock cycles											;558e	2b 	+
4551  558F 23           	inc hl							; delay 6 clock cycles											;558f	23 	#
4552  5590 2B           	dec hl							; delay 6 clock cycles											;5590	2b 	+
4553  5591 23           	inc hl							; delay 6 clock cycles											;5591	23 	#
4554  5592 2B           	dec hl							; delay 6 clock cycles											;5592	2b 	+
4555  5593 23           	inc hl							; delay 6 clock cycles											;5593	23 	#
4556  5594 00           	nop								; delay 4 clock cycles											;5594	00 	.
4557  5595 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5595	3e 00 	> .
4558  5597 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5597	db 11 	. .
4559  5599              .waitClockBit5:
4560  5599              ; -- wait for FDC Clock Pulse
4561  5599 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5599	ed 78 	. x
4562  559B F2 99 55     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;559b	f2 99 55 	. . U
4563  559E 2B           	dec hl							; delay 6 clock cycles											;559e	2b 	+
4564  559F 23           	inc hl							; delay 6 clock cycles											;559f	23 	#
4565  55A0 2B           	dec hl							; delay 6 clock cycles											;55a0	2b 	+
4566  55A1 23           	inc hl							; delay 6 clock cycles											;55a1	23 	#
4567  55A2 2B           	dec hl							; delay 6 clock cycles											;55a2	2b 	+
4568  55A3 23           	inc hl							; delay 6 clock cycles											;55a3	23 	#
4569  55A4 00           	nop								; delay 4 clock cycles											;55a4	00 	.
4570  55A5 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;55a5	3e 00 	> .
4571  55A7 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;55a7	db 11 	. .
4572  55A9              .waitClockBit6:
4573  55A9              ; -- wait for FDC Clock Pulse
4574  55A9 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;55a9	ed 78 	. x
4575  55AB F2 A9 55     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;55ab	f2 a9 55 	. . U
4576  55AE 2B           	dec hl							; delay 6 clock cycles											;55ae	2b 	+
4577  55AF 23           	inc hl							; delay 6 clock cycles											;55af	23 	#
4578  55B0 2B           	dec hl							; delay 6 clock cycles											;55b0	2b 	+
4579  55B1 23           	inc hl							; delay 6 clock cycles											;55b1	23 	#
4580  55B2 2B           	dec hl							; delay 6 clock cycles											;55b2	2b 	+
4581  55B3 23           	inc hl							; delay 6 clock cycles											;55b3	23 	#
4582  55B4 00           	nop								; delay 4 clock cycles											;55b4	00 	.
4583  55B5 3E 00        	ld a,0							; delay 7 clock cycles											;55b5	3e 00 	> .
4584  55B7 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;55b7	db 11 	. .
4585  55B9              .waitClockBit7:
4586  55B9              ; -- wait for FDC Clock Pulse
4587  55B9 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;55b9	ed 78 	. x
4588  55BB F2 B9 55     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;55bb	f2 b9 55 	. . U
4589  55BE 2B           	dec hl							; delay 6 clock cycles											;55be	2b 	+
4590  55BF 23           	inc hl							; delay 6 clock cycles											;55bf	23 	#
4591  55C0 2B           	dec hl							; delay 6 clock cycles											;55c0	2b 	+
4592  55C1 23           	inc hl							; delay 6 clock cycles											;55c1	23 	#
4593  55C2 2B           	dec hl							; delay 6 clock cycles											;55c2	2b 	+
4594  55C3 23           	inc hl							; delay 6 clock cycles											;55c3	23 	#
4595  55C4 00           	nop								; delay 4 clock cycles											;55c4	00 	.
4596  55C5 3E 00        	ld a,0							; delay 7 clock cycles											;55c5	3e 00 	> .
4597  55C7 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;55c7	db 11 	. .
4598  55C9 47           	ld b,a							; store for compare												;55c9	47 	G
4599  55CA              .waitClockBit8:
4600  55CA              ; -- wait for FDC Clock Pulse
4601  55CA ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;55ca	ed 78 	. x
4602  55CC F2 CA 55     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;55cc	f2 ca 55 	. . U
4603  55CF
4604  55CF              ; -- We have 2nd byte read (expected $e7)
4605  55CF 78           	ld a,b							; a - byte from Floppy Disk										;55cf	78 	x
4606  55D0 FE E7        	cp $e7							; is it E7 (second byte of IDAM)?								;55d0	fe e7 	. .
4607  55D2 C2 31 54     	jp nz,IDAM_WaitFor80			; no - start over and find byte = $80							;55d2	c2 31 54 	. 1 T
4608  55D5
4609  55D5
4610  55D5              ;***************************************************************************************************
4611  55D5              ;
4612  55D5              ; Read IDAM sequence 3rd byte - $18
4613  55D5              ;
4614  55D5
4615  55D5              ; ---------- [4] --- read byte 18 - third in IDAM sequence
4616  55D5
4617  55D5              IDAM_Read_18:
4618  55D5 00           	nop								; delay 4 clock cycles											;55d5	00 	.
4619  55D6 00           	nop								; delay 4 clock cycles											;55d6	00 	.
4620  55D7 00           	nop								; delay 4 clock cycles											;55d7	00 	.
4621  55D8 3E 00        	ld a,0							; delay 7 clock cycles											;55d8	3e 00 	> .
4622  55DA 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;55da	3e 00 	> .
4623  55DC DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;55dc	db 11 	. .
4624  55DE              .waitClockBit1:
4625  55DE              ; -- wait for FDC Clock Pulse
4626  55DE ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;55de	ed 78 	. x
4627  55E0 F2 DE 55     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;55e0	f2 de 55 	. . U
4628  55E3 2B           	dec hl							; delay 6 clock cycles											;55e3	2b 	+
4629  55E4 23           	inc hl							; delay 6 clock cycles											;55e4	23 	#
4630  55E5 2B           	dec hl							; delay 6 clock cycles											;55e5	2b 	+
4631  55E6 23           	inc hl							; delay 6 clock cycles											;55e6	23 	#
4632  55E7 2B           	dec hl							; delay 6 clock cycles											;55e7	2b 	+
4633  55E8 23           	inc hl							; delay 6 clock cycles											;55e8	23 	#
4634  55E9 00           	nop								; delay 4 clock cycles											;55e9	00 	.
4635  55EA 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;55ea	3e 00 	> .
4636  55EC DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;55ec	db 11 	. .
4637  55EE              .waitClockBit2:
4638  55EE              ; -- wait for FDC Clock Pulse
4639  55EE ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;55ee	ed 78 	. x
4640  55F0 F2 EE 55     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;55f0	f2 ee 55 	. . U
4641  55F3 2B           	dec hl							; delay 6 clock cycles											;55f3	2b 	+
4642  55F4 23           	inc hl							; delay 6 clock cycles											;55f4	23 	#
4643  55F5 2B           	dec hl							; delay 6 clock cycles											;55f5	2b 	+
4644  55F6 23           	inc hl							; delay 6 clock cycles											;55f6	23 	#
4645  55F7 2B           	dec hl							; delay 6 clock cycles											;55f7	2b 	+
4646  55F8 23           	inc hl							; delay 6 clock cycles											;55f8	23 	#
4647  55F9 00           	nop								; delay 4 clock cycles											;55f9	00 	.
4648  55FA 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;55fa	3e 00 	> .
4649  55FC DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;55fc	db 11 	. .
4650  55FE              .waitClockBit3:
4651  55FE              ; -- wait for FDC Clock Pulse
4652  55FE ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;55fe	ed 78 	. x
4653  5600 F2 FE 55     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5600	f2 fe 55 	. . U
4654  5603 2B           	dec hl							; delay 6 clock cycles											;5603	2b 	+
4655  5604 23           	inc hl							; delay 6 clock cycles											;5604	23 	#
4656  5605 2B           	dec hl							; delay 6 clock cycles											;5605	2b 	+
4657  5606 23           	inc hl							; delay 6 clock cycles											;5606	23 	#
4658  5607 2B           	dec hl							; delay 6 clock cycles											;5607	2b 	+
4659  5608 23           	inc hl							; delay 6 clock cycles											;5608	23 	#
4660  5609 00           	nop								; delay 4 clock cycles											;5609	00 	.
4661  560A 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;560a	3e 00 	> .
4662  560C DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;560c	db 11 	. .
4663  560E              .waitClockBit4:
4664  560E              ; -- wait for FDC Clock Pulse
4665  560E ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;560e	ed 78 	. x
4666  5610 F2 0E 56     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5610	f2 0e 56 	. . V
4667  5613 2B           	dec hl							; delay 6 clock cycles											;5613	2b 	+
4668  5614 23           	inc hl							; delay 6 clock cycles											;5614	23 	#
4669  5615 2B           	dec hl							; delay 6 clock cycles											;5615	2b 	+
4670  5616 23           	inc hl							; delay 6 clock cycles											;5616	23 	#
4671  5617 2B           	dec hl							; delay 6 clock cycles											;5617	2b 	+
4672  5618 23           	inc hl							; delay 6 clock cycles											;5618	23 	#
4673  5619 00           	nop								; delay 4 clock cycles											;5619	00 	.
4674  561A 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;561a	3e 00 	> .
4675  561C DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;561c	db 11 	. .
4676  561E              .waitClockBit5:
4677  561E              ; -- wait for FDC Clock Pulse
4678  561E ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;561e	ed 78 	. x
4679  5620 F2 1E 56     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5620	f2 1e 56 	. . V
4680  5623 2B           	dec hl							; delay 6 clock cycles											;5623	2b 	+
4681  5624 23           	inc hl							; delay 6 clock cycles											;5624	23 	#
4682  5625 2B           	dec hl							; delay 6 clock cycles											;5625	2b 	+
4683  5626 23           	inc hl							; delay 6 clock cycles											;5626	23 	#
4684  5627 2B           	dec hl							; delay 6 clock cycles											;5627	2b 	+
4685  5628 23           	inc hl							; delay 6 clock cycles											;5628	23 	#
4686  5629 00           	nop								; delay 4 clock cycles											;5629	00 	.
4687  562A 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;562a	3e 00 	> .
4688  562C DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;562c	db 11 	. .
4689  562E              .waitClockBit6:
4690  562E              ; -- wait for FDC Clock Pulse
4691  562E ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;562e	ed 78 	. x
4692  5630 F2 2E 56     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;5630	f2 2e 56 	. . V
4693  5633 2B           	dec hl							; delay 6 clock cycles											;5633	2b 	+
4694  5634 23           	inc hl							; delay 6 clock cycles											;5634	23 	#
4695  5635 2B           	dec hl							; delay 6 clock cycles											;5635	2b 	+
4696  5636 23           	inc hl							; delay 6 clock cycles											;5636	23 	#
4697  5637 2B           	dec hl							; delay 6 clock cycles											;5637	2b 	+
4698  5638 23           	inc hl							; delay 6 clock cycles											;5638	23 	#
4699  5639 00           	nop								; delay 4 clock cycles											;5639	00 	.
4700  563A 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;563a	3e 00 	> .
4701  563C DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;563c	db 11 	. .
4702  563E              .waitClockBit7:
4703  563E              ; -- wait for FDC Clock Pulse
4704  563E ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;563e	ed 78 	. x
4705  5640 F2 3E 56     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;5640	f2 3e 56 	. > V
4706  5643 2B           	dec hl							; delay 6 clock cycles											;5643	2b 	+
4707  5644 23           	inc hl							; delay 6 clock cycles											;5644	23 	#
4708  5645 2B           	dec hl							; delay 6 clock cycles											;5645	2b 	+
4709  5646 23           	inc hl							; delay 6 clock cycles											;5646	23 	#
4710  5647 2B           	dec hl							; delay 6 clock cycles											;5647	2b 	+
4711  5648 23           	inc hl							; delay 6 clock cycles											;5648	23 	#
4712  5649 00           	nop								; delay 4 clock cycles											;5649	00 	.
4713  564A 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;564a	3e 00 	> .
4714  564C DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;564c	db 11 	. .
4715  564E 47           	ld b,a							; store for compare												;564e	47 	G
4716  564F              .waitClockBit8:
4717  564F              ; -- wait for FDC Clock Pulse
4718  564F ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;564f	ed 78 	. x
4719  5651 F2 4F 56     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;5651	f2 4f 56 	. O V
4720  5654
4721  5654              ; -- We have 3rd byte read (expected $18)
4722  5654 78           	ld a,b							; a - byte from Floppy Disk										;5654	78 	x
4723  5655 FE 18        	cp $18							; is it 18 (third byte of IDAM)?								;5655	fe 18 	. .
4724  5657 C2 31 54     	jp nz,IDAM_WaitFor80			; no - start over and find byte = $80							;5657	c2 31 54 	. 1 T
4725  565A
4726  565A              ;***************************************************************************************************
4727  565A              ;
4728  565A              ; Read IDAM sequence 4th byte - $c3
4729  565A              ;
4730  565A
4731  565A              ; ---------- [5] --- read byte C3 - forth in IDAM sequence
4732  565A
4733  565A              IDAM_Read_C3:
4734  565A 00           	nop								; delay 4 clock cycles											;565a	00 	.
4735  565B 00           	nop								; delay 4 clock cycles											;565b	00 	.
4736  565C 00           	nop								; delay 4 clock cycles											;565c	00 	.
4737  565D 3E 00        	ld a,0							; delay 7 clock cycles											;565d	3e 00 	> .
4738  565F 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;565f	3e 00 	> .
4739  5661 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5661	db 11 	. .
4740  5663              .waitClockBit1:
4741  5663              ; -- wait for FDC Clock Pulse
4742  5663 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5663	ed 78 	. x
4743  5665 F2 63 56     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5665	f2 63 56 	. c V
4744  5668 2B           	dec hl							; delay 6 clock cycles											;5668	2b 	+
4745  5669 23           	inc hl							; delay 6 clock cycles											;5669	23 	#
4746  566A 2B           	dec hl							; delay 6 clock cycles											;566a	2b 	+
4747  566B 23           	inc hl							; delay 6 clock cycles											;566b	23 	#
4748  566C 2B           	dec hl							; delay 6 clock cycles											;566c	2b 	+
4749  566D 23           	inc hl							; delay 6 clock cycles											;566d	23 	#
4750  566E 00           	nop								; delay 4 clock cycles											;566e	00 	.
4751  566F 3E 00        	ld a,0							; delay 7 clock cycles											;566f	3e 00 	> .
4752  5671 3E 00        	ld a,0							; delay 7 clock cycles	(54 in total)							;5671	3e 00 	> .
4753  5673              .waitClockBit2:
4754  5673              ; [!] Not sure why we are shifting FDC data register so many times while waiting for Clock pulse [!]
4755  5673              ; -- wait for FDC Clock Pulse
4756  5673 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7,6,...]	;5673	db 11 	. .
4757  5675 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5675	ed 78 	. x
4758  5677 F2 73 56     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5677	f2 73 56 	. s V
4759  567A 2B           	dec hl							; delay 6 clock cycles											;567a	2b 	+
4760  567B 23           	inc hl							; delay 6 clock cycles											;567b	23 	#
4761  567C 2B           	dec hl							; delay 6 clock cycles											;567c	2b 	+
4762  567D 23           	inc hl							; delay 6 clock cycles											;567d	23 	#
4763  567E 2B           	dec hl							; delay 6 clock cycles											;567e	2b 	+
4764  567F 23           	inc hl							; delay 6 clock cycles											;567f	23 	#
4765  5680 00           	nop								; delay 4 clock cycles											;5680	00 	.
4766  5681 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5681	3e 00 	> .
4767  5683              .waitClockBit3:
4768  5683              ; -- wait for FDC Clock Pulse
4769  5683              ; [!] Still not sure why we are shifting FDC data register so many times while waiting for Clock pulse [!]
4770  5683 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7,6...]	;5683	db 11 	.
4771  5685 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5685	ed 78 	. x
4772  5687 F2 83 56     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5687	f2 83 56 	. . V
4773  568A 2B           	dec hl							; delay 6 clock cycles											;568a	2b 	+
4774  568B 23           	inc hl							; delay 6 clock cycles											;568b	23 	#
4775  568C 2B           	dec hl							; delay 6 clock cycles											;568c	2b 	+
4776  568D 23           	inc hl							; delay 6 clock cycles											;568d	23 	#
4777  568E 2B           	dec hl							; delay 6 clock cycles											;568e	2b 	+
4778  568F 23           	inc hl							; delay 6 clock cycles											;568f	23 	#
4779  5690 00           	nop								; delay 4 clock cycles	(40 cycles in total)					;5690	00 	.
4780  5691 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5691	db 11 	. .
4781  5693              .waitClockBit4:
4782  5693              ; -- wait for FDC Clock Pulse
4783  5693 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5693	ed 78 	. x
4784  5695 F2 93 56     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5695	f2 93 56 	. . V
4785  5698 2B           	dec hl							; delay 6 clock cycles											;5698	2b 	+
4786  5699 23           	inc hl							; delay 6 clock cycles											;5699	23 	#
4787  569A 2B           	dec hl							; delay 6 clock cycles											;569a	2b 	+
4788  569B 23           	inc hl							; delay 6 clock cycles											;569b	23 	#
4789  569C 2B           	dec hl							; delay 6 clock cycles											;569c	2b 	+
4790  569D 23           	inc hl							; delay 6 clock cycles											;569d	23 	#
4791  569E 00           	nop								; delay 4 clock cycles											;569e	00 	.
4792  569F 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;569f	3e 00 	> .
4793  56A1 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;56a1	db 11 	. .
4794  56A3              .waitClockBit5:
4795  56A3              ; -- wait for FDC Clock Pulse
4796  56A3 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;56a3	ed 78 	. x
4797  56A5 F2 A3 56     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;56a5	f2 a3 56 	. . V
4798  56A8 2B           	dec hl							; delay 6 clock cycles											;56a8	2b 	+
4799  56A9 23           	inc hl							; delay 6 clock cycles											;56a9	23 	#
4800  56AA 2B           	dec hl							; delay 6 clock cycles											;56aa	2b 	+
4801  56AB 23           	inc hl							; delay 6 clock cycles											;56ab	23 	#
4802  56AC 2B           	dec hl							; delay 6 clock cycles											;56ac	2b 	+
4803  56AD 23           	inc hl							; delay 6 clock cycles											;56ad	23 	#
4804  56AE 00           	nop								; delay 4 clock cycles											;56ae	00 	.
4805  56AF 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;56af	3e 00 	> .
4806  56B1 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;56b1	db 11 	. .
4807  56B3              .waitClockBit6:
4808  56B3              ; -- wait for FDC Clock Pulse
4809  56B3 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;56b3	ed 78 	. x
4810  56B5 F2 B3 56     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;56b5	f2 b3 56 	. . V
4811  56B8 2B           	dec hl							; delay 6 clock cycles											;56b8	2b 	+
4812  56B9 23           	inc hl							; delay 6 clock cycles											;56b9	23 	#
4813  56BA 2B           	dec hl							; delay 6 clock cycles											;56ba	2b 	+
4814  56BB 23           	inc hl							; delay 6 clock cycles											;56bb	23 	#
4815  56BC 2B           	dec hl							; delay 6 clock cycles											;56bc	2b 	+
4816  56BD 23           	inc hl							; delay 6 clock cycles											;56bd	23 	#
4817  56BE 00           	nop								; delay 4 clock cycles											;56be	00 	.
4818  56BF 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;56bf	3e 00 	> .
4819  56C1 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;56c1	db 11 	. .
4820  56C3              .waitClockBit7:
4821  56C3              ; -- wait for FDC Clock Pulse
4822  56C3 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;56c3	ed 78 	. x
4823  56C5 F2 C3 56     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;56c5	f2 c3 56 	. . V
4824  56C8 2B           	dec hl							; delay 6 clock cycles											;56c8	2b 	+
4825  56C9 23           	inc hl							; delay 6 clock cycles											;56c9	23 	#
4826  56CA 2B           	dec hl							; delay 6 clock cycles											;56ca	2b 	+
4827  56CB 23           	inc hl							; delay 6 clock cycles											;56cb	23 	#
4828  56CC 2B           	dec hl							; delay 6 clock cycles											;56cc	2b 	+
4829  56CD 23           	inc hl							; delay 6 clock cycles											;56cd	23 	#
4830  56CE 00           	nop								; delay 4 clock cycles											;56ce	00 	.
4831  56CF 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;56cf	3e 00 	> .
4832  56D1 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;56d1	db 11 	. .
4833  56D3 47           	ld b,a							; store for compare												;56d3	47 	G
4834  56D4              .waitClockBit8:
4835  56D4              ; -- wait for FDC Clock Pulse
4836  56D4 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;56d4	ed 78 	. x
4837  56D6 F2 D4 56     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;56d6	f2 d4 56 	. . V
4838  56D9
4839  56D9              ; -- We have 4th byte read (expected $c3)
4840  56D9
4841  56D9 78           	ld a,b							; a - byte from Floppy Disk										;56d9	78 	x
4842  56DA FE C3        	cp $c3							; is it c3 (fourth byte of IDAM)?								;56da	fe c3 	. .
4843  56DC C2 31 54     	jp nz,IDAM_WaitFor80			; no - start over and find byte = $80							;56dc	c2 31 54 	. 1 T
4844  56DF
4845  56DF
4846  56DF              ;***************************************************************************************************
4847  56DF              ;
4848  56DF              ; Read Track Number from IDAM sequence
4849  56DF              ;
4850  56DF
4851  56DF              ; ---------- [6] --- read Track Number
4852  56DF
4853  56DF              IDAM_Read_TrkNo:
4854  56DF 00           	nop								; delay 4 clock cycles											;56df	00 	.
4855  56E0 00           	nop								; delay 4 clock cycles											;56e0	00 	.
4856  56E1 00           	nop								; delay 4 clock cycles											;56e1	00 	.
4857  56E2 3E 00        	ld a,0							; delay 7 clock cycles											;56e2	3e 00 	> .
4858  56E4 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;56e4	3e 00 	> .
4859  56E6 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;56e6	db 11 	. .
4860  56E8              .waitClockBit1:
4861  56E8              ; -- wait for FDC Clock Pulse
4862  56E8 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;56e8	ed 78 	. x
4863  56EA F2 E8 56     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;56ea	f2 e8 56 	. . V
4864  56ED 2B           	dec hl							; delay 6 clock cycles											;56ed	2b 	+
4865  56EE 23           	inc hl							; delay 6 clock cycles											;56ee	23 	#
4866  56EF 2B           	dec hl							; delay 6 clock cycles											;56ef	2b 	+
4867  56F0 23           	inc hl							; delay 6 clock cycles											;56f0	23 	#
4868  56F1 2B           	dec hl							; delay 6 clock cycles											;56f1	2b 	+
4869  56F2 23           	inc hl							; delay 6 clock cycles											;56f2	23 	#
4870  56F3 00           	nop								; delay 4 clock cycles											;56f3	00 	.
4871  56F4 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;56f4	3e 00 	> .
4872  56F6 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;56f6	db 11 	. .
4873  56F8              .waitClockBit2:
4874  56F8              ; -- wait for FDC Clock Pulse
4875  56F8 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;56f8	ed 78 	. x
4876  56FA F2 F8 56     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;56fa	f2 f8 56 	. . V
4877  56FD 2B           	dec hl							; delay 6 clock cycles											;56fd	2b 	+
4878  56FE 23           	inc hl							; delay 6 clock cycles											;56fe	23 	#
4879  56FF 2B           	dec hl							; delay 6 clock cycles											;56ff	2b 	+
4880  5700 23           	inc hl							; delay 6 clock cycles											;5700	23 	#
4881  5701 2B           	dec hl							; delay 6 clock cycles											;5701	2b 	+
4882  5702 23           	inc hl							; delay 6 clock cycles											;5702	23 	#
4883  5703 00           	nop								; delay 4 clock cycles											;5703	00 	.
4884  5704 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5704	3e 00 	> .
4885  5706 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5706	db 11 	. .
4886  5708              .waitClockBit3:
4887  5708              ; -- wait for FDC Clock Pulse
4888  5708 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5708	ed 78 	. x
4889  570A F2 08 57     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;570a	f2 08 57 	. . W
4890  570D 2B           	dec hl							; delay 6 clock cycles											;570d	2b 	+
4891  570E 23           	inc hl							; delay 6 clock cycles											;570e	23 	#
4892  570F 2B           	dec hl							; delay 6 clock cycles											;570f	2b 	+
4893  5710 23           	inc hl							; delay 6 clock cycles											;5710	23 	#
4894  5711 2B           	dec hl							; delay 6 clock cycles											;5711	2b 	+
4895  5712 23           	inc hl							; delay 6 clock cycles											;5712	23 	#
4896  5713 00           	nop								; delay 4 clock cycles											;5713	00 	.
4897  5714 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5714	3e 00 	> .
4898  5716 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5716	db 11 	. .
4899  5718              .waitClockBit4:
4900  5718              ; -- wait for FDC Clock Pulse
4901  5718 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5718	ed 78 	. x
4902  571A F2 18 57     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;571a	f2 18 57 	. . W
4903  571D 2B           	dec hl							; delay 6 clock cycles											;571d	2b 	+
4904  571E 23           	inc hl							; delay 6 clock cycles											;571e	23 	#
4905  571F 2B           	dec hl							; delay 6 clock cycles											;571f	2b 	+
4906  5720 23           	inc hl							; delay 6 clock cycles											;5720	23 	#
4907  5721 2B           	dec hl							; delay 6 clock cycles											;5721	2b 	+
4908  5722 23           	inc hl							; delay 6 clock cycles											;5722	23 	#
4909  5723 00           	nop								; delay 4 clock cycles											;5723	00 	.
4910  5724 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5724	3e 00 	> .
4911  5726 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5726	db 11 	. .
4912  5728              .waitClockBit5:
4913  5728              ; -- wait for FDC Clock Pulse
4914  5728 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5728	ed 78 	. x
4915  572A F2 28 57     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;572a	f2 28 57 	. ( W
4916  572D 2B           	dec hl							; delay 6 clock cycles											;572d	2b 	+
4917  572E 23           	inc hl							; delay 6 clock cycles											;572e	23 	#
4918  572F 2B           	dec hl							; delay 6 clock cycles											;572f	2b 	+
4919  5730 23           	inc hl							; delay 6 clock cycles											;5730	23 	#
4920  5731 2B           	dec hl							; delay 6 clock cycles											;5731	2b 	+
4921  5732 23           	inc hl							; delay 6 clock cycles											;5732	23 	#
4922  5733 00           	nop								; delay 4 clock cycles											;5733	00 	.
4923  5734 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5734	3e 00 	> .
4924  5736 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;5736	db 11 	. .
4925  5738              .waitClockBit6:
4926  5738              ; -- wait for FDC Clock Pulse
4927  5738 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5738	ed 78 	. x
4928  573A F2 38 57     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;573a	f2 38 57 	. 8 W
4929  573D 2B           	dec hl							; delay 6 clock cycles											;573d	2b 	+
4930  573E 23           	inc hl							; delay 6 clock cycles											;573e	23 	#
4931  573F 2B           	dec hl							; delay 6 clock cycles											;573f	2b 	+
4932  5740 23           	inc hl							; delay 6 clock cycles											;5740	23 	#
4933  5741 2B           	dec hl							; delay 6 clock cycles											;5741	2b 	+
4934  5742 23           	inc hl							; delay 6 clock cycles											;5742	23 	#
4935  5743 00           	nop								; delay 4 clock cycles											;5743	00 	.
4936  5744 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5744	3e 00 	> .
4937  5746 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;5746	db 11 	. .
4938  5748              .waitClockBit7:
4939  5748              ; -- wait for FDC Clock Pulse
4940  5748 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5748	ed 78 	. x
4941  574A F2 48 57     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;574a	f2 48 57 	. H W
4942  574D FD 7E 12     	ld a,(iy+TRCK)					; a - requested track number 									;574d	fd 7e 12 	. ~ .
4943  5750 47           	ld b,a							; b - requested track number									;5750	47 	G
4944  5751 00           	nop								; delay 4 clock cycles 											;5751	00 	.
4945  5752 C3 55 57     	jp .continue1					; delay 10 clock cycles											;5752	c3 55 57 	. U W
4946  5755              .continue1:
4947  5755 C3 58 57     	jp .continue2					; delay 10 clock cycles											;5755	c3 58 57 	. X W
4948  5758              .continue2:
4949  5758 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register)  [bit 0]		;5758	db 11 	. .
4950  575A 08           	ex af,af'						; save a (byte from Floppy Disk) in alt register				;575a	08 	.
4951  575B              .waitClockBit8:
4952  575B              ; -- wait for FDC Clock Pulse
4953  575B ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;575b	ed 78 	. x
4954  575D F2 5B 57     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;575d	f2 5b 57 	. [ W
4955  5760
4956  5760              ; -- We have Track number byte read (expected the same as requested)
4957  5760
4958  5760 08           	ex af,af'						; restore a - track number read from disk 						;5760	08 	.
4959  5761 B8           	cp b							; is the same as requested (in IY+TRCK)							;5761	b8 	.
4960  5762 CA 6C 57     	jp z,IDAM_Read_SecNo			; yes - continue to read Sector number 							;5762	ca 6c 57 	. l W
4961  5765
4962  5765              ; -- wrong track number
4963  5765
4964  5765 2D           	dec l							; decrement Try Counter - is it 0?								;5765	2d 	-
4965  5766 C2 FB 53     	jp nz,IDAM_SetTrack				; no - set Track on Drive and start again						;5766	c2 fb 53 	. . S
4966  5769 C3 F0 53     	jp ResetTrackTo0				; yes - no more try - Reset Track to 0 and try 10 times again 	;5769	c3 f0 53 	. . S
4967  576C
4968  576C
4969  576C              ;***************************************************************************************************
4970  576C              ;
4971  576C              ; Read Sector Number from IDAM sequence
4972  576C              ;
4973  576C
4974  576C              ; ---------- [7] --- read Sector Number
4975  576C
4976  576C              IDAM_Read_SecNo:
4977  576C 00           	nop								; delay 4 clock cycles											;576c	00 	.
4978  576D 00           	nop								; delay 4 clock cycles											;576d	00 	.
4979  576E 00           	nop								; delay 4 clock cycles											;576e	00 	.
4980  576F C3 72 57     	jp .continue					; delay 10 clock cycles 										;576f	c3 72 57 	. r W
4981  5772              .continue:
4982  5772 3E 00        	ld a,0							; delay 7 clock cycles											;5772	3e 00 	> .
4983  5774 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5774	db 11 	. .
4984  5776              .waitClockBit1:
4985  5776              ; -- wait for FDC Clock Pulse
4986  5776 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5776	ed 78 	. x
4987  5778 F2 76 57     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5778	f2 76 57 	. v W
4988  577B 2B           	dec hl							; delay 6 clock cycles											;577b	2b 	+
4989  577C 23           	inc hl							; delay 6 clock cycles											;577c	23 	#
4990  577D 2B           	dec hl							; delay 6 clock cycles											;577d	2b 	+
4991  577E 23           	inc hl							; delay 6 clock cycles											;577e	23 	#
4992  577F 2B           	dec hl							; delay 6 clock cycles											;577f	2b 	+
4993  5780 23           	inc hl							; delay 6 clock cycles											;5780	23 	#
4994  5781 00           	nop								; delay 4 clock cycles											;5781	00 	.
4995  5782 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5782	3e 00 	> .
4996  5784 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;5784	db 11 	. .
4997  5786              .waitClockBit2:
4998  5786              ; -- wait for FDC Clock Pulse
4999  5786 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5786	ed 78 	. x
5000  5788 F2 86 57     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5788	f2 86 57 	. . W
5001  578B 2B           	dec hl							; delay 6 clock cycles											;578b	2b 	+
5002  578C 23           	inc hl							; delay 6 clock cycles											;578c	23 	#
5003  578D 2B           	dec hl							; delay 6 clock cycles											;578d	2b 	+
5004  578E 23           	inc hl							; delay 6 clock cycles											;578e	23 	#
5005  578F 2B           	dec hl							; delay 6 clock cycles											;578f	2b 	+
5006  5790 23           	inc hl							; delay 6 clock cycles											;5790	23 	#
5007  5791 00           	nop								; delay 4 clock cycles											;5791	00 	.
5008  5792 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5792	3e 00 	> .
5009  5794 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5794	db 11 	. .
5010  5796              .waitClockBit3:
5011  5796              ; -- wait for FDC Clock Pulse
5012  5796 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5796	ed 78 	. x
5013  5798 F2 96 57     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5798	f2 96 57 	. . W
5014  579B 2B           	dec hl							; delay 6 clock cycles											;579b	2b 	+
5015  579C 23           	inc hl							; delay 6 clock cycles											;579c	23 	#
5016  579D 2B           	dec hl							; delay 6 clock cycles											;579d	2b 	+
5017  579E 23           	inc hl							; delay 6 clock cycles											;579e	23 	#
5018  579F 2B           	dec hl							; delay 6 clock cycles											;579f	2b 	+
5019  57A0 23           	inc hl							; delay 6 clock cycles											;57a0	23 	#
5020  57A1 00           	nop								; delay 4 clock cycles											;57a1	00 	.
5021  57A2 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;57a2	3e 00 	> .
5022  57A4 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;57a4	db 11 	. .
5023  57A6              .waitClockBit4:
5024  57A6              ; -- wait for FDC Clock Pulse
5025  57A6 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;57a6	ed 78 	. x
5026  57A8 F2 A6 57     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;57a8	f2 a6 57 	. . W
5027  57AB 2B           	dec hl							; delay 6 clock cycles											;57ab	2b 	+
5028  57AC 23           	inc hl							; delay 6 clock cycles											;57ac	23 	#
5029  57AD 2B           	dec hl							; delay 6 clock cycles											;57ad	2b 	+
5030  57AE 23           	inc hl							; delay 6 clock cycles											;57ae	23 	#
5031  57AF 2B           	dec hl							; delay 6 clock cycles											;57af	2b 	+
5032  57B0 23           	inc hl							; delay 6 clock cycles											;57b0	23 	#
5033  57B1 00           	nop								; delay 4 clock cycles											;57b1	00 	.
5034  57B2 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;57b2	3e 00 	> .
5035  57B4 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;57b4	db 11 	. .
5036  57B6              .waitClockBit5:
5037  57B6              ; -- wait for FDC Clock Pulse
5038  57B6 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;57b6	ed 78 	. x
5039  57B8 F2 B6 57     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;57b8	f2 b6 57 	. . W
5040  57BB 2B           	dec hl							; delay 6 clock cycles											;57bb	2b 	+
5041  57BC 23           	inc hl							; delay 6 clock cycles											;57bc	23 	#
5042  57BD 2B           	dec hl							; delay 6 clock cycles											;57bd	2b 	+
5043  57BE 23           	inc hl							; delay 6 clock cycles											;57be	23 	#
5044  57BF 2B           	dec hl							; delay 6 clock cycles											;57bf	2b 	+
5045  57C0 23           	inc hl							; delay 6 clock cycles											;57c0	23 	#
5046  57C1 00           	nop								; delay 4 clock cycles											;57c1	00 	.
5047  57C2 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;57c2	3e 00 	> .
5048  57C4 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;57c4	db 11 	. .
5049  57C6              .waitClockBit6:
5050  57C6              ; -- wait for FDC Clock Pulse
5051  57C6 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;57c6	ed 78 	. x
5052  57C8 F2 C6 57     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;57c8	f2 c6 57 	. . W
5053  57CB 2B           	dec hl							; delay 6 clock cycles											;57cb	2b 	+
5054  57CC 23           	inc hl							; delay 6 clock cycles											;57cc	23 	#
5055  57CD 2B           	dec hl							; delay 6 clock cycles											;57cd	2b 	+
5056  57CE 23           	inc hl							; delay 6 clock cycles											;57ce	23 	#
5057  57CF 2B           	dec hl							; delay 6 clock cycles											;57cf	2b 	+
5058  57D0 23           	inc hl							; delay 6 clock cycles											;57d0	23 	#
5059  57D1 00           	nop								; delay 4 clock cycles											;57d1	00 	.
5060  57D2 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;57d2	3e 00 	> .
5061  57D4 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;57d4	db 11 	. .
5062  57D6              .waitClockBit7:
5063  57D6              ; -- wait for FDC Clock Pulse
5064  57D6 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;57d6	ed 78 	. x
5065  57D8 F2 D6 57     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;57d8	f2 d6 57 	. . W
5066  57DB FD 7E 11     	ld a,(iy+SCTR)					; a - requested sector number 									;57db	fd 7e 11 	. ~ .
5067  57DE 47           	ld b,a							; b - requested sector number 									;57de	47 	G
5068  57DF 00           	nop								; delay 4 clock cycles											;57df	00 	.
5069  57E0 C3 E3 57     	jp .continue1					; delay 10 clock cycles											;57e0	c3 e3 57 	. . W
5070  57E3              .continue1:
5071  57E3 C3 E6 57     	jp .continue2					; delay 10 clock cycles											;57e3	c3 e6 57 	. . W
5072  57E6              .continue2:
5073  57E6 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;57e6	db 11 	. .
5074  57E8 08           	ex af,af'						; save a (byte from Floppy Disk) in alt register				;57e8	08 	.
5075  57E9              .waitClockBit8:
5076  57E9              ; -- wait for FDC Clock Pulse
5077  57E9 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;57e9	ed 78 	. x
5078  57EB F2 E9 57     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;57eb	f2 e9 57 	. . W
5079  57EE
5080  57EE              ; -- We have Sector Number byte read (expected the same as requested)
5081  57EE
5082  57EE 08           	ex af,af'						; restore a - Sector Number read from disk 						;57ee	08 	.
5083  57EF B8           	cp b							; is the same as requested (in IY+SCTR)							;57ef	b8 	.
5084  57F0 CA FB 57     	jp z,IDAM_Read_Crc				; yes - continue to read Checksum Byte 							;57f0	ca fb 57 	. . W
5085  57F3
5086  57F3              ; -- wrong Sector Number
5087  57F3
5088  57F3 25           	dec h							; decrement Sector Try Counter - is it 0?						;57f3	25 	%
5089  57F4 C2 31 54     	jp nz,IDAM_WaitFor80			; no - start over and read next sector on this track			;57f4	c2 31 54 	. 1 T
5090  57F7
5091  57F7              ; -- been trying too many times - return with Error
5092  57F7
5093  57F7 3E 09        	ld a,09							; Error code 09 - SECTOR NOT FOUND								;57f7	3e 09 	> .
5094  57F9 B7           	or a							; clear Carry Flag												;57f9	b7 	.
5095  57FA C9           	ret								; -------------- End of proc (with Error) ---------------------	;57fa	c9 	.
5096  57FB
5097  57FB              ;***************************************************************************************************
5098  57FB              ;
5099  57FB              ; Read and verify Checksum for Track and Sector Number
5100  57FB              ;
5101  57FB
5102  57FB              ; ---------- [8] --- read/verify Track+Sector Number CRC
5103  57FB
5104  57FB
5105  57FB              IDAM_Read_Crc:
5106  57FB 00           	nop								; delay 4 clock cycles											;57fb	00 	.
5107  57FC 00           	nop								; delay 4 clock cycles											;57fc	00 	.
5108  57FD 00           	nop								; delay 4 clock cycles											;57fd	00 	.
5109  57FE C3 01 58     	jp .continue1					; delay 10 clock cycles											;57fe	c3 01 58 	. . X
5110  5801              .continue1:
5111  5801 3E 00        	ld a,0							; delay 7 clock cycles	(29 in total)							;5801	3e 00 	> .
5112  5803 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5803	db 11 	. .
5113  5805              .waitClockBit1:
5114  5805              ; -- wait for FDC Clock Pulse
5115  5805 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5805	ed 78 	. x
5116  5807 F2 05 58     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5807	f2 05 58 	. . X
5117  580A 2B           	dec hl							; delay 6 clock cycles											;580a	2b 	+
5118  580B 23           	inc hl							; delay 6 clock cycles											;580b	23 	#
5119  580C 2B           	dec hl							; delay 6 clock cycles											;580c	2b 	+
5120  580D 23           	inc hl							; delay 6 clock cycles											;580d	23 	#
5121  580E 2B           	dec hl							; delay 6 clock cycles											;580e	2b 	+
5122  580F 23           	inc hl							; delay 6 clock cycles											;580f	23 	#
5123  5810 00           	nop								; delay 4 clock cycles											;5810	00 	.
5124  5811 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5811	3e 00 	> .
5125  5813 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;5813	db 11 	. .
5126  5815              .waitClockBit2:
5127  5815              ; -- wait for FDC Clock Pulse
5128  5815 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5815	ed 78 	. x
5129  5817 F2 15 58     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5817	f2 15 58 	. . X
5130  581A 2B           	dec hl							; delay 6 clock cycles											;581a	2b 	+
5131  581B 23           	inc hl							; delay 6 clock cycles											;581b	23 	#
5132  581C 2B           	dec hl							; delay 6 clock cycles											;581c	2b 	+
5133  581D 23           	inc hl							; delay 6 clock cycles											;581d	23 	#
5134  581E 2B           	dec hl							; delay 6 clock cycles											;581e	2b 	+
5135  581F 23           	inc hl							; delay 6 clock cycles											;581f	23 	#
5136  5820 00           	nop								; delay 4 clock cycles											;5820	00 	.
5137  5821 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5821	3e 00 	> .
5138  5823 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5823	db 11 	. .
5139  5825              .waitClockBit3:
5140  5825              ; -- wait for FDC Clock Pulse
5141  5825 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5825	ed 78 	. x
5142  5827 F2 25 58     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5827	f2 25 58 	. % X
5143  582A 2B           	dec hl							; delay 6 clock cycles											;582a	2b 	+
5144  582B 23           	inc hl							; delay 6 clock cycles											;582b	23 	#
5145  582C 2B           	dec hl							; delay 6 clock cycles											;582c	2b 	+
5146  582D 23           	inc hl							; delay 6 clock cycles											;582d	23 	#
5147  582E 2B           	dec hl							; delay 6 clock cycles											;582e	2b 	+
5148  582F 23           	inc hl							; delay 6 clock cycles											;582f	23 	#
5149  5830 00           	nop								; delay 4 clock cycles											;5830	00 	.
5150  5831 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5831	3e 00 	> .
5151  5833 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5833	db 11 	. .
5152  5835              .waitClockBit4:
5153  5835              ; -- wait for FDC Clock Pulse
5154  5835 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5835	ed 78 	. x
5155  5837 F2 35 58     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5837	f2 35 58 	. 5 X
5156  583A 2B           	dec hl							; delay 6 clock cycles											;583a	2b 	+
5157  583B 23           	inc hl							; delay 6 clock cycles											;583b	23 	#
5158  583C 2B           	dec hl							; delay 6 clock cycles											;583c	2b 	+
5159  583D 23           	inc hl							; delay 6 clock cycles											;583d	23 	#
5160  583E 2B           	dec hl							; delay 6 clock cycles											;583e	2b 	+
5161  583F 23           	inc hl							; delay 6 clock cycles											;583f	23 	#
5162  5840 00           	nop								; delay 4 clock cycles											;5840	00 	.
5163  5841 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5841	3e 00 	> .
5164  5843 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5843	db 11 	. .
5165  5845              .waitClockBit5:
5166  5845              ; -- wait for FDC Clock Pulse
5167  5845 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5845	ed 78 	. x
5168  5847 F2 45 58     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5847	f2 45 58 	. E X
5169  584A 2B           	dec hl							; delay 6 clock cycles											;584a	2b 	+
5170  584B 23           	inc hl							; delay 6 clock cycles											;584b	23 	#
5171  584C 2B           	dec hl							; delay 6 clock cycles											;584c	2b 	+
5172  584D 23           	inc hl							; delay 6 clock cycles											;584d	23 	#
5173  584E 2B           	dec hl							; delay 6 clock cycles											;584e	2b 	+
5174  584F 23           	inc hl							; delay 6 clock cycles											;584f	23 	#
5175  5850 00           	nop								; delay 4 clock cycles											;5850	00 	.
5176  5851 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5851	3e 00 	> .
5177  5853 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;5853	db 11 	. .
5178  5855              .waitClockBit6:
5179  5855              ; -- wait for FDC Clock Pulse
5180  5855 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5855	ed 78 	. x
5181  5857 F2 55 58     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;5857	f2 55 58 	. U X
5182  585A 2B           	dec hl							; delay 6 clock cycles											;585a	2b 	+
5183  585B 23           	inc hl							; delay 6 clock cycles											;585b	23 	#
5184  585C 2B           	dec hl							; delay 6 clock cycles											;585c	2b 	+
5185  585D 23           	inc hl							; delay 6 clock cycles											;585d	23 	#
5186  585E 2B           	dec hl							; delay 6 clock cycles											;585e	2b 	+
5187  585F 23           	inc hl							; delay 6 clock cycles											;585f	23 	#
5188  5860 00           	nop								; delay 4 clock cycles											;5860	00 	.
5189  5861 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5861	3e 00 	> .
5190  5863 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;5863	db 11 	. .
5191  5865              .waitClockBit7:
5192  5865              ; -- wait for FDC Clock Pulse
5193  5865 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5865	ed 78 	. x
5194  5867 F2 65 58     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;5867	f2 65 58 	. e X
5195  586A 2B           	dec hl							; delay 6 clock cycles											;586a	2b 	+
5196  586B 23           	inc hl							; delay 6 clock cycles											;586b	23 	#
5197  586C 2B           	dec hl							; delay 6 clock cycles											;586c	2b 	+
5198  586D 23           	inc hl							; delay 6 clock cycles											;586d	23 	#
5199  586E 2B           	dec hl							; delay 6 clock cycles											;586e	2b 	+
5200  586F 23           	inc hl							; delay 6 clock cycles											;586f	23 	#
5201  5870 00           	nop								; delay 4 clock cycles											;5870	00 	.
5202  5871 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5871	3e 00 	> .
5203  5873 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;5873	db 11 	. .
5204  5875
5205  5875              ; -- We have IDAM Crc read (expected the same as calculated before for this track and sector)
5206  5875
5207  5875 BA           	cp d							; is it the same as calculated?									;5875	ba 	.
5208  5876 C2 31 54     	jp nz,IDAM_WaitFor80			; no - start over and read again								;5876	c2 31 54 	. 1 T
5209  5879
5210  5879              ; -- Found requested Sector and Crc is OK - return with Error 00
5211  5879
5212  5879 AF           	xor a							; set Error Code 00 - NO ERROR									;5879	af 	.
5213  587A C9           	ret								; -------------------- End of Proc ----------------------------	;587a	c9 	.
5214  587B
5215  587B
5216  587B
5217  587B
5218  587B
5219  587B              ;***************************************************************************************************
5220  587B              ; Create an entry in the disk directory
5221  587B              ; IN: (iy+FNAM) - name of file to create
5222  587B              ;     (iy+TYPE) - type of file to create ('T','B', etc)
5223  587B              ;     Interrupt disabled
5224  587B              ; OUT: a - Error code
5225  587B              ;     (iy+NTRK) - Track where is 1st sector for data
5226  587B              ;     (iy+NSCT) - 1st sector for data
5227  587B              ;***************************************************************************************************
5228  587B              CREATE:
5229  587B              ; -- check if requested fire already exists
5230  587B CD 13 59     	call SEARCH						; Search for file in Disk Directory 							;587b	cd 13 59 	. . Y
5231  587E FE 0D        	cp 13							; Error 13 - File Not Found?									;587e	fe 0d 	. .
5232  5880 28 02        	jr z,.checkSpace				; yes - continute and check if there is enough space			;5880	28 02 	( .
5233  5882 B7           	or a							; other error? (FILE ALREADY EXISTS, CHECKSUM ERROR, etc)?		;5882	b7 	.
5234  5883 C0           	ret nz							; yes ------------------- End of Proc (with Error) ------------	;5883	c0 	.
5235  5884
5236  5884              .checkSpace:
5237  5884              ; -- check if there is enough space for new Entry in Directory
5238  5884 CD 68 59     	call FIND						; Search empty space in Directory								;5884	cd 68 59 	. h Y
5239  5887 B7           	or a							; was any Error? 												;5887	b7 	.
5240  5888 C0           	ret nz							; yes - ------------ End of Proc (with Error) -----------------	;5888	c0 	.
5241  5889
5242  5889              ; -- hl will point to address in Data Buffer with empty space for new Directory Entry
5243  5889 FD 56 11     	ld d,(iy+SCTR)					; d - Sector Number with empty Directory Entry					;5889	fd 56 11 	. V .
5244  588C D5           	push de							; save de - Sector number										;588c	d5 	.
5245  588D E5           	push hl							; save hl - address in Data Buffer								;588d	e5 	.
5246  588E              ; -- find first not used Sector on Disk
5247  588E CD BF 58     	call MAP						; Search for empty sector in Map and mark it as used (allocate)	;588e	cd bf 58 	. . X
5248  5891 E1           	pop hl							; restore hl - address in Data Buffer of Directory Entry		;5891	e1 	.
5249  5892 D1           	pop de							; restore d - Sector Number with empty Directory Entry			;5892	d1 	.
5250  5893 B7           	or a							; any Sector allocate error? 									;5893	b7 	.
5251  5894 C0           	ret nz							; yes --------------- End of Proc (with Error) ----------------	;5894	c0 	.
5252  5895
5253  5895
5254  5895              ; -- read Sector with empty space for new Directory Entry
5255  5895 FD 72 11     	ld (iy+SCTR),d					; set Sector Number (track is still 0)							;5895	fd 72 11 	. r .
5256  5898 E5           	push hl							; save hl - address in Data Buffer of new Directory Entry		;5898	e5 	.
5257  5899 CD 27 5B     	call READ						; Read a sector from disk into Data Buffer						;5899	cd 27 5b 	. ' [
5258  589C E1           	pop hl							; restore hl - address in Data Buffer of new Directory Entry	;589c	e1 	.
5259  589D B7           	or a							; any Sector Read error? 										;589d	b7 	.
5260  589E C0           	ret nz							; yes --------------- End of Proc (with Error) ----------------	;589e	c0 	.
5261  589F
5262  589F              ; -- create Directory Entry - fill with data
5263  589F EB           	ex de,hl						; de - address in Data Buffer (Entry block)						;589f	eb 	.
5264  58A0              ; -- store File Type
5265  58A0 FD 7E 09     	ld a,(iy+TYPE)					; a - File Type specified by user								;58a0	fd 7e 09 	. ~ .
5266  58A3 12           	ld (de),a						; store as 1st char in Directory Entry							;58a3	12 	.
5267  58A4              ; -- store constant separator char
5268  58A4 13           	inc de							; de - address of separator										;58a4	13 	.
5269  58A5 3E 3A        	ld a,':'						; a - separator char ':'										;58a5	3e 3a 	> :
5270  58A7 12           	ld (de),a						; store as 2nd char in Directory Entry							;58a7	12 	.
5271  58A8              ; -- store filename (8 chars)
5272  58A8 13           	inc de							; de - address of filename area									;58a8	13 	.
5273  58A9 FD E5        	push iy							; iy - DOS base address											;58a9	fd e5 	. .
5274  58AB E1           	pop hl							; hl - DOS base address											;58ab	e1 	.
5275  58AC 23           	inc hl							; hl - points to filename field									;58ac	23 	#
5276  58AD 01 08 00     	ld bc,8							; bc - 8 chars to copy											;58ad	01 08 00 	. . .
5277  58B0 ED B0        	ldir							; copy filename													;58b0	ed b0 	. .
5278  58B2              ; -- store file start Track number
5279  58B2 FD 7E 16     	ld a,(iy+NTRK)					; a - Track number 												;58b2	fd 7e 16 	. ~ .
5280  58B5 12           	ld (de),a						; store as 10th byte in Directory Entry							;58b5	12 	.
5281  58B6              ; -- store file start Sector number
5282  58B6 13           	inc de							; de - address of start Sector number byte						;58b6	13 	.
5283  58B7 FD 7E 15     	ld a,(iy+NSCT)					; a - Sector number												;58b7	fd 7e 15 	. ~ .
5284  58BA 12           	ld (de),a						; store as 11th byte in Directory Entry							;58ba	12 	.
5285  58BB CD A1 59     	call WRITE						; Write back sector with Directory Entries to disk				;58bb	cd a1 59 	. . Y
5286  58BE C9           	ret								; ---------- End of Proc (with Error from WRITESECTOR) --------	;58be	c9 	.
5287  58BF
5288  58BF
5289  58BF
5290  58BF
5291  58BF              ;***************************************************************************************************
5292  58BF              ; Search for an empty sector in the allocation map.
5293  58BF              ;---------------------------------------------------------------------------------------------------
5294  58BF              ; IN: (iy+MAPADR) - address of Disk Map data
5295  58BF              ; OUT: a - Error Code
5296  58BF              ;      hl - address in Disk Map data of byte bitmap for empty sector
5297  58BF              ;      (iy+NSCT) - number of first not used Serctor
5298  58BF              ;      (iy+NTRK) - Track number with first not used Serctor
5299  58BF              ;      Allocated Sector bit is set to 1 in Allocation Map
5300  58BF              ;***************************************************************************************************
5301  58BF              MAP:
5302  58BF              ; -- setup starting point
5303  58BF FD 36 16 01  	ld (iy+NTRK),1					; start search from Track 1										;58bf	fd 36 16 01 	. 6 . .
5304  58C3 FD 36 15 00  	ld (iy+NSCT),0					; start search from Sector 0									;58c3	fd 36 15 00 	. 6 . .
5305  58C7 FD 6E 34     	ld l,(iy+MAPADR)																				;58c7	fd 6e 34 	. n 4
5306  58CA FD 66 35     	ld h,(iy+MAPADR+1)				; hl - address of Disk Map data									;58ca	fd 66 35 	. f 5
5307  58CD 2B           	dec hl							; hl - point to byte just before Disk Map data					;58cd	2b 	+
5308  58CE              .nextMapByte:
5309  58CE 23           	inc hl							; hl - address of Map byte										;58ce	23 	#
5310  58CF 4E           	ld c,(hl)						; c - 8 bit for 8 disk sectors - bit set means sector is used	;58cf	4e 	N
5311  58D0              .checkNextBit:
5312  58D0 CB 09        	rrc c							; Carry flag - least significant bit - is Sector used?			;58d0	cb 09 	. .
5313  58D2 30 2B        	jr nc,.markSectorUsed			; no - mark it as Used and update Disk Map in buffer			;58d2	30 2b 	0 +
5314  58D4
5315  58D4              ; -- current Sector is used - get next sector number
5316  58D4 FD 34 15     	inc (iy+NSCT)					; increment Sector number										;58d4	fd 34 15 	. 4 .
5317  58D7 FD 7E 15     	ld a,(iy+NSCT)					; a - sector number												;58d7	fd 7e 15 	. ~ .
5318  58DA FE 08        	cp 8							; is it 8? - sector marked in next Map Byte						;58da	fe 08 	. .
5319  58DC 20 F2        	jr nz,.checkNextBit				; no - check next bit of current Map Byte						;58dc	20 f2 	  .
5320  58DE
5321  58DE              ; -- 8 sectors checked - get next byte from Disk Map
5322  58DE 23           	inc hl							; hl - address of Map byte										;58de	23 	#
5323  58DF 4E           	ld c,(hl)						; c - 8 bit for 8 disk sectors - bit set means sector is used	;58df	4e 	N
5324  58E0              .checkNextBit1:
5325  58E0 CB 09        	rrc c							; Carry flag - least significant bit - is Sector used?			;58e0	cb 09 	. .
5326  58E2 30 1B        	jr nc,.markSectorUsed			; no - mark it as Used and update Disk Map in buffer			;58e2	30 1b 	0 .
5327  58E4
5328  58E4              ; -- current Sector is used - get next sector number
5329  58E4 FD 34 15     	inc (iy+NSCT)					; increment Sector number										;58e4	fd 34 15 	. 4 .
5330  58E7 FD 7E 15     	ld a,(iy+NSCT)					; a - sector number												;58e7	fd 7e 15 	. ~ .
5331  58EA FE 10        	cp 16							; is it 16? - sector marked in next Map Byte					;58ea	fe 10 	. .
5332  58EC 20 F2        	jr nz,.checkNextBit1			; no - check next bit of current Map Byte						;58ec	20 f2 	  .
5333  58EE
5334  58EE              ; -- 16 sectors checked (whole track) - set sector 0 on next track
5335  58EE FD 36 15 00  	ld (iy+NSCT),0					; set Sector number 0											;58ee	fd 36 15 00 	. 6 . .
5336  58F2 FD 34 16     	inc (iy+NTRK)					; increment Track number										;58f2	fd 34 16 	. 4 .
5337  58F5 FD 7E 16     	ld a,(iy+NTRK)					; a - Track number												;58f5	fd 7e 16 	. ~ .
5338  58F8 FE 28        	cp 40							; is it 40? - all Tracks checked already?						;58f8	fe 28 	. (
5339  58FA 20 D2        	jr nz,.nextMapByte				; no - continue to check all 40 tracks 							;58fa	20 d2 	  .
5340  58FC
5341  58FC              ; -- all sectors on all tracks are used - return Error 07 - DISK FULL
5342  58FC 3E 07        	ld a,7							; a - Error 07 - DISK FULL										;58fc	3e 07 	> .
5343  58FE C9           	ret								; ----------------- End of Proc (with Error) ------------------	;58fe	c9 	.
5344  58FF
5345  58FF              ; -- found 1st empty sector - mark it as used (allocate) and update Disk Map
5346  58FF              .markSectorUsed:
5347  58FF              ; -- update Map Byte
5348  58FF CB 01        	rlc c							; rotate back Map Byte so bit 0 is for current sector 			;58ff	cb 01 	. .
5349  5901 CB C1        	set 0,c							; set current Sector as used									;5901	cb c1 	. .
5350  5903              ; -- restore place and order of bits in Map Byte
5351  5903 FD 7E 15     	ld a,(iy+NSCT)					; a - current Sector number										;5903	fd 7e 15 	. ~ .
5352  5906 E6 07        	and %0111						; a - how many times we rotated Map Byte so far					;5906	e6 07 	. .
5353  5908 3C           	inc a							; pre increment counter											;5908	3c 	<
5354  5909 47           	ld b,a							; b - loop couner for rotate Map Byte back						;5909	47 	G
5355  590A CB 09        	rrc c							; rotate Map Byte to match current Sector						;590a	cb 09 	. .
5356  590C              .rotateBack:
5357  590C CB 01        	rlc c							; rotate Map Byte												;590c	cb 01 	. .
5358  590E 10 FC        	djnz .rotateBack				; continute to rotate Map Byte b times							;590e	10 fc 	. .
5359  5910 71           	ld (hl),c						; store back modified byte to Disk Map memory					;5910	71 	q
5360  5911 AF           	xor a							; a - Error 00 - NO ERROR										;5911	af 	.
5361  5912 C9           	ret								; ---------------------- End of Proc --------------------------	;5912	c9 	.
5362  5913
5363  5913
5364  5913
5365  5913
5366  5913
5367  5913              ;***************************************************************************************************
5368  5913              ; Search for matching of filename from IY+FNAM with that in the disk directory.
5369  5913              ; IN: interrupt disabled
5370  5913              ;     (iy+FNAM) - name of file to find
5371  5913              ; OUT: a - Error code
5372  5913              ; --- in case Error 02 - FILE ALREADY EXISTS ----
5373  5913              ;      de - address of file Track Number (next byte after filename in loaded Directory Entry)
5374  5913              ;      (iy+TYPE+1) - type of file
5375  5913              ;      (iy+SCTR) - Sector Number of directory entry
5376  5913              ;      (iy+TRCK) - Track Number of directory entry
5377  5913              ;      Buffer (iy+DBFR) sector with directory entry
5378  5913              ;***************************************************************************************************
5379  5913              SEARCH:
5380  5913              ; -- setup starting condition: data buffer, track and sector number
5381  5913 FD 6E 31     	ld l,(iy+DBFR)					; hl - address of DOS Data Buffer								;5913	fd 6e 31 	. n 1
5382  5916 FD 66 32     	ld h,(iy+DBFR+1)																				;5916	fd 66 32 	. f 2
5383  5919 FD 36 12 00  	ld (iy+TRCK),0					; search will start from Track Number 0							;5919	fd 36 12 00 	. 6 . .
5384  591D FD 36 11 00  	ld (iy+SCTR),0					; search will start from Sector Number 0						;591d	fd 36 11 00 	. 6 . .
5385  5921
5386  5921              ; -- read Sector from Disk and compare all directory entries
5387  5921              .readNextSector:
5388  5921 CD 27 5B     	call READ						; Read a sector from disk into iy+SectorBuffer					;5921	cd 27 5b 	. ' [
5389  5924 B7           	or a							; was any Error? 												;5924	b7 	.
5390  5925 C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine							;5925	c2 41 42 	. A B
5391  5928
5392  5928              ; -- we have sector with disk directory entries - read Directory Entry
5393  5928 06 08        	ld b,8							; b - 8 Directory Entries in 1 Sector							;5928	06 08 	. .
5394  592A FD 6E 31     	ld l,(iy+DBFR)																					;592a	fd 6e 31 	. n 1
5395  592D FD 66 32     	ld h,(iy+DBFR+1)				; hl - address of Data Buffer with 1st directory entry			;592d	fd 66 32 	. f 2
5396  5930 FD E5        	push iy							; iy - DOS base address											;5930	fd e5 	. .
5397  5932 D1           	pop de							; copy to de register											;5932	d1 	.
5398  5933 13           	inc de							; de + 1 - address of searched filename in DOS base structure	;5933	13 	.
5399  5934              .compareEntry:
5400  5934 7E           	ld a,(hl)						; a - 1st char from disk - fileType								;5934	7e 	~
5401  5935 B7           	or a							; is it 0? - no more directory entries in data					;5935	b7 	.
5402  5936 C8           	ret z							; yes - ------------ End of Proc (No Error) -------------------	;5936	c8 	.
5403  5937
5404  5937              ; -- filetype other than 0
5405  5937 D5           	push de							; save de - address of filename to find (to compare)			;5937	d5 	.
5406  5938 E5           	push hl							; save hl - address in Data Buffer of directory entry			;5938	e5 	.
5407  5939 FE 01        	cp 1							; is filetype = 1 (deleted file entry)							;5939	fe 01 	. .
5408  593B 28 16        	jr z,.nextDirEntry				; yes - get next directory entry								;593b	28 16 	( .
5409  593D              ; -- filetype other than 0 or 1
5410  593D FD 77 0A     	ld (iy+TYPE+1),a				; store filetype in filetype field of DOS structure (2nd byte)	;593d	fd 77 0a 	. w .
5411  5940 23           	inc hl							; skip 1 byte from Data Buffer (that will be ':')				;5940	23 	#
5412  5941 23           	inc hl							; hl - points to filename chars in Data Buffer					;5941	23 	#
5413  5942
5414  5942
5415  5942              ; -- compare if filename from Data Buffer (entry) equals searched fileane
5416  5942 0E 08        	ld c,8							; c - max 8 chars of filename									;5942	0e 08 	. .
5417  5944 EB           	ex de,hl						; de - address in Data Buffer, hl - address in DOS structure	;5944	eb 	.
5418  5945              .compareNextChar:
5419  5945 1A           	ld a,(de)						; a - char of filename to find									;5945	1a 	.
5420  5946 BE           	cp (hl)							; is it equal to char of filename from Disk?					;5946	be 	.
5421  5947 20 0A        	jr nz,.nextDirEntry				; no - skip to next Directory Entry								;5947	20 0a 	  .
5422  5949 23           	inc hl							; yes - point to next char from Disk							;5949	23 	#
5423  594A 13           	inc de							; de - point to next char of filename to find					;594a	13 	.
5424  594B 0D           	dec c							; decrement chars to compare counter - all compared?			;594b	0d 	.
5425  594C 20 F7        	jr nz,.compareNextChar			; no - continute to compare all 8 chars							;594c	20 f7 	  .
5426  594E              ; -- filenames match
5427  594E F1           	pop af							; discard (hl) from Stack Pointer								;594e	f1 	.
5428  594F F1           	pop af							; discard (de) from Stack Pointer								;594f	f1 	.
5429  5950 3E 02        	ld a,2							; a - Error 02 - FILE ALREADY EXISTS							;5950	3e 02 	> .
5430  5952 C9           	ret								; ------------------ End of Proc (with Error 02) --------------	;5952	c9 	.
5431  5953              .nextDirEntry:
5432  5953              ; -- deleted file
5433  5953 E1           	pop hl							; restore hl - address in Data Buffer of directory entry		;5953	e1 	.
5434  5954 11 10 00     	ld de,16						; de - 16 bytes per directory entry 							;5954	11 10 00 	. . .
5435  5957 19           	add hl,de						; hl - point to next entry										;5957	19 	.
5436  5958 D1           	pop de							; restore de - address of filename to find (to compare)			;5958	d1 	.
5437  5959 10 D9        	djnz .compareEntry				; continue to compare all 8 dir entries in this Sector			;5959	10 d9 	. .
5438  595B
5439  595B              ; -- all 8 entries compared - read next Sector
5440  595B FD 34 11     	inc (iy+SCTR)					; increment Sector number (track still 0) to read				;595b	fd 34 11 	. 4 .
5441  595E FD 7E 11     	ld a,(iy+SCTR)					; a - next sector number										;595e	fd 7e 11 	. ~ .
5442  5961 FE 0F        	cp 15							; is it 15? - end of disk directory (only 14 sectors) 			;5961	fe 0f 	. .
5443  5963 20 BC        	jr nz,.readNextSector			; no - continure to search all 14 sectors						;5963	20 bc 	  .
5444  5965
5445  5965              ; -- all 14 sectors scaned
5446  5965 3E 0D        	ld a,13							; a - Error 13 - FILE NOT FOUND									;5965	3e 0d 	> .
5447  5967 C9           	ret								; ------------------ End of Proc (with Error 13) --------------	;5967	c9 	.
5448  5968
5449  5968
5450  5968
5451  5968
5452  5968
5453  5968              ;***************************************************************************************************
5454  5968              ; Search for an empty space in the directory.
5455  5968              ;---------------------------------------------------------------------------------------------------
5456  5968              ; IN: Interrupt disabled.
5457  5968              ; OUT: a - Error Code
5458  5968              ;      hl - address od first empty directory entry (in Data Buffer)
5459  5968              ;      (iy+SCTR) - sector with empty entry (already loaded to Data Buf)
5460  5968              ;      (iy+TRCK) - track where is sector with empty entry (already loaded to Data Buf)
5461  5968              ;***************************************************************************************************
5462  5968              FIND:
5463  5968              ; -- setup starting condition: data buffer, track and sector number
5464  5968 FD 6E 31     	ld l,(iy+DBFR)					; hl - address of DOS Data Buffer								;5968	fd 6e 31 	. n 1
5465  596B FD 66 32     	ld h,(iy+DBFR+1)																				;596b	fd 66 32 	. f 2
5466  596E FD 36 12 00  	ld (iy+TRCK),0					; search will start from Track Number 0							;596e	fd 36 12 00 	. 6 . .
5467  5972 FD 36 11 00  	ld (iy+SCTR),0					; search will start from Sector Number 0						;5972	fd 36 11 00 	. 6 . .
5468  5976
5469  5976              ; -- read Sector from Disk and find first empty place for directory entry
5470  5976              .readNextSector:
5471  5976 CD 27 5B     	call READ						; Read a sector from disk into iy+SectorBuffer					;5976	cd 27 5b 	. ' [
5472  5979 B7           	or a							; was any Error? 												;5979	b7 	.
5473  597A C2 41 42     	jp nz,ERROR						; yes - go to Error handling routine							;597a	c2 41 42 	. A B
5474  597D
5475  597D              ; -- we have sector with disk directory entries - read Directory Entry
5476  597D 06 08        	ld b,8							; b - 8 Directory Entries in one Sector							;597d	06 08 	. .
5477  597F FD 6E 31     	ld l,(iy+DBFR)																					;597f	fd 6e 31 	. n 1
5478  5982 FD 66 32     	ld h,(iy+DBFR+1)				; hl - address of Data Buffer with 1st directory/file entry		;5982	fd 66 32 	. f 2
5479  5985              .checkDirEntry:
5480  5985 7E           	ld a,(hl)						; a - 1st char from disk - fileType								;5985	7e 	~
5481  5986 B7           	or a							; is it 0? - no more directory entries in data					;5986	b7 	.
5482  5987 C8           	ret z							; yes - ------------ End of Proc (No Error) -------------------	;5987	c8 	.
5483  5988
5484  5988              ; -- filetype other than 0
5485  5988 FE 01        	cp 1							; is filetype = 1 (deleted file entry)?							;5988	fe 01 	. .
5486  598A 20 02        	jr nz,.nextDirEntry				; no - get next directory entry									;598a	20 02 	  .
5487  598C              ; -- deleted file entry - we can reuse it - return with No Error
5488  598C AF           	xor a							; a - Error 00 - NO ERROR										;598c	af 	.
5489  598D C9           	ret								; ------------------ End of Proc (No Error) -------------------	;598d	c9 	.
5490  598E
5491  598E              .nextDirEntry:
5492  598E 11 10 00     	ld de,16						; de - 16 bytes per directory entry 							;598e	11 10 00 	. . .
5493  5991 19           	add hl,de						; hl - point to next entry										;5991	19 	.
5494  5992 10 F1        	djnz .checkDirEntry				; continue to check all 8 dir entries in this Sector			;5992	10 f1 	. .
5495  5994
5496  5994              ; -- all 8 entries checked - read next Sector
5497  5994 FD 34 11     	inc (iy+SCTR)					; increment Sector number (track still 0) to read				;5994	fd 34 11 	. 4 .
5498  5997 FD 7E 11     	ld a,(iy+SCTR)					; a - next sector number										;5997	fd 7e 11 	. ~ .
5499  599A FE 0F        	cp 15							; is it 15? - end of disk directory (only 14 sectors) 			;599a	fe 0f 	. .
5500  599C 20 D8        	jr nz,.readNextSector			; no - continure to search all 14 sectors						;599c	20 d8 	  .
5501  599E
5502  599E              ; -- all 14 sectors scaned
5503  599E 3E 03        	ld a,3							; a - Error 03 - DIRECTORY FULL									;599e	3e 03 	> .
5504  59A0 C9           	ret								; ---------------- End of Proc (with Error) -------------------	;59a0	c9 	.
5505  59A1
5506  59A1
5507  59A1
5508  59A1              ;***************************************************************************************************
5509  59A1              ; Write sector to disk.
5510  59A1              ;---------------------------------------------------------------------------------------------------
5511  59A1              ; Write the content of the buffer pointed to by iy+DBFR to the track and sector
5512  59A1              ; specified by user.
5513  59A1              ; IN: (iy+TRCK) - track number
5514  59A1              ;     (iy+SCTR) - sector number
5515  59A1              ;     (iy+DBFR) - address of 128 bytes buffer with data to write
5516  59A1              ; OUT: a - Error code
5517  59A1              ;***************************************************************************************************
5518  59A1              WRITE:
5519  59A1              ; -- calculate CRC
5520  59A1 CD 10 5B     	call CalcSectorCRC				; Calculate Sector Checksum and sore in de register				;59a1	cd 10 5b 	. . [
5521  59A4 D5           	push de							; save de - calculated Checksum of Sector data					;59a4	d5 	.
5522  59A5
5523  59A5              ; -- store Checksum into Sector Buffer
5524  59A5 FD E5        	push iy							; iy - DOS base address											;59a5	fd e5 	. .
5525  59A7 E1           	pop hl							; copy to hl													;59a7	e1 	.
5526  59A8 11 CD 00     	ld de,SectorCRCBuf				; de - offset where CRC to be stored (just after sector data)	;59a8	11 cd 00 	. . .
5527  59AB 19           	add hl,de						; hl - address in Sector Buffer to store Checksum 				;59ab	19 	.
5528  59AC D1           	pop de							; restore de - calculated Checksum of Sector data				;59ac	d1 	.
5529  59AD 73           	ld (hl),e						; store LSB of Checksum											;59ad	73 	s
5530  59AE 23           	inc hl							; hl - points to MSB											;59ae	23 	#
5531  59AF 72           	ld (hl),d						; store MSB of Checksum											;59af	72 	r
5532  59B0
5533  59B0              ; -- find sector to write to and set ready to write data
5534  59B0 FD E5        	push iy							; iy - DOS base address											;59b0	fd e5 	. .
5535  59B2 E1           	pop hl							; copy to hl													;59b2	e1 	.
5536  59B3 11 43 00     	ld de,SectorHeader				; de - offset to Sector Header bytes							;59b3	11 43 00 	. C .
5537  59B6 19           	add hl,de						; hl - address of Sector Header bytes							;59b6	19 	.
5538  59B7 06 8C        	ld b,10+128+2					; 10 bytes GAP2+IDAM, 128 bytes Sector Data, 2 bytes CRC		;59b7	06 8c 	. .
5539  59B9 D9           	exx								; save bc,de,hl to alternate registers							;59b9	d9 	.
5540  59BA CD EA 53     	call IDAM			; Read identification address mark (Disk head on start sector)	;59ba	cd ea 53 	. . S
5541  59BD CA C6 59     	jp z,.setWriteReqActive			; 0 - no error - set Write Request and continue					;59bd	ca c6 59 	. . Y
5542  59C0
5543  59C0              ; -- we have Error - was it canceled by user (pressing Break Key)?
5544  59C0 FE 11        	cp 17							; was it Error 17 - BREAK?										;59c0	fe 11 	. .
5545  59C2 C8           	ret z							; yes -------------- End of Proc (with Error) -----------------	;59c2	c8 	.
5546  59C3
5547  59C3              ; -- other error - return with Error 9 - SECTOR NOT FOUND
5548  59C3 3E 09        	ld a,9							; a - Error 9 - SECTOR NOT FOUND								;59c3	3e 09 	> .
5549  59C5 C9           	ret								; ------------------ End of Proc (with Error) -----------------	;59c5	c9 	.
5550  59C6
5551  59C6
5552  59C6              .setWriteReqActive:
5553  59C6 D9           	exx								; restore bc,de,hl from alternate registers						;59c6	d9 	.
5554  59C7              ; -- set Write Request bit in hardware Floppy Control Register
5555  59C7 FD 56 33     	ld d,(iy+LTHCPY)				; d - last value sent to FLCtrl									;59c7	fd 56 33 	. V 3
5556  59CA CB B2        	res 6,d							; clear bit 6 - Write Request (active)							;59ca	cb b2 	. .
5557  59CC 7A           	ld a,d							; a - new value of Control bits									;59cc	7a 	z
5558  59CD D3 10        	out (FLCTRL),a					; set Write Request Bit to 0 (active)							;59cd	d3 10 	. .
5559  59CF
5560  59CF              ; --------------------------------------------------------------------------------------------------
5561  59CF              ; IN: b - number of bytes to write
5562  59CF              ;     d - backed up value sent to FDC Control Register
5563  59CF              ;     hl - pointer to current byte in Copy Buffer
5564  59CF              WR_WriteByte:
5565  59CF 4E           	ld c,(hl)						; c - byte from buffer to send		 							;59cf	4e 	N
5566  59D0
5567  59D0              ; -- write bit 7 of data byte
5568  59D0 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;59d0	3e 20 	>
5569  59D2 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;59d2	aa 	.
5570  59D3              ; -- set CY flag to bit 7 of data byte
5571  59D3 CB 11        	rl c							; Carry flag = bit 7 of data byte - is it 1?					;59d3	cb 11 	. .
5572  59D5 D2 E3 59     	jp nc,.writeBit7_0				; no - write cell with data bit = 0								;59d5	d2 e3 59 	. . Y
5573  59D8              .writeBit7_1:
5574  59D8              ; -- write cell with bit=1 - 0-1 or 1-0
5575  59D8 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;59d8	d3 10 	. .
5576  59DA EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;59da	ee 20 	.
5577  59DC 57           	ld d,a							; save as last value sent to FLCTRL								;59dc	57 	W
5578  59DD 2B           	dec hl							; delay 6 cycles												;59dd	2b 	+
5579  59DE D3 10        	out (FLCTRL),a					; set Write Data Bit 											;59de	d3 10 	. .
5580  59E0 C3 EE 59     	jp .contBit7					; continue with next bit 6										;59e0	c3 ee 59 	. . Y
5581  59E3              .writeBit7_0:
5582  59E3              ; -- write cell with bit=0 - 0-0 or 1-1
5583  59E3 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;59e3	d3 10 	. .
5584  59E5 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;59e5	ee 00 	. .
5585  59E7 57           	ld d,a							; save as last value sent to FLCTRL								;59e7	57 	W
5586  59E8 2B           	dec hl							; delay 6 cycles												;59e8	2b 	+
5587  59E9 D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;59e9	d3 10 	. .
5588  59EB C3 EE 59     	jp .contBit7					; continue with next bit 6										;59eb	c3 ee 59 	. . Y
5589  59EE              .contBit7:
5590  59EE 23           	inc hl							; delay 6 cycles												;59ee	23 	#
5591  59EF C3 F2 59     	jp .delayBit7					; delay 10 cycles												;59ef	c3 f2 59 	. . Y
5592  59F2              .delayBit7:
5593  59F2 C3 F5 59     	jp .writeBit6Cell				; delay 10 cycles												;59f2	c3 f5 59 	. . Y
5594  59F5
5595  59F5              .writeBit6Cell:
5596  59F5              ; -- write bit 6 of data byte
5597  59F5 DB 12        	in a,(FLPOOL)					; send clock to drive controller								;59f5	db 12 	. .
5598  59F7 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;59f7	3e 20 	>
5599  59F9 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;59f9	aa 	.
5600  59FA              ; -- set CY flag to bit 6 of data byte
5601  59FA CB 11        	rl c							; Carry flag = bit 6 of data byte - is it 1?					;59fa	cb 11 	. .
5602  59FC D2 0A 5A     	jp nc,.writeBit6_0				; no - write cell with data bit = 0								;59fc	d2 0a 5a 	. . Z
5603  59FF              .writeBit6_1:
5604  59FF              ; -- write cell with bit=1 - 0-1 or 1-0
5605  59FF D3 10        	out (FLCTRL),a					; set Write Data Bit 											;59ff	d3 10 	. .
5606  5A01 EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;5a01	ee 20 	.
5607  5A03 57           	ld d,a							; save as last value sent to FLCTRL								;5a03	57 	W
5608  5A04 2B           	dec hl							; delay 6 cycles												;5a04	2b 	+
5609  5A05 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a05	d3 10 	. .
5610  5A07 C3 15 5A     	jp .contBit6					; continue with next bit 5										;5a07	c3 15 5a 	. . Z
5611  5A0A              .writeBit6_0:
5612  5A0A              ; -- write cell with bit=0 - 0-0 or 1-1
5613  5A0A D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a0a	d3 10 	. .
5614  5A0C EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;5a0c	ee 00 	. .
5615  5A0E 57           	ld d,a							; save as last value sent to FLCTRL								;5a0e	57 	W
5616  5A0F 2B           	dec hl							; delay 6 cycles												;5a0f	2b 	+
5617  5A10 D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;5a10	d3 10 	. .
5618  5A12 C3 15 5A     	jp .contBit6					; continue with next bit 5										;5a12	c3 15 5a 	. . Z
5619  5A15              .contBit6:
5620  5A15 23           	inc hl							; delay 6 cycles												;5a15	23 	#
5621  5A16 C3 19 5A     	jp .delayBit6					; delay 10 cycles												;5a16	c3 19 5a 	. . Z
5622  5A19              .delayBit6:
5623  5A19 C3 1C 5A     	jp .writeBit5Cell				; delay 10 cycles												;5a19	c3 1c 5a 	. . Z
5624  5A1C
5625  5A1C              .writeBit5Cell:
5626  5A1C              ; -- write bit 5 of data byte
5627  5A1C DB 12        	in a,(FLPOOL)					; send clock to drive controller								;5a1c	db 12 	. .
5628  5A1E 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;5a1e	3e 20 	>
5629  5A20 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;5a20	aa 	.
5630  5A21              ; -- set CY flag to bit 5 of data byte
5631  5A21 CB 11        	rl c							; Carry flag = bit 5 of data byte - is it 1?					;5a21	cb 11 	. .
5632  5A23 D2 31 5A     	jp nc,.writeBit5_0				; no - write cell with data bit = 0								;5a23	d2 31 5a 	. 1 Z
5633  5A26              .writeBit5_1:
5634  5A26              ; -- write cell with bit=1 - 0-1 or 1-0
5635  5A26 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a26	d3 10 	. .
5636  5A28 EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;5a28	ee 20 	.
5637  5A2A 57           	ld d,a							; save as last value sent to FLCTRL								;5a2a	57 	W
5638  5A2B 2B           	dec hl							; delay 6 cycles												;5a2b	2b 	+
5639  5A2C D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a2c	d3 10 	. .
5640  5A2E C3 3C 5A     	jp .contBit5					; continue with next bit 4										;5a2e	c3 3c 5a 	. < Z
5641  5A31              .writeBit5_0:
5642  5A31              ; -- write cell with bit=0 - 0-0 or 1-1
5643  5A31 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a31	d3 10 	. .
5644  5A33 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;5a33	ee 00 	. .
5645  5A35 57           	ld d,a							; save as last value sent to FLCTRL								;5a35	57 	W
5646  5A36 2B           	dec hl							; delay 6 cycles												;5a36	2b 	+
5647  5A37 D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;5a37	d3 10 	. .
5648  5A39 C3 3C 5A     	jp .contBit5					; continue with next bit 4										;5a39	c3 3c 5a 	. < Z
5649  5A3C              .contBit5:
5650  5A3C 23           	inc hl							; delay 6 cycles												;5a3c	23 	#
5651  5A3D C3 40 5A     	jp .delayBit5					; delay 10 cycles												;5a3d	c3 40 5a 	. @ Z
5652  5A40              .delayBit5:
5653  5A40 C3 43 5A     	jp .writeBit4Cell				; delay 10 cycles												;5a40	c3 43 5a 	. C Z
5654  5A43
5655  5A43              .writeBit4Cell:
5656  5A43              ; -- write bit 4 of data byte
5657  5A43 DB 12        	in a,(FLPOOL)					; send clock to drive controller								;5a43	db 12 	. .
5658  5A45 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;5a45	3e 20 	>
5659  5A47 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;5a47	aa 	.
5660  5A48              ; -- set CY flag to bit 4 of data byte
5661  5A48 CB 11        	rl c							; Carry flag = bit 4 of data byte - is it 1?					;5a48	cb 11 	. .
5662  5A4A D2 58 5A     	jp nc,.writeBit4_0				; no - write cell with data bit = 0								;5a4a	d2 58 5a 	. X Z
5663  5A4D              .writeBit4_1:
5664  5A4D              ; -- write cell with bit=1 - 0-1 or 1-0
5665  5A4D D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a4d	d3 10 	. .
5666  5A4F EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;5a4f	ee 20 	.
5667  5A51 57           	ld d,a							; save as last value sent to FLCTRL								;5a51	57 	W
5668  5A52 2B           	dec hl							; delay 6 cycles												;5a52	2b 	+
5669  5A53 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a53	d3 10 	. .
5670  5A55 C3 63 5A     	jp .contBit4					; continue with next bit 3										;5a55	c3 63 5a 	. c Z
5671  5A58              .writeBit4_0:
5672  5A58              ; -- write cell with bit=0 - 0-0 or 1-1
5673  5A58 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a58	d3 10 	. .
5674  5A5A EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;5a5a	ee 00 	. .
5675  5A5C 57           	ld d,a							; save as last value sent to FLCTRL								;5a5c	57 	W
5676  5A5D 2B           	dec hl							; delay 6 cycles												;5a5d	2b 	+
5677  5A5E D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;5a5e	d3 10 	. .
5678  5A60 C3 63 5A     	jp .contBit4					; continue with next bit 3										;5a60	c3 63 5a 	. c Z
5679  5A63              .contBit4:
5680  5A63 23           	inc hl							; delay 6 cycles												;5a63	23 	#
5681  5A64 C3 67 5A     	jp .delayBit4					; delay 10 cycles												;5a64	c3 67 5a 	. g Z
5682  5A67              .delayBit4:
5683  5A67 C3 6A 5A     	jp .writeBit3Cell				; delay 10 cycles												;5a67	c3 6a 5a 	. j Z
5684  5A6A
5685  5A6A              .writeBit3Cell:
5686  5A6A              ; -- write bit 3 of data byte
5687  5A6A DB 12        	in a,(FLPOOL)					; send clock to drive controller								;5a6a	db 12 	. .
5688  5A6C 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;5a6c	3e 20 	>
5689  5A6E AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;5a6e	aa 	.
5690  5A6F              ; -- set CY flag to bit 3 of data byte
5691  5A6F CB 11        	rl c							; Carry flag = bit 3 of data byte - is it 1?					;5a6f	cb 11 	. .
5692  5A71 D2 7F 5A     	jp nc,.writeBit3_0				; no - write cell with data bit = 0								;5a71	d2 7f 5a 	.  Z
5693  5A74              .writeBit3_1:
5694  5A74              ; -- write cell with bit=1 - 0-1 or 1-0
5695  5A74 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a74	d3 10 	. .
5696  5A76 EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;5a76	ee 20 	.
5697  5A78 57           	ld d,a							; save as last value sent to FLCTRL								;5a78	57 	W
5698  5A79 2B           	dec hl							; delay 6 cycles												;5a79	2b 	+
5699  5A7A D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a7a	d3 10 	. .
5700  5A7C C3 8A 5A     	jp .contBit3					; continue with next bit 2										;5a7c	c3 8a 5a 	. . Z
5701  5A7F              .writeBit3_0:
5702  5A7F              ; -- write cell with bit=0 - 0-0 or 1-1
5703  5A7F D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a7f	d3 10 	. .
5704  5A81 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;5a81	ee 00 	. .
5705  5A83 57           	ld d,a							; save as last value sent to FLCTRL								;5a83	57 	W
5706  5A84 2B           	dec hl							; delay 6 cycles												;5a84	2b 	+
5707  5A85 D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;5a85	d3 10 	. .
5708  5A87 C3 8A 5A     	jp .contBit3					; continue with next bit 2										;5a87	c3 8a 5a 	. . Z
5709  5A8A              .contBit3:
5710  5A8A 23           	inc hl							; delay 6 cycles												;5a8a	23 	#
5711  5A8B C3 8E 5A     	jp .delayBit3					; delay 10 cycles												;5a8b	c3 8e 5a 	. . Z
5712  5A8E              .delayBit3:
5713  5A8E C3 91 5A     	jp .writeBit2Cell				; delay 10 cycles												;5a8e	c3 91 5a 	. . Z
5714  5A91
5715  5A91              .writeBit2Cell:
5716  5A91              ; -- write bit 2 of data byte
5717  5A91 DB 12        	in a,(FLPOOL)					; send clock to drive controller								;5a91	db 12 	. .
5718  5A93 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;5a93	3e 20 	>
5719  5A95 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;5a95	aa 	.
5720  5A96              ; -- set CY flag to bit 2 of data byte
5721  5A96 CB 11        	rl c							; Carry flag = bit 2 of data byte - is it 1?					;5a96	cb 11 	. .
5722  5A98 D2 A6 5A     	jp nc,.writeBit2_0				; no - write cell with data bit = 0								;5a98	d2 a6 5a 	. . Z
5723  5A9B              .writeBit2_1:
5724  5A9B              ; -- write cell with bit=1 - 0-1 or 1-0
5725  5A9B D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5a9b	d3 10 	. .
5726  5A9D EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;5a9d	ee 20 	.
5727  5A9F 57           	ld d,a							; save as last value sent to FLCTRL								;5a9f	57 	W
5728  5AA0 2B           	dec hl							; delay 6 cycles												;5aa0	2b 	+
5729  5AA1 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5aa1	d3 10 	. .
5730  5AA3 C3 B1 5A     	jp .contBit2					; continue with next bit 1										;5aa3	c3 b1 5a 	. . Z
5731  5AA6              .writeBit2_0:
5732  5AA6              ; -- write cell with bit=0 - 0-0 or 1-1
5733  5AA6 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5aa6	d3 10 	. .
5734  5AA8 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;5aa8	ee 00 	. .
5735  5AAA 57           	ld d,a							; save as last value sent to FLCTRL								;5aaa	57 	W
5736  5AAB 2B           	dec hl							; delay 6 cycles												;5aab	2b 	+
5737  5AAC D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;5aac	d3 10 	. .
5738  5AAE C3 B1 5A     	jp .contBit2					; continue with next bit 1										;5aae	c3 b1 5a 	. . Z
5739  5AB1              .contBit2:
5740  5AB1 23           	inc hl							; delay 6 cycles												;5ab1	23 	#
5741  5AB2 C3 B5 5A     	jp .delayBit2					; delay 10 cycles												;5ab2	c3 b5 5a 	. . Z
5742  5AB5              .delayBit2:
5743  5AB5 C3 B8 5A     	jp .writeBit1Cell				; delay 10 cycles												;5ab5	c3 b8 5a 	. . Z
5744  5AB8
5745  5AB8              .writeBit1Cell:
5746  5AB8              ; -- write bit 1 of data byte
5747  5AB8 DB 12        	in a,(FLPOOL)					; send clock to drive controller								;5ab8	db 12 	. .
5748  5ABA 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;5aba	3e 20 	>
5749  5ABC AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;5abc	aa 	.
5750  5ABD              ; -- set CY flag to bit 1 of data byte
5751  5ABD CB 11        	rl c							; Carry flag = bit 1 of data byte - is it 1?					;5abd	cb 11 	. .
5752  5ABF D2 CD 5A     	jp nc,.writeBit1_0				; no - write cell with data bit = 0								;5abf	d2 cd 5a 	. . Z
5753  5AC2              .writeBit1_1:
5754  5AC2              ; -- write cell with bit=1 - 0-1 or 1-0
5755  5AC2 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5ac2	d3 10 	. .
5756  5AC4 EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;5ac4	ee 20 	.
5757  5AC6 57           	ld d,a							; save as last value sent to FLCTRL								;5ac6	57 	W
5758  5AC7 2B           	dec hl							; delay 6 cycles												;5ac7	2b 	+
5759  5AC8 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5ac8	d3 10 	. .
5760  5ACA C3 D8 5A     	jp .contBit1					; continue with next bit 0										;5aca	c3 d8 5a 	. . Z
5761  5ACD              .writeBit1_0:
5762  5ACD              ; -- write cell with bit=0 - 0-0 or 1-1
5763  5ACD D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5acd	d3 10 	. .
5764  5ACF EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;5acf	ee 00 	. .
5765  5AD1 57           	ld d,a							; save as last value sent to FLCTRL								;5ad1	57 	W
5766  5AD2 2B           	dec hl							; delay 6 cycles												;5ad2	2b 	+
5767  5AD3 D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;5ad3	d3 10 	. .
5768  5AD5 C3 D8 5A     	jp .contBit1					; continue with next bit 0										;5ad5	c3 d8 5a 	. . Z
5769  5AD8              .contBit1:
5770  5AD8 23           	inc hl							; delay 6 cycles												;5ad8	23 	#
5771  5AD9 C3 DC 5A     	jp .delayBit1					; delay 10 cycles												;5ad9	c3 dc 5a 	. . Z
5772  5ADC              .delayBit1:
5773  5ADC C3 DF 5A     	jp .writeBit0Cell				; delay 10 cycles												;5adc	c3 df 5a 	. . Z
5774  5ADF
5775  5ADF              .writeBit0Cell:
5776  5ADF              ; -- write bit 0 of data byte
5777  5ADF DB 12        	in a,(FLPOOL)					; send clock to drive controller								;5adf	db 12 	. .
5778  5AE1 3E 20        	ld a,FL_WRITE_DATA				; bit 5 (Write Data) to toggle 									;5ae1	3e 20 	>
5779  5AE3 AA           	xor d							; invert last sent Write Data Bit (0->1 or 1>0)					;5ae3	aa 	.
5780  5AE4              ; -- set CY flag to bit 0 of data byte
5781  5AE4 CB 11        	rl c							; Carry flag = bit 0 of data byte - is it 1?					;5ae4	cb 11 	. .
5782  5AE6 D2 F4 5A     	jp nc,.writeBit0_0				; no - write cell with data bit = 0								;5ae6	d2 f4 5a 	. . Z
5783  5AE9              .writeBit0_1:
5784  5AE9              ; -- write cell with bit=1 - 0-1 or 1-0
5785  5AE9 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5ae9	d3 10 	. .
5786  5AEB EE 20        	xor FL_WRITE_DATA				; toggle bit 5 (Write Data 0->1 or 1->0)						;5aeb	ee 20 	.
5787  5AED 57           	ld d,a							; save as last value sent to FLCTRL								;5aed	57 	W
5788  5AEE 2B           	dec hl							; delay 6 cycles												;5aee	2b 	+
5789  5AEF D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5aef	d3 10 	. .
5790  5AF1 C3 FF 5A     	jp .nextByte					; continue with next byte										;5af1	c3 ff 5a 	. . Z
5791  5AF4              .writeBit0_0:
5792  5AF4              ; -- write cell with bit=0 - 0-0 or 1-1
5793  5AF4 D3 10        	out (FLCTRL),a					; set Write Data Bit 											;5af4	d3 10 	. .
5794  5AF6 EE 00        	xor %00000000					; no change of Write Data Bit (0->0) (delay 7 cycles)			;5af6	ee 00 	. .
5795  5AF8 57           	ld d,a							; save as last value sent to FLCTRL								;5af8	57 	W
5796  5AF9 2B           	dec hl							; delay 6 cycles												;5af9	2b 	+
5797  5AFA D3 10        	out (FLCTRL),a					; set Write Data Bit (unchanged)								;5afa	d3 10 	. .
5798  5AFC C3 FF 5A     	jp .nextByte					; continue with next byte										;5afc	c3 ff 5a 	. . Z
5799  5AFF
5800  5AFF              .nextByte:
5801  5AFF 23           	inc hl							; hl was decremented previously									;5aff	23 	#
5802  5B00 23           	inc hl							; hl - address of next byte in buffer							;5b00	23 	#
5803  5B01 00           	nop								; delay 4 cycles												;5b01	00 	.
5804  5B02 05           	dec b							; decrement bytes-to-send counter								;5b02	05 	.
5805  5B03 C2 CF 59     	jp nz,WR_WriteByte				; continue to write all 140 bytes do Disk						;5b03	c2 cf 59 	. . Y
5806  5B06
5807  5B06              ; -- reset Wriite Request bit and update FLCtrl shadow
5808  5B06 CB F2        	set 6,d							; set bit 6 - Write Request (inactive)							;5b06	cb f2 	. .
5809  5B08 7A           	ld a,d							; a - new value of FDC Conntrol Register						;5b08	7a 	z
5810  5B09 D3 10        	out (FLCTRL),a					; set Flopy Control byte										;5b09	d3 10 	. .
5811  5B0B FD 77 33     	ld (iy+LTHCPY),a				; store FLCtrl to shadow register								;5b0b	fd 77 33 	. w 3
5812  5B0E
5813  5B0E              ; -- return with No Error
5814  5B0E AF           	xor a							; a - Error 0 - NO ERROR										;5b0e	af 	.
5815  5B0F C9           	ret								; ------------------- End of Proc -----------------------------	;5b0f	c9 	.
5816  5B10
5817  5B10
5818  5B10              ;***************************************************************************************************
5819  5B10              ; Calculate Sector Checksum and sore in de register
5820  5B10              ; It is a 16bit sum of 128 bytes stored in Sector Buffer
5821  5B10              ; IN: (iy+SectorBuffer) - 128 bytes of data
5822  5B10              ; OUT: de - calculated checksum
5823  5B10              CalcSectorCRC:
5824  5B10              ; -- setup address of data to calculate checksum
5825  5B10 FD E5        	push iy							; iy - DOS base address											;5b10	fd e5 	. .
5826  5B12 E1           	pop hl							; copy to hl register											;5b12	e1 	.
5827  5B13 11 4D 00     	ld de,SectorBuffer				; de offset from DOS base to Buffer with Sector data			;5b13	11 4d 00 	. M .
5828  5B16 19           	add hl,de						; hl - address of first byte in Sector Buffer					;5b16	19 	.
5829  5B17              ; -- just get first byte - no point to add it to 0
5830  5B17 5E           	ld e,(hl)						; e - low byte of checksum of first byte						;5b17	5e 	^
5831  5B18 16 00        	ld d,$00						; de - checksum of first byte									;5b18	16 00 	. .
5832  5B1A 06 7F        	ld b,128-1						; number of bytes to add to checksum (1 added already)			;5b1a	06 7f 	. 
5833  5B1C              .addNext:
5834  5B1C 23           	inc hl							; hl - points to next byte in Sector Buffer						;5b1c	23 	#
5835  5B1D              ; -- 16 bit addition of de and byte
5836  5B1D 7B           	ld a,e							; a - low byte of checksum										;5b1d	7b 	{
5837  5B1E 86           	add a,(hl)						; add byte from buffer											;5b1e	86 	.
5838  5B1F 5F           	ld e,a							; store back to e register										;5b1f	5f 	_
5839  5B20 3E 00        	ld a,0							; a - high byte to add											;5b20	3e 00 	> .
5840  5B22 8A           	adc a,d							; add Carry flag from adding low bytes							;5b22	8a 	.
5841  5B23 57           	ld d,a							; de - checksum new value										;5b23	57 	W
5842  5B24 10 F6        	djnz .addNext					; continue until 127 bytes added								;5b24	10 f6 	. .
5843  5B26 C9           	ret								; ----------------------- End of Proc -------------------------	;5b26	c9 	.
5844  5B27
5845  5B27
5846  5B27
5847  5B27
5848  5B27              ;***************************************************************************************************
5849  5B27              ; Read sector from disk
5850  5B27              ;---------------------------------------------------------------------------------------------------
5851  5B27              ; Read the content of specified Sector on specified Track into DOS Data Buffer
5852  5B27              ; IN: (iy+TRCK) - Track number to read
5853  5B27              ;     (iy+SCTR) - Sector number to read
5854  5B27              ;	  (iy+DBFR) - address of 128 byte buffer to store sector
5855  5B27              ;     interrupt disabled
5856  5B27              ; OUT: a - Error Code
5857  5B27              ;***************************************************************************************************
5858  5B27              READ:
5859  5B27              ; -- set number of tries
5860  5B27 FD 36 13 0A  	ld (iy+RETRY),10				; try to read sector max 10 times								;5b27	fd 36 13 0a 	. 6 . .
5861  5B2B              RD_StartRead:
5862  5B2B CD EA 53     	call IDAM						; find and Read IDAM header for requested Sector				;5b2b	cd ea 53 	. . S
5863  5B2E CA 37 5B     	jp z,.sectorFound				; if 0 (No Error) continue to read Sector Data					;5b2e	ca 37 5b 	. 7 [
5864  5B31
5865  5B31              ; -- can't find or read specified Sector
5866  5B31 FE 11        	cp 17							; was it BREAK error (canceled by user)?						;5b31	fe 11 	. .
5867  5B33 C8           	ret z							; yes -------------- End of Proc (with Error 17) --------------	;5b33	c8 	.
5868  5B34              ; -- other error - return with SECTOR NOT FOUND Error
5869  5B34 3E 09        	ld a,9							; a - Error 09 - SECTOR NOT FOUND								;5b34	3e 09 	> .
5870  5B36 C9           	ret								; ------------------ End of Proc (with Error 09) --------------	;5b36	c9 	.
5871  5B37
5872  5B37
5873  5B37              .sectorFound:
5874  5B37              ; -- set destination address to store Sector data of destination
5875  5B37 FD E5        	push iy							; iy - DOS base address											;5b37	fd e5 	. .
5876  5B39 E1           	pop hl							; copy to hl 													;5b39	e1 	.
5877  5B3A 11 4C 00     	ld de,SectorBuffer-1			; add offset from DOS base to Sector Buffer -1					;5b3a	11 4c 00 	. L .
5878  5B3D 19           	add hl,de						; hl - points to byte just before Sector Buffer memory			;5b3d	19 	.
5879  5B3E              ; -- set number of bytes to read - 128 bytes Sector data, 2 bytes Data Checksum, 1 - ???
5880  5B3E 1E 83        	ld e,128+3						; e - number of bytes to read from Disk (128 + 2 + 1)			;5b3e	1e 83 	. .
5881  5B40 18 03        	jr RD_ReadyRead					; wait for Clock Bit and synchronize to byte 80					;5b40	18 03 	. .
5882  5B42
5883  5B42              RD_BreakExit:
5884  5B42 C3 A4 5E     	jp WaitBreakKeyReleased			; Wait for Break key released									;5b42	c3 a4 5e 	. . ^
5885  5B45
5886  5B45              RD_ReadyRead:
5887  5B45 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5b45	db 11 	. .
5888  5B47              .waitClockBit:
5889  5B47 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5b47	ed 78 	. x
5890  5B49 F2 47 5B     	jp p,.waitClockBit				; wait until Clock BIt = 1										;5b49	f2 47 5b 	. G [
5891  5B4C 00           	nop								; delay 4 clock cycles											;5b4c	00 	.
5892  5B4D 00           	nop								; delay 4 clock cycles											;5b4d	00 	.
5893  5B4E 00           	nop								; delay 4 clock cycles											;5b4e	00 	.
5894  5B4F 00           	nop								; delay 4 clock cycles											;5b4f	00 	.
5895  5B50
5896  5B50
5897  5B50              ;***************************************************************************************************
5898  5B50              ; Find GAP2
5899  5B50              ; Read incomming bistream from Floppy Disk until $80 value is found or BREAK key pressed
5900  5B50              ; NOTE: In order to read 1 byte from FDC we have to read FLDATA register 8 times (bit by bit)
5901  5B50              ;       FLDATA hardware register will be shifted every time we read it.
5902  5B50
5903  5B50              ; ---------- [1] --- read bits from Disk until $80 received
5904  5B50
5905  5B50              RD_WaitFor80:
5906  5B50              ; -- test if BREAK key is pressed
5907  5B50 3A DF 68     	ld a,(BreakKeybRow)				; read Keyboard Row with BREAK key								;5b50	3a df 68 	: . h
5908  5B53 E6 04        	and BreakKeybMask				; mask only BREAK key - if 0 -> key is pressed					;5b53	e6 04 	. .
5909  5B55 28 EB        	jr z,RD_BreakExit				; yes - exit reading											;5b55	28 eb 	( .
5910  5B57
5911  5B57              ; -- read data (bit)
5912  5B57 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register)				;5b57	db 11 	. .
5913  5B59 47           	ld b,a							; b - store byte 												;5b59	47 	G
5914  5B5A              .waitClockBit:
5915  5B5A              ; -- wait for FDC Clock Pulse
5916  5B5A ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5b5a	ed 78 	. x
5917  5B5C F2 5A 5B     	jp p,.waitClockBit				; wait until Clock BIt = 1										;5b5c	f2 5a 5b 	. Z [
5918  5B5F              ; -- test if we have $80 received
5919  5B5F 78           	ld a,b							; byte being received											;5b5f	78 	x
5920  5B60 FE 80        	cp $80							; is this $80 - GAP2 start sequence								;5b60	fe 80 	. .
5921  5B62 C2 50 5B     	jp nz,RD_WaitFor80				; no - keep reding until $80 received (or BREAK key pressed)	;5b62	c2 50 5b 	. P [
5922  5B65
5923  5B65              ; -- we have $80 received - next byte can be:
5924  5B65              ; $80 - still GAP2 byte -> keep reading
5925  5B65              ; other - end of GAP1 -> go to IDAM (ending) sequence read
5926  5B65              .readByte:
5927  5B65 00           	nop								; delay 4 clock cycles											;5b65	00 	.
5928  5B66 00           	nop								; delay 4 clock cycles											;5b66	00 	.
5929  5B67 00           	nop								; delay 4 clock cycles											;5b67	00 	.
5930  5B68 3E 00        	ld a,0							; delay 7 clock cycles											;5b68	3e 00 	> .
5931  5B6A 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;5b6a	3e 00 	> .
5932  5B6C DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5b6c	db 11 	. .
5933  5B6E              .waitClockBit1:
5934  5B6E              ; -- wait for FDC Clock Pulse
5935  5B6E ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5b6e	ed 78 	. x
5936  5B70 F2 6E 5B     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5b70	f2 6e 5b 	. n [
5937  5B73 2B           	dec hl							; delay 6 clock cycles											;5b73	2b 	+
5938  5B74 23           	inc hl							; delay 6 clock cycles											;5b74	23 	#
5939  5B75 2B           	dec hl							; delay 6 clock cycles											;5b75	2b 	+
5940  5B76 23           	inc hl							; delay 6 clock cycles											;5b76	23 	#
5941  5B77 2B           	dec hl							; delay 6 clock cycles											;5b77	2b 	+
5942  5B78 23           	inc hl							; delay 6 clock cycles											;5b78	23 	#
5943  5B79 00           	nop								; delay 4 clock cycles											;5b79	00 	.
5944  5B7A 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5b7a	3e 00 	> .
5945  5B7C DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;5b7c	db 11 	. .
5946  5B7E              .waitClockBit2:
5947  5B7E              ; -- wait for FDC Clock Pulse
5948  5B7E ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5b7e	ed 78 	. x
5949  5B80 F2 7E 5B     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5b80	f2 7e 5b 	. ~ [
5950  5B83 2B           	dec hl							; delay 6 clock cycles											;5b83	2b 	+
5951  5B84 23           	inc hl							; delay 6 clock cycles											;5b84	23 	#
5952  5B85 2B           	dec hl							; delay 6 clock cycles											;5b85	2b 	+
5953  5B86 23           	inc hl							; delay 6 clock cycles											;5b86	23 	#
5954  5B87 2B           	dec hl							; delay 6 clock cycles											;5b87	2b 	+
5955  5B88 23           	inc hl							; delay 6 clock cycles											;5b88	23 	#
5956  5B89 00           	nop								; delay 4 clock cycles											;5b89	00 	.
5957  5B8A 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5b8a	3e 00 	> .
5958  5B8C DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5b8c	db 11 	. .
5959  5B8E              .waitClockBit3:
5960  5B8E              ; -- wait for FDC Clock Pulse
5961  5B8E ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5b8e	ed 78 	. x
5962  5B90 F2 8E 5B     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5b90	f2 8e 5b 	. . [
5963  5B93 2B           	dec hl							; delay 6 clock cycles											;5b93	2b 	+
5964  5B94 23           	inc hl							; delay 6 clock cycles											;5b94	23 	#
5965  5B95 2B           	dec hl							; delay 6 clock cycles											;5b95	2b 	+
5966  5B96 23           	inc hl							; delay 6 clock cycles											;5b96	23 	#
5967  5B97 2B           	dec hl							; delay 6 clock cycles											;5b97	2b 	+
5968  5B98 23           	inc hl							; delay 6 clock cycles											;5b98	23 	#
5969  5B99 00           	nop								; delay 4 clock cycles											;5b99	00 	.
5970  5B9A 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5b9a	3e 00 	> .
5971  5B9C DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5b9c	db 11 	. .
5972  5B9E              .waitClockBit4:
5973  5B9E              ; -- wait for FDC Clock Pulse
5974  5B9E ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5b9e	ed 78 	. x
5975  5BA0 F2 9E 5B     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5ba0	f2 9e 5b 	. . [
5976  5BA3 2B           	dec hl							; delay 6 clock cycles											;5ba3	2b 	+
5977  5BA4 23           	inc hl							; delay 6 clock cycles											;5ba4	23 	#
5978  5BA5 2B           	dec hl							; delay 6 clock cycles											;5ba5	2b 	+
5979  5BA6 23           	inc hl							; delay 6 clock cycles											;5ba6	23 	#
5980  5BA7 2B           	dec hl							; delay 6 clock cycles											;5ba7	2b 	+
5981  5BA8 23           	inc hl							; delay 6 clock cycles											;5ba8	23 	#
5982  5BA9 00           	nop								; delay 4 clock cycles											;5ba9	00 	.
5983  5BAA 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5baa	3e 00 	> .
5984  5BAC DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5bac	db 11 	. .
5985  5BAE              .waitClockBit5:
5986  5BAE              ; -- wait for FDC Clock Pulse
5987  5BAE ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5bae	ed 78 	. x
5988  5BB0 F2 AE 5B     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5bb0	f2 ae 5b 	. . [
5989  5BB3 2B           	dec hl							; delay 6 clock cycles											;5bb3	2b 	+
5990  5BB4 23           	inc hl							; delay 6 clock cycles											;5bb4	23 	#
5991  5BB5 2B           	dec hl							; delay 6 clock cycles											;5bb5	2b 	+
5992  5BB6 23           	inc hl							; delay 6 clock cycles											;5bb6	23 	#
5993  5BB7 2B           	dec hl							; delay 6 clock cycles											;5bb7	2b 	+
5994  5BB8 23           	inc hl							; delay 6 clock cycles											;5bb8	23 	#
5995  5BB9 00           	nop								; delay 4 clock cycles											;5bb9	00 	.
5996  5BBA 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5bba	3e 00 	> .
5997  5BBC DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;5bbc	db 11 	. .
5998  5BBE              .waitClockBit6:
5999  5BBE              ; -- wait for FDC Clock Pulse
6000  5BBE ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5bbe	ed 78 	. x
6001  5BC0 F2 BE 5B     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;5bc0	f2 be 5b 	. . [
6002  5BC3 2B           	dec hl							; delay 6 clock cycles											;5bc3	2b 	+
6003  5BC4 23           	inc hl							; delay 6 clock cycles											;5bc4	23 	#
6004  5BC5 2B           	dec hl							; delay 6 clock cycles											;5bc5	2b 	+
6005  5BC6 23           	inc hl							; delay 6 clock cycles											;5bc6	23 	#
6006  5BC7 2B           	dec hl							; delay 6 clock cycles											;5bc7	2b 	+
6007  5BC8 23           	inc hl							; delay 6 clock cycles											;5bc8	23 	#
6008  5BC9 00           	nop								; delay 4 clock cycles											;5bc9	00 	.
6009  5BCA 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5bca	3e 00 	> .
6010  5BCC DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;5bcc	db 11 	. .
6011  5BCE              .waitClockBit7:
6012  5BCE              ; -- wait for FDC Clock Pulse
6013  5BCE ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5bce	ed 78 	. x
6014  5BD0 F2 CE 5B     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;5bd0	f2 ce 5b 	. . [
6015  5BD3 2B           	dec hl							; delay 6 clock cycles											;5bd3	2b 	+
6016  5BD4 23           	inc hl							; delay 6 clock cycles											;5bd4	23 	#
6017  5BD5 2B           	dec hl							; delay 6 clock cycles											;5bd5	2b 	+
6018  5BD6 23           	inc hl							; delay 6 clock cycles											;5bd6	23 	#
6019  5BD7 2B           	dec hl							; delay 6 clock cycles											;5bd7	2b 	+
6020  5BD8 23           	inc hl							; delay 6 clock cycles											;5bd8	23 	#
6021  5BD9 00           	nop								; delay 4 clock cycles											;5bd9	00 	.
6022  5BDA 3E 00        	ld a,0							; delay 7 clock cycles	(47 in totoal)							;5bda	3e 00 	> .
6023  5BDC DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;5bdc	db 11 	. .
6024  5BDE 47           	ld b,a							; store for compare												;5bde	47 	G
6025  5BDF              .waitClockBit8:
6026  5BDF              ; -- wait for FDC Clock Pulse
6027  5BDF ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5bdf	ed 78 	. x
6028  5BE1 F2 DF 5B     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;5be1	f2 df 5b 	. . [
6029  5BE4
6030  5BE4
6031  5BE4              ; -- We have 1 byte read - if 80 then still reading GAP2
6032  5BE4 78           	ld a,b							; a - byte from Floppy Disk										;5be4	78 	x
6033  5BE5 FE 80        	cp $80							; is it still $80 - GAP2 sequence byte?							;5be5	fe 80 	. .
6034  5BE7 CA 65 5B     	jp z,.readByte					; yes - read next byte from disk								;5be7	ca 65 5b 	. e [
6035  5BEA
6036  5BEA              ; -- byte from disk is NOT $80 (expected 00 but not verified)
6037  5BEA
6038  5BEA
6039  5BEA
6040  5BEA              ;***************************************************************************************************
6041  5BEA              ;
6042  5BEA              ; Read IDAM (ending) sequence 1st byte - $c3
6043  5BEA              ;
6044  5BEA
6045  5BEA              ; ---------- [2] --- read byte C3 - fist in IDAM (ending) sequence
6046  5BEA
6047  5BEA              RD_IDAM_C3:
6048  5BEA 00           	nop								; delay 4 clock cycles											;5bea	00 	.
6049  5BEB 00           	nop								; delay 4 clock cycles											;5beb	00 	.
6050  5BEC 00           	nop								; delay 4 clock cycles											;5bec	00 	.
6051  5BED 3E 00        	ld a,0							; delay 7 clock cycles											;5bed	3e 00 	> .
6052  5BEF 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;5bef	3e 00 	> .
6053  5BF1 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5bf1	db 11 	. .
6054  5BF3              .waitClockBit1:
6055  5BF3              ; -- wait for FDC Clock Pulse
6056  5BF3 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5bf3	ed 78 	. x
6057  5BF5 F2 F3 5B     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5bf5	f2 f3 5b 	. . [
6058  5BF8 2B           	dec hl							; delay 6 clock cycles											;5bf8	2b 	+
6059  5BF9 23           	inc hl							; delay 6 clock cycles											;5bf9	23 	#
6060  5BFA 2B           	dec hl							; delay 6 clock cycles											;5bfa	2b 	+
6061  5BFB 23           	inc hl							; delay 6 clock cycles											;5bfb	23 	#
6062  5BFC 2B           	dec hl							; delay 6 clock cycles											;5bfc	2b 	+
6063  5BFD 23           	inc hl							; delay 6 clock cycles											;5bfd	23 	#
6064  5BFE 00           	nop								; delay 4 clock cycles											;5bfe	00 	.
6065  5BFF 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5bff	3e 00 	> .
6066  5C01 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;5c01	db 11 	. .
6067  5C03              .waitClockBit2:
6068  5C03              ; -- wait for FDC Clock Pulse
6069  5C03 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c03	ed 78 	. x
6070  5C05 F2 03 5C     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5c05	f2 03 5c 	. . \
6071  5C08 2B           	dec hl							; delay 6 clock cycles											;5c08	2b 	+
6072  5C09 23           	inc hl							; delay 6 clock cycles											;5c09	23 	#
6073  5C0A 2B           	dec hl							; delay 6 clock cycles											;5c0a	2b 	+
6074  5C0B 23           	inc hl							; delay 6 clock cycles											;5c0b	23 	#
6075  5C0C 2B           	dec hl							; delay 6 clock cycles											;5c0c	2b 	+
6076  5C0D 23           	inc hl							; delay 6 clock cycles											;5c0d	23 	#
6077  5C0E 00           	nop								; delay 4 clock cycles											;5c0e	00 	.
6078  5C0F 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5c0f	3e 00 	> .
6079  5C11 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5c11	db 11 	. .
6080  5C13              .waitClockBit3:
6081  5C13              ; -- wait for FDC Clock Pulse
6082  5C13 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c13	ed 78 	. x
6083  5C15 F2 13 5C     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5c15	f2 13 5c 	. . \
6084  5C18 2B           	dec hl							; delay 6 clock cycles											;5c18	2b 	+
6085  5C19 23           	inc hl							; delay 6 clock cycles											;5c19	23 	#
6086  5C1A 2B           	dec hl							; delay 6 clock cycles											;5c1a	2b 	+
6087  5C1B 23           	inc hl							; delay 6 clock cycles											;5c1b	23 	#
6088  5C1C 2B           	dec hl							; delay 6 clock cycles											;5c1c	2b 	+
6089  5C1D 23           	inc hl							; delay 6 clock cycles											;5c1d	23 	#
6090  5C1E 00           	nop								; delay 4 clock cycles											;5c1e	00 	.
6091  5C1F 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5c1f	3e 00 	> .
6092  5C21 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5c21	db 11 	. .
6093  5C23              .waitClockBit4:
6094  5C23              ; -- wait for FDC Clock Pulse
6095  5C23 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c23	ed 78 	. x
6096  5C25 F2 23 5C     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5c25	f2 23 5c 	. # \
6097  5C28 2B           	dec hl							; delay 6 clock cycles											;5c28	2b 	+
6098  5C29 23           	inc hl							; delay 6 clock cycles											;5c29	23 	#
6099  5C2A 2B           	dec hl							; delay 6 clock cycles											;5c2a	2b 	+
6100  5C2B 23           	inc hl							; delay 6 clock cycles											;5c2b	23 	#
6101  5C2C 2B           	dec hl							; delay 6 clock cycles											;5c2c	2b 	+
6102  5C2D 23           	inc hl							; delay 6 clock cycles											;5c2d	23 	#
6103  5C2E 00           	nop								; delay 4 clock cycles											;5c2e	00 	.
6104  5C2F 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5c2f	3e 00 	> .
6105  5C31 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5c31	db 11 	. .
6106  5C33              .waitClockBit5:
6107  5C33              ; -- wait for FDC Clock Pulse
6108  5C33 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c33	ed 78 	. x
6109  5C35 F2 33 5C     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5c35	f2 33 5c 	. 3 \
6110  5C38 2B           	dec hl							; delay 6 clock cycles											;5c38	2b 	+
6111  5C39 23           	inc hl							; delay 6 clock cycles											;5c39	23 	#
6112  5C3A 2B           	dec hl							; delay 6 clock cycles											;5c3a	2b 	+
6113  5C3B 23           	inc hl							; delay 6 clock cycles											;5c3b	23 	#
6114  5C3C 2B           	dec hl							; delay 6 clock cycles											;5c3c	2b 	+
6115  5C3D 23           	inc hl							; delay 6 clock cycles											;5c3d	23 	#
6116  5C3E 00           	nop								; delay 4 clock cycles											;5c3e	00 	.
6117  5C3F 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5c3f	3e 00 	> .
6118  5C41 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;5c41	db 11 	. .
6119  5C43              .waitClockBit6:
6120  5C43              ; -- wait for FDC Clock Pulse
6121  5C43 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c43	ed 78 	. x
6122  5C45 F2 43 5C     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;5c45	f2 43 5c 	. C \
6123  5C48 2B           	dec hl							; delay 6 clock cycles											;5c48	2b 	+
6124  5C49 23           	inc hl							; delay 6 clock cycles											;5c49	23 	#
6125  5C4A 2B           	dec hl							; delay 6 clock cycles											;5c4a	2b 	+
6126  5C4B 23           	inc hl							; delay 6 clock cycles											;5c4b	23 	#
6127  5C4C 2B           	dec hl							; delay 6 clock cycles											;5c4c	2b 	+
6128  5C4D 23           	inc hl							; delay 6 clock cycles											;5c4d	23 	#
6129  5C4E 00           	nop								; delay 4 clock cycles											;5c4e	00 	.
6130  5C4F 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5c4f	3e 00 	> .
6131  5C51 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;5c51	db 11 	. .
6132  5C53              .waitClockBit7:
6133  5C53              ; -- wait for FDC Clock Pulse
6134  5C53 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c53	ed 78 	. x
6135  5C55 F2 53 5C     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;5c55	f2 53 5c 	. S \
6136  5C58 2B           	dec hl							; delay 6 clock cycles											;5c58	2b 	+
6137  5C59 23           	inc hl							; delay 6 clock cycles											;5c59	23 	#
6138  5C5A 2B           	dec hl							; delay 6 clock cycles											;5c5a	2b 	+
6139  5C5B 23           	inc hl							; delay 6 clock cycles											;5c5b	23 	#
6140  5C5C 2B           	dec hl							; delay 6 clock cycles											;5c5c	2b 	+
6141  5C5D 23           	inc hl							; delay 6 clock cycles											;5c5d	23 	#
6142  5C5E 00           	nop								; delay 4 clock cycles											;5c5e	00 	.
6143  5C5F 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5c5f	3e 00 	> .
6144  5C61 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;5c61	db 11 	. .
6145  5C63 47           	ld b,a							; store for compare												;5c63	47 	G
6146  5C64              .waitClockBit8:
6147  5C64              ; -- wait for FDC Clock Pulse
6148  5C64 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c64	ed 78 	. x
6149  5C66 F2 64 5C     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;5c66	f2 64 5c 	. d \
6150  5C69
6151  5C69              ; -- We have 1st byte read (expected $c3)
6152  5C69
6153  5C69 78           	ld a,b							; a - byte from Floppy Disk										;5c69	78 	x
6154  5C6A FE C3        	cp $c3							; is it C3 (first byte of IDAM ending)?							;5c6a	fe c3 	. .
6155  5C6C C2 50 5B     	jp nz,RD_WaitFor80				; no - start over and find byte = $80							;5c6c	c2 50 5b 	. P [
6156  5C6F
6157  5C6F              ;***************************************************************************************************
6158  5C6F              ;
6159  5C6F              ; Read IDAM (ending) sequence 2nd byte - $18
6160  5C6F              ;
6161  5C6F
6162  5C6F              ; ---------- [3] --- read byte 18 - second in IDAM sequence
6163  5C6F
6164  5C6F              RD_IDAM_18:
6165  5C6F 00           	nop								; delay 4 clock cycles											;5c6f	00 	.
6166  5C70 00           	nop								; delay 4 clock cycles											;5c70	00 	.
6167  5C71 00           	nop								; delay 4 clock cycles											;5c71	00 	.
6168  5C72 3E 00        	ld a,0							; delay 7 clock cycles											;5c72	3e 00 	> .
6169  5C74 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;5c74	3e 00 	> .
6170  5C76 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5c76	db 11 	. .
6171  5C78              .waitClockBit1:
6172  5C78              ; -- wait for FDC Clock Pulse
6173  5C78 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c78	ed 78 	. x
6174  5C7A F2 78 5C     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5c7a	f2 78 5c 	. x \
6175  5C7D 2B           	dec hl							; delay 6 clock cycles											;5c7d	2b 	+
6176  5C7E 23           	inc hl							; delay 6 clock cycles											;5c7e	23 	#
6177  5C7F 2B           	dec hl							; delay 6 clock cycles											;5c7f	2b 	+
6178  5C80 23           	inc hl							; delay 6 clock cycles											;5c80	23 	#
6179  5C81 2B           	dec hl							; delay 6 clock cycles											;5c81	2b 	+
6180  5C82 23           	inc hl							; delay 6 clock cycles											;5c82	23 	#
6181  5C83 00           	nop								; delay 4 clock cycles											;5c83	00 	.
6182  5C84 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5c84	3e 00 	> .
6183  5C86 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;5c86	db 11 	. .
6184  5C88              .waitClockBit2:
6185  5C88              ; -- wait for FDC Clock Pulse
6186  5C88 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c88	ed 78 	. x
6187  5C8A F2 88 5C     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5c8a	f2 88 5c 	. . \
6188  5C8D 2B           	dec hl							; delay 6 clock cycles											;5c8d	2b 	+
6189  5C8E 23           	inc hl							; delay 6 clock cycles											;5c8e	23 	#
6190  5C8F 2B           	dec hl							; delay 6 clock cycles											;5c8f	2b 	+
6191  5C90 23           	inc hl							; delay 6 clock cycles											;5c90	23 	#
6192  5C91 2B           	dec hl							; delay 6 clock cycles											;5c91	2b 	+
6193  5C92 23           	inc hl							; delay 6 clock cycles											;5c92	23 	#
6194  5C93 00           	nop								; delay 4 clock cycles											;5c93	00 	.
6195  5C94 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5c94	3e 00 	> .
6196  5C96 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5c96	db 11 	. .
6197  5C98              .waitClockBit3:
6198  5C98              ; -- wait for FDC Clock Pulse
6199  5C98 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5c98	ed 78 	. x
6200  5C9A F2 98 5C     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5c9a	f2 98 5c 	. . \
6201  5C9D 2B           	dec hl							; delay 6 clock cycles											;5c9d	2b 	+
6202  5C9E 23           	inc hl							; delay 6 clock cycles											;5c9e	23 	#
6203  5C9F 2B           	dec hl							; delay 6 clock cycles											;5c9f	2b 	+
6204  5CA0 23           	inc hl							; delay 6 clock cycles											;5ca0	23 	#
6205  5CA1 2B           	dec hl							; delay 6 clock cycles											;5ca1	2b 	+
6206  5CA2 23           	inc hl							; delay 6 clock cycles											;5ca2	23 	#
6207  5CA3 00           	nop								; delay 4 clock cycles											;5ca3	00 	.
6208  5CA4 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5ca4	3e 00 	> .
6209  5CA6 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5ca6	db 11 	. .
6210  5CA8              .waitClockBit4:
6211  5CA8              ; -- wait for FDC Clock Pulse
6212  5CA8 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5ca8	ed 78 	. x
6213  5CAA F2 A8 5C     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5caa	f2 a8 5c 	. . \
6214  5CAD 2B           	dec hl							; delay 6 clock cycles											;5cad	2b 	+
6215  5CAE 23           	inc hl							; delay 6 clock cycles											;5cae	23 	#
6216  5CAF 2B           	dec hl							; delay 6 clock cycles											;5caf	2b 	+
6217  5CB0 23           	inc hl							; delay 6 clock cycles											;5cb0	23 	#
6218  5CB1 2B           	dec hl							; delay 6 clock cycles											;5cb1	2b 	+
6219  5CB2 23           	inc hl							; delay 6 clock cycles											;5cb2	23 	#
6220  5CB3 00           	nop								; delay 4 clock cycles											;5cb3	00 	.
6221  5CB4 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5cb4	3e 00 	> .
6222  5CB6 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5cb6	db 11 	. .
6223  5CB8              .waitClockBit5:
6224  5CB8              ; -- wait for FDC Clock Pulse
6225  5CB8 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5cb8	ed 78 	. x
6226  5CBA F2 B8 5C     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5cba	f2 b8 5c 	. . \
6227  5CBD 2B           	dec hl							; delay 6 clock cycles											;5cbd	2b 	+
6228  5CBE 23           	inc hl							; delay 6 clock cycles											;5cbe	23 	#
6229  5CBF 2B           	dec hl							; delay 6 clock cycles											;5cbf	2b 	+
6230  5CC0 23           	inc hl							; delay 6 clock cycles											;5cc0	23 	#
6231  5CC1 2B           	dec hl							; delay 6 clock cycles											;5cc1	2b 	+
6232  5CC2 23           	inc hl							; delay 6 clock cycles											;5cc2	23 	#
6233  5CC3 00           	nop								; delay 4 clock cycles											;5cc3	00 	.
6234  5CC4 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5cc4	3e 00 	> .
6235  5CC6 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;5cc6	db 11 	. .
6236  5CC8              .waitClockBit6:
6237  5CC8              ; -- wait for FDC Clock Pulse
6238  5CC8 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5cc8	ed 78 	. x
6239  5CCA F2 C8 5C     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;5cca	f2 c8 5c 	. . \
6240  5CCD 2B           	dec hl							; delay 6 clock cycles											;5ccd	2b 	+
6241  5CCE 23           	inc hl							; delay 6 clock cycles											;5cce	23 	#
6242  5CCF 2B           	dec hl							; delay 6 clock cycles											;5ccf	2b 	+
6243  5CD0 23           	inc hl							; delay 6 clock cycles											;5cd0	23 	#
6244  5CD1 2B           	dec hl							; delay 6 clock cycles											;5cd1	2b 	+
6245  5CD2 23           	inc hl							; delay 6 clock cycles											;5cd2	23 	#
6246  5CD3 00           	nop								; delay 4 clock cycles											;5cd3	00 	.
6247  5CD4 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5cd4	3e 00 	> .
6248  5CD6 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;5cd6	db 11 	. .
6249  5CD8              .waitClockBit7:
6250  5CD8              ; -- wait for FDC Clock Pulse
6251  5CD8 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5cd8	ed 78 	. x
6252  5CDA F2 D8 5C     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;5cda	f2 d8 5c 	. . \
6253  5CDD 2B           	dec hl							; delay 6 clock cycles											;5cdd	2b 	+
6254  5CDE 23           	inc hl							; delay 6 clock cycles											;5cde	23 	#
6255  5CDF 2B           	dec hl							; delay 6 clock cycles											;5cdf	2b 	+
6256  5CE0 23           	inc hl							; delay 6 clock cycles											;5ce0	23 	#
6257  5CE1 2B           	dec hl							; delay 6 clock cycles											;5ce1	2b 	+
6258  5CE2 23           	inc hl							; delay 6 clock cycles											;5ce2	23 	#
6259  5CE3 00           	nop								; delay 4 clock cycles											;5ce3	00 	.
6260  5CE4 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5ce4	3e 00 	> .
6261  5CE6 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;5ce6	db 11 	. .
6262  5CE8 47           	ld b,a							; store for compare												;5ce8	47 	G
6263  5CE9              .waitClockBit8:
6264  5CE9              ; -- wait for FDC Clock Pulse
6265  5CE9 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5ce9	ed 78 	. x
6266  5CEB F2 E9 5C     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;5ceb	f2 e9 5c 	. . \
6267  5CEE
6268  5CEE              ; -- We have 2nd byte read (expected $18)
6269  5CEE
6270  5CEE 78           	ld a,b							; a - byte from Floppy Disk										;5cee	78 	x
6271  5CEF FE 18        	cp $18							; is it 18 (second byte of IDAM ending)?						;5cef	fe 18 	. .
6272  5CF1 C2 27 5B     	jp nz,READ						; no - start over and Read a sector from disk					;5cf1	c2 27 5b 	. ' [
6273  5CF4
6274  5CF4
6275  5CF4              ;***************************************************************************************************
6276  5CF4              ;
6277  5CF4              ; Read IDAM (ending) sequence 3rd byte - $E7
6278  5CF4              ;
6279  5CF4
6280  5CF4              ; ---------- [4] --- read byte E7 - third in IDAM (ending) sequence
6281  5CF4
6282  5CF4              RD_IDAM_E7:
6283  5CF4 00           	nop								; delay 4 clock cycles											;5cf4	00 	.
6284  5CF5 00           	nop								; delay 4 clock cycles											;5cf5	00 	.
6285  5CF6 00           	nop								; delay 4 clock cycles											;5cf6	00 	.
6286  5CF7 3E 00        	ld a,0							; delay 7 clock cycles											;5cf7	3e 00 	> .
6287  5CF9 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;5cf9	3e 00 	> .
6288  5CFB DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5cfb	db 11 	. .
6289  5CFD              .waitClockBit1:
6290  5CFD              ; -- wait for FDC Clock Pulse
6291  5CFD ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5cfd	ed 78 	. x
6292  5CFF F2 FD 5C     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5cff	f2 fd 5c 	. . \
6293  5D02 2B           	dec hl							; delay 6 clock cycles											;5d02	2b 	+
6294  5D03 23           	inc hl							; delay 6 clock cycles											;5d03	23 	#
6295  5D04 2B           	dec hl							; delay 6 clock cycles											;5d04	2b 	+
6296  5D05 23           	inc hl							; delay 6 clock cycles											;5d05	23 	#
6297  5D06 2B           	dec hl							; delay 6 clock cycles											;5d06	2b 	+
6298  5D07 23           	inc hl							; delay 6 clock cycles											;5d07	23 	#
6299  5D08 00           	nop								; delay 4 clock cycles											;5d08	00 	.
6300  5D09 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5d09	3e 00 	> .
6301  5D0B DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;5d0b	db 11 	. .
6302  5D0D              .waitClockBit2:
6303  5D0D              ; -- wait for FDC Clock Pulse
6304  5D0D ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5d0d	ed 78 	. x
6305  5D0F F2 0D 5D     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5d0f	f2 0d 5d 	. . ]
6306  5D12 2B           	dec hl							; delay 6 clock cycles											;5d12	2b 	+
6307  5D13 23           	inc hl							; delay 6 clock cycles											;5d13	23 	#
6308  5D14 2B           	dec hl							; delay 6 clock cycles											;5d14	2b 	+
6309  5D15 23           	inc hl							; delay 6 clock cycles											;5d15	23 	#
6310  5D16 2B           	dec hl							; delay 6 clock cycles											;5d16	2b 	+
6311  5D17 23           	inc hl							; delay 6 clock cycles											;5d17	23 	#
6312  5D18 00           	nop								; delay 4 clock cycles											;5d18	00 	.
6313  5D19 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5d19	3e 00 	> .
6314  5D1B DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5d1b	db 11 	. .
6315  5D1D              .waitClockBit3:
6316  5D1D              ; -- wait for FDC Clock Pulse
6317  5D1D ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5d1d	ed 78 	. x
6318  5D1F F2 1D 5D     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5d1f	f2 1d 5d 	. . ]
6319  5D22 2B           	dec hl							; delay 6 clock cycles											;5d22	2b 	+
6320  5D23 23           	inc hl							; delay 6 clock cycles											;5d23	23 	#
6321  5D24 2B           	dec hl							; delay 6 clock cycles											;5d24	2b 	+
6322  5D25 23           	inc hl							; delay 6 clock cycles											;5d25	23 	#
6323  5D26 2B           	dec hl							; delay 6 clock cycles											;5d26	2b 	+
6324  5D27 23           	inc hl							; delay 6 clock cycles											;5d27	23 	#
6325  5D28 00           	nop								; delay 4 clock cycles											;5d28	00 	.
6326  5D29 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5d29	3e 00 	> .
6327  5D2B DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5d2b	db 11 	. .
6328  5D2D              .waitClockBit4:
6329  5D2D              ; -- wait for FDC Clock Pulse
6330  5D2D ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5d2d	ed 78 	. x
6331  5D2F F2 2D 5D     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5d2f	f2 2d 5d 	. - ]
6332  5D32 2B           	dec hl							; delay 6 clock cycles											;5d32	2b 	+
6333  5D33 23           	inc hl							; delay 6 clock cycles											;5d33	23 	#
6334  5D34 2B           	dec hl							; delay 6 clock cycles											;5d34	2b 	+
6335  5D35 23           	inc hl							; delay 6 clock cycles											;5d35	23 	#
6336  5D36 2B           	dec hl							; delay 6 clock cycles											;5d36	2b 	+
6337  5D37 23           	inc hl							; delay 6 clock cycles											;5d37	23 	#
6338  5D38 00           	nop								; delay 4 clock cycles											;5d38	00 	.
6339  5D39 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5d39	3e 00 	> .
6340  5D3B DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5d3b	db 11 	. .
6341  5D3D              .waitClockBit5:
6342  5D3D              ; -- wait for FDC Clock Pulse
6343  5D3D ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5d3d	ed 78 	. x
6344  5D3F F2 3D 5D     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5d3f	f2 3d 5d 	. = ]
6345  5D42 2B           	dec hl							; delay 6 clock cycles											;5d42	2b 	+
6346  5D43 23           	inc hl							; delay 6 clock cycles											;5d43	23 	#
6347  5D44 2B           	dec hl							; delay 6 clock cycles											;5d44	2b 	+
6348  5D45 23           	inc hl							; delay 6 clock cycles											;5d45	23 	#
6349  5D46 2B           	dec hl							; delay 6 clock cycles											;5d46	2b 	+
6350  5D47 23           	inc hl							; delay 6 clock cycles											;5d47	23 	#
6351  5D48 00           	nop								; delay 4 clock cycles											;5d48	00 	.
6352  5D49 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5d49	3e 00 	> .
6353  5D4B DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;5d4b	db 11 	. .
6354  5D4D              .waitClockBit6:
6355  5D4D              ; -- wait for FDC Clock Pulse
6356  5D4D ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5d4d	ed 78 	. x
6357  5D4F F2 4D 5D     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;5d4f	f2 4d 5d 	. M ]
6358  5D52 2B           	dec hl							; delay 6 clock cycles											;5d52	2b 	+
6359  5D53 23           	inc hl							; delay 6 clock cycles											;5d53	23 	#
6360  5D54 2B           	dec hl							; delay 6 clock cycles											;5d54	2b 	+
6361  5D55 23           	inc hl							; delay 6 clock cycles											;5d55	23 	#
6362  5D56 2B           	dec hl							; delay 6 clock cycles											;5d56	2b 	+
6363  5D57 23           	inc hl							; delay 6 clock cycles											;5d57	23 	#
6364  5D58 00           	nop								; delay 4 clock cycles											;5d58	00 	.
6365  5D59 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5d59	3e 00 	> .
6366  5D5B DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;5d5b	db 11 	. .
6367  5D5D              .waitClockBit7:
6368  5D5D              ; -- wait for FDC Clock Pulse
6369  5D5D ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5d5d	ed 78 	. x
6370  5D5F F2 5D 5D     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;5d5f	f2 5d 5d 	. ] ]
6371  5D62 2B           	dec hl							; delay 6 clock cycles											;5d62	2b 	+
6372  5D63 23           	inc hl							; delay 6 clock cycles											;5d63	23 	#
6373  5D64 2B           	dec hl							; delay 6 clock cycles											;5d64	2b 	+
6374  5D65 23           	inc hl							; delay 6 clock cycles											;5d65	23 	#
6375  5D66 2B           	dec hl							; delay 6 clock cycles											;5d66	2b 	+
6376  5D67 23           	inc hl							; delay 6 clock cycles											;5d67	23 	#
6377  5D68 00           	nop								; delay 4 clock cycles											;5d68	00 	.
6378  5D69 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5d69	3e 00 	> .
6379  5D6B DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;5d6b	db 11 	. .
6380  5D6D 47           	ld b,a							; store for compare												;5d6d	47 	G
6381  5D6E              .waitClockBit8:
6382  5D6E              ; -- wait for FDC Clock Pulse
6383  5D6E ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5d6e	ed 78 	. x
6384  5D70 F2 6E 5D     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;5d70	f2 6e 5d 	. n ]
6385  5D73
6386  5D73              ; -- We have 3rd byte read (expected $e7)
6387  5D73
6388  5D73 78           	ld a,b							; a - byte from Floppy Disk										;5d73	78 	x
6389  5D74 FE E7        	cp $e7							; is it E7 (third byte of IDAM ending)?							;5d74	fe e7 	. .
6390  5D76 C2 27 5B     	jp nz,READ						; no - start over and Read a sector from disk					;5d76	c2 27 5b 	. ' [
6391  5D79
6392  5D79              ;***************************************************************************************************
6393  5D79              ;
6394  5D79              ; Read IDAM (ending) sequence 4th byte - $FE
6395  5D79              ;
6396  5D79
6397  5D79              ; ---------- [5] --- read byte FE - forth in IDAM (ending) sequence
6398  5D79
6399  5D79              RD_IDAM_FE:
6400  5D79 00           	nop								; delay 4 clock cycles											;5d79	00 	.
6401  5D7A 00           	nop								; delay 4 clock cycles											;5d7a	00 	.
6402  5D7B 00           	nop								; delay 4 clock cycles											;5d7b	00 	.
6403  5D7C 3E 00        	ld a,0							; delay 7 clock cycles											;5d7c	3e 00 	> .
6404  5D7E 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;5d7e	3e 00 	> .
6405  5D80 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5d80	db 11 	. .
6406  5D82              .waitClockBit1:
6407  5D82              ; -- wait for FDC Clock Pulse
6408  5D82 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5d82	ed 78 	. x
6409  5D84 F2 82 5D     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5d84	f2 82 5d 	. . ]
6410  5D87 2B           	dec hl							; delay 6 clock cycles											;5d87	2b 	+
6411  5D88 23           	inc hl							; delay 6 clock cycles											;5d88	23 	#
6412  5D89 2B           	dec hl							; delay 6 clock cycles											;5d89	2b 	+
6413  5D8A 23           	inc hl							; delay 6 clock cycles											;5d8a	23 	#
6414  5D8B 2B           	dec hl							; delay 6 clock cycles											;5d8b	2b 	+
6415  5D8C 23           	inc hl							; delay 6 clock cycles											;5d8c	23 	#
6416  5D8D 00           	nop								; delay 4 clock cycles											;5d8d	00 	.
6417  5D8E 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5d8e	3e 00 	> .
6418  5D90 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;5d90	db 11 	. .
6419  5D92              .waitClockBit2:
6420  5D92              ; -- wait for FDC Clock Pulse
6421  5D92 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5d92	ed 78 	. x
6422  5D94 F2 92 5D     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5d94	f2 92 5d 	. . ]
6423  5D97 2B           	dec hl							; delay 6 clock cycles											;5d97	2b 	+
6424  5D98 23           	inc hl							; delay 6 clock cycles											;5d98	23 	#
6425  5D99 2B           	dec hl							; delay 6 clock cycles											;5d99	2b 	+
6426  5D9A 23           	inc hl							; delay 6 clock cycles											;5d9a	23 	#
6427  5D9B 2B           	dec hl							; delay 6 clock cycles											;5d9b	2b 	+
6428  5D9C 23           	inc hl							; delay 6 clock cycles											;5d9c	23 	#
6429  5D9D 00           	nop								; delay 4 clock cycles											;5d9d	00 	.
6430  5D9E 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5d9e	3e 00 	> .
6431  5DA0 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5da0	db 11 	. .
6432  5DA2              .waitClockBit3:
6433  5DA2              ; -- wait for FDC Clock Pulse
6434  5DA2 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5da2	ed 78 	. x
6435  5DA4 F2 A2 5D     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5da4	f2 a2 5d 	. . ]
6436  5DA7 2B           	dec hl							; delay 6 clock cycles											;5da7	2b 	+
6437  5DA8 23           	inc hl							; delay 6 clock cycles											;5da8	23 	#
6438  5DA9 2B           	dec hl							; delay 6 clock cycles											;5da9	2b 	+
6439  5DAA 23           	inc hl							; delay 6 clock cycles											;5daa	23 	#
6440  5DAB 2B           	dec hl							; delay 6 clock cycles											;5dab	2b 	+
6441  5DAC 23           	inc hl							; delay 6 clock cycles											;5dac	23 	#
6442  5DAD 00           	nop								; delay 4 clock cycles											;5dad	00 	.
6443  5DAE 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5dae	3e 00 	> .
6444  5DB0 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5db0	db 11 	. .
6445  5DB2              .waitClockBit4:
6446  5DB2              ; -- wait for FDC Clock Pulse
6447  5DB2 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5db2	ed 78 	. x
6448  5DB4 F2 B2 5D     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5db4	f2 b2 5d 	. . ]
6449  5DB7 2B           	dec hl							; delay 6 clock cycles											;5db7	2b 	+
6450  5DB8 23           	inc hl							; delay 6 clock cycles											;5db8	23 	#
6451  5DB9 2B           	dec hl							; delay 6 clock cycles											;5db9	2b 	+
6452  5DBA 23           	inc hl							; delay 6 clock cycles											;5dba	23 	#
6453  5DBB 2B           	dec hl							; delay 6 clock cycles											;5dbb	2b 	+
6454  5DBC 23           	inc hl							; delay 6 clock cycles											;5dbc	23 	#
6455  5DBD 00           	nop								; delay 4 clock cycles											;5dbd	00 	.
6456  5DBE 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5dbe	3e 00 	> .
6457  5DC0 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5dc0	db 11 	. .
6458  5DC2              .waitClockBit5:
6459  5DC2              ; -- wait for FDC Clock Pulse
6460  5DC2 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5dc2	ed 78 	. x
6461  5DC4 F2 C2 5D     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5dc4	f2 c2 5d 	. . ]
6462  5DC7 2B           	dec hl							; delay 6 clock cycles											;5dc7	2b 	+
6463  5DC8 23           	inc hl							; delay 6 clock cycles											;5dc8	23 	#
6464  5DC9 2B           	dec hl							; delay 6 clock cycles											;5dc9	2b 	+
6465  5DCA 23           	inc hl							; delay 6 clock cycles											;5dca	23 	#
6466  5DCB 2B           	dec hl							; delay 6 clock cycles											;5dcb	2b 	+
6467  5DCC 23           	inc hl							; delay 6 clock cycles											;5dcc	23 	#
6468  5DCD 00           	nop								; delay 4 clock cycles											;5dcd	00 	.
6469  5DCE 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5dce	3e 00 	> .
6470  5DD0 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;5dd0	db 11 	. .
6471  5DD2              .waitClockBit6:
6472  5DD2              ; -- wait for FDC Clock Pulse
6473  5DD2 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5dd2	ed 78 	. x
6474  5DD4 F2 D2 5D     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;5dd4	f2 d2 5d 	. . ]
6475  5DD7 2B           	dec hl							; delay 6 clock cycles											;5dd7	2b 	+
6476  5DD8 23           	inc hl							; delay 6 clock cycles											;5dd8	23 	#
6477  5DD9 2B           	dec hl							; delay 6 clock cycles											;5dd9	2b 	+
6478  5DDA 23           	inc hl							; delay 6 clock cycles											;5dda	23 	#
6479  5DDB 2B           	dec hl							; delay 6 clock cycles											;5ddb	2b 	+
6480  5DDC 23           	inc hl							; delay 6 clock cycles											;5ddc	23 	#
6481  5DDD 00           	nop								; delay 4 clock cycles											;5ddd	00 	.
6482  5DDE 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5dde	3e 00 	> .
6483  5DE0 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;5de0	db 11 	. .
6484  5DE2              .waitClockBit7:
6485  5DE2              ; -- wait for FDC Clock Pulse
6486  5DE2 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5de2	ed 78 	. x
6487  5DE4 F2 E2 5D     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;5de4	f2 e2 5d 	. . ]
6488  5DE7 2B           	dec hl							; delay 6 clock cycles											;5de7	2b 	+
6489  5DE8 23           	inc hl							; delay 6 clock cycles											;5de8	23 	#
6490  5DE9 2B           	dec hl							; delay 6 clock cycles											;5de9	2b 	+
6491  5DEA 23           	inc hl							; delay 6 clock cycles											;5dea	23 	#
6492  5DEB 2B           	dec hl							; delay 6 clock cycles											;5deb	2b 	+
6493  5DEC 23           	inc hl							; delay 6 clock cycles											;5dec	23 	#
6494  5DED 00           	nop								; delay 4 clock cycles											;5ded	00 	.
6495  5DEE 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5dee	3e 00 	> .
6496  5DF0 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;5df0	db 11 	. .
6497  5DF2 47           	ld b,a			;5df2	47 	G
6498  5DF3              .waitClockBit8:
6499  5DF3              ; -- wait for FDC Clock Pulse
6500  5DF3 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5df3	ed 78 	. x
6501  5DF5 F2 F3 5D     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;5df5	f2 f3 5d 	. . ]
6502  5DF8
6503  5DF8              ; -- We have 4th byte read (expected $fe)
6504  5DF8
6505  5DF8 78           	ld a,b							; a - byte from Floppy Disk										;5df8	78 	x
6506  5DF9 FE FE        	cp $fe							; is it FE (fourth byte of IDAM ending)?						;5df9	fe fe 	. .
6507  5DFB C2 27 5B     	jp nz,READ						; no - start over and  Read a sector from disk					;5dfb	c2 27 5b 	. ' [
6508  5DFE
6509  5DFE              ;***************************************************************************************************
6510  5DFE              ;
6511  5DFE              ; Read Sector Data Bytes and Checksum (128+2 bytes)
6512  5DFE              ;
6513  5DFE
6514  5DFE              ; ---------- [6] --- read Sector Data Byte
6515  5DFE
6516  5DFE              RD_DataByte:
6517  5DFE 00           	nop								; delay 4 clock cycles											;5dfe	00 	.
6518  5DFF 00           	nop								; delay 4 clock cycles											;5dff	00 	.
6519  5E00 00           	nop								; delay 4 clock cycles											;5e00	00 	.
6520  5E01 3E 00        	ld a,0							; delay 7 clock cycles											;5e01	3e 00 	> .
6521  5E03 3E 00        	ld a,0							; delay 7 clock cycles	(26 in total)							;5e03	3e 00 	> .
6522  5E05
6523  5E05              RD_NextDataByte:
6524  5E05 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 7]		;5e05	db 11 	. .
6525  5E07              .waitClockBit1:
6526  5E07              ; -- wait for FDC Clock Pulse
6527  5E07 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5e07	ed 78 	. x
6528  5E09 F2 07 5E     	jp p,.waitClockBit1				; wait until Clock BIt = 1										;5e09	f2 07 5e 	. . ^
6529  5E0C 2B           	dec hl							; delay 6 clock cycles											;5e0c	2b 	+
6530  5E0D 23           	inc hl							; delay 6 clock cycles											;5e0d	23 	#
6531  5E0E 2B           	dec hl							; delay 6 clock cycles											;5e0e	2b 	+
6532  5E0F 23           	inc hl							; delay 6 clock cycles											;5e0f	23 	#
6533  5E10 2B           	dec hl							; delay 6 clock cycles											;5e10	2b 	+
6534  5E11 23           	inc hl							; delay 6 clock cycles											;5e11	23 	#
6535  5E12 00           	nop								; delay 4 clock cycles											;5e12	00 	.
6536  5E13 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5e13	3e 00 	> .
6537  5E15 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 6]		;5e15	db 11 	. .
6538  5E17              .waitClockBit2:
6539  5E17              ; -- wait for FDC Clock Pulse
6540  5E17 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5e17	ed 78 	. x
6541  5E19 F2 17 5E     	jp p,.waitClockBit2				; wait until Clock BIt = 1										;5e19	f2 17 5e 	. . ^
6542  5E1C 2B           	dec hl							; delay 6 clock cycles											;5e1c	2b 	+
6543  5E1D 23           	inc hl							; delay 6 clock cycles											;5e1d	23 	#
6544  5E1E 2B           	dec hl							; delay 6 clock cycles											;5e1e	2b 	+
6545  5E1F 23           	inc hl							; delay 6 clock cycles											;5e1f	23 	#
6546  5E20 2B           	dec hl							; delay 6 clock cycles											;5e20	2b 	+
6547  5E21 23           	inc hl							; delay 6 clock cycles											;5e21	23 	#
6548  5E22 00           	nop								; delay 4 clock cycles											;5e22	00 	.
6549  5E23 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5e23	3e 00 	> .
6550  5E25 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 5]		;5e25	db 11 	. .
6551  5E27              .waitClockBit3:
6552  5E27              ; -- wait for FDC Clock Pulse
6553  5E27 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5e27	ed 78 	. x
6554  5E29 F2 27 5E     	jp p,.waitClockBit3				; wait until Clock BIt = 1										;5e29	f2 27 5e 	. ' ^
6555  5E2C 2B           	dec hl							; delay 6 clock cycles											;5e2c	2b 	+
6556  5E2D 23           	inc hl							; delay 6 clock cycles											;5e2d	23 	#
6557  5E2E 2B           	dec hl							; delay 6 clock cycles											;5e2e	2b 	+
6558  5E2F 23           	inc hl							; delay 6 clock cycles											;5e2f	23 	#
6559  5E30 2B           	dec hl							; delay 6 clock cycles											;5e30	2b 	+
6560  5E31 23           	inc hl							; delay 6 clock cycles											;5e31	23 	#
6561  5E32 00           	nop								; delay 4 clock cycles											;5e32	00 	.
6562  5E33 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5e33	3e 00 	> .
6563  5E35 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 4]		;5e35	db 11 	. .
6564  5E37              .waitClockBit4:
6565  5E37              ; -- wait for FDC Clock Pulse
6566  5E37 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5e37	ed 78 	. x
6567  5E39 F2 37 5E     	jp p,.waitClockBit4				; wait until Clock BIt = 1										;5e39	f2 37 5e 	. 7 ^
6568  5E3C 2B           	dec hl							; delay 6 clock cycles											;5e3c	2b 	+
6569  5E3D 23           	inc hl							; delay 6 clock cycles											;5e3d	23 	#
6570  5E3E 2B           	dec hl							; delay 6 clock cycles											;5e3e	2b 	+
6571  5E3F 23           	inc hl							; delay 6 clock cycles											;5e3f	23 	#
6572  5E40 2B           	dec hl							; delay 6 clock cycles											;5e40	2b 	+
6573  5E41 23           	inc hl							; delay 6 clock cycles											;5e41	23 	#
6574  5E42 00           	nop								; delay 4 clock cycles											;5e42	00 	.
6575  5E43 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5e43	3e 00 	> .
6576  5E45 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 3]		;5e45	db 11 	. .
6577  5E47              .waitClockBit5:
6578  5E47              ; -- wait for FDC Clock Pulse
6579  5E47 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5e47	ed 78 	. x
6580  5E49 F2 47 5E     	jp p,.waitClockBit5				; wait until Clock BIt = 1										;5e49	f2 47 5e 	. G ^
6581  5E4C 2B           	dec hl							; delay 6 clock cycles											;5e4c	2b 	+
6582  5E4D 23           	inc hl							; delay 6 clock cycles											;5e4d	23 	#
6583  5E4E 2B           	dec hl							; delay 6 clock cycles											;5e4e	2b 	+
6584  5E4F 23           	inc hl							; delay 6 clock cycles											;5e4f	23 	#
6585  5E50 2B           	dec hl							; delay 6 clock cycles											;5e50	2b 	+
6586  5E51 23           	inc hl							; delay 6 clock cycles											;5e51	23 	#
6587  5E52 00           	nop								; delay 4 clock cycles											;5e52	00 	.
6588  5E53 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5e53	3e 00 	> .
6589  5E55 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 2]		;5e55	db 11 	. .
6590  5E57              .waitClockBit6:
6591  5E57              ; -- wait for FDC Clock Pulse
6592  5E57 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5e57	ed 78 	. x
6593  5E59 F2 57 5E     	jp p,.waitClockBit6				; wait until Clock BIt = 1										;5e59	f2 57 5e 	. W ^
6594  5E5C 2B           	dec hl							; delay 6 clock cycles											;5e5c	2b 	+
6595  5E5D 23           	inc hl							; delay 6 clock cycles											;5e5d	23 	#
6596  5E5E 2B           	dec hl							; delay 6 clock cycles											;5e5e	2b 	+
6597  5E5F 23           	inc hl							; delay 6 clock cycles											;5e5f	23 	#
6598  5E60 2B           	dec hl							; delay 6 clock cycles											;5e60	2b 	+
6599  5E61 23           	inc hl							; delay 6 clock cycles											;5e61	23 	#
6600  5E62 00           	nop								; delay 4 clock cycles											;5e62	00 	.
6601  5E63 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5e63	3e 00 	> .
6602  5E65 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 1]		;5e65	db 11 	. .
6603  5E67              .waitClockBit7:
6604  5E67              ; -- wait for FDC Clock Pulse
6605  5E67 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5e67	ed 78 	. x
6606  5E69 F2 67 5E     	jp p,.waitClockBit7				; wait until Clock BIt = 1										;5e69	f2 67 5e 	. g ^
6607  5E6C 2B           	dec hl							; delay 6 clock cycles											;5e6c	2b 	+
6608  5E6D 23           	inc hl							; delay 6 clock cycles											;5e6d	23 	#
6609  5E6E 2B           	dec hl							; delay 6 clock cycles											;5e6e	2b 	+
6610  5E6F 23           	inc hl							; delay 6 clock cycles											;5e6f	23 	#
6611  5E70 2B           	dec hl							; delay 6 clock cycles											;5e70	2b 	+
6612  5E71 23           	inc hl							; delay 6 clock cycles											;5e71	23 	#
6613  5E72 00           	nop								; delay 4 clock cycles											;5e72	00 	.
6614  5E73 3E 00        	ld a,0							; delay 7 clock cycles	(47 in total)							;5e73	3e 00 	> .
6615  5E75 DB 11        	in a,(FLDATA)					; a - read byte from disk (shift FLDATA register) [bit 0]		;5e75	db 11 	. .
6616  5E77 08           	ex af,af'						; save a (byte from Floppy Disk) in alt register				;5e77	08 	.
6617  5E78              .waitClockBit8:
6618  5E78              ; -- wait for FDC Clock Pulse
6619  5E78 ED 78        	in a,(c)						; read Clock Bit from Flopy Drive								;5e78	ed 78 	. x
6620  5E7A F2 78 5E     	jp p,.waitClockBit8				; wait until Clock BIt = 1										;5e7a	f2 78 5e 	. x ^
6621  5E7D
6622  5E7D              ; -- We have Data byte from Disk
6623  5E7D
6624  5E7D 23           	inc hl							; increment address in Sector Buffer to store new Byte			;5e7d	23 	#
6625  5E7E 1D           	dec e							; decrement number of bytes to read from Disk					;5e7e	1d 	.
6626  5E7F 28 07        	jr z,RD_VerifyCRC				; if all read verify Sector Data Checksum						;5e7f	28 07 	( .
6627  5E81
6628  5E81              ; -- store Data Byte into Sector Buffer and read next byte
6629  5E81 08           	ex af,af'						; restore a - Data Byte from Disk								;5e81	08 	.
6630  5E82 77           	ld (hl),a						; store Data Byte in Sector Buffer								;5e82	77 	w
6631  5E83 ED 5F        	ld a,r							; delay 9 clock cycles											;5e83	ed 5f 	. _
6632  5E85 C3 05 5E     	jp RD_NextDataByte				; start read next Data Byte										;5e85	c3 05 5e 	. . ^
6633  5E88
6634  5E88              ;***************************************************************************************************
6635  5E88              ;
6636  5E88              ; Verify Sector Data Checksum
6637  5E88              ;
6638  5E88
6639  5E88              ; ---------- [7] --- read Track Number
6640  5E88
6641  5E88              RD_VerifyCRC:
6642  5E88 CD 10 5B     	call CalcSectorCRC				; de - sum of all 128 bytes from Sector Buffer					;5e88	cd 10 5b 	. . [
6643  5E8B 23           	inc hl							; hl - points to next byte from Disk (checksum LSB)				;5e8b	23 	#
6644  5E8C 7E           	ld a,(hl)						; a - checksum LSB from Disk									;5e8c	7e 	~
6645  5E8D BB           	cp e							; is equal to calculated ?										;5e8d	bb 	.
6646  5E8E 20 05        	jr nz,RD_Error					; no - try read again or exit with Error 10 - CHECKSUM ERROR	;5e8e	20 05 	  .
6647  5E90 23           	inc hl							; hl - points to next byte from Disk (checksum MSB)				;5e90	23 	#
6648  5E91 7E           	ld a,(hl)						; a - checksum MSB from Disk									;5e91	7e 	~
6649  5E92 BA           	cp d							; is equal to calculated ?										;5e92	ba 	.
6650  5E93 28 0D        	jr z,RS_ExitOK					; yes - exit with Error 0 - NO ERROR							;5e93	28 0d 	( .
6651  5E95
6652  5E95              RD_Error:
6653  5E95 FD 7E 13     	ld a,(iy+RETRY)					; a - number of read tries when CRC error 						;5e95	fd 7e 13 	. ~ .
6654  5E98 3D           	dec a							; decrement Try Counter	- is it already 0?						;5e98	3d 	=
6655  5E99 FD 77 13     	ld (iy+RETRY),a					; store back number of tries									;5e99	fd 77 13 	. w .
6656  5E9C C2 2B 5B     	jp nz,RD_StartRead				; no - start Read Sector again									;5e9c	c2 2b 5b 	. + [
6657  5E9F              ; -- no more try - exit with Error 10 - CHECKSUM ERROR
6658  5E9F 3E 0A        	ld a,10							; a - Error 10 - CHECKSUM ERROR									;5e9f	3e 0a 	> .
6659  5EA1 C9           	ret								; --------------------- End of Proc (with Error) --------------	;5ea1	c9 	.
6660  5EA2
6661  5EA2              RS_ExitOK:
6662  5EA2              ; -- Success
6663  5EA2 AF           	xor a							; a - Error 00 - NO ERROR										;5ea2	af 	.
6664  5EA3 C9           	ret								; --------------------- End of Proc ---------------------------	;5ea3	c9 	.
6665  5EA4
6666  5EA4
6667  5EA4
6668  5EA4              ;***************************************************************************************************
6669  5EA4              ; Wait for Break key released
6670  5EA4              ; IN: none
6671  5EA4              ; OUT: a - Error code (17) - BREAK pressed
6672  5EA4              WaitBreakKeyReleased:
6673  5EA4              ; -- wait until Break key is released
6674  5EA4 3A DF 68     	ld a,(BreakKeybRow)				; read Keyboard row with Break key								;5ea4	3a df 68 	: . h
6675  5EA7 E6 04        	and BreakKeybMask				; mask only BREAK key - if 0 -> Break is pressed				;5ea7	e6 04 	. .
6676  5EA9 28 F9        	jr z,WaitBreakKeyReleased		; yes - wait until released										;5ea9	28 f9 	( .
6677  5EAB              ; -- wait 20 ms
6678  5EAB C5           	push bc							; save bc														;5eab	c5 	.
6679  5EAC 01 14 00     	ld bc,20						; number of ms to wait											;5eac	01 14 00 	. . .
6680  5EAF CD BE 5E     	call DLY						; wait 20 ms delay												;5eaf	cd be 5e 	. . ^
6681  5EB2 C1           	pop bc							; restore bc 													;5eb2	c1 	.
6682  5EB3              ; -- confirm that Break key is released
6683  5EB3 3A DF 68     	ld a,(BreakKeybRow)				; read Keyboard row with Break key								;5eb3	3a df 68 	: . h
6684  5EB6 E6 04        	and BreakKeybMask				; mask only BREAK key - if 0 -> Break is pressed				;5eb6	e6 04 	. .
6685  5EB8 28 EA        	jr z,WaitBreakKeyReleased		; yes - wait until released										;5eb8	28 ea 	( .
6686  5EBA              ; -- Break key released - set Error Code and return
6687  5EBA 3E 11        	ld a,17							; a - Error 17 - BREAK											;5eba	3e 11 	> .
6688  5EBC B7           	or a							; clear CY flag													;5ebc	b7 	.
6689  5EBD C9           	ret								; -------------------- End of Proc ----------------------------	;5ebd	c9 	.
6690  5EBE
6691  5EBE
6692  5EBE
6693  5EBE
6694  5EBE              ;***************************************************************************************************
6695  5EBE              ; Delay n miliseconds
6696  5EBE              ; Routine is tuned for CPU running at 3.58 MHz
6697  5EBE              ;---------------------------------------------------------------------------------------------------
6698  5EBE              ; IN: BC - number of miliseconds to delay
6699  5EBE              ; OUT: none
6700  5EBE              ;***************************************************************************************************
6701  5EBE              DLY:
6702  5EBE C5           	push bc							; save bc - number of miliseconds								;5ebe	c5 	.
6703  5EBF              ; -- setup 1ms loop
6704  5EBF 01 89 00     	ld bc,137						; number of loop iteration per 1 ms								;5ebf	01 89 00 	. . .
6705  5EC2              .loop:
6706  5EC2 0B           	dec bc							; decrement loop counter										;5ec2	0b 	.
6707  5EC3 78           	ld a,b							; test if counter is 0											;5ec3	78 	x
6708  5EC4 B1           	or c							; is bc == 0 ?													;5ec4	b1 	.
6709  5EC5 20 FB        	jr nz,.loop						; no - continue loop											;5ec5	20 fb 	  .
6710  5EC7              ; -- decrement number of miliseconds of wait
6711  5EC7 C1           	pop bc							; restore bc - miliseconds counter								;5ec7	c1 	.
6712  5EC8 0B           	dec bc							; decrement miliseconds counter									;5ec8	0b 	.
6713  5EC9 78           	ld a,b							; test if counter is 0											;5ec9	78 	x
6714  5ECA B1           	or c							; is bc == 0 ?													;5eca	b1 	.
6715  5ECB 20 F1        	jr nz,DLY						; no - wait another milisecond									;5ecb	20 f1 	  .
6716  5ECD C9           	ret								; -------------------- End of Proc ----------------------------	;5ecd	c9 	.
6717  5ECE
6718  5ECE
6719  5ECE
6720  5ECE              ;***************************************************************************************************
6721  5ECE              ; Step the stepper N tracks inwards specified by register b
6722  5ECE              ;---------------------------------------------------------------------------------------------------
6723  5ECE              ; NOTE: Stepper Phase variable contains 4 bits values duplicated in high and low nibble
6724  5ECE              ; this way futher rotation operations used by StepIn and StepOut don't need any corrections
6725  5ECE              ; IN: b - how many tracks to stepin
6726  5ECE              ;***************************************************************************************************
6727  5ECE              STPIN:
6728  5ECE              ; -- calculate maximum number of tracks we can step in from current
6729  5ECE FD 7E 14     	ld a,(iy+DTRCK)					; a - current Track Number										;5ece	fd 7e 14 	. ~ .
6730  5ED1 80           	add a,b							; add number of tracks requested								;5ed1	80 	.
6731  5ED2 FE 28        	cp 40							; is final Track number >= 40?									;5ed2	fe 28 	. (
6732  5ED4 38 02        	jr c,.continue					; no - continue													;5ed4	38 02 	8 .
6733  5ED6
6734  5ED6              ; -- DOS supports only 40 tracks - force last one
6735  5ED6 3E 27        	ld a,39							; set final target Track number to 39							;5ed6	3e 27 	> '
6736  5ED8
6737  5ED8              .continue:
6738  5ED8 FD 77 14     	ld (iy+DTRCK),a					; set final number as current track number						;5ed8	fd 77 14 	. w .
6739  5EDB CB 20        	sla b							; b - physical steps needed (b * 2 steps per Track)				;5edb	cb 20 	.
6740  5EDD
6741  5EDD              .doStepIn:
6742  5EDD              ; -- calculate and store new Step Phase
6743  5EDD FD 7E 38     	ld a,(iy+PHASE)					; a - current Step Phase										;5edd	fd 7e 38 	. ~ 8
6744  5EE0 4F           	ld c,a							; c - save current Step Phase									;5ee0	4f 	O
6745  5EE1 07           	rlca							; rotate left to get next Phase (i.e. 0001 -> 0010)				;5ee1	07 	.
6746  5EE2
6747  5EE2              ; -- write Half-Step Phase to FDC (combined old and new bits)
6748  5EE2              ; -- example: when old Phase was 0001 and new Phase is 0010 then combined Phase is 0011
6749  5EE2 F5           	push af							; save a - new Step Phase										;5ee2	f5 	.
6750  5EE3 FD 77 38     	ld (iy+PHASE),a					; set new value as current Step Phase							;5ee3	fd 77 38 	. w 8
6751  5EE6 B1           	or c							; a - combine old and new values to Half-Step Phase				;5ee6	b1 	.
6752  5EE7              ; -- write Step Phase
6753  5EE7 CD 32 5F     	call WriteStepPhase				; write Half-Step to FDC - move Disk Head						;5ee7	cd 32 5f 	. 2 _
6754  5EEA              ; -- delay 2 ms
6755  5EEA C5           	push bc							; save bc - physical steps needed								;5eea	c5 	.
6756  5EEB 01 02 00     	ld bc,2							; number of miliseconds to delay								;5eeb	01 02 00 	. . .
6757  5EEE CD BE 5E     	call DLY						; delay 2 ms 													;5eee	cd be 5e 	. . ^
6758  5EF1 C1           	pop bc							; restore bc - physical steps needed							;5ef1	c1 	.
6759  5EF2              ; -- write Step Phase
6760  5EF2 F1           	pop af							; restore a - new Step Phase									;5ef2	f1 	.
6761  5EF3 CD 32 5F     	call WriteStepPhase				; write new Step Phase to FDC - move Disk Head					;5ef3	cd 32 5f 	. 2 _
6762  5EF6              ; -- delay 14 ms
6763  5EF6 C5           	push bc							; save bc - physical steps needed								;5ef6	c5 	.
6764  5EF7 01 0E 00     	ld bc,14						; number of miliseconds to delay								;5ef7	01 0e 00 	. . .
6765  5EFA CD BE 5E     	call DLY						; delay 14 ms													;5efa	cd be 5e 	. . ^
6766  5EFD C1           	pop bc							; restore bc - physical steps needed							;5efd	c1 	.
6767  5EFE 10 DD        	djnz .doStepIn					; continue to Step-in required times							;5efe	10 dd 	. .
6768  5F00 C9           	ret								; ----------------------- End of Proc -------------------------	;5f00	c9 	.
6769  5F01
6770  5F01
6771  5F01
6772  5F01              ;***************************************************************************************************
6773  5F01              ; Step the stepper N tracks outwards specified by register b
6774  5F01              ;---------------------------------------------------------------------------------------------------
6775  5F01              ; NOTE: Stepper Phase variable contains 4 bits values duplicated in high and low nibble
6776  5F01              ; this way futher rotation operations used by StepIn and StepOut don't need any corrections
6777  5F01              ; IN: b - how many tracks to step out
6778  5F01              ;***************************************************************************************************
6779  5F01              STPOUT:
6780  5F01              ; -- calculate maximum number of tracks we can step out from current
6781  5F01 FD 7E 14     	ld a,(iy+DTRCK)					; a - current Track Number										;5f01	fd 7e 14 	. ~ .
6782  5F04 90           	sub b							; subtract number of tracks requested - is result < 0 ?			;5f04	90 	.
6783  5F05 F2 09 5F     	jp p,.continue					; no - continue													;5f05	f2 09 5f 	. . _
6784  5F08
6785  5F08              ; -- DOS supports tracks from 0 to 39 - force first one
6786  5F08 AF           	xor a							; set final target Track number to 0							;5f08	af 	.
6787  5F09
6788  5F09              .continue:
6789  5F09 FD 77 14     	ld (iy+DTRCK),a					; set final number as current track number						;5f09	fd 77 14 	. w .
6790  5F0C CB 20        	sla b							; b - physical steps needed (b * 2 steps per Track)				;5f0c	cb 20 	.
6791  5F0E
6792  5F0E              .doStepOut:
6793  5F0E              ; -- calculate and store new Step Phase
6794  5F0E FD 7E 38     	ld a,(iy+PHASE)					; a - current Step Phase										;5f0e	fd 7e 38 	. ~ 8
6795  5F11 4F           	ld c,a							; c - save current Step Phase									;5f11	4f 	O
6796  5F12 0F           	rrca							; rotate right to get next Phase (i.e. 0100 -> 0010)			;5f12	0f 	.
6797  5F13
6798  5F13              ; -- write Half-Step Phase to FDC (combined old and new bits)
6799  5F13              ; -- example: when old Phase was 0100 and new Phase is 0010 then combined Phase is 0110
6800  5F13 F5           	push af							; save a - new Step Phase										;5f13	f5 	.
6801  5F14 FD 77 38     	ld (iy+PHASE),a					; set new value as current Step Phase							;5f14	fd 77 38 	. w 8
6802  5F17 B1           	or c							; a - combine old and new values to Half-Step Phase				;5f17	b1 	.
6803  5F18              ; -- write Step Phase
6804  5F18 CD 32 5F     	call WriteStepPhase				; write Half-Step to FDC - move Disk Head						;5f18	cd 32 5f 	. 2 _
6805  5F1B              ; -- delay 2 ms
6806  5F1B C5           	push bc							; save bc - physical steps needed								;5f1b	c5 	.
6807  5F1C 01 02 00     	ld bc,2							; number of miliseconds to delay								;5f1c	01 02 00 	. . .
6808  5F1F CD BE 5E     	call DLY						; delay 2 ms 													;5f1f	cd be 5e 	. . ^
6809  5F22 C1           	pop bc							; restore bc - physical steps needed							;5f22	c1 	.
6810  5F23              ; -- write Step Phase
6811  5F23 F1           	pop af							; restore a - new Step Phase									;5f23	f1 	.
6812  5F24 CD 32 5F     	call WriteStepPhase				; write new Step Phase to FDC - move Disk Head					;5f24	cd 32 5f 	. 2 _
6813  5F27 C5           	push bc							; save bc - physical steps needed								;5f27	c5 	.
6814  5F28 01 0E 00     	ld bc,14						; number of miliseconds to delay								;5f28	01 0e 00 	. . .
6815  5F2B CD BE 5E     	call DLY						; delay 14 ms 													;5f2b	cd be 5e 	. . ^
6816  5F2E C1           	pop bc							; restore bc - physical steps needed							;5f2e	c1 	.
6817  5F2F 10 DD        	djnz .doStepOut					; continue to Step-out required times							;5f2f	10 dd 	. .
6818  5F31 C9           	ret								; ----------------------- End of Proc -------------------------	;5f31	c9 	.
6819  5F32
6820  5F32
6821  5F32              ;***************************************************************************************************
6822  5F32              ; Write new Step Phase bits to Floppy Disk COntroller
6823  5F32              ; IN: a - new Step Phase in lower 4 bits
6824  5F32              WriteStepPhase:
6825  5F32 E6 0F        	and FL_STEPPER_MASK				; only lower 4 bits of value									;5f32	e6 0f 	. .
6826  5F34 4F           	ld c,a							; c - new Step Phase bits										;5f34	4f 	O
6827  5F35 3E F0        	ld a,%11110000					; mask to select only high 4 bits								;5f35	3e f0 	> .
6828  5F37 FD A6 33     	and (iy+LTHCPY)					; a - FLCtrl last value w/o Step Phase bits						;5f37	fd a6 33 	. . 3
6829  5F3A B1           	or c							; a - add new Step Phase bits									;5f3a	b1 	.
6830  5F3B FD 77 33     	ld (iy+LTHCPY),a				; store FLCtrl to shadow register								;5f3b	fd 77 33 	. w 3
6831  5F3E D3 10        	out (FLCTRL),a					; set Flopy Control byte										;5f3e	d3 10 	. .
6832  5F40 C9           	ret								; ------------------ End of Proc ------------------------------	;5f40	c9 	.
6833  5F41
6834  5F41
6835  5F41              ;***************************************************************************************************
6836  5F41              ; Disk power ON
6837  5F41              ; --------------------------------------------------------------------------------------------------
6838  5F41              ; Turn ON the power of the drive selected in DOS vector IY+DK.
6839  5F41              ; IN: IY+DK: $10 - Drive 1 selected, $80 - Drive 2 selected
6840  5F41              ; OUT: ---
6841  5F41              ; Registers affected: A
6842  5F41              ;***************************************************************************************************
6843  5F41              PWRON:
6844  5F41              ; -- get current state of FDD Step Motor
6845  5F41 FD 7E 38     	ld a,(iy+PHASE)					; get current Step Motor Phase									;5f41	fd 7e 38 	. ~ 8
6846  5F44 E6 0F        	and FL_STEPPER_MASK				; only 4 low bits												;5f44	e6 0f 	. .
6847  5F46              ; -- add bits sent before to Floppy Drive Control Register
6848  5F46 FD B6 33     	or (iy+LTHCPY)					; add last byte sent to FLCtrl 									;5f46	fd b6 33 	. . 3
6849  5F49              ; -- select drive
6850  5F49 FD B6 0B     	or (iy+DK)						; set bit for selected drive 									;5f49	fd b6 0b 	. . .
6851  5F4C              ; -- write new parameters to Control register and it's shadow
6852  5F4C FD 77 33     	ld (iy+LTHCPY),a				; store FLCtrl to shadow register								;5f4c	fd 77 33 	. w 3
6853  5F4F D3 10        	out (FLCTRL),a					; set Flopy Control byte										;5f4f	d3 10 	. .
6854  5F51 C9           	ret								; ------------------ End of Proc ------------------------------	;5f51	c9 	.
6855  5F52
6856  5F52
6857  5F52              ;***************************************************************************************************
6858  5F52              ; Disk power OFF
6859  5F52              ;---------------------------------------------------------------------------------------------------
6860  5F52              ; Turn OFF the power to the disk.
6861  5F52              ; Both disks are turned OFF no matter which one was selected in iy+DK.
6862  5F52              ; IN: ---
6863  5F52              ; OUT: ---
6864  5F52              ;***************************************************************************************************
6865  5F52              PWROFF:
6866  5F52              ; -- get bits sent before to Floppy Drive Control Register
6867  5F52 FD 7E 33     	ld a,(iy+LTHCPY)				; get last byte sent to FLCtrl 									;5f52	fd 7e 33 	. ~ 3
6868  5F55              ; -- clear WriteReq bit (deactivate)
6869  5F55 F6 40        	or FL_WRITE_REQ					; set bit 6 - Write Request (inactive)							;5f55	f6 40 	. @
6870  5F57              ; -- disable drive D1 and D2 and set Step Motor Phase to 0-0-0-0
6871  5F57 E6 60        	and %01100000					; clear all bits except WriteReq and Write Data					;5f57	e6 60 	. `
6872  5F59              ; -- write new parameters to Control register and it's shadow
6873  5F59 FD 77 33     	ld (iy+LTHCPY),a				; store FLCtrl to shadow register								;5f59	fd 77 33 	. w 3
6874  5F5C D3 10        	out (FLCTRL),a					; set Flopy Control byte										;5f5c	d3 10 	. .
6875  5F5E C9           	ret								; ------------------ End of Proc ------------------------------	;5f5e	c9 	.
6876  5F5F
6877  5F5F
6878  5F5F              ;***************************************************************************************************
6879  5F5F              ; END
6880  5F5F 00 00 00...  	ds	30, $00						;5f5f	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	.
6881  5F7D              									;5f6f	00 00 00 00 00 00 00 00 00 00 00 00 00 00 	.
6882  5F7D FF FF FF...  	ds  131, $ff					;5f7d	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 	.
6883  6000              									;5f8d	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 	.
6884  6000              									;5f9d	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 	.
6885  6000              									;5fad	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 	.
6886  6000              									;5fbd	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 	.
6887  6000              									;5fcd	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 	.
6888  6000              									;5fdd	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 	.
6889  6000              									;5fed	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 	.
6890  6000              									;5ffd	ff ff ff 	.
6891  6000
# file closed: vzdos.asm

Value    Label
------ - -----------------------------------------------------------
0x5F0E   STPOUT.doStepOut
0x5F09   STPOUT.continue
0x5F32   WriteStepPhase
0x5EDD   STPIN.doStepIn
0x5ED8   STPIN.continue
0x5EC2   DLY.loop
0x5EA2   RS_ExitOK
0x5E95   RD_Error
0x5E88   RD_VerifyCRC
0x5E78   RD_NextDataByte.waitClockBit8
0x5E67   RD_NextDataByte.waitClockBit7
0x5E57   RD_NextDataByte.waitClockBit6
0x5E47   RD_NextDataByte.waitClockBit5
0x5E37   RD_NextDataByte.waitClockBit4
0x5E27   RD_NextDataByte.waitClockBit3
0x5E17   RD_NextDataByte.waitClockBit2
0x5E07   RD_NextDataByte.waitClockBit1
0x5DFE X RD_DataByte
0x5DF3   RD_IDAM_FE.waitClockBit8
0x5DE2   RD_IDAM_FE.waitClockBit7
0x5DD2   RD_IDAM_FE.waitClockBit6
0x5DC2   RD_IDAM_FE.waitClockBit5
0x5DA2   RD_IDAM_FE.waitClockBit3
0x5D92   RD_IDAM_FE.waitClockBit2
0x5D82   RD_IDAM_FE.waitClockBit1
0x5D79 X RD_IDAM_FE
0x5D6E   RD_IDAM_E7.waitClockBit8
0x5D5D   RD_IDAM_E7.waitClockBit7
0x5D4D   RD_IDAM_E7.waitClockBit6
0x5D3D   RD_IDAM_E7.waitClockBit5
0x5D2D   RD_IDAM_E7.waitClockBit4
0x5D1D   RD_IDAM_E7.waitClockBit3
0x5D0D   RD_IDAM_E7.waitClockBit2
0x5CFD   RD_IDAM_E7.waitClockBit1
0x5CF4 X RD_IDAM_E7
0x5CE9   RD_IDAM_18.waitClockBit8
0x5CD8   RD_IDAM_18.waitClockBit7
0x5CC8   RD_IDAM_18.waitClockBit6
0x5CB8   RD_IDAM_18.waitClockBit5
0x5CA8   RD_IDAM_18.waitClockBit4
0x5C98   RD_IDAM_18.waitClockBit3
0x5C88   RD_IDAM_18.waitClockBit2
0x5C78   RD_IDAM_18.waitClockBit1
0x5C6F X RD_IDAM_18
0x5C64   RD_IDAM_C3.waitClockBit8
0x5C53   RD_IDAM_C3.waitClockBit7
0x5C43   RD_IDAM_C3.waitClockBit6
0x5C33   RD_IDAM_C3.waitClockBit5
0x5C23   RD_IDAM_C3.waitClockBit4
0x5C13   RD_IDAM_C3.waitClockBit3
0x5C03   RD_IDAM_C3.waitClockBit2
0x5BF3   RD_IDAM_C3.waitClockBit1
0x5BEA X RD_IDAM_C3
0x5BDF   RD_WaitFor80.waitClockBit8
0x5BCE   RD_WaitFor80.waitClockBit7
0x5BBE   RD_WaitFor80.waitClockBit6
0x5BAE   RD_WaitFor80.waitClockBit5
0x5B9E   RD_WaitFor80.waitClockBit4
0x5B8E   RD_WaitFor80.waitClockBit3
0x5B7E   RD_WaitFor80.waitClockBit2
0x5B6E   RD_WaitFor80.waitClockBit1
0x5B65   RD_WaitFor80.readByte
0x5B5A   RD_WaitFor80.waitClockBit
0x5B50   RD_WaitFor80
0x5B47   RD_ReadyRead.waitClockBit
0x5B42   RD_BreakExit
0x5B45   RD_ReadyRead
0x5B37   RD_StartRead.sectorFound
0x5B2B   RD_StartRead
0x5B1C   CalcSectorCRC.addNext
0x5AFF   WR_WriteByte.nextByte
0x5AE9 X WR_WriteByte.writeBit0_1
0x5ADF   WR_WriteByte.writeBit0Cell
0x5ADC   WR_WriteByte.delayBit1
0x5AD8   WR_WriteByte.contBit1
0x5AC2 X WR_WriteByte.writeBit1_1
0x5ACD   WR_WriteByte.writeBit1_0
0x5AB8   WR_WriteByte.writeBit1Cell
0x5AB5   WR_WriteByte.delayBit2
0x5AB1   WR_WriteByte.contBit2
0x5A9B X WR_WriteByte.writeBit2_1
0x5AA6   WR_WriteByte.writeBit2_0
0x5A91   WR_WriteByte.writeBit2Cell
0x5A8E   WR_WriteByte.delayBit3
0x5A8A   WR_WriteByte.contBit3
0x5A74 X WR_WriteByte.writeBit3_1
0x5A7F   WR_WriteByte.writeBit3_0
0x5A6A   WR_WriteByte.writeBit3Cell
0x5A67   WR_WriteByte.delayBit4
0x5A63   WR_WriteByte.contBit4
0x5A4D X WR_WriteByte.writeBit4_1
0x5A58   WR_WriteByte.writeBit4_0
0x5A43   WR_WriteByte.writeBit4Cell
0x5A40   WR_WriteByte.delayBit5
0x5A3C   WR_WriteByte.contBit5
0x5A26 X WR_WriteByte.writeBit5_1
0x5A31   WR_WriteByte.writeBit5_0
0x5A1C   WR_WriteByte.writeBit5Cell
0x5A19   WR_WriteByte.delayBit6
0x5A15   WR_WriteByte.contBit6
0x59FF X WR_WriteByte.writeBit6_1
0x5A0A   WR_WriteByte.writeBit6_0
0x59F5   WR_WriteByte.writeBit6Cell
0x59F2   WR_WriteByte.delayBit7
0x59EE   WR_WriteByte.contBit7
0x59D8 X WR_WriteByte.writeBit7_1
0x59E3   WR_WriteByte.writeBit7_0
0x59CF   WR_WriteByte
0x59C6   WRITE.setWriteReqActive
0x5B10   CalcSectorCRC
0x598E   FIND.nextDirEntry
0x5985   FIND.checkDirEntry
0x5976   FIND.readNextSector
0x5945   SEARCH.compareNextChar
0x5953   SEARCH.nextDirEntry
0x5934   SEARCH.compareEntry
0x5921   SEARCH.readNextSector
0x590C   MAP.rotateBack
0x58E0   MAP.checkNextBit1
0x58FF   MAP.markSectorUsed
0x58D0   MAP.checkNextBit
0x58CE   MAP.nextMapByte
0x5884   CREATE.checkSpace
0x5865   IDAM_Read_Crc.waitClockBit7
0x5855   IDAM_Read_Crc.waitClockBit6
0x5845   IDAM_Read_Crc.waitClockBit5
0x5835   IDAM_Read_Crc.waitClockBit4
0x5825   IDAM_Read_Crc.waitClockBit3
0x5815   IDAM_Read_Crc.waitClockBit2
0x5805   IDAM_Read_Crc.waitClockBit1
0x5801   IDAM_Read_Crc.continue1
0x57FB   IDAM_Read_Crc
0x57E9   IDAM_Read_SecNo.waitClockBit8
0x57E6   IDAM_Read_SecNo.continue2
0x57E3   IDAM_Read_SecNo.continue1
0x57D6   IDAM_Read_SecNo.waitClockBit7
0x57C6   IDAM_Read_SecNo.waitClockBit6
0x57B6   IDAM_Read_SecNo.waitClockBit5
0x57A6   IDAM_Read_SecNo.waitClockBit4
0x5796   IDAM_Read_SecNo.waitClockBit3
0x5786   IDAM_Read_SecNo.waitClockBit2
0x5776   IDAM_Read_SecNo.waitClockBit1
0x5772   IDAM_Read_SecNo.continue
0x576C   IDAM_Read_SecNo
0x575B   IDAM_Read_TrkNo.waitClockBit8
0x5758   IDAM_Read_TrkNo.continue2
0x5755   IDAM_Read_TrkNo.continue1
0x5DB2   RD_IDAM_FE.waitClockBit4
0x5748   IDAM_Read_TrkNo.waitClockBit7
0x5738   IDAM_Read_TrkNo.waitClockBit6
0x5728   IDAM_Read_TrkNo.waitClockBit5
0x5718   IDAM_Read_TrkNo.waitClockBit4
0x5708   IDAM_Read_TrkNo.waitClockBit3
0x56F8   IDAM_Read_TrkNo.waitClockBit2
0x56E8   IDAM_Read_TrkNo.waitClockBit1
0x56DF X IDAM_Read_TrkNo
0x56D4   IDAM_Read_C3.waitClockBit8
0x56C3   IDAM_Read_C3.waitClockBit7
0x56B3   IDAM_Read_C3.waitClockBit6
0x56A3   IDAM_Read_C3.waitClockBit5
0x5693   IDAM_Read_C3.waitClockBit4
0x5683   IDAM_Read_C3.waitClockBit3
0x5673   IDAM_Read_C3.waitClockBit2
0x5663   IDAM_Read_C3.waitClockBit1
0x565A X IDAM_Read_C3
0x564F   IDAM_Read_18.waitClockBit8
0x563E   IDAM_Read_18.waitClockBit7
0x562E   IDAM_Read_18.waitClockBit6
0x561E   IDAM_Read_18.waitClockBit5
0x560E   IDAM_Read_18.waitClockBit4
0x55FE   IDAM_Read_18.waitClockBit3
0x55EE   IDAM_Read_18.waitClockBit2
0x55DE   IDAM_Read_18.waitClockBit1
0x55D5 X IDAM_Read_18
0x55CA   IDAM_Read_E7.waitClockBit8
0x55B9   IDAM_Read_E7.waitClockBit7
0x55A9   IDAM_Read_E7.waitClockBit6
0x5599   IDAM_Read_E7.waitClockBit5
0x5589   IDAM_Read_E7.waitClockBit4
0x5579   IDAM_Read_E7.waitClockBit3
0x5569   IDAM_Read_E7.waitClockBit2
0x5559   IDAM_Read_E7.waitClockBit1
0x5550 X IDAM_Read_E7
0x5545   IDAM_Read_FE.waitClockBit8
0x5534   IDAM_Read_FE.waitClockBit7
0x5524   IDAM_Read_FE.waitClockBit6
0x5514   IDAM_Read_FE.waitClockBit5
0x5504   IDAM_Read_FE.waitClockBit4
0x54F4   IDAM_Read_FE.waitClockBit3
0x54E4   IDAM_Read_FE.waitClockBit2
0x54D4   IDAM_Read_FE.waitClockBit1
0x54CB X IDAM_Read_FE
0x54C0   IDAM_WaitFor80.waitClockBit8
0x54AF   IDAM_WaitFor80.waitClockBit7
0x549F   IDAM_WaitFor80.waitClockBit6
0x548F   IDAM_WaitFor80.waitClockBit5
0x547F   IDAM_WaitFor80.waitClockBit4
0x546F   IDAM_WaitFor80.waitClockBit3
0x545F   IDAM_WaitFor80.waitClockBit2
0x544F   IDAM_WaitFor80.waitClockBit1
0x5446   IDAM_WaitFor80.readByte
0x543B   IDAM_WaitFor80.waitClockBit
0x5431   IDAM_WaitFor80
0x5428   IDAM_TrackIsSet.wait
0x5EA4   WaitBreakKeyReleased
0x540E   IDAM_BreakExit
0x5411   IDAM_NeedStepIn
0x541D   IDAM_TrackIsSet
0x53F0   ResetTrackTo0
0x53FB   IDAM_SetTrack
0x53E8   HEX.exit
0x53DF   HEX.tryAtoF
0x53D5   HEX.conv1Char
0x53C1   HEX.conv2Chars
0x53AA   ParseFilename.checkNext
0x53B5   ParseFilename.exitNoErrPopIY
0x539B   ParseFilename.copyNext
0x5396   ParseFilename.exitSyntaxError
0x5399   ParseFilename.copyChars
0x5386   ParseFilename.skipSpaces
0x537C   ParseFilename.next
0x5359   MSG_KBytesFree
0x533C   l533ch
0x534A   MSG_RecordsFree
0x5310 X l5310h
0x5308   l5308h
0x5303   l5303h
0x5302 X l5302h
0x5300   l5300h
0x52B7   TXT_INSERTDSTDISK
0x5268   l5268h
0x524B   l524bh
0x523C   l523ch
0x522F   WaitUserReady.wait
0x529D   TXT_PRESSSPACEREADY
0x5226   WaitUserReady
0x5284   TXT_INSERTSRCDISK
0x51E2   l51dah.waitKeysReleased
0x51DA   l51dah
0x51CB   GetDriveNoInput.l51cbh
0x51AE   GetDriveNoInput.waitForINTEnd
0x519F   GetDriveNoInput.waitForINT
0x5192   GetDriveNoInput
0x51EC   TXT_ASKSOURCEDISK
0x50F1   DCmdDCOPY.writeNextSector
0x50CB   DCmdDCOPY.writeTracks
0x5091   DCmdDCOPY.readNextSector
0x5083   DCmdDCOPY.readTracks
0x5137   DCmdDCOPY.cleanAndExit
0x5275   SelectDstDrive
0x5162   ClearAndError
0x5039   DCmdDCOPY.fileFound
0x5168   AskUserForSrcAndDst
0x505D   DCmdDCOPY.copyWholeDisk
0x4F9C   WriteCharToDataFile.exit
0x4F0C   WriteCharToDataFile.writeByte
0x4EC1   WriteStrToDataFile.next
0x4ECA   WriteCharToDataFile
0x4EBA   WriteStrToDataFile
0x4EA6   DCmdPR#.writeStringFromACC
0x4EB7   DCmdPR#.parseNextChar
0x4EB3   DCmdPR#.writeComma
0x4E81   DCmdPR#.nextOrExit
0x4EAC   DCmdPR#.writeCR
0x4E7C   DCmdPR#.nextExpression
0x4E5F   DCmdIN#.returnLastByte
0x4E5A   DCmdIN#.returnByte
0x4E1A   DCmdIN#.continue
0x4DF2   DCmdIN#.evalExprToVariable
0x4DF9   DCmdIN#.getCharFromFile
0x4DE7   DCmdIN#.nextChar
0x4DE2   DCmdIN#.readyToRead
0x4D8D   SelectDriveNo.selectDrive2
0x4D84   SelectDriveNo
0x4D3B   DI_ExitOK
0x4D45   DI_ExitError
0x4D14   DI_VerifySector
0x4D10   DI_VerifyTrack
0x4CF9   DI_VerifyDisk
0x4CC0   DI_WriteByte.nextByte
0x4CAA X DI_WriteByte.writeBit0_1
0x4CB5   DI_WriteByte.writeBit0_0
0x4CA0   DI_WriteByte.writeBit0Cell
0x4C9D   DI_WriteByte.delayBit1
0x4C99   DI_WriteByte.contBit1
0x4C83 X DI_WriteByte.writeBit1_1
0x4C8E   DI_WriteByte.writeBit1_0
0x4C79   DI_WriteByte.writeBit1Cell
0x4C76   DI_WriteByte.delayBit2
0x4C72   DI_WriteByte.contBit2
0x4C5C X DI_WriteByte.writeBit2_1
0x4C67   DI_WriteByte.writeBit2_0
0x4C52   DI_WriteByte.writeBit2Cell
0x5200   TXT_ASKDESTDISK
0x4C4F   DI_WriteByte.delayBit3
0x4C4B   DI_WriteByte.contBit3
0x4C35 X DI_WriteByte.writeBit3_1
0x4C40   DI_WriteByte.writeBit3_0
0x4C2B   DI_WriteByte.writeBit3Cell
0x4C28   DI_WriteByte.delayBit4
0x4C24   DI_WriteByte.contBit4
0x4C0E X DI_WriteByte.writeBit4_1
0x4C19   DI_WriteByte.writeBit4_0
0x4C04   DI_WriteByte.writeBit4Cell
0x4C01   DI_WriteByte.delayBit5
0x4BFD   DI_WriteByte.contBit5
0x4BE7 X DI_WriteByte.writeBit5_1
0x4BF2   DI_WriteByte.writeBit5_0
0x4BDD   DI_WriteByte.writeBit5Cell
0x4BDA   DI_WriteByte.delayBit6
0x4BD6   DI_WriteByte.contBit6
0x4BC0 X DI_WriteByte.writeBit6_1
0x4BCB   DI_WriteByte.writeBit6_0
0x4BB6   DI_WriteByte.writeBit6Cell
0x4BB3   DI_WriteByte.delayBit7
0x4BAF   DI_WriteByte.contBit7
0x4B99 X DI_WriteByte.writeBit7_1
0x4BA4   DI_WriteByte.writeBit7_0
0x4B90   DI_WriteByte
0x4B85   DI_WriteSector
0x5AF4   WR_WriteByte.writeBit0_0
0x4D67   SectorsSequence
0x4B67   DI_WriteTrack
0x4D4F   SecHeaderInitData
0x4ACE   DCmdREN.newFilenameNotFound
0x4ABD   DCmdREN.oldFilenameFound
0x4A48   DCmdERA.loop2
0x4A3F   DCmdERA.loop1
0x4A4F   DCmdERA.saveDiskMap
0x49F7   DCmdERA.nextFileSector
0x49C0   DCmdERA.fileFound
0x497A   DCmdDIR.waitKeyRelAgain
0x496B   DCmdDIR.waitKeyPressed
0x495C   DCmdDIR.waitKeyReleased
0x4981   DCmdDIR.moveToNextEntry
0x4940   DCmdDIR.printNextChar
0x494C   DCmdDIR.testSPACEPress
0x493E   DCmdDIR.printFilename
0x498F   DCmdDIR.exit
0x492E   DCmdDIR.printDirEntry
0x491B   DCmdDIR.nextSector
0x48B6   SAVE_ExitError.exitWithError
0x4874   DCmdBSAVE.continue
0x48B7   BS_ExitError
0x47F7   DCmdCLOSE.fromBasicProg
0x47D7   FCBHandlesFile.returnNotOpen
0x47C6   FCBHandlesFile.nextChar
0x47A9   FindFCBForOpen.exitError
0x47AC   l47ach
0x47BF   FCBHandlesFile
0x4790   FindFCBForOpen.checkFCB2
0x4738   ClearDataBuffer
0x4703   DCmdOPEN.updateFCBexit
0x46D9   DCmdOPEN.lastSecFound
0x46BA   DCmdOPEN.readNextSector
0x46A8   DCmdOPEN.exitError
0x46B9   DCmdOPEN.seekEndOfFile
0x466B   DCmdOPEN.fileNotExists
0x4FA5   FlushSectorData
0x4778   FindFCBForOpen
0x460E   DCmdOPEN.continue
0x5378   ParseFilename
0x4562   DoSaveFile.loop2
0x4559   DoSaveFile.loop1
0x4530   DoSaveFile.flushSector
0x4576   DoSaveFile.partialSector
0x453A   DoSaveFile.writeLastSector
0x44E2   DoSaveFile.checkOtherError
0x457C   DoSaveFile.finalizeSave
0x44B3   DoSaveFile.writeNextChunk
0x489A   SAVE_ExitError
0x4479   DoSaveFile
0x4430   LoadProgramData.loadLastChunk
0x4441   LoadProgramData.exitError
0x43F3   LoadProgramData.loadFileChunk
0x43D3   LoadProgramData
0x53B7   ParseFilename.exitNoError
0x43CA   LOAD.verifyType
0x52D5   DCmdSTATUS
0x4FFB   DCmdDCOPY
0x4E64   DCmdPR#
0x4D92   DCmdIN#
0x4D78   DCmdDRIVE
0x4B08   DCmdINIT
0x4A80   DCmdREN
0x4994   DCmdERA
0x4906   DCmdDIR
0x5E05   RD_NextDataByte
0x48EF   DCmdBRUN
0x48C4   DCmdBLOAD
0x4839   DCmdBSAVE
0x47DD   DCmdCLOSE
0x45F5   DCmdOPEN
0x444E   DCmdSAVE
0x4391   DCmdLOAD
0x4371   DOSCmdPointers
0x4306   ParseCmdText.compareNext
0x42F6   ParseCmdText.searchNext
0x42F4   ParseCmdText.compareCmd
0x432E   DOSCmdNames
0x4315   ExecIdxDOSCmd
0x42EB   TryParseMixedSyntax.backToROM
0x42DC   TryParseMixedSyntax.checkDCOPY
0x42C9   TryParseMixedSyntax
0x4326   ExecDOSCmd
0x45DB   LoadAndRunFile
0x42C5   DOSCheckNextChar.backToROM
0x42B0   DOSCheckNextChar.parse_RUN
0x42EF   ParseCmdText
0x42A6   DOSCheckNextChar.exit
0x42A8   DOSCheckNextChar.startParse
0x428A   ERROR.GotoBASICBreak
0x4281   ERROR.GotoBASICReady
0x5144   ClearBASIC
0x4232   ERR_IllegalWrite
0x4224   ERR_IllegalRead
0x4212   ERR_DiskBufferFull
0x4202   ERR_FileNotFound
0x41EE   ERR_FileTypeMismatch
0x41DA   ERR_UnsupportedDevice
0x41C7   ERR_FileAlreadyOpen
0x41BC   ERR_DiskFull
0x41AC   ERR_DiskIOError
0x419D   ERR_FileNotOpen
0x4187   ERR_DiskWriteProtected
0x4177   ERR_DirectoryFull
0x4162   ERR_FileAlreadyExists
0x4126   ErrorsTable
0x410F   DOSInit.finish
0x4113   TxtDosBasic12
0x4293   DOSCheckNextChar
0x4D5D   SectorGAP2Data
0x4144   ERR_InsufficientMemoryForDOS
0x406A   DOSInit.continue
0x446E   SAVE
0x43B1   LOAD
0x5F01   STPOUT
0x5ECE   STPIN
0x5EBE   DLY
0x5B27   READ
0x59A1   WRITE
0x5968   FIND
0x5913   SEARCH
0x58BF   MAP
0x587B   CREATE
0x53EA   IDAM
0x53B9   HEX
0x5367   CSI
0x4B08   INIT
0x4754   SVMAP
0x4749   CLEAR
0x4717   RDMAP
0x4241   ERROR
0x5F52   PWROFF
0x5F41   PWRON
0x4047   DOSInit
0x00E7   MapBuffer
0x00CF X Unknown
0x00CD   SectorCRCBuf
0x004D   SectorBuffer
0x0043   SectorHeader
0x003A X RESVE
0x0039   DCPYF
0x0038   PHASE
0x0037   TRKPTR
0x0036   TRKCNT
0x0034   MAPADR
0x0033   LTHCPY
0x0031   DBFR
0x0024   FCB2
0x0017   FCB1
0x0016   NTRK
0x0015   NSCT
0x0014   DTRCK
0x0013   RETRY
0x0012   TRCK
0x0011   SCTR
0x0010   DESTIN
0x000E   UBFR
0x000D   SOURCE
0x000C   RQST
0x000B   DK
0x0009   TYPE
0x0001   FNAM
0x0000   FILNO
0x4FBB   FlushSectorData.flushSector
0x000D X FCBLENGTH
0x000C X FCB_PTR
0x000B X FCB_SCTRNO
0x000A X FCB_TRKN0
0x0002 X FCB_FNAM
0x0001 X FCB_ACCESS
0x0000 X FCB_OPENFLAG
0x0080 X FL_DRV_2_ENABLE
0x0040   FL_WRITE_REQ
0x0020   FL_WRITE_DATA
0x0010 X FL_DRV_1_ENABLE
0x000F   FL_STEPPER_MASK
0x0013   FLWRPROT
0x0012   FLPOOL
0x0011   FLDATA
0x0010   FLCTRL
0x1929   TXT_READY
0x1E4A   SysErrRaiseFuncCode
0x21BD   SysExecINPUTProc
0x29DA   SysGetStrVarPtr
0x2865   SysStrToACC
0x09C4   SysStrVarToBCD
0x0FBD   SysNumToStr
0x2337   SysEvalBasicExpr
0x2B1C   SysEvalByteExpr
0x2828   SysCheckIllegalDirect
0x1AE8   SysSetPrgReady
0x1D1E   SysParseNextExpr
0x36E9   SysExecRUN
0x5219   sub_5219h
0x1D78   SysCheckNextChar
0x0FA7   PrintMsg_IN_LINE
0x1B4D   SysBASICDeletePrg
0x1B9A   SysBASICReset
0x1DA0   SysBASICStop
0x1997   SysRaiseSyntaxError
0x19A2   SysRaiseError
0x1A19   SysStartBASIC
0x28A7   SysMsgOut
0x20F9   SysNewLine
0x032A   SysPrintChar
0x7921   SYS_ACC
0x7AAF   EditBufCounter
0x78EC   EditLineNumber
0x78EA   ErrorLineNumber
0x78A9   CmdINPUTSrcFlag
0x78A7   BasicLineBufPtr
0x78A2   BasicLineNumber
0x46E1   DCmdOPEN.nextByte
0x78FD   SYS_ARR_END_PTR
0x78FB   SYS_ARR_START_PTR
0x78F9   SYS_BASIC_END_PTR
0x78A4   SYS_BASIC_START_PTR
0x7AE9   SYS_BASIC_PRG
0x78E8   SYS_BACKSP_STACK
0x78D6   SYS_STRING_SPACE
0x78B1   SYS_MEMTOP_PTR
0x78A0   SYS_BASIC_STACK
0x7820   SysCursorAddr
0x7804   SysVecParse
0x0002   BreakKeyCol
0x0004   BreakKeybMask
0x68DF   BreakKeybRow
0x0004   SpaceKeyCol
0x68EF   SpaceKeyRow
0x0002 X CtrlKeyCol
0x68FD   CtrlKeyRow
0x6800   AllKeyRows
0x6800   SYS_INT_STATE
0x001B   UP
0x000D   CR
