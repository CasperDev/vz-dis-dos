# file opened: src\vtech12.asm
    1 0000
    2 0000
    3 0000 ~            /***********************************************************************************************
    4 0000 ~             *
    5 0000 ~             *  Laser 210/VZ210 ROM 1+2
    6 0000 ~             *  -----------------------
    7 0000 ~             *  $0000 - $3fff
    8 0000 ~             *
    9 0000 ~             *  Disassembled by z80dasm 1.1.2
   10 0000 ~             *  Command line: z80dasm.exe --address --labels --source --origin=0x0000
   11 0000 ~                                          --output=src/vtech12.asm bin/vtech12.org
   12 0000 ~             *  Verified by compare binary content with output file
   13 0000 ~             *  generated by SjASMPlus Z80 Cross-Assembler v1.18.3 (https://github.com/z00m128/sjasmplus)
   14 0000 ~             *
   15 0000 ~             *  Various Sources
   16 0000 ~             * ********************************************************************************************/
   17 0000               ifndef VER_12
   18 0000 ~            	ifndef VER_20
   19 0000 ~            		DEFINE VER_12
   20 0000 ~            	endif
   21 0000               endif
   22 0000
   23 0000              	;DEFINE VER_20
   24 0000
   25 0000              	DEVICE NOSLOT64K
   26 0000
   27 0000               ifdef VER_12
   28 0000                  OUTPUT "out/vtech12.rom"
   29 0000               endif
   30 0000               ifdef VER_20
   31 0000 ~                OUTPUT "out/vtech20.rom"
   32 0000               endif
   33 0000
   34 0000              	include "vars.inc"
# file opened: src\vars.inc
    1+0000              VRAM        equ     $7000   ; Video RAM start
    2+0000
    3+0000              // *********************************************************************
    4+0000              ;RAM COMMUNICATION ADRESSSES
    5+0000              ; by David Mitchel 1987, R. Quinn 1988
    6+0000
    7+0000              ; 7800-7814 : RST jump Vectors
    8+0000              RAMCommArea    equ AssertTokenVect
    9+0000
   10+0000
   11+0000              AssertTokenVect   equ     $7800   ; RTS08         jp $1c96
   12+0000              NextTokenVect     equ     $7803   ; RTS10         jp $1d78    (DOS: 4293)
   13+0000              CmpHLDEVect      equ     $7806   ; RTS18         jp MAT_iCmp_HL_DE
   14+0000              TestNTFVect      equ     $7809   ; RST20         jp MAT_TestNTF
   15+0000
   16+0000              ; In non-disk systems 780c contains a RET instruction.
   17+0000              ; In a disk system this vector is used for DOS overlay requests
   18+0000              ; (Bit 7 of the A register is set on entry if DOS overlay).
   19+0000              TestBreakKeyVect   equ     $780c   ; RST28   BreakVector      set to: RET
   20+0000
   21+0000              ; In non-disk systems 780f contains a RET instruction.
   22+0000              ; DEBUG entry point under DOS.
   23+0000              OnDebug   equ     $780f   ; RST30         set to: RET
   24+0000
   25+0000              ; In non-disk system 7812 contains an EI (Enable Interrupts)
   26+0000              ; instruction, followed by a RET instruction at 7813.
   27+0000              DOSINTHandlerVect   equ     $7812   ; RST38         set to: EI,RET
   28+0000
   29+0000
   30+0000
   31+0000              ; 7815-781c : Keyboard
   32+0000              ;---------------------------------------------------------------
   33+0000              KEYBOARD_DCB           equ $7815   ; (structure)
   34+0000              DevSysKeysCaps           equ $7815   ; (byte) Capabilities Flags ( 1 - read only)
   35+0000              DevSysKeysDrvPtr     equ $7816   ; (word) DriveRAddress - 2ef4
   36+0000              ; TRS 0 (in Model III but NOT Model 4, location used by shift-lock routine)
   37+0000              KEYS_INVERSE_SCREEN     equ $7818   ; (byte)
   38+0000              ; TRS 0 (in Model III, 0="Upper & Lower Case", else "Caps only")
   39+0000              KEYS_INVERSE_TYPING     equ $7819   ; (byte)
   40+0000              ; TRS 0 (in Model III, time counting byte for blinking cursor)
   41+0000              KEYS_UNKNOWN            equ $781a   ; byte
   42+0000              ; 781b TRS "K" (in Model III, status of blinking cursor-on or off)
   43+0000              ; 781c TRS "I" (in Model III, Cursor Blink Switch - 0="Blink")
   44+0000              ; ( "Ki"=Keyboard Input - Model I only)
   45+0000              KEYS_BUFFER_ADDRESS     equ $781b   ; word
   46+0000
   47+0000              KEYS_MATRIX             equ $6800   ; all keys matrix address
   48+0000              ; /---------------------------------------------------------------------\
   49+0000              ; |                         ADRES   |   D5  D4      D3  D2      D1  D0  |
   50+0000              ; |---------|-----------------------------------------------------------|
   51+0000              KEYS_ROW_0:         equ     68FEh   ;   R   Q       E           W   T   |
   52+0000              KEYS_ROW_1:         equ     68FDh   ;   F   A       D   CTRL    S   G   |
   53+0000              KEYS_ROW_2:         equ     68FBh   ;   V   Z       C   SHIFT   X   B   |
   54+0000              KEYS_ROW_3:         equ     68F7h   ;   4   1       3           2   5   |
   55+0000              KEYS_ROW_4:         equ     68EFh   ;   M   SPACE   ,           .   N   |
   56+0000              KEYS_ROW_5:         equ     68DFh   ;   7   0       8   -       9   6   |
   57+0000              KEYS_ROW_6:         equ     68BFh   ;   U   P       I   RETURN  O   Y   |
   58+0000              KEYS_ROW_7:         equ     687Fh   ;   J   ;       K   :       L   H   |
   59+0000              ; |---------|-----------------------------------------------------------|
   60+0000              KROW_CTRL       equ KEYS_ROW_1   ; Keyboard Row with Control Key at bit 2
   61+0000              KEYS_ROW_SHIFT      equ KEYS_ROW_2   ; Keyboard Row with Shift Key at bit 2
   62+0000              KROW_SPACE      equ KEYS_ROW_4   ; Keyboard Row with Shift Key at bit 2
   63+0000              KROW_BREAK      equ KEYS_ROW_5   ; Keyboard Row with Inverse Key at bit 2
   64+0000              KEYS_ROW_RETURN     equ KEYS_ROW_6   ; Keyboard Row with RETURN Key at bit 2
   65+0000              KEYS_ROW_INVERSE    equ KEYS_ROW_7   ; Keyboard Row with Inverse Key at bit 2
   66+0000              KEYS_ROWS_NMI       equ KEYS_ROW_0 & KEYS_ROW_1 & KEYS_ROW_4   ; Keyboard Row with Inverse Key at bit 2
   67+0000
   68+0000              ; 781d-7824 : Video
   69+0000              ;----------------------------------------------------------------
   70+0000              ; TRS DeviceType (normally 7 = read and write)
   71+0000              SCREEN_DCB               equ $781d   ; byte Device type 0
   72+0000              VIDEO_DEVICE_TYPE       equ $781d   ; byte Device type 0
   73+0000              VIDEO_DRIVER_ADDRESS    equ $781e   ; word TRS DriverAddress
   74+0000              TAPESTARTPRG			equ $781e   ; Startup address from Tape
   75+0000              CURSORADDR        equ $7820   ; word Cursor Address in VRAM (range 7000 to 71ff) also TRS
   76+0000              ; TRS Character "covered" on video by Cursor character
   77+0000              VIDEO_UNKNOWN           equ $7822   ; byte
   78+0000              ; TRS 7823 "D" (in Model III, ASCII code for Cursor character)
   79+0000              ; TRS 7824 "O" (Model III j 0=Space Compression , l="Special" Characters)
   80+0000              ; ( ™DO"=Display Output - Model I only)
   81+0000              TAPE_CRC      	equ $7823   ; word
   82+0000
   83+0000
   84+0000              ; 7825-782c : Printer
   85+0000              ;----------------------------------------------------------------
   86+0000              PRINTER_DCB     equ $7825   ; (structure)
   87+0000              PRINTER_DEVICE_TYPE     equ $7825   ; byte Capabilities (normally 6 = write only)
   88+0000              PRINTER_DRIVER_ADDRESS  equ $7826   ; word DriverAddress 058d
   89+0000              ; TRS 67 - Number of lines per page (+1 in Model III only)
   90+0000              PRINTER_LINES_PER_PAGE  equ $7828   ; byte
   91+0000              ; TRS Current Line Number (Model III: Number of lines printed +1)
   92+0000              PRINTER_LINES_PRINTED   equ $7829   ; byte
   93+0000              ; TRS 0 (Model III Number of characters printed on current line)
   94+0000              PRINTER_UNKNOWN         equ $782a   ; byte
   95+0000              ; TRS 782B "P" (in Model III, max. line length -2, 255="No maximum")
   96+0000              ; TRS 782C "R" (in Model 4 only, zero byte)
   97+0000              ; ( "PR"=printer - Model I only)
   98+0000              PRINTER_BUFFER_ADDRESS  equ $782b   ; word
   99+0000
  100+0000              ;------------------------------------------
  101+0000              SYS.DosReEntry      equ     $782d   ;
  102+0000              SYS.DosErrEntry      equ     $7830   ;
  103+0000              SYS.DosDevExec      equ     $7833   ;
  104+0000              ; ...
  105+0000              PRINTER_ERROR_VECTOR    equ $7833   ; (code) ld a,0; ret
  106+0000
  107+0000              ;---------------------------------------------
  108+0000              ; Keyboard work area
  109+0000              KEYCODE1         equ     $7836   ; KeyCode of 1st key pressed
  110+0000              KEYCODE2         equ     $7837   ; KeyCode of 2nd key pressed
  111+0000
  112+0000
  113+0000              ; bit 0 - Shift is pressed
  114+0000              ; bit 1 - INVERSE is Active
  115+0000              ; bit 2 - ???Function is Active
  116+0000              ; bit 3 - KEYCODE1 variable has pressed KeyCode
  117+0000              ; bit 4 - KEYCODE2 variable has pressed KeyCode
  118+0000              ; bit 5 - ??? is pressed
  119+0000              ; bit 7 - Ctrl is pressed
  120+0000              KEYSFLAGS      equ     $7838   ; Keyboard's current State
  121+0000
  122+0000              ; bit 0 - RETURN key pressed
  123+0000              ; bit 2 - BREAK key pressed
  124+0000              ; bit 3 - tape load for VERIFY Command
  125+0000              ; bit 4 - text edited for INPUT Command
  126+0000              ; bit 5 - buffered output while reading text from keyboard
  127+0000              ; bit 6 - tape load for CRUN Command
  128+0000              SYSFLAGS		equ		$7839	; System flags
  129+0000              KEYS_DEBOUNCER      equ    $783a    ; Key Debounce Counter
  130+0000              IOLATCH_COPY        equ     $783b  ; copy of Hardware IO latch
  131+0000              CURSORCHAR      equ     $783c  ;(byte) character at cursor position
  132+0000
  133+0000              ; $783d  video control word
  134+0000              ; TRS NOTE: Uses flag byte to determine if Video Display is in 32 or 64 chars/line mode.
  135+0000              ; TRS Model 1 - flag contains CURRENT PORT 0FFh OUTPUT BITS:
  136+0000              ; - bit 3	Select video 32 character mode if set
  137+0000              ; - bit 2 	Turns on cassette tape relay if set
  138+0000              ; - bit 0,1	Are set for positive and negative audio pulses to the cassette "AUK" plug
  139+0000
  140+0000              ; $783e-$787c  ?
  141+0000
  142+0000              CURSORTIMER			equ	$7841	; timer for inverse char under cursor
  143+0000              KEYS_SCAN_COORDS equ $7842   ; MSB-bit (6..1), LSB-row (8..1)
  144+0000              KEYS_SCAN_ROWADR equ $7844   ; np: $68fe
  145+0000
  146+0000              FCOLOR				equ	$7846	; Foreground Color
  147+0000
  148+0000              TAPEHIDEINFO		equ	$784c	; Hide Tape operations info texts (0-show, nonzero-hide)
  149+0000              OnCpuINT		equ $787d  ; user interrupt vector interrupt (jump - 3 bytes)
  150+0000
  151+0000              BASIC_VARS_AREA      equ     $7880
  152+0000              ; $7880-$788d  division support routine
  153+0000              BAS_UsrVector       equ     $788e  ; BASIC USR routine pointer (word)
  154+0000              ; $7890  rnd number seed (3 bytes)
  155+0000              ; $7893  INP (XX) (3 bytes)
  156+0000              ; $7896  OUT (XX) (3 bytes)
  157+0000              KEYS_LASTKEY        equ     $7899       ; Last Key Pressed
  158+0000              LASTERRORNO       equ     $789a   ; error code
  159+0000              PRN_PosInLine         equ     $789b       ; printer position in line
  160+0000
  161+0000              ; 00 - Screen Display Device
  162+0000              ; 01 - Printer Device
  163+0000              ; 80-ff - Tape Cassette Device
  164+0000              SysCurOutDev          equ     $789c  ; Current Output Device for System/Errors
  165+0000              SCR_LINEMAXLEN          equ     $789d  ; size of video line
  166+0000
  167+0000              ; Specifies maximum number of 16-character print zones on line
  168+0000              ; (used when items in PRINT statement are separated by commas).
  169+0000              ; Value decodes as follows:
  170+0000              ;  0 - one print zone
  171+0000              ; 16 - two print zones
  172+0000              ; 32 - three print zones
  173+0000              ; 48 - four print zones
  174+0000              ; When comma separator is found in PRINT statement, BASIC
  175+0000              ; checks the current cursor position and if is greater or
  176+0000              ; equal to this value, a CR char is send to screen.
  177+0000              SCR_PRINTZONES      equ     $789e   ;
  178+0000              ; $789f  ?
  179+0000
  180+0000              ; 78A0-78xx : Basic
  181+0000              STACKTOPPTR     equ     $78a0       ; (word)
  182+0000              BasicLineNo       equ     $78a2       ; Current Basic Line Number (word)
  183+0000              PrgStartPtr     equ     $78a4       ; (word)
  184+0000              CURSORPOS    equ     $78a6       ; (byte) Cursor in Line Position
  185+0000
  186+0000              LINEBUFPTR   equ     $78a7       ; thru 7a28 (65 bytes)
  187+0000              TapeInputFlag         equ     $78a9       ;(byte) 0 if cassete input else non zero
  188+0000
  189+0000              ; Funkcja BASIC RANDOM zapisuje tu aktualna wartość rejestru odświeżania
  190+0000              ; pamięci RAM (R) - wartość przypadkowa zależna od czasu jaki upłynął od
  191+0000              ; właczenia komputera.
  192+0000              RANDOMSEED       equ     $78ab       ;(byte)
  193+0000              ; 78aa-d    random number seed
  194+0000
  195+0000
  196+0000              ; Flag is used by BASIC locate or Create Variable routine.
  197+0000              ;  0 - variable will be created or located (if already exists)
  198+0000              ; nonzero - variable will be Created or error will be raised
  199+0000              ;           if variable already exists (when DIM is used)
  200+0000              CreateVarFlag   equ     $78ae       ; variable flag
  201+0000
  202+0000
  203+0000              ;   2 - integer
  204+0000              ;   4 - single-precision number
  205+0000              ;   8 - double-precision number
  206+0000              ;   3 - the number of bytes required for the string vector
  207+0000              MATH_NTF             equ     $78af       ; Number Type Flag
  208+0000
  209+0000
  210+0000              ; Used to flag DATA statements while encoding BASIC lines, and
  211+0000              ; to store operator number during expression evaluation.
  212+0000              ; 78b0      expression evaluator
  213+0000
  214+0000
  215+0000              MEMORY_TOP                 equ     $78b1       ; (word) Top of memory pointer.
  216+0000
  217+0000              ; Pointer to the next available location for storage of a three-byte
  218+0000              ; string variable VARPTR in the string VARPTR storage area (78B5).
  219+0000              BAS_StrNextVar        equ     $78b3       ; (word) next location in literal string pool
  220+0000
  221+0000
  222+0000              ; String variable VARPTR storage area. Holds three-byte string vectors
  223+0000              ; (1 byte length, 2 bytes address of string) for strings currently
  224+0000              ; being used in BASIC string operations.
  225+0000              BAS_StrVars       equ     $78b5       ; start of literal string pool
  226+0000              ; 78b7 ... 78e1   ?
  227+0000
  228+0000              ; VARPTR storage area for string currently being created by BASIC
  229+0000              ; (1 byte length, 2 bytes address of string)
  230+0000              StrVecBuf         equ     $78d3       ; length of last defined string
  231+0000
  232+0000              ; Pointer to next free byte in string storage area.
  233+0000              ; Strings build downward from the top of memory, therefore at power-up
  234+0000              ; (or when a CLEAR command is executed) this pointer will contain the
  235+0000              ; same address as the top of memory pointer { 40B1H-40B2B) . If a ten
  236+0000              ; byte long string is then created, this pointer will point to the top
  237+0000              ; of memory minus ten, and so on. When there is not enough room left to
  238+0000              ; insert a new string (the difference between this pointer and the one
  239+0000              ; at 40A0B-40A1B is less than the length of a string to be stored), a
  240+0000              ; "garbage collection" is performed, and if that does not free enough
  241+0000              ; string space an Out of String Space error occurs.
  242+0000              BAS_StrFreePtr          equ     $78d6       ; (word)  Pointer to next free byte in string storage area.
  243+0000
  244+0000
  245+0000              ; This pair of locations is used a temporary storage location by more
  246+0000              ; than one routine.
  247+0000              ;   - program pointer during expression evaluation,
  248+0000              ;   - pointer to data while processing DIM statement,
  249+0000              ;   - pointer to end of array while packing strings,
  250+0000              ;   - PRINT USING format flag bits temporarily store
  251+0000              BAS_TempPtr             equ     $78d8       ; temporary pointer
  252+0000              BAS_TempFlags           equ     $78d8       ; temporary byte
  253+0000
  254+0000              ; Line number of last DATA item read.
  255+0000              ; Line number is saved so that in the event of a syntax error in a DATA
  256+0000              ; statement, the proper error line number will be displayed and the EDIT
  257+0000              ; mode will function on the correct line.
  258+0000              DATALineNo       equ     $78da       ; Line number of last DATA item read.
  259+0000
  260+0000              ; If this byte contains 64 a FOR-NEXT loop is being processed,
  261+0000              ; otherwise byte will contain zero. Used to prevent an array variable
  262+0000              ; from being used as the index counter in a FOR-NEXT loop (for example,
  263+0000              ; the statement FOR X(O) = 1 TO 10 will cause a syntax error, because
  264+0000              ; X(0) is an array variable and cannot be used as the counter variable).
  265+0000              ForNextFlag         equ     $78dc       ; inside For-Next loop
  266+0000
  267+0000              ; Flag indicates whether inputing text. Used by RETURN and RESUME NEXT commands.
  268+0000              INPUTFLAG           equ     $78dd       ;
  269+0000
  270+0000              ; Used for two different purposes:
  271+0000              ;   - Flags whether READ (non-zero) or INPUT (zero) statement is processing
  272+0000              ;   - delimiter character during processing of PRINT USING statement
  273+0000              BAS_ReadInSrc           equ     $78de     ; READ (non-zero) or INPUT (zero)
  274+0000              BAS_PrintUsingDelim     equ     $78de     ; delimiter for PRINT USING
  275+0000
  276+0000              ; Used by several routines,
  277+0000              ;   - pointer to variable for new value during evaluation of LET expression
  278+0000              ;   - execution address of BASIC program
  279+0000              ;   - after a SYSTEM tape is loaded contain the entry point address
  280+0000              ;     of the program (which is used if only a "/" is typed in response
  281+0000              ;     to the next SYSTEM command prompt)
  282+0000              PrgStart            equ     $78df       ;(word) pointer to start of program when run
  283+0000              BAS_NewVarPtr           equ     $78df       ;(word) pointer to LET variable
  284+0000
  285+0000              ; Basic AUTO input flag [TRS]. 0 - OFF, 1 - ON.
  286+0000              AUTONUM_ON         equ     $78e1       ; 0=no auto
  287+0000
  288+0000              ; Current input line number used by AUTO input function.
  289+0000              AUTONUM_LINE          equ     $78e2       ; (word) current line number
  290+0000
  291+0000              ; Line increment used by AUTO input function
  292+0000              AUTONUM_INC         equ     $78e4       ; (word) auto increment
  293+0000
  294+0000
  295+0000              ; Used by several routines for temporary pointers to the BASIC program
  296+0000              ;   - saved position in program text (last byte executed in current line?)
  297+0000              ;   - buffer position during text encoding
  298+0000              ;   - etc.
  299+0000              BAS_TmpCharPtr          equ     $78e6       ; last byte executed in current line
  300+0000              ; TRS -> 78a7 - 78a8 - editor line buffer address (buffer 255 bytes)
  301+0000              BAS_StackPtr       equ     $78e8   ; (word) backspaced stack address
  302+0000              ErrorLineNo       equ     $78ea   ; (word) error line number
  303+0000
  304+0000              ; Current or error line number.
  305+0000              ; Used when a period is used to replace a BASIC line number,
  306+0000              ; and when syntax error occurs in program.
  307+0000              EditLineNo      equ     $78ec       ;(word)
  308+0000
  309+0000              ; Pointer to last byte executed when error occured.
  310+0000              ; Used by RESUME command.
  311+0000              ErrorTokenPtr       equ     $78ee   ; byte executed with error
  312+0000
  313+0000              ; Address of error trap line
  314+0000              ; Points to first statement of line specified in ON ERROR GOTO
  315+0000              ; statement, or zero if no error trap set.
  316+0000              BAS_OnErrorPtr      equ     $78f0   ; address of statement to resume at
  317+0000
  318+0000              ; Flag to indicate whether an error has occured.
  319+0000              ; Set to -1 (FF) on error, otherwise set to zero
  320+0000              ; Setting the appropriate values into this location will allow
  321+0000              ; you to do many things that BASIC normally does not permit,
  322+0000              ; such as exiting an error trap without using a RESUME statement,
  323+0000              ; or redefining the error trap (by using an ON ERROR GOTO statement)
  324+0000              ; from within a previously defined error trap.
  325+0000              ERRORFLAG       equ     $78f2     ; error message override
  326+0000
  327+0000              ; Used to store position of expressions being evaluated,
  328+0000              ; as a decimal point location pointer, etc.
  329+0000              BAS_ExprTmpPtr      equ     $78f3   ; ?
  330+0000
  331+0000
  332+0000              ; Last line number executed prior to execution of STOP or END
  333+0000              ; statement or termination using the BREAK key.
  334+0000              BAS_LastLineNo  equ     $78f5       ;(word)  line number ended on
  335+0000
  336+0000              ; Pointer to end of last statement executed;
  337+0000              ; (points to the colon or zero byte terminator). Used by CONT command.
  338+0000              BAS_StopedPtr   equ     $78f7       ; last statement byte executed
  339+0000
  340+0000              ; Pointer to start of simple variables, or one memory location
  341+0000              ; higher than the last of the three zero bytes marking the end
  342+0000              ; of the BASIC program. Used to determine end of BASIC program
  343+0000              ; when saving the program.
  344+0000              PrgEndPtr       equ     $78f9       ; (word) end of program
  345+0000
  346+0000              ; Pointer to start of array variables
  347+0000              ArrStartPtr  equ     $78fb       ; (word) start of DIM variables table
  348+0000              ArrEndPtr        equ     $78fd       ; (word) start of free memory
  349+0000
  350+0000              ; Pointer to end of last DATA item read.
  351+0000              ; Points to comma or other terminator at end of last item read.
  352+0000              ; Search for next DATA item to be read will begin here.
  353+0000              ; RESTORE changes this pointer to one byte prior to beginning of BASIC program.
  354+0000              DataReadPtr  equ  $78ff       ; (word) data pointer (READ statement)
  355+0000
  356+0000              // *******************************************************************
  357+0000              ; BASIC Variable Declaration Table
  358+0000              ; This table is organized so that location 7901 contains variable type
  359+0000              ; flag (NTF) that begins with "A", 7902 for one begins with "B" and so on.
  360+0000              ; This type flag is same as NTF: Int=2, Str=3, Sng=4, Dbl=8.
  361+0000              ; All table locations are set to 4 (Single) on cmd RUN or CLEAR.
  362+0000              BAS_VarTypesTab  equ  $7901       ; thru $791A - variable declaration table
  363+0000
  364+0000              ; Trace flag.
  365+0000              ; Zero - trace is off, AF (non-zero) - trace is on
  366+0000              TRACEFLAG      equ     $791b       ; byte
  367+0000              ; 792f  ???
  368+0000
  369+0000              ; Conversion Buffer for numbers converted to displayable ASCII
  370+0000              ; When positive integers (BASIC line numbers , etc.) are converted,
  371+0000              ; the area from 7930 to 7936 is used, and the string is stored
  372+0000              ; right justified with leading spaces in locations 7930 to 7935
  373+0000              ; (7930 always contains a space character), while 7936 always
  374+0000              ; contains a zero byte to terminate the string.
  375+0000              ; Other routines (such as PRINT USING) may use more of this area.
  376+0000              SysConvBuffer      equ     $7930       ; thru 7949 (32 bytes)
  377+0000
  378+0000              SysDosVectors       equ     $7952
  379+0000              ; 7952-79a5  DOS Vectors
  380+0000              SysDosCVI           equ     $7952
  381+0000              SysDosFN           equ     $7955
  382+0000              SysDosCVS           equ     $7958
  383+0000              SysDosDEF           equ     $795b
  384+0000              SysDosCVD           equ     $795e
  385+0000              SysDosEOF           equ     $7961
  386+0000              SysDosLOC           equ     $7964
  387+0000              SysDosLOF           equ     $7967
  388+0000              SysDosMKIS           equ     $796a
  389+0000              SysDosMKSS           equ     $796d
  390+0000              SysDosMKDS           equ     $7970
  391+0000              SysDosCMD           equ     $7973
  392+0000              SysDosTIMES           equ     $7976
  393+0000              SysDosOPEN           equ     $7979
  394+0000              SysDosFIELD           equ     $797c
  395+0000              SysDosGET           equ     $797f
  396+0000              SysDosPUT           equ     $7982
  397+0000              SysDosCLOSE           equ     $7985
  398+0000              SysDosLOAD           equ     $7988
  399+0000              SysDosMERGE           equ     $798b
  400+0000              SysDosNAME           equ     $798e
  401+0000              SysDosKILL           equ     $7991
  402+0000              SysDosAND           equ     $7994
  403+0000              SysDosLSET           equ     $7997
  404+0000              SysDosRSET           equ     $799a
  405+0000              SysDosINSTR           equ     $799d
  406+0000              SysDosSAVE           equ     $79a0
  407+0000              SysDosLINE           equ     $79a3
  408+0000
  409+0000
  410+0000              ; 79A6 - 79E4 contain three-byte Disk BASIC links used to extend
  411+0000              ; the capabilities of BASIC routines when a Disk BASIC is present.
  412+0000              ; Under non-disk systems, the first byte of each of these vectors
  413+0000              ; is a machine language RET instruction.
  414+0000              SysExtVectors      equ     $79a6   ; Extension links - initialized to RET
  415+0000
  416+0000              ; Called at 19ECH, from error-handling routine.
  417+0000              ; Used to provide long error messages.
  418+0000              SysExtErrMsg       equ     $79a6
  419+0000
  420+0000              ; Called at 27FEH, from entrance to USR function routine.
  421+0000              ; Used to expand function to provide up to ten USR calls.
  422+0000              ; If a program running under Disk BASIC contained the statement
  423+0000              ; POKE 16809,201 (placing a RET instruction at 79A9),
  424+0000              ; the expanded USR function would be defeated and the single USR
  425+0000              ; call of non-disk BASIC would be restored.
  426+0000              ; Such a program could run correctly under either non-disk or
  427+0000              ; Disk BASIC, provided that the normal Level II/Model III BASIC
  428+0000              ; requirement for POKEing the USR routine starting address into
  429+0000              ; memory locations 788E-788F is adhered to (rather than use of
  430+0000              ; the DEFUSE command that Disk BASIC normally requires).
  431+0000              SysExtUsr          equ     $79a9
  432+0000
  433+0000              ; Called at 1A1CH, from BASIC re-entry ("READY").
  434+0000              OnBasicREADY        equ     $79ac
  435+0000
  436+0000              ; Called at 0368H, from near start of routine to input a line
  437+0000              ; from the keyboard into the I/O buffer (zeroes INKEY$ buffer
  438+0000              ; and video tab position indicator prior to call)
  439+0000              SysExtInkey        equ     $79af
  440+0000
  441+0000              ; Called at 1AA1, after BASIC line has been tokenized
  442+0000              ; (HL points to start of tokenized line)
  443+0000              SysExtTokenize     equ     $79b2
  444+0000
  445+0000              ; Called at 1AEC, after insertion or replacement of BASIC line
  446+0000              OnLineChanged  equ     $79b5
  447+0000
  448+0000              ; Called at 1AF2, after above call followed by call to 1B5D
  449+0000              ; (CLEAR command, leaves HL pointing to start of BASIC program -1)
  450+0000              OnResetBasPrg        equ     $79b8
  451+0000
  452+0000              ; Called at 1B8C (NEW command) and at 1DB0 (END command).
  453+0000              ; Used to CLOSE any files remaining open.
  454+0000              SysExtNew          equ     $79bb
  455+0000
  456+0000              ; Called at 2174H, at termination of PRINT statement.
  457+0000              ; Used to terminate output to disk using PRINT # statement)
  458+0000              SysExtPrintEnd      equ     $79be   ; TODO ???
  459+0000
  460+0000              ; Called at 032CH, from byte output routine.
  461+0000              SysExtByteOut        equ     $79c1   ; TODO ???
  462+0000
  463+0000              ; Called at 0358H, from start of routine to scan keyboard
  464+0000              ; and input keystroke (if any).
  465+0000              SysExtKeyRead     equ     $79c4   ; TODO ???
  466+0000
  467+0000              ; Called at 1EA6H, when RUN command has an argument (filename).
  468+0000              SysExtRunFile     equ     $79c7   ; TODO ???
  469+0000
  470+0000              ; Called at 206FH, from start of PRINT command
  471+0000              ; (check for output to disk using PRINT #).
  472+0000              SysExtPrint     equ     $79ca   ; TODO ???
  473+0000
  474+0000              ; Called at 20C6H, from PRINT routine after a numeric item has
  475+0000              ; been converted to an ASCII string in preparation for printing.
  476+0000              SysExtPrintNum     equ     $79cd   ; TODO ???
  477+0000
  478+0000              ; Called at 2103H, from PRINT routine after code which outputs
  479+0000              ; a carriage return (to prevent numeric items being printed
  480+0000              ; from overflowing the end of a line).
  481+0000              SysExtPrintCR      equ     $79d0   ; TODO ???
  482+0000
  483+0000              ; Called at 2108H (from PRINT command when a comma is used to
  484+0000              ; separate items to be printed) and at 2141H (from PRINT command
  485+0000              ; routine when the TAB function is used, after the TAB argument
  486+0000              ; has been evaluated and placed in the E register.
  487+0000              SysExtPrintTab      equ     $79d3   ; TODO ???
  488+0000
  489+0000              ; Called at 219EH, from start of INPUT command
  490+0000              ; (check for input from disk using INPUT #).
  491+0000              SysExtInput      equ     $79d6   ; TODO ???
  492+0000
  493+0000              ; Jump to this location at 2AECH, to Disk BASIC routine that
  494+0000              ; permits MID$ on left side of " = " (assignment statement).
  495+0000              SysExtAssign       equ     $79d9
  496+0000
  497+0000              ; Called at 222DH, Part of READ/INPUT command routine,
  498+0000              ; called just prior to assigning data that has been READ or INPUT
  499+0000              ; to variable.
  500+0000              SysExtReadData       equ     $79dc
  501+0000
  502+0000              ; Called at 2278H (after data from INPUT command has been assigned
  503+0000              ; to variable, just prior to test for "extra™ data that would
  504+0000              ; cause an "?EXTRA IGNORED" message to be printed) and at 2B44H
  505+0000              ; (from LIST command after start and end addresses of program
  506+0000              ; have been found and a check for end of program has been made).
  507+0000              SysExtExtraTest       equ     $79df
  508+0000
  509+0000              ; Called at 02B2H. This call is located at the entrance to the
  510+0000              ; SYSTEM command and is executed each time the "*?" prompt
  511+0000              ; is about to be displayed.
  512+0000              ; If a SYSTEM tape is being loaded and it places a jump to its
  513+0000              ; entry point address in this vector, the program will start
  514+0000              ; automatically. The same thing can be achieved by placing
  515+0000              ; a JP (HL) instruction (an E9H byte) at 79E2, provided that
  516+0000              ; the entry point address on the tape is correct.
  517+0000              ; Note, however, that the SYSTEM command will be unusable
  518+0000              ; afterwards unless the program reloads a RET instruction
  519+0000              ; (a C9H byte) to 79E2 after execution begins.
  520+0000              SysExtPrompt       equ     $79e2
  521+0000
  522+0000              ; Addresses are initialized by ROM code at 0G8OH-OO89B to contain
  523+0000              ; the bytes 3A, 0, and 2C (a colon, zero byte, and comma).
  524+0000              BAS_SEPARATORS      equ     $79e5   ; BASIC separators ':' \0 ','  used by input
  525+0000              BAS_sepCOMMA      equ     $79e7   ; BASIC separator '','  used by input
  526+0000
  527+0000              ; TRS 79e5 - 79ec DCB RS-232-C INPUT DEVICE CONTROL BLOCK (Model III only)
  528+0000              ; 79E5 Device Type (normally 1 read only)
  529+0000              ; 79E6 (word) Driver Address
  530+0000              ; 79E9 Bit 1 = Wait/No Wait Flag, Bit 2 = Driver On/Off Flag
  531+0000              ; 79EB "F1" key definition in Model 4 only (used by Keyboard Driver)
  532+0000              ; 79EC "F2" key definition in Model 4 only (used by Keyboard Driver)
  533+0000
  534+0000              ; TRS 79ED - 79F4 DCB RS-232-C OUTPUT DEVICE CONTROL BLOCK (Model III only)
  535+0000              ; 79ED Device Type (normally 2 write only)
  536+0000              ; 79EE (word) Driver Address
  537+0000              ; 79F0 Character to Transmit
  538+0000              ; 79F1 Bit 1 = Wait/No Wait Flag, Bit 2 = Driver On/Off Flag
  539+0000              ; 79F3 "F3" key definition in Model 4 only (used by Keyboard Driver)
  540+0000              ; 79F4 "Keyboard row storage for 3880H' in Model 4 only (used by Keyboard Driver)
  541+0000
  542+0000              EditLineBuf   equ     $79e8       ; thru 7a28 (65 bytes)
  543+0000
  544+0000              ; TRS 79F5 - 79FA RS-232-C INITIALIZATION DEVICE CONTROL BLOCK (Model III only)
  545+0000              ; 79F5 Device Type (normally 2 = write only)
  546+0000              ; 79F6 (word) Driver Address
  547+0000              ; 79F8 Baud Rate Codes (Bits 0-3 = Receive, Bits 4-7 = Send)
  548+0000              ; 79F9 RS-232-C Characteristics Switch
  549+0000              ; 79FA Wait/Don't Wait Switch CO = Don't Wait)
  550+0000
  551+0000              ; TRS 7a10 Model III - flag contains CURRENT PORT OECH OUTPUT BITS:
  552+0000              ; - bit 6	Enables fast clock speed if set on Model 4 only
  553+0000              ; - bit 5	Disables video wait states if set (not used on Model 4)
  554+0000              ; - bit 4	Enables I/O bos if set
  555+0000              ; - bit 3	Japanese Kana character set used as "special" characters if set
  556+0000              ; - bit 2	Select video 32 character mode if set
  557+0000              ; - bit 1	Turns on cassette tape relay if set
  558+0000              ; - bit 0	Enables clock display on video if set
  559+0000
  560+0000              ; TRS 7a1d - 7a25 I/O ROUTER DEVICE CONTROL BLOCK (Model III only, NOT initialized in Model 4)
  561+0000              ; 7A1D Device Type (normally 2 write only)
  562+0000              ; 7A1E Driver Address
  563+0000              ; 7A20 First character of Destination Device Code
  564+0000              ; 7A21 Second character of Destination Device Code
  565+0000              ; 7A22 First character of Source Device Code
  566+0000              ; 7A23 Second character of Source Device Code
  567+0000              ; 7A24 Control Key Flag (used by Keyboard Driver - Models II and 4)
  568+0000              ; (Source & Destination Codes may be any of KI, DO, RI, RO, PR)
  569+0000
  570+0000              ; 7a29-7a9c   ?
  571+0000              FileNameBuf		equ	$7a9d		; tape file name buffer (16 bytes)
  572+0000              ; 7aad-7ad5   ?
  573+0000              TAPEFILENAME	equ	$7ab2		; tape buffer for filename (18) bytes
  574+0000              PRINTBUFFER		equ	$7ad2		; 4 byte buffer used by Printer routines (up to 7AD5H)
  575+0000
  576+0000              TAPEFILETYPE	equ	$7ad2		; file type read from Tape
  577+0000              TAPEBYTEBUF		equ	$7ad3		; last byte read from Tape
  578+0000              FILENAMELEN		equ	$7ad6		; length of file name for tape
  579+0000              ; 7ad7-7ae6   Editor Flags
  580+0000              ; For every screen line there is info about line in editor context:
  581+0000              ;   80 - single line
  582+0000              ;   81 - first line of two line statement
  583+0000              ;    0 - second line of two line statement
  584+0000              EDITORLINES	equ		$7ad7		; 16 bytes for every screen line
  585+0000              ; 7ae7-8       zero
  586+0000
  587+0000
  588+0000              BAS_PrgMemory      equ     $7ae9
  589+0000              SysMinMemory       equ     $7b4c
  590+0000              MEMORY_TESTSTART       equ     $7b4d
  591+0000              MEMORY_MIN         equ     $7c14
  592+0000
  593+0000 ~            /***********************************************************
  594+0000 ~             *
  595+0000 ~             *  Laser 210/VZ210 ROM 1+2
  596+0000 ~             *  -----------------------
  597+0000 ~             *  Input/Output Interface
  598+0000 ~             *
  599+0000 ~             *  Various Sources
  600+0000 ~             ***********************************************************/
  601+0000
  602+0000              ; Hardware Output Register for Gfx Mode, Speaker and Cassette Out
  603+0000              ; bit 5 - Speaker Out (-)
  604+0000              ; bit 4 - MC6847 CSS pin - COLOR 0 (Green) or 1 (Orange)
  605+0000              ; bit 3 - MC6847 AG pin - MODE 0 or 1
  606+0000              ; bit 2 - Cassette Out (-) N/C
  607+0000              ; bit 1 - Cassette Out (+)
  608+0000              ; bit 0 - Speaker Out (+)
  609+0000              IO_LATCH      equ $6800   ; (byte) write only, used bits 5-0
  610+0000
  611+0000              CassIn       equ $6800   ; (bit 6) read only [shared with Keyboard Matrix]
  612+0000              INTLineIn    equ $6800   ; (bit 7) read only [shared with Keyboard Matrix]
  613+0000
  614+0000
  615+0000              ;
  616+0000              ; Single precision numbers are stored in four bytes of memory (or
  617+0000              ; sometimes two register pairs f such as BC and DE), while double
  618+0000              ; precision numbers take eight bytes of memory. However, the formats
  619+0000              ;for single and double precision are exactly the same, except that
  620+0000              ;double precision numbers have four more bytes. Therefore , anything
  621+0000              ;that is said about single precision numbers also applies equally to
  622+0000              ;double precision,, if you change the byte count accordingly.
  623+0000
  624+0000              ; If we talk about "the remaining three bytes" of a single precision
  625+0000              ; number, you can usually figure that the same thing will apply
  626+0000              ; to "the remaining seven bytes" of a double precision number.
  627+0000
  628+0000              ; A single precision number is stored in memory in the following format:
  629+0000              ;   LSB     2SB     MSB     EXP
  630+0000              ; A double precision number is stored in this manner;
  631+0000              ;   LSB     6SB     5SB     4SB     3SB     2SB     MSB     EXP
  632+0000
  633+0000              ; In the above examples, MSB indicates the Most Significant Byte,
  634+0000              ; S2B is the 2nd most Significant Byte, and so on to the Least
  635+0000              ; Significant Byte (LSB), EXB stands for the Exponent byte.
  636+0000
  637+0000              ; To decode a number in memory, start with the exponent byte. If this byte contains zero,
  638+0000              ; the number is zero regardless of what the other bytes may contain.
  639+0000
  640+0000              ; if EXP == 0 => Number = 0
  641+0000
  642+0000              ; Otherwise, take the number found in the exponent byte and subtract 128
  643+0000              ; to get the actual exponent. Another way to think of this is that the leftmost bit
  644+0000              ; of the exponent byte will be set if the exponent is positive, or will equal zero
  645+0000              ; if the exponent is negative. The rightmost seven bits contain the actual exponent value,
  646+0000              ; which can be read "as is" for a positive exponent. If the exponent is negative,
  647+0000              ; the rightmost seven bits must be complemented, and then have a value of one added,
  648+0000              ; to produce the proper negative exponent. It's easier to just subtract 128 decimal (80H)
  649+0000              ; from the value found in the exponent byte.
  650+0000              ; NOTE: if the exponent byte contains 128 decimal, onr exponent will be zero (which does NOT mean
  651+0000              ; that the number is zero - for that the exponent byte itself must be zero).
  652+0000
  653+0000              ; Next, look at the Most Significant Byte. If the leftmost bit of that byte is set, the number
  654+0000              ; is negative, but if it's a zero the number is positive (note that we are talking about
  655+0000              ; the number itself here, whereas before we were dealing with the sign of the exponent).
  656+0000              ; Now that you know the sign of the number, treat the leftmost bit as if it were set (a binary "1")
  657+0000              ; and write down the bits of the MSB.
  658+0000
  659+0000              ; Continue to write out the bits of the remaining bytes, until yon have written out the LSB.
  660+0000              ; Place a decimal point to the left of the resulting binary number.
  661+0000              ; At this point, your number should be written out in this format:
  662+0000              ;   .1bbbbbbb   bbbbbbbb    bbbbbbbb    (... continue if Double Precision)
  663+0000              ;   MSB         S2B         LSB         (S3B,S4B,...)
  664+0000              ; Again note that the first digit of the MSB (which contained the sign
  665+0000              ; bit) has been changed to a one,
  666+0000              ; Next, take the exponent value and move the decimal point that many places,
  667+0000              ; If the exponent was positive, move the decimal point that number of places
  668+0000              ; to the right, while a negative exponent moves the decimal point to the left
  669+0000              ; (in which case you'll have to add leading zeros as required).
  670+0000
  671+0000              ; Suppose we want to decode the binary number 10110,01101, Here's how it's done:
  672+0000              ;   1   0   1   1   0   ,   0   1   1       0       1
  673+0000              ;   16  8   4   2   1   ,   1/2 1/4 1/8     1/16    1/32
  674+0000              ;                           .5  .25 .125    .0625   .3125
  675+0000              ; = 16 + 4 + 2 + .25 + .125 + .3125 = 22.40626
  676+0000
  677+0000
  678+0000
  679+0000
  680+0000              ; STRING VECTORS
  681+0000
  682+0000              ;        struct StrVec
  683+0000              ;LEN     byte
  684+0000              ;ADDR    word
  685+0000              ;        ends
  686+0000
  687+0000
  688+0000
  689+0000
  690+0000              ; NUMBER TYPES
  691+0000
  692+0000              ; The VZ Math uses a single digit as a number type indicator.
  693+0000              ; This digit is the number of bytes required to store a given type of number:
  694+0000              ;   2 - integer
  695+0000              ;   4 - single-precision number
  696+0000              ;   8 - double-precision number
  697+0000              ;   3 - the number of bytes required for the string vector
  698+0000              ; The number type indicator digit figures in all arithmetic operations
  699+0000              ; and number currently being processed is stored in NUMBER TYPE FLAG - NTF
  700+0000              ; which is located at 78af.
  701+0000              ; This flag is generally associated with the number currently stored
  702+0000              ; in the primary ACCUMULATOR.
  703+0000
  704+0000
  705+0000
  706+0000              ; SMC Sub - Self Modified Code Subtract routine
  707+0000              ; IN: bhl - 24 bit integer to subtract from
  708+0000              ;     a - LSB of bhl integer (a == l)
  709+0000              ; OUT bhl - 24 bit result
  710+0000              ;     a - 0
  711+0000              MAT_SubBHLCust   equ $7880   ; routine entry
  712+0000              MAT_SubBHLArgL  equ $7881   ; LSB of value to subtract from BHL
  713+0000              MAT_SubBHLArgH  equ $7885   ; SB2 of value to subtract from BHL
  714+0000              MAT_SubBHLArgB  equ $7889   ; MB2 of value to subtract from BHL
  715+0000              MAT_SubBHLRetA  equ $788c   ; result value returned in A
  716+0000
  717+0000              ; ACCUMULATORS
  718+0000
  719+0000              ; The two arithmetic accumulators in the memory are located:
  720+0000              ;   791d to 7824 (8 bytes)
  721+0000              ;   7927 to 792e (8 bytes)
  722+0000              ; Numbers are stored in the accumulators during computations.
  723+0000              ; The method of storage of a given number depends on its number type,
  724+0000              ; and on which accumulator is being used.
  725+0000
  726+0000              ; Accumulator 1
  727+0000              MATH_ACC_CY      equ     $791c       ; extension byte for ACC
  728+0000              ACC_DBL    		 equ     $791d       ; Double variable (8 bytes): LSB LSB LSB LSB LSB LSB MSB EXP
  729+0000              ACC_SNG        	 equ     $7921       ; Int,Single,String (2 or 4 bytes):  LSB LSB MSB EXP
  730+0000              MATH_ACC_MSB     equ     $7923       ; shortcut to MSB of Component part
  731+0000              MATH_ACC_EXP     equ     $7924       ; shortcut to Exponent part (EXP)
  732+0000
  733+0000              ; Operation sign/flags beetween Accumulators
  734+0000              MATH_ACC_SIGN    equ     $7925       ; math routines
  735+0000
  736+0000              ; Accumulator 2
  737+0000              MATH_ACC2_CY     equ     $7926       ; extension byte for ACC
  738+0000              ACC2    equ     $7927       ; Double variable (8 bytes): LSB LSB LSB LSB LSB LSB MSB EXP
  739+0000              MATH_ACC2_MSB    equ     $792d       ; shortcut to MSB of Component part
  740+0000              MATH_ACC2_EXP    equ     $792e       ; shortcut to Exponent part (EXP)
  741+0000
  742+0000              ;794a-7951  double precision math
  743+0000              MATH_ACC3_DBL    equ     $794a       ; Double variable (8 bytes): LSB LSB LSB LSB LSB LSB MSB EXP
  744+0000              MATH_ACC3_MSB    equ     $7950       ; shortcut to MSB of Component part
  745+0000              MATH_ACC3_EXP    equ     $7951       ; shortcut to Exponent part (EXP)
  746+0000
  747+0000
  748+0000
  749+0000
  750+0000
# file closed: src\vars.inc
   35 0000
   36 0000              	ORG	$0000
   37 0000
   38 0000              ; **********************************************************************************************
   39 0000              ; ****************************************************************************
   40 0000              ; ****************************************************************************
   41 0000
   42 0000
   43 0000
   44 0000
   45 0000
   46 0000
   47 0000              ; ****************************************************************************
   48 0000              ; PowerOn Reset
   49 0000              SysReset
   50 0000 F3           	di						; Disable interrupts for initialisation phase						;0000	f3 	.
   51 0001              ; -- Clear state of Gfx Mode, Speaker and Cassette Out
   52 0001 AF           	xor a					; GfxMode=0, Color=0, SpeakerOut={0,0}, CassetteOut={0,0}  			;0001	af 	.
   53 0002 32 00 68     	ld (IO_LATCH),a		    ; set initial values 												;0002	32 00 68 	2 . h
   54 0005 C3 74 06     	jp SysInit				; continue System Initialization									;0005	c3 74 06 	. t .
   55 0008              	// ------------------------------------------------------------------------
   56 0008
   57 0008
   58 0008
   59 0008              ; ****************************************************************************
   60 0008              ; COMPARE SYMBOL ROUTINE – “SYNTAX” or “RST08”
   61 0008              ; ****************************************************************************
   62 0008              ; Hardware Jump via Z80 instruction RST $08
   63 0008              ; Jump to AssertToken [$1c96] via Jump Table
   64 0008              ; This routine is used for scanning strings. It compares the character pointed to
   65 0008              ; by the HL register pair with the character pointed to by the return address
   66 0008              ; on the top of the stack (Note that a RST instruction is in effect a CALL and places
   67 0008              ; a return address on the stack) formula: (HL)=((SP))?
   68 0008              ; If they are not equal an SYNTAX ERROR will result; if they are equal then
   69 0008              ; the return address on the stack will be incremented to bypass the test character
   70 0008              ; and control will be passed to RST 10H logic.
   71 0008              ; RST 08H is used to look for expected characters in a string and then return with (HL)
   72 0008              ; pointing to the next non-blank character. (see RST l0H) (BC and DE registers unaffected.).
   73 0008              ; This routine can be used by CALLing 1C96H or RST 08H.
   74 0008              CpuRST08					ASSERT($==$0008)
   75 0008 C3 00 78     	jp AssertTokenVect	    ; jump to AssertToken via RST Jump Table [$7800 -> $1c96]	    	;0008	c3 00 78 	. . x
   76 000B
   77 000B
   78 000B              ; ****************************************************************************
   79 000B              ; DISK ROUTINE – “WHERE”
   80 000B              ; ****************************************************************************
   81 000B              ; POP HL followed by JP (EL) . Same as RET instruction except leaves
   82 000B              ; return address in HL. Thus, a relocatable program car. CALL OO0BH, and
   83 000B              ; upon return, the HL register pair will contain the current address of
   84 000B              ; the Program Counter. In this way, a program can "find" itself in memory.
   85 000B              ResolveRelocAddr:
   86 000B E1           	pop hl					; Get return address from CPU Stack									;000b	e1 	.
   87 000C E9           	jp (hl)					; jump to that address - return to calling code						;000c	e9 	.
   88 000D
   89 000D
   90 000D               ifdef TRS
   91 000D ~            ; ****************************************************************************
   92 000D ~            ; [TRS Only] 000DH – DISK ROUTINE – “DBOOT”
   93 000D ~            ; ****************************************************************************
   94 000D ~            	jp $069F				; Jump to disk load and run sector routine at 069FH.
   95 000D ~
   96 000D               else ; VER_12 or VER_20
   97 000D              ; ****************************************************************************
   98 000D              ;  --- deleted code ---
   99 000D              ; ****************************************************************************
  100 000D 00           	nop
  100 000E 00             nop
  100 000F 00             nop			; deleted code
  101 0010              ; ****************************************************************************
  102 0010
  103 0010               endif
  104 0010
  105 0010
  106 0010
  107 0010              ; ****************************************************************************
  108 0010              ; NEXT TOKEN ROUTINE – “NEXTTOKEN” or “RST10”
  109 0010              ; ****************************************************************************
  110 0010              ; Hardware Jump via Z80 instruction RST $10
  111 0010              ; This routine INCrements HL and tests the characters pointed to by the HL.
  112 0010              ; It will bypass any spaces and CHAR’S 9 and 10 (TAB and CR).
  113 0010              ; IN:  hl - pointer to last parsed token
  114 0010              ; OUT: hl - pointer to next non-blank character
  115 0010              ;      a  - next non-blank character or 0 or ':'
  116 0010              ;      Z=1 - found 0 (end of BASIC Line) or ':' (End of BASIC statement)
  117 0010              ;      CY=1 - found numeric ASCII char ('0'..'9')
  118 0010              ; BC and DE registers are unaffected.
  119 0010              CpuRST10:					ASSERT($==$0010)
  120 0010 C3 03 78     	jp NextTokenVect			; go to $1d78 via RST Jump Table [$7803]						;0010	c3 03 78 	. . x
  121 0013
  122 0013
  123 0013
  124 0013
  125 0013              ; ****************************************************************************
  126 0013              ; DCS INPUT ENTRY – “INBYTE”
  127 0013              ; ****************************************************************************
  128 0013              ; Read Byte from Device via Device Control Subsystem
  129 0013              ; IN:  de - address of DCB of device to read from
  130 0013              ; OUT: a - byte received from device
  131 0013              ;      Z - flag set if device ready
  132 0013              DevSysReadByte:
  133 0013 C5           	push bc					; save BC register													;0013	c5 	.
  134 0014 06 01        	ld b,%0001				; Device/Operation Type Code (Read)									;0014	06 01 	. .
  135 0016 18 2E        	jr DevSysExecute		; execute DCS operation 						                	;0016	18 2e 	. .
  136 0018
  137 0018
  138 0018
  139 0018
  140 0018              ; ****************************************************************************
  141 0018              ; COMPARE DE HL ROUTINE – “CMPDEHL” or “RST18"
  142 0018              ; ****************************************************************************
  143 0018              ; Hardware Jump via Z80 instruction RST $18
  144 0018              ; This routine can be called by using RST 18H or CALL lC90H.
  145 0018              ; It compares two 16 bit unsigned values in HL and DE and sets the S and Z flags accordingly.
  146 0018              ; All registers are unchanged except for A.
  147 0018              ; IN: de - 16 bit unsigned value (0..65635)
  148 0018              ;     hl - 16 bit unsigned value (0..65635)
  149 0018              ; OUT: CY=1 - when hl < de
  150 0018              ;      CY=0 - when hl >= de
  151 0018              ;	   Z=1  - when hl == de
  152 0018              ;      Z=0  - when hl != de
  153 0018              CpuRST18					ASSERT($==$0018)
  154 0018 C3 06 78     	jp CmpHLDEVect			; go to $1c90 via RST Jump Table [$7806]							;0018	c3 06 78 	. . x
  155 001B
  156 001B
  157 001B
  158 001B
  159 001B              ; ****************************************************************************
  160 001B              ; DCS OUTPUT ENTRY – “OUTBYTE”
  161 001B              ; ****************************************************************************
  162 001B              ; Write Byte to Device via Device Control Subsystem
  163 001B              ; Outputs a byte to a device. When calling, A = output byte, DE
  164 001B              ; IN:  de - address of DCB of device to write to
  165 001B              ; 	   a - byte to send
  166 001B              ; OUT: Z - flag set if device ready
  167 001B              DevSysWriteByte:
  168 001B C5           	push bc					; save bc															;001b	c5 	.
  169 001C 06 02        	ld b,%0010				; Device/Operation Type Code (Write)								;001c	06 02 	. .
  170 001E 18 26        	jr DevSysExecute		; execute DCS operation		                						;001e	18 26 	. &
  171 0020
  172 0020
  173 0020
  174 0020
  175 0020              ; ****************************************************************************
  176 0020              ; TEST NUMBER TYPE FLAG – “TESTNTF” or “RST20”
  177 0020              ; ****************************************************************************
  178 0020              ; Hardware Jump via Z80 instruction RST $20
  179 0020              ; This CALL is used to determine the Type of the current value in ACC/REG1.
  180 0020              ; NTF (Number Type Flag) stores following values for variable types:
  181 0020              ;   8 - Double Precision Number
  182 0020              ;   4 - Single Precision Number
  183 0020              ;   3 - String
  184 0020              ;   2 - Integer (16bit) Number
  185 0020              ; OUT: a - (NTF-3) -> -1(Integer), 0(String), 1(Single), 5(Double)
  186 0020              ;      Z=1 - variable is String
  187 0020              ;      CY=0 - variable is Double
  188 0020              ;      PO=1 - variable is Single
  189 0020              ;      M=1  - variable is Integer
  190 0020              CpuRST20					ASSERT($==$0020)
  191 0020 C3 09 78     	jp TestNTFVect			; go to $25d9 via RST Jump Table [$7809]							;0020	c3 09 78 	. . x
  192 0023
  193 0023
  194 0023
  195 0023
  196 0023              ; ****************************************************************************
  197 0023              ; DCS STATUS ROUTINE – “CTLBYTE”
  198 0023              ; ****************************************************************************
  199 0023              ; Read Status from Device via Device Control Subsystem
  200 0023
  201 0023              DevSysGetStatus:
  202 0023 C5           	push bc					; save bc															;0023	c5 	.
  203 0024 06 04        	ld b,%0100		        ; Device/Operation Type Code (Status ??)             				;0024	06 04 	. .
  204 0026 18 1E        	jr DevSysExecute		; execute DCS operation				               					;0026	18 1e 	. .
  205 0028
  206 0028
  207 0028
  208 0028
  209 0028              ; ****************************************************************************
  210 0028              ; DOS BREAK ROUTINE – “DBREAK” or “RST28”
  211 0028              ; ****************************************************************************
  212 0028              ; Hardware Jump via Z80 instruction RST $28
  213 0028              ; This vector is only used by Disk BASIC. It is called by the BREAK key routine,
  214 0028              ; and can be used to intercept the BREAK key logic
  215 0028              ; In non-disk systems 780CH contains a RET instruction.
  216 0028              ; In a disk system this is the DOS FUNCTION CALL routine (which passes request code
  217 0028              ; in A-register to DOS for processing. The A register must contain a legitimate DOS
  218 0028              ; function code. If the code is positive, the CALL is ignored and control returns
  219 0028              ; to the caller.
  220 0028              CpuRST28					ASSERT($==$0028)
  221 0028 C3 0C 78     	jp TestBreakKeyVect		; Not used by System - RET via RST Jump Table [$780C]				;0028	c3 0c 78 	. . x
  222 002B
  223 002B
  224 002B
  225 002B
  226 002B              ; ****************************************************************************
  227 002B              ; KEYBOARD READ ROUTINE – “KBDSCN” or “$KBCHAR”
  228 002B              ; ****************************************************************************
  229 002B              ; Loads DE with address of keyboard DCB and scans keyboard.
  230 002B              ; OUT: a - ASCII character read from keyboard (0 if no key is pressed)
  231 002B              ;      Z=1 - no key is pressed
  232 002B              KeysReadKey:
  233 002B 11 15 78     	ld de,KEYBOARD_DCB	    ; address of Keyboard Device Control Block							;002b	11 15 78 	. . x
  234 002E 18 E3        	jr DevSysReadByte		; Read ASCII char from Keboard via DCB								;002e	18 e3 	. .
  235 0030
  236 0030
  237 0030
  238 0030
  239 0030              ; ****************************************************************************
  240 0030              ; DEBUG TRAP ROUTINE – “DEBUG” or “RST30”
  241 0030              ; ****************************************************************************
  242 0030              ; Hardware Jump via Z80 instruction RST $30
  243 0030              ; This vector is only used by Disk BASIC.
  244 0030              ; This is the LOAD DEBUG routine, and loads the DEBUG program and transfers control
  245 0030              ; to it. When DEBUG processing is complete, control is returned to the original caller.
  246 0030              ; For non-disk systems control is returned immediately (780FH contains a RET instruction).
  247 0030              CpuRST30					ASSERT($==$0030)
  248 0030 C3 0F 78     	jp OnDebug				; Not used by System - RET via RST Jump Table [$780F]				;0030	c3 0f 78 	. . x
  249 0033
  250 0033
  251 0033
  252 0033
  253 0033              ; ****************************************************************************
  254 0033              ; VIDEO ROUTINE – “VDCHAR”
  255 0033              ; ****************************************************************************
  256 0033              ; Loads DE with address of video DCB, and displays character stored in A
  257 0033              ; at current Cursor Position (stored at 7820-7821).
  258 0033              ; This routine also performs control functions (like Cursor Home, Cls, etc).
  259 0033              ; To save DE use routine at 033AH.
  260 0033              ; IN: a - ASCII char to print on Screen or ASCII Control Char
  261 0033              ScrSendByte:
  262 0033 11 1D 78     	ld de,SCREEN_DCB		; select Screen Device Control Block								;0033	11 1d 78 	. . x
  263 0036 18 E3        	jr DevSysWriteByte		; send Char to Screen via DCB			    						;0036	18 e3 	. .
  264 0038
  265 0038
  266 0038
  267 0038
  268 0038
  269 0038              ; ****************************************************************************
  270 0038              ; INTERRUPT MAIN ENTRY – “INTMAIN” or “RST38”
  271 0038              ; ****************************************************************************
  272 0038              ; This is the INTERRUPT MAIN ENTRY POINT routine at RST 38H which is the system
  273 0038              ; entry point for all maskable interrupts. Interrupt is generated 60 (NTSC)
  274 0038              ; or 50 (PAL) times per second by Video Display Generator (VDG) MC 6847.
  275 0038              ; Cpu jumps here if INT signal is detected and CPU is in Interrupt Mode 1
  276 0038              ; and Interrupts are Enabled (EI).
  277 0038              CpuRST38					ASSERT($==$0038)
  278 0038 C3 B8 2E     	jp CpuINTHandler		; jump to Main Interrupt Handler routine							;0038	c3 b8 2e 	. . .
  279 003B
  280 003B
  281 003B
  282 003B
  283 003B              ; ****************************************************************************
  284 003B              ; PRINTER ROUTINE – “PRCHAR” or LPTBYTE”
  285 003B              ; ****************************************************************************
  286 003B              ; Loads DE with address of Printer DCB, and print character in A
  287 003B              ; at current printer caret position.
  288 003B              ; This routine also performs control functions.
  289 003B              ; IN: a - char to send to Printer
  290 003B              PRN_SendChar:
  291 003B 11 25 78     	ld de,PRINTER_DCB		; select PRINTER Device Control Block								;003b	11 25 78 	. % x
  292 003E 18 DB        	jr DevSysWriteByte		; send Char to Printer	via DCB										;003e	18 db 	. .
  293 0040
  294 0040
  295 0040
  296 0040
  297 0040              ; ****************************************************************************
  298 0040              ; [TRS] INPUT ROUTINE – “KBLINE” (not used)
  299 0040              ; ****************************************************************************
  300 0040              ; TRS Line input routine - in this ROM this is Keyborard Scan routine.
  301 0040              ; Jump to 2EFDH - DCS Keyboard Driver routine
  302 0040              l0040h:
  303 0040 C3 FD 2E     	jp l2efdh				; go directly to DCS Keyboard Driver routine						;0040	c3 fd 2e 	. . .
  304 0043
  305 0043
  306 0043
  307 0043
  308 0043              ; ****************************************************************************
  309 0043              ; --- deleted code --- (probably jump)
  310 0043              ; ****************************************************************************
  311 0043              l0043h:
  312 0043 C9           	ret
  312 0044 00             nop
  312 0045 00             nop			; deleted code														;0043	c9 00 00 	.
  313 0046
  314 0046
  315 0046
  316 0046              ; ****************************************************************************
  317 0046              ; DCS ENTRY ROUTINE – DCSEXEC
  318 0046              ; ****************************************************************************
  319 0046              ; Jump to Device Control Subsystem execute entry
  320 0046              ; This routine executes I/O command via Device Control System.
  321 0046              ; This include Input a byte from device, send a byte to device or get device status.
  322 0046              ; DSC Execute routine assumes that BC register was saved on stack.
  323 0046              ; IN: de - starting address of Device Control Block of device
  324 0046              ;	  b - Device/Operation entry code (1-Read, 2-Write, 4-Status??)
  325 0046              ;     a - byte to send to device if Write operation
  326 0046              ; OUT: a - data byte received from device if Read operation or status code
  327 0046              ;     Z=1 - when device is Ready
  328 0046              DevSysExecute:
  329 0046 C3 C2 03     	jp ExecuteDCBOperation	; Go Execute operation via Device Control Subsystem					;0046	c3 c2 03 	. . .
  330 0049
  331 0049
  332 0049
  333 0049
  334 0049              ; ****************************************************************************
  335 0049              ; KEYBOARD ROUTINE – “$KBWAIT”
  336 0049              ; ****************************************************************************
  337 0049              ; Scan keyboard until key pressed (continuous calls to O02Bh).
  338 0049              ; OUT: a - character read from keyboard
  339 0049              KeysWaitKey:
  340 0049 CD 2B 00     	call KeysReadKey	; read Key Pressed or none												;0049	cd 2b 00 	. + .
  341 004C B7           	or a				; if any key is pressed?												;004c	b7 	.
  342 004D C0           	ret nz				; yes ------------ End of Proc ---------------------------- 			;004d	c0 	.
  343 004E 18 F9        	jr KeysWaitKey		; read key until any is pressed 										;004e	18 f9 	. .
  344 0050
  345 0050
  346 0050
  347 0050
  348 0050              ; ****************************************************************************
  349 0050              ; UPDATE CURSOR CHAR
  350 0050              ; ****************************************************************************
  351 0050              ; Update Cursor Char variable from current Cursor Position
  352 0050              UpdateCursorChar:
  353 0050 2A 20 78     	ld hl,(CURSORADDR)		; hl - address of VRAM where is Cursor								;0050	2a 20 78 	*   x
  354 0053
  355 0053
  356 0053
  357 0053
  358 0053              ; ****************************************************************************
  359 0053              ; SET CURSOR CHAR FROM (HL)
  360 0053              ; ****************************************************************************
  361 0053              ; Update Cursor Char variable from VRAM location pointed by HL
  362 0053              ; IN: hl - VRAM address with char to set as Cursor
  363 0053              SetCursorFromHL:
  364 0053 7E           	ld a,(hl)				; get char from VRAM memory pointed by hl register					;0053	7e 	~
  365 0054 32 3C 78     	ld (CURSORCHAR),a	    ; store as current Cursor Char										;0054	32 3c 78 	2 < x
  366 0057 C9           	ret						; ------------ End of Proc ----------------------------				;0057	c9 	.
  367 0058
  368 0058
  369 0058
  370 0058
  371 0058              ; ****************************************************************************
  372 0058              ; --- unused data ----
  373 0058              ; ****************************************************************************
  374 0058              ; Probably garbage data left from previous versions of ROM
  375 0058 4C FE 54 20  	db $4c,$fe,$54,$20,$d6,$fd,$21,$f1															;0058	4c fe 54 20 d6 fd 21 f1 	. ! . .
  375 005C D6 FD 21 F1
  376 0060
  377 0060
  378 0060
  379 0060
  380 0060              ; **********************************************************************************
  381 0060              ; DELAY ROUTINE – “$DELAY”
  382 0060              ; **********************************************************************************
  383 0060              ; This is a delay loop. The BC register pair is used as the loop counter.
  384 0060              ; The duration of the delay, in microseconds, is the value of BC times 5,86us plus 4,73us
  385 0060              ; IN: bc - delay countdown value
  386 0060              SysDelayBC
  387 0060 0B           	dec bc					; decrement delay counter											;0060	0b 	. ! . .
  388 0061 78           	ld a,b					; Load A with the counter’s MSB in register B						;0061	78 	x
  389 0062 B1           	or c					; Combine with the LSB in register C. Test if BC==0					;0062	b1 	.
  390 0063 20 FB        	jr nz,SysDelayBC		; no - continue until bc == 0										;0063	20 fb 	  .
  391 0065 C9           	ret						; ---------------- End of Proc ----------------------------			;0065	c9 	.
  392 0066
  393 0066
  394 0066
  395 0066              ; **********************************************************************************
  396 0066              ; NMI INTERRUPT ROUTINE	(not used)
  397 0066              ; **********************************************************************************
  398 0066              ; NMI Interrupt is NOT USED nor generated inside VZ/Laser machine.
  399 0066              ; Below code is description is provided as described for TRS Level II BASIC
  400 0066              ; [TRS] Determine if a disk controller is present, and if so a jump is taken to power-up (0000).
  401 0066              ; [TRS] Otherwise the routine jumps to the BASIC re-entry point at 06CC
  402 0066              CpuNMI:						ASSERT($==$0066)
  403 0066 31 00 06     	ld sp,$0600				; [TRS] Set the stack pointer to 0600H								;0066	31 00 06 	1 . .
  404 0069 3A EC 68     	ld a,(KEYS_ROWS_NMI)	; [TRS] Load register A with the disk controller status 			;0069	3a ec 68 	: . h
  405 006C 3C           	inc a					; [TRS] Increment the disk controller status in register A.			;006c	3c 	<
  406 006D FE 02        	cp 2					; [TRS] Check the value in register A to see if a disk is present.
  407 006F              							; It is usually FFH if there is no expansion interface 				;006d	fe 02 	. .
  408 006F              ; -- jump to Reset Basic when value >= 2
  409 006F D2 00 00     	jp nc,SysReset			; [TRS] If a disk is present go to Full Reset 						;006f	d2 00 00 	. . .
  410 0072 C3 CC 06     	jp BAS_ReEntry			; [TRS] No disk present so Restart BASIC 							;0072	c3 cc 06 	. . .
  411 0075
  412 0075
  413 0075
  414 0075
  415 0075              ; ********************************************************************************************
  416 0075              ; BASIC INITIALIZATION ROUTINE
  417 0075              ; ********************************************************************************************
  418 0075              ; Initialize RCA BASIC values and Self Modified Code (SMC) routines.
  419 0075              ; This is part of the BASIC Initialization procedure. It moves a block of memory
  420 0075              ; from 18F7H to l9lEH up to 7880H to 78A7H. (reserved RAM area)
  421 0075              ; Note:
  422 0075              ;	7880H-788DH is a division support routine.
  423 0075              ; 	788EH-788FH is the BASIC USR execute address
  424 0075              ; 	7890H-7892H is a Random Seed Value (24bit)
  425 0075              ; 	7893H-7895H is IO Read SMC routine
  426 0075              ; 	7896H-7898H is IO Write SMC routine
  427 0075              BasicInit:
  428 0075 11 80 78     	ld de,BASIC_VARS_AREA	; destination - RAM address of RCA Basic values Block				;0075	11 80 78 	. . x
  429 0078 21 F7 18     	ld hl,BAS_RCAInitData	; source - ROM address of initial values/code to copy				;0078	21 f7 18 	! . .
  430 007B 01 27 00     	ld bc,39				; size of block to copy (39 bytes)									;007b	01 27 00 	. ' .
  431 007E ED B0        	ldir					; bulk copy 														;007e	ed b0 	. .
  432 0080
  433 0080              ; --- init BASIC separators
  434 0080 21 E5 79     	ld hl,BAS_SEPARATORS	; hl - BASIC Separators address										;0080	21 e5 79 	! . y
  435 0083 36 3A        	ld (hl),':'				; store ':' - BASIC Statement separator								;0083	36 3a 	6 :
  436 0085 23           	inc hl					; address 79E6H														;0085	23 	#
  437 0086 70           	ld (hl),b				; store 0 - BASIC Line Terminator									;0086	70 	p
  438 0087 23           	inc hl					; address 79E7H														;0087	23 	#
  439 0088 36 2C        	ld (hl),','				; store ',' - BASIC Parameter Separator								;0088	36 2c 	6 ,
  440 008A
  441 008A              ; --- set default BASIC Line Buffer address 79E8H
  442 008A 23           	inc hl					; BASIC Line Buffer address											;008a	23 	#
  443 008B 22 A7 78     	ld (LINEBUFPTR),hl	    ; store 79E8H as address of BASIC Line Buffer 						;008b	22 a7 78 	" . x
  444 008E
  445 008E              ; Initialize DOS Vectors (7952-79A5) to raise DISK COMMAND ERROR
  446 008E 11 2D 01     	ld de,ErrRaiseDiskCmd	; adres of routine raising 'DISK COMMAND' Error						;008e	11 2d 01 	. - .
  447 0091 06 1C        	ld b,28					; 28 entries to fill with "jp ErrRaiseDiskCmd"						;0091	06 1c 	. .
  448 0093 21 52 79     	ld hl,SysDosVectors		; address of DOS Vectors Table in RAM								;0093	21 52 79 	! R y
  449 0096              .loop:
  450 0096 36 C3        	ld (hl),$c3				; store JP opcode byte												;0096	36 c3 	6 .
  451 0098 23           	inc hl					; inc destination address											;0098	23 	#
  452 0099 73           	ld (hl),e				; store LSB of ErrRaiseDiskCmd routine address						;0099	73 	s
  453 009A 23           	inc hl					; inc destination address											;009a	23 	#
  454 009B 72           	ld (hl),d				; store MSB of ErrRaiseDiskCmd routine address						;009b	72 	r
  455 009C 23           	inc hl					; inc destination address - next entry								;009c	23 	#
  456 009D 10 F7        	djnz .loop				; repeat for 28 jump vectors										;009d	10 f7 	. .
  457 009F
  458 009F              ; Initialize Extension Vectors (79A6-79E4) to RET
  459 009F 06 15        	ld b,21					; 21 entries to fill with RET opcode								;009f	06 15 	. .
  460 00A1              .loop1:
  461 00A1 36 C9        	ld (hl),$c9				; store RET opcode byte												;00a1	36 c9 	6 .
  462 00A3 23           	inc hl					; point to LSB byte (reserved when entry has JP XXXX)				;00a3	23 	#
  463 00A4 23           	inc hl					; point to MSB byte (reserved when entry has JP XXXX)				;00a4	23 	#
  464 00A5 23           	inc hl					; point to next Extension Vector Entry								;00a5	23 	#
  465 00A6 10 F9        	djnz .loop1				; repeat for 21 Extension Vectors 									;00a6	10 f9 	. .
  466 00A8
  467 00A8              ; -- initialize BASIC Program start
  468 00A8 21 E8 7A     	ld hl,BAS_PrgMemory-1	; address of byte just before BASIC Progrem Memory					;00a8	21 e8 7a 	! . z
  469 00AB 70           	ld (hl),b				; this byte must be 0												;00ab	70 	p
  470 00AC
  471 00AC              ; -- set CPU stack pointer temporarily in area where is BASIC Line Buffer - we dont know memory size yet
  472 00AC 31 F8 79     	ld sp,EditLineBuf+$10	; set CPU Stack in Line Buffer 										;00ac	31 f8 79 	1 . y
  473 00AF
  474 00AF              ; -- reset BASIC  (Stack, For loops, clear Variables)
  475 00AF CD 8F 1B     	call ResetBasicStack	; reset Basic Stack and String Variables							;00af	cd 8f 1b 	. . .
  476 00B2 CD C9 01     	call CmdCLS				; call Clear Screen routine											;00b2	cd c9 01 	. . .
  477 00B5
  478 00B5
  479 00B5              ; ********************************************************************************************
  480 00B5              ; --- deleted code ---
  481 00B5              ; ********************************************************************************************
  482 00B5              ; This code in TRS machine was used to ask user for MEMORY SIZE? by displaying message
  483 00B5              ; and input size typed by user.
  484 00B5              l00b5h:
  485 00B5 00           	nop
  485 00B6 00             nop
  485 00B7 00             nop			; deleted code														;00b5	00 00 00 	.
  486 00B8 00           	nop
  486 00B9 00             nop
  486 00BA 00             nop			; deleted code														;00b8	00 00 00 	.
  487 00BB 00           	nop
  487 00BC 00             nop
  487 00BD 00             nop			; deleted code														;00bb	00 00 00 	.
  488 00BE
  489 00BE
  490 00BE              ; ********************************************************************************************
  491 00BE              ; (cont.) BASIC INITIALIZATION ROUTINE
  492 00BE              ; ********************************************************************************************
  493 00BE 18 04        	jr TestMemory			; Go to Memory Test routine (skip deprecated code)					;00be	18 04 	. .
  494 00C0
  495 00C0
  496 00C0
  497 00C0              ; ********************************************************************************************
  498 00C0              ; --- TRS deprecated code ---
  499 00C0              ; ********************************************************************************************
  500 00C0              ; This code in TRS machine was used to ask user for MEMORY SIZE? by displaying message
  501 00C0              ; and input size typed by user.
  502 00C0 D7           	rst $10					; [TRS] hl - next valid BASIC program char							;00c0	d7 	.
  503 00C1 B7           	or a					; [TRS] Test if entered text (Memory Size) is not empty				;00c1	b7 	.
  504 00C2 20 12        	jr nz,l00d6h			; TRS] Jump if user entered requested Memory Size					;00c2	20 12 	  .
  505 00C4              ; -- [TRS] if entered text was empty program falls thru to determine size of Installed Memory
  506 00C4
  507 00C4
  508 00C4
  509 00C4
  510 00C4              ; ********************************************************************************************
  511 00C4              ; TEST MEMORY SIZE – “MEMSIZE”
  512 00C4              ; ********************************************************************************************
  513 00C4              ; Determine size of installed RAM by Write and Verify Memory locations starting at 7B4D
  514 00C4              ; and continuing upward until Verify fails means the end of memory (or a bad memory location)
  515 00C4              ; is found. After that it jumps to rest of BASIC initialization process.
  516 00C4              TestMemory:
  517 00C4 21 4C 7B     	ld hl,SysMinMemory	; hl - starting address of memory to test 		 						;00c4	21 4c 7b 	! L {
  518 00C7              .loop:
  519 00C7 23           	inc hl				; next address to test													;00c7	23 	#
  520 00C8 7C           	ld a,h				; check if hl is equal to 0												;00c8	7c 	|
  521 00C9 B5           	or l				; .. is this end of memory (address wrapped)?							;00c9	b5 	.
  522 00CA 28 1B        	jr z,l00e7h			; yes - end of memory test - we have full RAM (up to FFFFH)				;00ca	28 1b 	( .
  523 00CC 7E           	ld a,(hl)			; read byte from memory													;00cc	7e 	~
  524 00CD 47           	ld b,a				; save byte to restore it latter										;00cd	47 	G
  525 00CE 2F           	cpl					; inverse bits of byte													;00ce	2f 	/
  526 00CF 77           	ld (hl),a			; store inverted byte as test value										;00cf	77 	w
  527 00D0 BE           	cp (hl)				; test if write was successful											;00d0	be 	.
  528 00D1 70           	ld (hl),b			; restore old value at this location									;00d1	70 	p
  529 00D2 28 F3        	jr z,.loop			; continue if success													;00d2	28 f3 	( .
  530 00D4 18 11        	jr l00e7h			; fail - end of memory test - we have RAM up to HL-1					;00d4	18 11 	. .
  531 00D6
  532 00D6
  533 00D6
  534 00D6
  535 00D6              ; ********************************************************************************************
  536 00D6              ; --- TRS deprecated code ---
  537 00D6              ; ********************************************************************************************
  538 00D6              ; This code in TRS machine was used to ask user for MEMORY SIZE? by displaying message
  539 00D6              ; and input size typed by user.
  540 00D6              l00d6h:
  541 00D6              ; -- hl containst text entered by User to answer MEMORY SIZE? prompt
  542 00D6 CD 5A 1E     	call TextToInt		; [TRS] convert text pointed by hl to integer value (de = value)		;00d6	cd 5a 1e 	. Z .
  543 00D9 B7           	or a				; [TRS] test conversion status - is it 0 (OK)?							;00d9	b7 	.
  544 00DA C2 97 19     	jp nz,ErrRaiseSyntax; [TRS] if non zero - Raise 'SYNTAX ERROR'								;00da	c2 97 19 	. . .
  545 00DD EB           	ex de,hl			; [TRS] Put Memory Size ito hl 											;00dd	eb 	.
  546 00DE 2B           	dec hl				; [TRS] hl - last usable Memory address									;00de	2b 	+
  547 00DF 3E 8F        	ld a,$8f			; [TRS] a - test value to verify RAM at this address					;00df	3e 8f 	> .
  548 00E1 46           	ld b,(hl)			; [TRS] save current byte from tested Memory location					;00e1	46 	F
  549 00E2 77           	ld (hl),a			; [TRS] write test byte to RAM											;00e2	77 	w
  550 00E3 BE           	cp (hl)				; [TRS] Check to see if value was stored successfully					;00e3	be 	.
  551 00E4 70           	ld (hl),b			; [TRS] Restore the old memory content back.							;00e4	70 	p
  552 00E5 20 CE        	jr nz,l00b5h		; [TRS] write failed - ask MEMORY SIZE again by jumping to 00B5H		;00e5	20 ce 	  .
  553 00E7
  554 00E7
  555 00E7
  556 00E7
  557 00E7              ; ********************************************************************************************
  558 00E7              ; MEMORY SETUP – “MEMSETUP”
  559 00E7              ; ********************************************************************************************
  560 00E7              ; After Memory Test register hl contains top RAM address + 1 (one above last good RAM location)
  561 00E7              ; IN: HL - memory address of 1st bad memory cell (fail) or 0000 (pass)
  562 00E7              l00e7h:
  563 00E7 2B           	dec hl					; address of last verified memory location							;00e7	2b 	+
  564 00E8              sub_00e8h:
  565 00E8 11 14 7C     	ld de,MEMORY_MIN		; minimum address required by BASIC to operate						;00e8	11 14 7c 	. . |
  566 00EB DF           	rst $18					; compare if detected memory is above minimum						;00eb	df 	.
  567 00EC DA 7A 19     	jp c,ErrRaiseOutOfMem	; no - raise 'OUT OF MEMORY' error 									;00ec	da 7a 19 	. z .
  568 00EF
  569 00EF              ; -- reserve top 50 bytes for BASIC String Area/Space
  570 00EF 11 CE FF     	ld de,-50				; need to reserve 50 bytes for BASIC String Area/Space				;00ef	11 ce ff 	. . .
  571 00F2 22 B1 78     	ld (MEMORY_TOP),hl		; store Top of Memory available for Basic							;00f2	22 b1 78 	" . x
  572 00F5 19           	add hl,de				; substract 50 bytes for BASIC String Area/Space					;00f5	19 	.
  573 00F6              ; -- start of BASIC String Area/Space is also Top of Stack Pointer
  574 00F6 22 A0 78     	ld (STACKTOPPTR),hl		; store address as CPU Stack Pointer for BASIC						;00f6	22 a0 78 	" . x
  575 00F9 CD 4D 1B     	call DeleteAllBasic		; delete Basic Program, Variables, Pointers and Flags				;00f9	cd 4d 1b 	. M .
  576 00FC
  577 00FC
  578 00FC              ; ----------------- ROM 1.2 only --------------------------------------------------------------
  579 00FC               ifdef VER_12
  580 00FC              ; -- display welcome message
  581 00FC 21 0F 01     	ld hl,TXT_VIDEOTECHBASIC; address of "VIDEO TECHNOLOGY BASIC V1.2" text						;00fc	21 0f 01 	! . .
  582 00FF CD A7 28     	call PrintBasicStr		; print text on Screen	pointed by hl								;00ff	cd a7 28 	. . (
  583 0102 CD 84 34     	call sub_3484h			; Initialize IO Devices (Screen Cursor, Sound, Cassette, etc).		;0102	cd 84 34 	. . 4
  584 0105
  585 0105              ; ----------------- ROM 2.0 only --------------------------------------------------------------
  586 0105               else
  587 0105 ~             	call sub_3484h			; Initialize IO Devices (Screen Cursor, Sound, Cassette, etc).		;00fc	cd 84 34 	. . 4
  588 0105 ~            	ld hl,TXT_VIDEOTECHBASIC; address of "VIDEO TECHNOLOGY BASIC V2.0" text						;00ff	21 0f 01 	! . .
  589 0105 ~            	call PrintBasicStr		; print text on Screen	pointed by hl								;0102	cd a7 28 	. . (
  590 0105               endif
  591 0105              ; ----------------- common code --------------------------------------------------------------
  592 0105
  593 0105
  594 0105
  595 0105
  596 0105              ; ********************************************************************************************
  597 0105              ; CARTRIDGE TEST AND SETUP – “CARTSETUP”
  598 0105              ; ********************************************************************************************
  599 0105              ; At this point Basic Version is on Screen and Machine is ready to start.
  600 0105              ; Following code will determine if any Cartridge/Extension is connected (i.e. Floppy with DOS)
  601 0105              ; and give control to plugged in Cardridge or back system ROM.
  602 0105 ED 56        	im 1					; set CPU Interrupt Mode 1 											;0105	ed 56 	. V
  603 0107 C3 8E 06     	jp SysCartTest			; test if any Cartridge is connected and Init/Start	it				;0107	c3 8e 06 	. . .
  604 010A
  605 010A
  606 010A              ; ********************************************************************************************
  607 010A              ; --- unused data ----
  608 010A              ; ********************************************************************************************
  609 010A              ; Probably garbage data or code left from previous versions of ROM
  610 010A
  611 010A 00 7E 23 FE  	db $00,$7e,$23,$fe,$0d				; unused data											;010a	00 7e 23 fe 0d 	. .
  611 010E 0D
  612 010F
  613 010F
  614 010F              ; ********************************************************************************************
  615 010F              ; BACIC VERSION MESSAGE DATA – “VTBASICMSG”
  616 010F              ; ********************************************************************************************
  617 010F              TXT_VIDEOTECHBASIC:
  618 010F 56 49 44 45  	db "VIDEO TECHNOLOGY",$0d																	;010f	56 49 44 45 4f 20 54 45 43 48 4e 4f 4c 4f 47 59 0d 	.
  618 0113 4F 20 54 45
  618 0117 43 48 4E 4F
  618 011B 4C 4F 47 59
  618 011F 0D
  619 0120
  620 0120              ; ----------------- ROM 1.2 only --------------------------------------------------------------
  621 0120               ifdef VER_12
  622 0120 42 41 53 49  	db "BASIC V1.2",$0d,$0d,0																	;0120	42 41 53 49 43 20 56 31 2e 32 0d 0d 00 	.
  622 0124 43 20 56 31
  622 0128 2E 32 0D 0D
  622 012C 00
  623 012D
  624 012D              ; ----------------- ROM 2.0 only --------------------------------------------------------------
  625 012D               else ; VER_20
  626 012D ~             	db "BASIC V2.0",$0d,$0d,0																	;0120	42 41 53 49 43 20 56 32 2e 30 0d 0d 00 	.
  627 012D               endif
  628 012D
  629 012D              ; ----------------- common code ---------------------------------------------------------------
  630 012D
  631 012D
  632 012D
  633 012D
  634 012D              ; ********************************************************************************************
  635 012D              ; DISK COMMAND ERROR ROUTINE
  636 012D              ; ********************************************************************************************
  637 012D              ; Sets Error Code to 2CH (DISK COMMAND) and jump to common routine to rise BASIC Error
  638 012D              ErrRaiseDiskCmd:
  639 012D 1E 2C        	ld e,#2c				; e - Error Code 2CH - DISK COMMAND									;012d	1e 2c 	. ,
  640 012F C3 A2 19     	jp ErrRaiseError		; Raise 'DISK COMMAND' Error 										;012f	c3 a2 19 	. . .
  641 0132
  642 0132
  643 0132
  644 0132              ; ********************************************************************************************
  645 0132              ; BASIC “POINT” COMMAND ENTRY POINT
  646 0132              ; ********************************************************************************************
  647 0132              ; Test pixel at provided Coordinates and returns it's Color
  648 0132              ; IN: hl - current executed command parser pointer
  649 0132              ;     a - program token
  650 0132              ;     Z = 1 - end of statement ('\0' or ':' found)
  651 0132              ;     CY = 1 - char is digit
  652 0132              l0132h:
  653 0132 D7           	rst $10					; Call NEXT SYMBOL routine at RST 10H								;0132	d7 	.
  654 0133 AF           	xor a					; Set A register to 0 – flag meaning the POINT command				;0133	af 	.
  655 0134 01           	db $01 					; Z80 Trick to skip code											;0134	01 3e 80 	. > .
  656 0135              ; -- The byte at this memory location, 01H, create harmless 3 byte instruction LD BC,803EH.
  657 0135              ; -- As an effect CPU skips 2 next bytes which sets flag to 80H – meaning the SET command.
  658 0135              ; -- This way, they didn’t have to jump over SET or RESET to get to the common graphics code.
  659 0135
  660 0135
  661 0135
  662 0135              ; ********************************************************************************************
  663 0135              ; BASIC "SET" COMMAND ENTRY POINT
  664 0135              ; ********************************************************************************************
  665 0135              ; Set pixel with current selected Color at provided Coordinates
  666 0135              ; IN: hl - current executed command parser pointer
  667 0135              ;     a - program token
  668 0135              ;     Z = 1 - end of statement ('\0' or ':' found)
  669 0135              ;     CY = 1 - char is digit
  670 0135              CmdSET
  671 0135 3E 80        	ld a,$80				; a - flag meaning the SET command 									;0135	3e 80 	. > .
  672 0137 01           	db $01					;  Z80 Trick to skip code											;0137	01 3e 01 	. > .
  673 0138              ; -- The byte at this memory location, 01H, create harmless 3 byte instruction LD BC,013EH.
  674 0138              ; -- As an effect CPU skips 2 next bytes which sets flag to 01H – meaning the RESET command.
  675 0138              ; -- This way, they didn’t have to jump over RESET to get to the common graphics code.
  676 0138
  677 0138
  678 0138
  679 0138              ; ********************************************************************************************
  680 0138              ; BASIC "RESET" COMMAND ENTRY POINT
  681 0138              ; ********************************************************************************************
  682 0138              ; Clear pixel at provided Coordinates
  683 0138              ; IN: hl - current executed command parser pointer
  684 0138              ;     a - program token
  685 0138              ;     Z = 1 - end of statement ('\0' or ':' found)
  686 0138              ;     CY = 1 - char is digit
  687 0138              CmdRESET
  688 0138 3E 01        	ld a,$01				; a - flag meaning the RESET command								;0138	3e 01 	. > .
  689 013A
  690 013A              ; -- common code for POINT, SET and RESET command
  691 013A              ; -- IN: a - BASIC command Flag:
  692 013A              ;            0 - POINT
  693 013A              ;            $80 - SET
  694 013A              ;            1 - RESET
  695 013A F5           	push af					; Save the Command flag in register A on the stack					;013a	f5 	.
  696 013B
  697 013B              ; -- all SET/RESET/POINT commands need a “(” char to start with
  698 013B CF           	rst $08					; Verify Next Token is '('											;013b	cf 	.
  699 013C 28           	defb '('				; Basic '(' token 													;013c	28
  700 013D
  701 013D CD 1C 2B     	call EvalByteExpr		; convert text parameter (X coordinate) to 8bit value				;013d	cd 	. 1c 2b 	+
  702 0140 FE 80        	cp 128					; is X >= 128? (X must be in range 0..127) 							;0140	fe 80 	. .
  703 0142 D2 4A 1E     	jp nc,ErrRaiseFuncCode	; yes - raise FUNCTION CODE Error									;0142	d2 4a 1e 	. J .
  704 0145              ; -- A register = X pixel coordinate
  705 0145 F5           	push af					; save X coordinate on Stack for future use							;0145	f5 	.
  706 0146
  707 0146              ; -- all SET/RESET/POINT commands must have X and Y parameter so ',' is expected
  708 0146 CF           	rst $08					; Verify Next Token is ','											;0146	cf 	.
  709 0147 2C           	defb ','				; Basic ',' token 													;0147	2c 	,
  710 0148 CD 1C 2B     	call EvalByteExpr		; convert text parameter (Y coordinate) to 8bit value				;0148	cd 1c 2b 	. . +
  711 014B FE 40        	cp 64					; is Y >= 64? (Y must be in range 0..63) 							;014b	fe 40 	. @
  712 014D D2 4A 1E     	jp nc,ErrRaiseFuncCode	; yes - raise FUNCTION CODE Error									;014d	d2 4a 1e 	. J .
  713 0150
  714 0150              ; -- calculate Video RAM address of byte defining pixel at X,Y coordinates
  715 0150 5F           	ld e,a					; e - given Y coordinate (screen line number)						;0150	5f 	_
  716 0151 AF           	xor a					; zero value for MSB 												;0151	af 	.
  717 0152 57           	ld d,a					; de - given Y coordinate (screen line number)						;0152	57 	W
  718 0153              ; -- 32 bytes make one line on screen - multiply Y by 32
  719 0153 EB           	ex de,hl				; hl - given Y coordinate (screen line number)						;0153	eb 	.
  720 0154 29           	add hl,hl				; hl = Y * 2														;0154	29 	)
  721 0155 29           	add hl,hl				; hl = Y * 4														;0155	29 	)
  722 0156 29           	add hl,hl				; hl = Y * 8														;0156	29 	)
  723 0157 29           	add hl,hl				; hl = Y * 16														;0157	29 	)
  724 0158 29           	add hl,hl				; hl = Y * 32														;0158	29 	)
  725 0159 EB           	ex de,hl				; de - byte offset in bytes of line to work with					;0159	eb 	.
  726 015A              ; -- every byte makes 4 pixels on screen - divide X by 4
  727 015A F1           	pop af					; a - restore saved X coordinate from Stack							;015a	f1 	.
  728 015B F5           	push af					; save X coordinate on Stack (we will need "fine" offset later)		;015b	f5 	.
  729 015C CB 3F        	srl a					; a = X/2															;015c	cb 3f 	. ?
  730 015E CB 3F        	srl a					; a = X/4															;015e	cb 3f 	. ?
  731 0160              ; -- calculate total VRAM byte offset
  732 0160 83           	add a,e					; add byte-in-line offset (X/4) to LSB of line offset (Y*32)		;0160	83 	.
  733 0161 5F           	ld e,a					; de - total offset of VRAM byte with pixel							;0161	5f 	_
  734 0162              ; -- calculate absolute VRAM address
  735 0162 7A           	ld a,d					; a - MSB of offset													;0162	7a 	z
  736 0163 F6 70        	or $70					; add $70 to MSB of offset (VRAM starts at 7000H)					;0163	f6 70 	. p
  737 0165 57           	ld d,a					; de - absolute VRAM address for byte with our pixel				;0165	57 	W
  738 0166              ; -- prepeare mask and determine number of byte shifts to mask this pixel
  739 0166 F1           	pop af					; a - restore saved X coordinate from Stack							;0166	f1 	.
  740 0167 E6 03        	and %00000011			; extract from X pixel-in-byte index (0..3)							;0167	e6 03 	. .
  741 0169 87           	add a,a					; a - bit number (counted from left to right!) (0,2,4,6)			;0169	87 	.
  742 016A 47           	ld b,a					; save in b as counter of shifts to do								;016a	47 	G
  743 016B              ; -- split code if we process POINT command
  744 016B F1           	pop af					; a - BASIC Command Flag 											;016b	f1 	.
  745 016C B7           	or a					; is it 0 (POINT COmmand)?											;016c	b7 	.
  746 016D CA E7 38     	jp z,l38e7h				; yes - jump to 38E7 routine 										;016d	ca e7 38 	. . 8
  747 0170
  748 0170              ; -- code for SET or RESET Command
  749 0170 F5           	push af					; save on Stack BASIC Command Flag									;0170	f5 	.
  750 0171 0E 3F        	ld c,%00111111			; c - pixel bitmask (set for pixel-in-byte index = 0)				;0171	0e 3f 	. ?
  751 0173 3A 46 78     	ld a,(FCOLOR)			; a - current selected Color (stored in high nibble)				;0173	3a 46 78 	: F x
  752 0176              ; -- convert Colot to 2bit value stored in bit 7 and bit 6 (4 colors allowed)
  753 0176 CB 27        	sla a					; shift left Color value by 1 bit									;0176	cb 27 	. '
  754 0178 CB 27        	sla a					; shift left Color value by 1 bit									;0178	cb 27 	. '
  755 017A              .loop:
  756 017A CB 0F        	rrc a					; rotate right Color bits 											;017a	cb 0f 	. .
  757 017C CB 09        	rrc c					; rotate right Mask bits											;017c	cb 09 	. .
  758 017E 10 FA        	djnz .loop				; repeat rotate as many bits as computes in b						;017e	10 fa 	. .
  759 0180              ; -- NOTE --
  760 0180              ; Above code is bad in terms of performance.
  761 0180              ; When we address specific pixels like 0,4,8,12,… register B will contain 0 and Color (a)
  762 0180              ; and Mask (c) already have required value. There is no need for rotating at all.
  763 0180              ; But having 0 in register b, first djnz will make b equals 255 and in turn Color
  764 0180              ; and Mask will be rotated 256 times instead of none at all.
  765 0180 C3 03 39     	jp l3903h				; jump to execute SET or RESET Command								;0180	c3 03 39 	. . 9
  766 0183
  767 0183
  768 0183
  769 0183
  770 0183              ; ********************************************************************************************
  771 0183              ; TAPE VERIFY EXIT WITH ERROR ROUTINE
  772 0183              ; ********************************************************************************************
  773 0183              ; Clears VERIFY Command Flag, displays 'ERROR' text and jumps back to finalize
  774 0183              ; Tape Read  routine.
  775 0183              l0183h:
  776 0183              ; -- clear flag meaning VERIFY in progress
  777 0183 21 39 78     	ld hl,SYSFLAGS			; hl - address of System Flags variable								;0183	21 39 78 	! 9 x
  778 0186 CB 9E        	res 3,(hl)				; clear BASIC VERIFY Command Flag 									;0186	cb 9e 	. .
  779 0188              ; -- display ERROR text
  780 0188 21 84 03     	ld hl,TXT_ERROR			; hl - address of 'ERROR' text										;0188	21 84 03 	! . .
  781 018B CD A7 28     	call PrintBasicStr		; print 'ERROR' text on Screen										;018b	cd a7 28 	. . (
  782 018E C3 CF 36     	jp TapeReadExit			; Go finalize Read/Verify Tape routine and go back to BASIC 		;018e	c3 cf 36 	. . 6
  783 0191
  784 0191
  785 0191
  786 0191              ; ********************************************************************************************
  787 0191              ; --- unknown deprecated data or code – not used ----
  788 0191              ; ********************************************************************************************
  789 0191              ; Probably garbage data or code left from previous versions of ROM
  790 0191 F1 FE 20 20  	db $f1,$fe,$20,$20,$14,$1a,$13,$fe				; unused data								;0191	f1 fe 20 20 14 1a 13 fe	.
  790 0195 14 1A 13 FE
  791 0199 20 28 FA FE  	db $20,$28,$fa,$fe								; unused data								;0199	20 28 fa fe 	( .
  792 019D
  793 019D
  794 019D
  795 019D              ; ********************************************************************************************
  796 019D              ; BASIC "INKEY$" COMMAND ENTRY POINT
  797 019D              ; ********************************************************************************************
  798 019D              ; Create one-character string from keyboard input.
  799 019D              ; Routine will create a one-character string using the contents of Last Key Pressed at 7899H.
  800 019D              ; However, if 7899H contains zero, the keyboard will be scanned and if a key is depressed,
  801 019D              ; a string will be created using the character input from the keyboard.
  802 019D              ; If no key is depressed,, a null string (a string zero bytes in length) will be created.
  803 019D              ; On exit, the VARPTRR to the string created by this routine will be found in the ACC,
  804 019D              ; with the NTF set to 3.
  805 019D              ; Also, note that the keyboard is normally scanned during BASIC program execution
  806 019D              ; for the presence of the BREAK keys. If a character other than that is pressed,
  807 019D              ; the character thus entered is stored in Last Key Pressed variable at 7899H.
  808 019D              ; Thus, a keystroke received between successive INKEY$ calls is held "in the buffer"
  809 019D              ; to be used at the next execution of INKEY$
  810 019D              ; IN: hl - current executed command parser pointer
  811 019D              ;     a - program token
  812 019D              ;     Z = 1 - end of statement ('\0' or ':' found)
  813 019D              ;     CY = 1 - char is digit
  814 019D              l019dh:
  815 019D D7           	rst $10					; Call NEXT SYMBOL routine at RST 10H								;019d	d7 	. .
  816 019E
  817 019E
  818 019E
  819 019E              ; ********************************************************************************************
  820 019E              ; BASIC "INKEY$" COMMAND SECOND ENTRY POINT
  821 019E              ; ********************************************************************************************
  822 019E              ; Create one-character string from keyboard input (see above description).
  823 019E              BAS_InkeySToACC:
  824 019E E5           	push hl					; save hl - interpreter current pointer								;019e	e5 	.
  825 019F              ; -- check if we already have key pressed in Last Key Pressed variable
  826 019F 3A 99 78     	ld a,(KEYS_LASTKEY)		; a - Last Key Pressed												;019f	3a 99 78 	: . x
  827 01A2 B7           	or a					; was key presset before?											;01a2	b7 	.
  828 01A3 20 06        	jr nz,.keypressed		; yes - consume this key and create one character String 			;01a3	20 06 	  .
  829 01A5              ; -- no key in buffer - read key from user
  830 01A5 CD 58 03     	call KeysReadKeySaveDE	; scan keyboard to test if now key is pressed 						;01a5	cd 58 03 	. X .
  831 01A8 B7           	or a					; was key pressed now?												;01a8	b7 	.
  832 01A9 28 11        	jr z,.setempty			; no - create Empty String											;01a9	28 11 	( .
  833 01AB              .keypressed:
  834 01AB              ; -- A contains Key Pressed
  835 01AB F5           	push af					; save key pressed on Stack											;01ab	f5 	.
  836 01AC              ; -- consume key - clear Last Key variable
  837 01AC AF           	xor a					; a =0 - no key pressed												;01ac	af 	.
  838 01AD 32 99 78     	ld (KEYS_LASTKEY),a		; store 0 to clear Last Key Pressed variable						;01ad	32 99 78 	2 . x
  839 01B0              ; -- allocate 1-char String
  840 01B0 3C           	inc a					; a = 1 - string length in bytes 									;01b0	3c 	<
  841 01B1 CD 57 28     	call StrNew				; Allocate 1 char string and Create String Vector (VARPTR)			;01b1	cd 57 28 	. W (
  842 01B4              ; -- store char into allocated memory
  843 01B4 F1           	pop af					; restore af - key pressed (converted to char)						;01b4	f1 	.
  844 01B5 2A D4 78     	ld hl,(StrVecBuf+1)		; hl - address of memory allocated for string						;01b5	2a d4 78 	* . x
  845 01B8 77           	ld (hl),a				; put char into String body		 									;01b8	77 	w
  846 01B9              ; -- copy result to ACC/REG1
  847 01B9 C3 84 28     	jp l2884h				; copy created string to ACC/REG1									;01b9	c3 84 28 	. . (
  848 01BC
  849 01BC              .setempty:
  850 01BC              ; -- create Empty String variable directly in ACC/REG1
  851 01BC 21 28 19     	ld hl,TXT_EMPTY			; hl points to char '\0' - End of String Terminator					;01bc	21 28 19 	! ( .
  852 01BF 22 21 79     	ld (ACC_SNG),hl			; store char address to ACC/REG1						 			;01bf	22 21 79 	" ! y
  853 01C2 3E 03        	ld a,3					; a - Number Type Flag (NTF) = 3 (String type)						;01c2	3e 03 	> .
  854 01C4 32 AF 78     	ld (MATH_NTF),a			; set NTF - ACC contains String Type value							;01c4	32 af 78 	2 . x
  855 01C7 E1           	pop hl					; restore hl - interpreter current pointer							;01c7	e1 	.
  856 01C8 C9           	ret						; ---------------- End of Proc ------------------------				;01c8	c9 	.
  857 01C9
  858 01C9
  859 01C9
  860 01C9
  861 01C9              ; ********************************************************************************************
  862 01C9              ; BASIC CLS ROUTINE – “CLS“
  863 01C9              ; ********************************************************************************************
  864 01C9              ; Set Cursor Position to top left (Cursor Home) and clears Screen
  865 01C9              ; IN: hl - current executed command parser
  866 01C9              ;     a - command byte
  867 01C9              ;     Z = 1 - end of statement ('\0' or ':' found)
  868 01C9              ;     CY = 1 - char is digit
  869 01C9              CmdCLS:
  870 01C9 3E 1C        	ld a,#1c			; a - Cursor Home ASCII control char 									;01c9	3e 1c 	> .
  871 01CB CD 3A 03     	call ScrSendByteSafe; send char to Screen - set Cursot to top-left 							;01cb	cd 3a 03 	. : .
  872 01CE 3E 1F        	ld a,#1f			; a - Clear Screen ASCII control char									;01ce	3e 1f 	> .
  873 01D0 C3 3A 03     	jp ScrSendByteSafe	; send char to Screen - clear Scree and reset Editor Variables			;01d0	c3 3a 03 	. : .
  874 01D3
  875 01D3
  876 01D3
  877 01D3
  878 01D3              ; ********************************************************************************************
  879 01D3              ; BASIC RANDOM ROUTINE “RANDOM“
  880 01D3              ; ********************************************************************************************
  881 01D3              ; This routine takes a value out of the REFRESH register R and stores it in location 78ABH
  882 01D3              ; which is middle byte of 24bit Random Seed variable.
  883 01D3              CmdRANDOM
  884 01D3 ED 5F        	ld a,r				; a - value from Refresh Memory Register R								;01d3	ed 5f 	. _
  885 01D5 32 AB 78     	ld (RANDOMSEED),a	; store 8bit value as middle byte of Random Seed variable				;01d5	32 ab 78 	2 . x
  886 01D8 C9           	ret					; -------------- End of Proc -------------------------- 				;01d8	c9 	.
  887 01D9
  888 01D9
  889 01D9
  890 01D9              ; ********************************************************************************************
  891 01D9              ; KEYS TO ASCII or BASIC COMMAND CONVERSION TABLE
  892 01D9              ; ********************************************************************************************
  893 01D9              ; Keyboard Scan Code to Ascii Conversion Table
  894 01D9              ;
  895 01D9              ; -- Normal (w/o Shift, w/o Ctrl, w/o Function)
  896 01D9              TabKey2Char:
  897 01D9 54 47 42 35  	db 'T','G','B','5','N','6','Y','H'															;01d9	54 47 42 35 4e 36 59 48 	H
  897 01DD 4E 36 59 48
  898 01E1 57 53 58 32  	db 'W','S','X','2','.','9','O','L'															;01e1	57 53 58 32 2e 39 4f 4c 	L
  898 01E5 2E 39 4F 4C
  899 01E9 00 00 00 00  	db  0,  0,  0,  0,  0, '-',$0d,':'															;01e9	00 00 00 00 00 2d 0d 3a	.
  899 01ED 00 2D 0D 3A
  900 01F1 45 44 43 33  	db 'E','D','C','3',',','8','I','K'															;01f1	45 44 43 33 2c 38 49 4b 	K
  900 01F5 2C 38 49 4B
  901 01F9 51 41 5A 31  	db 'Q','A','Z','1',' ','0','P',';'															;01f9	51 41 5a 31 20 30 50 3b 	;
  901 01FD 20 30 50 3B
  902 0201 52 46 56 34  	db 'R','F','V','4','M','7','U','J'															;0201	52 46 56 34 4d 37 55 4a 	J
  902 0205 4D 37 55 4A
  903 0209
  904 0209              ; -- Shift (w/ Shift)
  905 0209              ; -- Values in range 80H..8FH are Semigraphic Chars
  906 0209              TabShiftKey2Char:
  907 0209 8C 89 00 25  	db $8c,$89, 0, '%','^','&',$83,$86															;0209	8c 89 00 25 5e 26 83 86 	.
  907 020D 5E 26 83 86
  908 0211 8D 82 00 22  	db $8d,$82, 0, '"','>',')','[','?'															;0211	8d 82 00 22 3e 29 5b 3f 	?
  908 0215 3E 29 5B 3F
  909 0219 00 00 00 00  	db  0,  0,  0,  0,  0, '=',$0d,'*'															;0219	00 00 00 00 00 3d 0d 2a	.
  909 021D 00 3D 0D 2A
  910 0221 8B 84 00 23  	db $8b,$84, 0, '#','<','(',$85,'/'															;0221	8b 84 00 23 3c 28 85 2f 	/
  910 0225 3C 28 85 2F
  911 0229 8E 81 80 21  	db $8e,$81,$80,'!',' ','@',']','+'															;0229	8e 81 80 21 20 40 5d 2b 	+
  911 022D 20 40 5D 2B
  912 0231 87 88 00 24  	db $87,$88, 0, '$',$5c,$27,$8a,$8f															;0231	87 88 00 24 5c 27 8a 8f 	.
  912 0235 5C 27 8A 8F
  913 0239
  914 0239              ; -- Ctrl (w/ Ctrl)
  915 0239              ; -- Values 80H and higher are BASIC Commands Tokens
  916 0239              TabCtrlKey2Cmd:
  917 0239              ; BASIC: THEN   GOTO  LLIST  LIST   COLOR   RUN     ELSE  CLS
  918 0239 CA 8D B5 B4  	db 	 $ca,   $8d,  $b5,   $b4,   $97,    $8e,    $95,  $84									;0239	ca 8d b5 b4 97 8e 95 84 	.
  918 023D 97 8E 95 84
  919 0241              ; BASIC: TO     STEP  POKE   CLOAD  <UP>    READ    LET   <INS>
  920 0241 BD CC B1 B9  	db   $bd,   $cc,  $b1,   $b9,   $1b,    $8b,    $8c,  $15									;0241	bd cc b1 b9 1b 8b 8c 15 	.
  920 0245 1B 8B 8C 15
  921 0249              ; BASIC: <>     <>    <>     <>     <>      <BREAK> <>    <>
  922 0249 00 00 00 00  	db    0,    0,    0,     0,     0,      1,      0,    0										;0249	00 00 00 00 00 01 00 00 	. . .
  922 024D 00 01 00 00
  923 0251              ; BASIC: NEXT   DIM   CONT   CRUN   <RIGHT> NEW     INPUT TAB(
  924 0251 87 8A B3 9C  	db   $87,   $8a,  $b3,   $9c,   $09,    $bb,    $89,  $bc									;0251	87 8a b3 9c 09 bb 89 bc 	.
  924 0255 09 BB 89 BC
  925 0259              ; BASIC: FOR    MODE( PEEK(  CSAVE  <DOWN>  DATA    PRINT <RUBOUT>
  926 0259 81 9D E5 BA  	db   $81,   $9d,  $e5,   $ba,   $0a,    $88,    $b2,  $7f									;0259	81 9d e5 ba 0a 88 b2 7f
  926 025D 0A 88 B2 7F
  927 0261              ; BASIC: RETURN GOSUB LPRINT VERIFY <LEFT>  END     IF    REM
  928 0261 92 91 AF 98  	db   $92,   $91,  $af,   $98,   $08,    $80,    $8f,  $93									;0261	92 91 af 98 08 80 8f 93 	.
  928 0265 08 80 8F 93
  929 0269
  930 0269              ; -- Function (w/ Function active)
  931 0269              ; -- Values 80H and higher are BASIC Commands Tokens
  932 0269              TabCtrlKey2Func:
  933 0269              ; BASIC: MID$(  STOP    SOUND LOG(  USING EXP(    RIGHT$( SET
  934 0269 FA 94 9E DF  	db   $fa,   $94,    $9e,  $df,  $bf,  $e0,    $f9,    $83									;0269	fa 94 9e df bf e0 f9 83 	.
  934 026D BF E0 F9 83
  935 0271              ; BASIC: VAL(   STR$(   OUT   COS(  <>    ABS(    OR      <>
  936 0271 F5 F4 A0 E1  	db   $f5,   $f4,    $a0,  $e1,  0,    $d9,    $d3,    0										;0271	f5 f4 a0 e1 00 d9 d3 00 	. .
  936 0275 00 D9 D3 00
  937 0279              ; BASIC: <>     <>      <>    <>    <>    <BREAK> <>      <>
  938 0279 00 00 00 00  	db   0,     0,      0,    0,    0,    1,      0,      0										;0279	00 00 00 00 00 01 00 00 	. . .
  938 027D 00 01 00 00
  939 0281              ; BASIC: LEN(   RESTORE COPY  TAN(  <>    SQR(    AND     POINT
  940 0281 F3 90 96 E3  	db   $f3,   $90,    $96,  $e3,  0,    $dd,    $d2,    $c6									;0281	f3 90 96 e3 00 dd d2 c6 	. . .
  940 0285 00 DD D2 C6
  941 0289              ; BASIC: CHR$(  ASC(    INP   SIN(  <>    INT(    NOT     <>
  942 0289 F7 F6 DB E2  	db   $f7,   $f6,    $db,  $e2,  0,    $d8,    $cb,    0										;0289	f7 f6 db e2 00 d8 cb 00 	. .
  942 028D 00 D8 CB 00
  943 0291              ; BASIC: LEFT$( RND(    USR   ATN(  <>    SGN(    INKEY$  RESET
  944 0291 F8 DE C1 E4  	db   $f8,   $de,    $c1,  $e4,  0,    $d7,    $c9,$82										;0291	f8 de c1 e4 00 d7 c9 82	.
  944 0295 00 D7 C9 82
  945 0299
  946 0299
  947 0299
  948 0299
  949 0299              ; ********************************************************************************************
  950 0299              ; BASIC FUNCTION TOKENS LIST
  951 0299              ; ********************************************************************************************
  952 0299              ; This is list of BASIC Functions Tokens that need to be appended with the '(' to output
  953 0299              ; after key is pressed with active Function Mode (CTRL+RETURN).
  954 0299              l0299h:
  955 0299 E2 E1 E3 E4  	db $e2, $e1, $e3, $e4				; SIN, COS, TAN, ATN 									;0299	e2 e1 e3 e4 	. . .
  956 029D DF E0 D7 DD  	db $df, $e0, $d7, $dd				; LOG, EXP, SNG, SQR									;029d	df e0 d7 dd .
  957 02A1 D9 D8        	db $d9, $d8							; ABS, INT 												;02a1	d9 d8.
  958 02A3 F7 F5 F3 F8  	db $f7, $f5, $f3, $f8, $f7, $f9		; CHR$, VAL, LEN, LEFT$, CHR$, RIGHT$					;02a3	f7 	.
  958 02A7 F7 F9
  959 02A9 9D           	db $9d								; MODE													;02a9	9d 	.
  960 02AA F6 F4        	db $f6, $f4							; ASC, STR$												;02aa	f6 f4 	. .
  961 02AC DE E5        	db $de, $e5 						; RND, PEEK												;02ac	de e5 	. .
  962 02AE FA           	db $fa								; MID$													;02ae	fa  	. . .
  963 02AF
  964 02AF
  965 02AF
  966 02AF              ; ********************************************************************************************
  967 02AF              ; SEMIGRAPHIC CHARS DEFINITIONS
  968 02AF              ; ********************************************************************************************
  969 02AF              ; Table for outputting Semigraphic (Semi4) characters on a printer.
  970 02AF              ; The table contains two bytes per character.
  971 02AF              ; Printer will use only 7 bits. Set bit (6..0) will plot a dot by Printer.
  972 02AF              ; TODO: How Printing with Dot Printer Works
  973 02AF              l02afh:
  974 02AF 80 80        	db %10000000,%10000000																		;02af	80 80 	. . .
  975 02B1 80 B8        	db %10000000,%10111000 																		;02b1	80 b8 	.
  976 02B3 B8 80        	db %10111000,%10000000 																		;02b3	b8 80 	.
  977 02B5 B8 B8        	db %10111000,%10111000																		;02b5	b8 b8 	.
  978 02B7 80 87        	db %10000000,%10000111																		;02b7	80 87 	.
  979 02B9 80 BF        	db %10000000,%10111111																		;02b9	80 bf 	.
  980 02BB B8 87        	db %10111000,%10000111																		;02bb	b8 87 	.
  981 02BD B8 BF        	db %10111000,%10111111																		;02bd	b8 bf 	.
  982 02BF 87 80        	db %10000111,%10000000																		;02bf	87 80 	.
  983 02C1 87 B8        	db %10000111,%10111000																		;02c1	87 b8 	.
  984 02C3 BF 80        	db %10111111,%10000000																		;02c3	bf 80 	.
  985 02C5 BF B8        	db %10111111,%10111000																		;02c5	bf b8 	.
  986 02C7 87 87        	db %10000111,%10000111																		;02c7	87 87 	.
  987 02C9 87 BF        	db %10000111,%10111111																		;02c9	87 bf 	.
  988 02CB BF 87        	db %10111111,%10000111																		;02cb	bf 87 	.
  989 02CD BF BF        	db %10111111,%10111111																		;02cd	bf bf 	.
  990 02CF
  991 02CF
  992 02CF
  993 02CF
  994 02CF              ; ********************************************************************************************
  995 02CF              ; SOUND NOTES PERIOD DEFINITIONS
  996 02CF              ; ********************************************************************************************
  997 02CF              ; Table of 16bit values for every 30 Sound Notes.
  998 02CF              ; Every entry is related to Sound wave cycle time (1/f). Higher value makes lower note.
  999 02CF              ; Used as counter init value in routine generating sound.
 1000 02CF              SNDFREQTAB:
 1001 02CF 72 02        	dw	$0272							; A2													;02cf	72 02 	.
 1002 02D1 4F 02        	dw	$024f							; A#2													;02d1	4f 02 	.
 1003 02D3 2E 02        	dw	$022e							; B2													;02d3	2e 02 	. .
 1004 02D5 0E 02        	dw	$020e							; C3													;02d5	0e 02 	. .
 1005 02D7 F1 01        	dw	$01f1							; C#3													;02d7	f1 01	.
 1006 02D9 D5 01        	dw	$01d5							; D3													;02d9	d5 01 	. . .
 1007 02DB B7 01        	dw	$01b7							; D#3													;02db	b7 01	.
 1008 02DD 9E 01        	dw	$019e							; E3													;02dd	9e 01 	. . .
 1009 02DF 86 01        	dw	$0186							; F3													;02df	86 01	.
 1010 02E1 70 01        	dw	$0170							; F#3													;02e1	70 01 	. p .
 1011 02E3 5B 01        	dw	$015b							; G3													;02e3	5b 01	[
 1012 02E5 48 01        	dw	$0148							; G#3													;02e5	48 01 	. H .
 1013 02E7 35 01        	dw	$0135							; A3													;02e7	35 01	5
 1014 02E9 23 01        	dw	$0123							; A#3													;02e9	23 01 	. # .
 1015 02EB 13 01        	dw	$0113							; B3													;02eb	13 01	.
 1016 02ED 03 01        	dw	$0103							; C4													;02ed	03 01 	. . .
 1017 02EF F4 00        	dw	$00f4							; C#4													;02ef	f4 00 	. . .
 1018 02F1 E6 00        	dw	$00e6							; D4													;02f1	e6 00 	.
 1019 02F3 D9 00        	dw	$00d9							; D#4													;02f3	d9 00 	.
 1020 02F5 CD 00        	dw	$00cd							; E4													;02f5	cd 00 	. . .
 1021 02F7 C1 00        	dw	$00c1							; F4													;02f7	c1 00 	.
 1022 02F9 B6 00        	dw	$00b6							; F#4													;02f9	b6 00 	.
 1023 02FB AB 00        	dw	$00ab							; G4													;02fb	ab 00 	.
 1024 02FD A1 00        	dw	$00a1							; G#4													;02fd	a1 00 	.
 1025 02FF 98 00        	dw	$0098							; A4													;02ff	98 00 	.
 1026 0301 8F 00        	dw	$008f							; A#4													;0301	8f 00 	.
 1027 0303 87 00        	dw	$0087							; B4													;0303	87 00 	.
 1028 0305 7F 00        	dw	$007f							; C5													;0305	7f 00 	.
 1029 0307 78 00        	dw	$0078							; C#5													;0307	78 00 	.
 1030 0309 70 00        	dw	$0070							; D5													;0309	70 00 	.
 1031 030B 6A 00        	dw	$006a							; D#5													;030b	6a 00 	.
 1032 030D
 1033 030D
 1034 030D
 1035 030D
 1036 030D
 1037 030D              ; ********************************************************************************************
 1038 030D              ; REFRESH CURSOR
 1039 030D              ; ********************************************************************************************
 1040 030D              ; Refresh char at Cursor Position on Screen (remove Invert)
 1041 030D              ; Register A is preserved
 1042 030D              ScrRefreshCursor:
 1043 030D 47           	ld b,a					; save a register													;030d	47 	G
 1044 030E 3A 3C 78     	ld a,(CURSORCHAR)	    ; a - stored current Cursor char at Cursor Position					;030e	3a 3c 78 	: < x
 1045 0311 2A 20 78     	ld hl,(CURSORADDR)	    ; hl - Video RAM absolute address of Cursor 						;0311	2a 20 78 	*   x
 1046 0314 77           	ld (hl),a				; update char on Screen												;0314	77 	w
 1047 0315 78           	ld a,b					; restore a	regiser													;0315	78 	x
 1048 0316 C9           	ret						; ------------------ End of Proc ------------------					;0316	c9 	.
 1049 0317
 1050 0317
 1051 0317
 1052 0317
 1053 0317              ; ********************************************************************************************
 1054 0317              ; MOVE CURSOR UP
 1055 0317              ; ********************************************************************************************
 1056 0317              ; Moves Cursor Position 1 line up. This routine doesnt check if parameter is valid
 1057 0317              ; (i.e. Cursor is at 1st line of screen).
 1058 0317              ; IN: hl - Video RAM address of current Cursor Position
 1059 0317              sub_0317h:
 1060 0317 01 20 00     	ld bc,32		        ; 32 chars per line                                 				;0317	01 20 00 	.   .
 1061 031A B7           	or a			        ; clear Carry flag                                  				;031a	b7 	.
 1062 031B ED 42        	sbc hl,bc		        ; subtract 32 bytes                                 				;031b	ed 42 	. B
 1063 031D 22 20 78     	ld (CURSORADDR),hl		; save as new Cursor address                        				;031d	22 20 78 	"   x
 1064 0320 C9           	ret			            ; ------------------ End of Proc ------------------					;0320	c9 	.
 1065 0321
 1066 0321
 1067 0321
 1068 0321
 1069 0321              ; ********************************************************************************************
 1070 0321              ; ; SOUND NOTES DURATION DEFINITIONS
 1071 0321              ; ********************************************************************************************
 1072 0321              ; Table of multiplers for Music Notes duration
 1073 0321              ; Entries for every valid 2nd param of SOUND Command (in range 1..9)
 1074 0321              SNDDURTAB:
 1075 0321              ; -- Notes:	1/8	 1/4  3/8  1/2  3/4	 1	 3/2	2	 3
 1076 0321 01 02 03 04  	db		1,	 2,	  3,   4,	6,	 8,	 12,	16,	 24											;0321	01 02 03 04 06 08 0c 10 18 	. .
 1076 0325 06 08 0C 10
 1076 0329 18
 1077 032A
 1078 032A
 1079 032A
 1080 032A
 1081 032A              ; ********************************************************************************************
 1082 032A              ; OUTPUT CHAR ROUTINE - “OUTCHR”
 1083 032A              ; ********************************************************************************************
 1084 032A              ; This is a general purpose output routine which outputs a byte/char from the A register to Screen,
 1085 032A              ; Tape or Printer. In order to use it, the Current Output Device variable must be loaded with:
 1086 032A              ;   0 for Screen
 1087 032A              ;   1 for Printer
 1088 032A              ;  -1 for Tape/Cassette (any negative value 80H..FFH).
 1089 032A              ; NOTE: Warning: This routine calls a [TODO] Disk BASIC link at address 79c1
 1090 032A              ; which may have to be "plugged" with a RET (C9H) instruction.
 1091 032A              ; IN:  a - byte to send
 1092 032A              ;      [789CH] - Output Device Flag to send byte to
 1093 032A              PrintChar:
 1094 032A C5           	push bc					; save bc																	;032a	c5 	.
 1095 032B 4F           	ld c,a					; save char/byte to send in C												;032b	4f 	O
 1096 032C              ; -- call Extension Vector in case external device want intercept
 1097 032C CD C1 79     	call SysExtByteOut		; call Extension Vector at [79C1H] - just RET w/o installed Extension		;032c	cd c1 79 	. . y
 1098 032F              ; -- determine Output Device
 1099 032F 3A 9C 78     	ld a,(SysCurOutDev)		; a - Current Output Device													;032f	3a 9c 78 	: . x
 1100 0332 B7           	or a					; set flags: Z - screen, NZ - printer, M - tape								;0332	b7 	.
 1101 0333              ; -- restore input data
 1102 0333 79           	ld a,c					; restore a (byte/char to send)												;0333	79 	y
 1103 0334 C1           	pop bc					; restore bc																;0334	c1 	.
 1104 0335              ; -- output char/byte to DEvice
 1105 0335 FA 54 3B     	jp m,TapeWriteChar		; M=1 - send char/byte to Tape Device										;0335	fa 54 3b 	. T ;
 1106 0338 20 62        	jr nz,PrinterSendByte	; Z=0 - send char/byte to Printer Device									;0338	20 62 	  b
 1107 033A              ; -- Z=1 - send char to Screen Device
 1108 033A
 1109 033A
 1110 033A
 1111 033A
 1112 033A
 1113 033A              ; *********************************************************************************************************
 1114 033A              ; OUTPUT CHAR TO SCREEN ROUTINE (SAFE)
 1115 033A              ; *********************************************************************************************************
 1116 033A              ; Saves contents of all registers and calls PrintChar routine
 1117 033A              ; IN: a - char to print on Screen
 1118 033A              ScrSendByteSafe:
 1119 033A D5           	push de					; save de 																	;033a	d5 	.
 1120 033B F5           	push af					; save af																	;033b	f5 	.
 1121 033C C5           	push bc					; save bc																	;033c	c5 	.
 1122 033D E5           	push hl					; save hl																	;033d	e5 	.
 1123 033E CD 8B 30     	call ScrPrintChar		; print char on Screen at current Cursor position							;033e	cd 8b 30 	. . 0
 1124 0341 E1           	pop hl					; restore hl																;0341	e1 	.
 1125 0342 C1           	pop bc					; restore bc 																;0342	c1 	.
 1126 0343 00           	nop
 1126 0344 00             nop				; removed code																;0343	00 00 	.
 1127 0345 F1           	pop af					; restore af																;0345	f1 	.
 1128 0346 D1           	pop de					; restore de																;0346	d1 	.
 1129 0347 C9           	ret						; -------------- End of Proc ------------------------------					;0347	c9 	.
 1130 0348
 1131 0348
 1132 0348
 1133 0348
 1134 0348              ; *********************************************************************************************************
 1135 0348              ; [TRS] GET CURSOR POSITION IN LINE ---- not used ----
 1136 0348              ; *********************************************************************************************************
 1137 0348              ; Get the cursor location (taking into account whether we are in 32 or 64 character mode).
 1138 0348              ; Just like in VZ/Laser computers variable at 783BH shadows last value wrote to IOLATCH (6800H)
 1139 0348              ; in TRS-80 Computers variable at 403DH (in VZ200 it would be 783DH) contains last value wrote
 1140 0348              ; to IO PORT 0FFh with BITS meaning:
 1141 0348              ; - bit 3	Select video 32 character mode if set
 1142 0348              ; - bit 2 	Turns on cassette tape relay if set
 1143 0348              ; - bit 0,1	Are set for positive and negative audio pulses to the cassette "AUX" plug
 1144 0348              ; Not used in VZ/Laser ROM 1.2 nor ROM 2.0
 1145 0348              ; OUT: A - value in the range 0..63 or 0..31 depend on video display mode
 1146 0348              GetCursorInLine:
 1147 0348              ; -- check flag byte to determine if Video Display is in 32 or 64 chars/line mode.
 1148 0348 3A 3D 78     	ld a,($783d)			; a - last value wrote to IO Port FFH - HW Latch							;0348	3a 3d 78 	: = x
 1149 034B E6 08        	and %00001000			; isolate and test bit 3 - is 32 chars/line mode ON							;034b	e6 08 	. .
 1150 034D              ; -- low byte of Video RAM address is enough to determine CUrsor in line index
 1151 034D 3A 20 78     	ld a,(CURSORADDR)		; a - Cursor VRAM address LSB only 											;034d	3a 20 78 	:   x
 1152 0350 28 03        	jr z,.mode64			; no - active Mode 64 chars/line - skip rotation and next instruction		;0350	28 03 	( .
 1153 0352              ; -- when 32 chars/line Mode is active
 1154 0352 0F           	rrca					; divide address LSB by 2 													;0352	0f 	.
 1155 0353 E6 1F        	and $1f					; constrain value range to 0..31											;0353	e6 1f 	. .
 1156 0355              .mode64:
 1157 0355 E6 1F        	and $1f					; constrain value range to 0..31 (see NOTE below)							;0355	e6 1f 	. .
 1158 0357 C9           	ret						; return with value															;0357	c9 	.
 1159 0358              ; NOTE: Originally in TRS ROM above instruction was "and $3f" which constrains value to 0..63
 1160 0358              ;       Hard to say why mask was changed to $1f and in the end of day routine was not used.
 1161 0358
 1162 0358
 1163 0358
 1164 0358
 1165 0358
 1166 0358              ; *********************************************************************************************************
 1167 0358              ; GET KEY ROUTINE
 1168 0358              ; *********************************************************************************************************
 1169 0358              ; Calls standard Keyboard Read routine but preserve DE register and calls Extension Vector first.
 1170 0358              ; NOTE: You may bypass this Extension Vector call by entering the routine at 035BH.
 1171 0358              ; OUT: a - key pressed or 0 if none
 1172 0358              KeysReadKeySaveDE:
 1173 0358 CD C4 79     	call SysExtKeyRead		; call DOS OnKeysRead hook													;0358	cd c4 79 	. . y
 1174 035B D5           	push de					; save de 																	;035b	d5 	.
 1175 035C CD 2B 00     	call KeysReadKey		; read Key Pressed via standard Keyboard Read routine						;035c	cd 2b 00 	. + .
 1176 035F D1           	pop de					; restore de																;035f	d1 	.
 1177 0360 C9           	ret						; --------------- End of Proc --------------------- 						;0360	c9 	.
 1178 0361
 1179 0361
 1180 0361
 1181 0361
 1182 0361              ; *********************************************************************************************************
 1183 0361              ; SOUND NOTES PERIOD MULTIPLIERS DEFINITIONS
 1184 0361              ; *********************************************************************************************************
 1185 0361              ; Table with 8bit values for every Sound Notes
 1186 0361              ; Every entry contains how many times Sound Period must be played for 1/8 note
 1187 0361              SNDFCNTTAB:
 1188 0361 0A           	db	$0a					; A2																		;0361	0a 	.
 1189 0362 0B           	db	$0b					; A#2																		;0362	0b 	.
 1190 0363 0C           	db	$0c					; B2																		;0363	0c 	.
 1191 0364 0C           	db 	$0c					; C3																		;0364	0c 	.
 1192 0365 0D           	db	$0d					; C#3																		;0365	0d 	.
 1193 0366 0E           	db	$0e					; D3																		;0366	0e  	. .
 1194 0367 0F           	db	$0f					; D#3																		;0367	0f 	. .
 1195 0368 0F           	db	$0f					; E3																		;0368	0f 	.
 1196 0369 10           	db	$10					; F3																		;0369	10 	. .
 1197 036A 11           	db	$11					; F#3																		;036a	11 	. .
 1198 036B 12           	db	$12					; G3																		;036b	12 	.
 1199 036C 13           	db	$13					; G#3																		;036c	13 	.
 1200 036D 15           	db	$15					; A3																		;036d	15 	.
 1201 036E 16           	db	$16					; A#3																		;036e	16 	. .
 1202 036F 17           	db	$17					; B3																		;036f	17 	. .
 1203 0370 19           	db	$19					; C4																		;0370	19 	.
 1204 0371 1A           	db	$1a					; C#4																		;0371	1a 	.
 1205 0372 1C           	db	$1c					; D4																		;0372	1c 	.
 1206 0373 1D           	db	$1d					; D#4																		;0373	1d 	.
 1207 0374 1F           	db	$1f					; E4																		;0374	1f 	.
 1208 0375 21           	db	$21					; F4																		;0375	21 	! # %
 1209 0376 23           	db	$23					; F#4																		;0376	23 	! # %
 1210 0377 25           	db	$25					; G4																		;0377	25 	! # %
 1211 0378 27           	db	$27					; G#4																		;0378	27 	'
 1212 0379 29           	db	$29					; A4																		;0379	29 	)
 1213 037A 2C           	db	$2c					; A#4																		;037a	2c 	,
 1214 037B 2E           	db	$2e					; B4																		;037b	2e 	. 1
 1215 037C 31           	db	$31					; C5																		;037b	31 	. 1
 1216 037D 34           	db	$34					; C#5																		;037d	34 	4
 1217 037E 35           	db	$35					; D5																		;037e	35 	5
 1218 037F 3A           	db 	$3a					; D#5																		;037f	3a 	:
 1219 0380
 1220 0380
 1221 0380
 1222 0380
 1223 0380
 1224 0380              ; *********************************************************************************************************
 1225 0380              ; VERIFY COMMAND STATUS TEXTS
 1226 0380              ; *********************************************************************************************************
 1227 0380              ; Text definitions used by BASIC VERIFY Command
 1228 0380 4F 4B 0D 00  TXT_OK:		db "OK",$d,0        																		;0380	4f 4b 0d 00 	.
 1229 0384 45 52 52 4F  TXT_ERROR:	db "ERROR",$d,0																				;0384	45 52 52 4f 52 0d 00
 1229 0388 52 0D 00
 1230 038B
 1231 038B
 1232 038B
 1233 038B
 1234 038B
 1235 038B              ; *********************************************************************************************************
 1236 038B              ; SET OUTPUT DEVICE TO SCREEN
 1237 038B              ; *********************************************************************************************************
 1238 038B              ; Reset current Output Device Flag at 789CH to 0 (output to Screen), also outputs
 1239 038B              ; a CR to the Printer Device if printer's head is not at beginning of line
 1240 038B              ; (determined by checking the contents of the Printer Line Position variable at 789BH
 1241 038B              ; - if variable contains zero, printer's head is at start of line).
 1242 038B              ; Note that if Printer Line Position does not contain zero (printing stopped in the middle of line)
 1243 038B              ; and the printer is not OnLine, the computer will "hang up" waiting for a "printer ready" signal.
 1244 038B              SwitchPrnToScr:
 1245 038B              ; -- set Screen as Current Output Device
 1246 038B AF           	xor a					; a - Device Id 0 (Screen)													;038b	af 	.
 1247 038C 32 9C 78     	ld (SysCurOutDev),a		; set Screen as Current Output Device										;038c	32 9c 78 	2 . x
 1248 038F
 1249 038F              ; -- flush line to Printer Device if printer's head position is not at start of line
 1250 038F 3A 9B 78     	ld a,(PRN_PosInLine)	; a - current Printer Line Position  										;038f	3a 9b 78 	: . x
 1251 0392 B7           	or a					; is it 0? (printer's head is at begining of the line						;0392	b7 	.
 1252 0393 C8           	ret z					; yes - return - nothing to do												;0393	c8 	.
 1253 0394
 1254 0394              ; -- set CR char to Printer
 1255 0394 3E 0D        	ld a,$0d				; a - CR char to send to Printer											;0394	3e 0d 	> .
 1256 0396 D5           	push de					; save de (this become Device Control Block address)						;0396	d5 	.
 1257 0397 CD 9C 03     	call PrinterSendByte	; send CR to Printer Device													;0397	cd 9c 03 	. . .
 1258 039A D1           	pop de					; restore de																;039a	d1 	.
 1259 039B C9           	ret						; --------------- End of Proc ----------------------------- 				;039b	c9 	.
 1260 039C
 1261 039C
 1262 039C
 1263 039C
 1264 039C              ; *********************************************************************************************************
 1265 039C              ; SEND CHAR TO PRINTER
 1266 039C              ; *********************************************************************************************************
 1267 039C              ; Outputs character in the A register to the Printer.
 1268 039C              ; Also maintains the current printer's head position in Printer Line Position variable at 789BH.
 1269 039C              ; This variable is incremented for each character printed, except that it is reset to zero if character
 1270 039C              ; is line feed (0A), form feed (0C), or carriage return (0D).
 1271 039C              ; Line feed (OA) characters are changed to carriage return (0D) characters
 1272 039C              ; prior to calling the printer output routine. CALLs routine at 003BH.
 1273 039C              ; IN: a - char to print on Printer
 1274 039C              PrinterSendByte:
 1275 039C              ; -- save registers used
 1276 039C F5           	push af					; save af 																	;039c	f5 	.
 1277 039D D5           	push de					; save de																	;039d	d5 	.
 1278 039E C5           	push bc					; save bc																	;039e	c5 	.
 1279 039F              ; -- check character to print
 1280 039F 4F           	ld c,a					; c - save char to print													;039f	4f 	O
 1281 03A0 1E 00        	ld e,0					; default Printer Line Position after print char (assuming LF,FF or CR)		;03a0	1e 00 	. .
 1282 03A2 FE 0C        	cp #0c					; is this FormFeed (0CH) control character?									;03a2	fe 0c 	. .
 1283 03A4 28 10        	jr z,.printChar			; yes - set new Printer Line Position to 0 and send FF to printer			;03a4	28 10 	( .
 1284 03A6 FE 0A        	cp #0a					; is this LineFeed (0A) control character?									;03a6	fe 0a 	. .
 1285 03A8 20 03        	jr nz,.checkCR			; no - skip replace LF to CR												;03a8	20 03 	  .
 1286 03AA              ; -- change LineFeed (0A) to CarriageReturn (0D)
 1287 03AA 3E 0D        	ld a,#0d				; set char as CR															;03aa	3e 0d 	> .
 1288 03AC 4F           	ld c,a					; set saved char as CR too													;03ac	4f 	O
 1289 03AD              .checkCR:
 1290 03AD FE 0D        	cp #0d					; is this CR char (or was LF)?												;03ad	fe 0d 	. .
 1291 03AF 28 05        	jr z,.printChar			; yes - skip increment Printer Line Position - will be set to 0				;03af	28 05 	( .
 1292 03B1              ; -- increment Printer Line Position by 1
 1293 03B1 3A 9B 78     	ld a,(PRN_PosInLine)	; current Printer Line Position												;03b1	3a 9b 78 	: . x
 1294 03B4 3C           	inc a					; increment by 1															;03b4	3c 	<
 1295 03B5 5F           	ld e,a					; set as new value to set													;03b5	5f 	_
 1296 03B6              .printChar:
 1297 03B6 7B           	ld a,e					; a - new Printer Line Position												;03b6	7b 	{
 1298 03B7 32 9B 78     	ld (PRN_PosInLine),a	; update position variable 													;03b7	32 9b 78 	2 . x
 1299 03BA 79           	ld a,c					; a - char to send to printer												;03ba	79 	y
 1300 03BB CD 3B 00     	call PRN_SendChar		; send char on Printer														;03bb	cd 3b 00 	. ; .
 1301 03BE C1           	pop bc					; restore bc																;03be	c1 	.
 1302 03BF D1           	pop de					; restore de																;03bf	d1 	.
 1303 03C0 F1           	pop af					; restore af																;03c0	f1 	.
 1304 03C1 C9           	ret						; -------------- End of Proc ------------------------------ 				;03c1	c9 	.
 1305 03C2
 1306 03C2
 1307 03C2
 1308 03C2
 1309 03C2              ; *********************************************************************************************************
 1310 03C2              ; EXECUTE DCS OPERATION ROUTINE
 1311 03C2              ; *********************************************************************************************************
 1312 03C2              ; Executes operation (read/write/control) via Device Control Subsystem
 1313 03C2              ; IN: de - address of selected Device Control Block
 1314 03C2              ;	  b - operation/type (1-read, 2-write, 4-control)
 1315 03C2              ;     a - byte to write if write operation selected
 1316 03C2              ExecuteDCBOperation:
 1317 03C2              ; -- save registers and set IX to point to DCB
 1318 03C2 E5           	push hl					; save HL																	;03c2	e5 	.
 1319 03C3 DD E5        	push ix					; save IX																	;03c3	dd e5 	. .
 1320 03C5 D5           	push de					; copy Device Control Block address to IX									;03c5	d5 	.
 1321 03C6 DD E1        	pop ix					; ix - selected DCB															;03c6	dd e1 	. .
 1322 03C8 D5           	push de					; save DE																	;03c8	d5 	.
 1323 03C9              ; -- set return procedure to ensure restore saved registers
 1324 03C9 21 DD 03     	ld hl,.exit				; address of code to execute on exit after operation						;03c9	21 dd 03 	! . .
 1325 03CC E5           	push hl					; push on CPU stack return address  										;03cc	e5 	.
 1326 03CD              ; -- check if Device can do Operation and if not then return via DOS Vector 7833H
 1327 03CD 4F           	ld c,a					; c - data to send to Device												;03cd	4f 	O
 1328 03CE 1A           	ld a,(de)				; a - Device Capabilities													;03ce	1a 	.
 1329 03CF A0           	and b					; mask only requested operation 											;03cf	a0 	.
 1330 03D0 B8           	cp b					; check if Device is capable to do this operation							;03d0	b8 	.
 1331 03D1 C2 33 78     	jp nz,07833h			; no - return via DOS Vector 7833H (w/o DOS this will be RET)				;03d1	c2 33 78 	. 3 x
 1332 03D4              ; -- execute Operation
 1333 03D4 FE 02        	cp 2					; set FLAGS -> Z - Write Op, NC - Read Op, C - Control Op					;03d4	fe 02 	. .
 1334 03D6 DD 6E 01     	ld l,(ix+1)				; l - DriverAddress LSB 													;03d6	dd 6e 01 	. n .
 1335 03D9 DD 66 02     	ld h,(ix+2)				; h - DriverAddress MSB														;03d9	dd 66 02 	. f .
 1336 03DC E9           	jp (hl)					; call Driver																;03dc	e9 	.
 1337 03DD              .exit:
 1338 03DD D1           	pop de					; restore de																;03dd	d1 	.
 1339 03DE DD E1        	pop ix					; restore ix																;03de	dd e1 	. .
 1340 03E0 E1           	pop hl					; restore hl																;03e0	e1 	.
 1341 03E1 C1           	pop bc					; restore bc																;03e1	c1 	.
 1342 03E2 C9           	ret						; return to caller															;03e2	c9 	.
 1343 03E3
 1344 03E3
 1345 03E3
 1346 03E3
 1347 03E3
 1348 03E3              ; *********************************************************************************************************
 1349 03E3              ; READ LINE FROM KEYBOARD INTO BUFFER
 1350 03E3              ; *********************************************************************************************************
 1351 03E3              ; Reading a text line from the keyboard into Buffer.
 1352 03E3              ; The line is read in until the RETURN or BREAK key is pressed, displayed on the screen
 1353 03E3              ; and then transferred to the Editor Buffer
 1354 03E3              ; IN: c - length of prefix text (???)
 1355 03E3              ReadLine:
 1356 03E3              ; -- set System Flag - text input is buffered
 1357 03E3 21 39 78     	ld hl,SYSFLAGS			; address of System Flags variable 											;03e3	21 39 78 	! 9 x
 1358 03E6 CB EE        	set 5,(hl)				; set buffered output flag													;03e6	cb ee 	. .
 1359 03E8              ; -- refresh Cursor on Screen
 1360 03E8 2A 20 78     	ld hl,(CURSORADDR)		; hl - VRAM address of Cursor location on Screen 	                        ;03e8	2a 20 78 	*   x
 1361 03EB CD 53 00     	call SetCursorFromHL	; update Cursor Char (refresh)				  		                        ;03eb	cd 53 00 	. S .
 1362 03EE              ; -- test if cursor is at the begining of last Screen line - hl == address 71e0
 1363 03EE 7C           	ld a,h			    	; MSB of VRAM Cursor address                  								;03ee	7c 	|
 1364 03EF FE 71        	cp $71		        	; is it bottom half of Screen ?                     						;03ef	fe 71 	. q
 1365 03F1 20 10        	jr nz,.startInputLIne	; no - skip checking Editor status 											;03f1	20 10 	  .
 1366 03F3 7D           	ld a,l			    	; LSB of VRAM Cursor address                   								;03f3	7d 	}
 1367 03F4 FE E0        	cp $e0		        	; is it begin of last line on Screen ?              						;03f4	fe e0 	. .
 1368 03F6 20 0B        	jr nz,.startInputLIne	; no - skip checking Editor status											;03f6	20 0b 	  .
 1369 03F8
 1370 03F8              ; -- Test if this is 2nd line of Editor Line Data - could be 1 or 2 line
 1371 03F8 3A D7 7A     	ld a,(EDITORLINES)		; first Editor Line info													;03f8	3a d7 7a 	: . z
 1372 03FB B7           	or a					; is it second line of two-line-statement?									;03fb	b7 	.
 1373 03FC 20 05        	jr nz,.startInputLIne	; no - no need to scroll screen up											;03fc	20 05 	  .
 1374 03FE              ; -- if 1st Editor line is a 2nd of two we need discard it scrolling up
 1375 03FE 3E 0D        	ld a,#0D		    	; a - CR character 															;03fe	3e 0d 	> .
 1376 0400 CD 8B 30     	call ScrPrintChar		; Print CR to Screen (move to next line)	        						;0400	cd 8b 30 	. . 0
 1377 0403              .startInputLIne:
 1378 0403              ; -- save Prompt Text length and read line via Interrupt routine
 1379 0403 41           	ld b,c					; b - length of prompt text	(column)										;0403	41 	A
 1380 0404 C5           	push bc					; save bc																	;0404	c5 	.
 1381 0405              ; -- clear status of Editing
 1382 0405 21 39 78     	ld hl,SYSFLAGS			; address of System Flags													;0405	21 39 78 	! 9 x
 1383 0408 CB 86        	res 0,(hl)				; clear RETURN pressed Flag													;0408	cb 86 	. .
 1384 040A CB 96        	res 2,(hl)				; clear BREAK pressed Flag													;040a	cb 96 	. .
 1385 040C              .wait:
 1386 040C              ; -- wait until user pressed RETURN while typing line
 1387 040C CB 46        	bit 0,(hl)				; is RETURN pressed Flag set?												;040c	cb 46 	. F
 1388 040E 28 FC        	jr z,.wait				; no - wait until user end editing by pressing RETURN						;040e	28 fc 	( .
 1389 0410
 1390 0410              ; -- user pressed RETURN - end of editing - text is on Screen
 1391 0410              ; -- reset Cursor Position at start but save length of inserted text
 1392 0410 3A A6 78     	ld a,(CURSORPOS) 		; position of Cursor in Edited line											;0410	3a a6 78 	: . x
 1393 0413 4F           	ld c,a					; store it as LSB of difference from start									;0413	4f 	O
 1394 0414 AF           	xor a					; a - 0 for new Cursor Position and difference MSB							;0414	af 	.
 1395 0415 32 A6 78     	ld (CURSORPOS),a 		; set Cursor at begining of line											;0415	32 a6 78 	2 . x
 1396 0418 47           	ld b,a					; bc - current edited line length (difference from starat)					;0418	47 	G
 1397 0419 2A 20 78     	ld hl,(CURSORADDR)		; Cursor absolute Address in VRAM 											;0419	2a 20 78 	*   x
 1398 041C ED 42        	sbc hl,bc				; move back Cursor address to the beginig of edited line					;041c	ed 42 	. B
 1399 041E 22 20 78     	ld (CURSORADDR),hl		; set as new Cursor Address in VRAM 										;041e	22 20 78 	"   x
 1400 0421              ; -- Cursor Position moved back at start of line
 1401 0421 11 E8 79     	ld de,EditLineBuf		; de - address of Editor Line Buffer										;0421	11 e8 79 	. . y
 1402 0424 C1           	pop bc					; c=b - length of Prompt text in case we processing INPUT Command 			;0424	c1 	.
 1403 0425              ; -- test if we're processing INPUT Command
 1404 0425 21 39 78     	ld hl,SYSFLAGS			; address of System Flags													;0425	21 39 78 	! 9 x
 1405 0428 CB 66        	bit 4,(hl)				; is bit 4 set? (BASIC INPUT Command in progress)							;0428	cb 66 	. f
 1406 042A 2A 20 78     	ld hl,(CURSORADDR)		; hl - Cursor Address in VRAM - begining of entered line					;042a	2a 20 78 	*   x
 1407 042D 28 42        	jr z,l0471h				; no - is was interractive Edit 											;042d	28 42 	( B
 1408 042F
 1409 042F              ; -- Line was edited for INPUT Command
 1410 042F C5           	push bc					; save bc - length of Prompt text											;042f	c5 	.
 1411 0430 E5           	push hl					; save hl - VRAM address of entered text 									;0430	e5 	.
 1412 0431 CD A8 33     	call GetEditorLineFlag	; Get status of Editor Line													;0431	cd a8 33 	. . 3
 1413 0434 E1           	pop hl					; restore hl - VRAM address of entered text									;0434	e1 	.
 1414 0435 C1           	pop bc					; restore bc - length of Prompt text										;0435	c1 	.
 1415 0436 B7           	or a					; is the 2nd line of two-line-statement?									;0436	b7 	.
 1416 0437 20 08        	jr nz,.skipPrompt		; no - skip address correction 												;0437	20 08 	  .
 1417 0439              ; -- it is 2nd line - move address to begining of 1st line
 1418 0439 7D           	ld a,l					; a - LSB of VRAM address													;0439	7d 	}
 1419 043A D6 20        	sub 32					; subtract 32 bytes (1 screen line)											;043a	d6 20 	.
 1420 043C 6F           	ld l,a					; store back																;043c	6f 	o
 1421 043D 7C           	ld a,h					; a - MSB of VRAM address													;043d	7c 	|
 1422 043E DE 00        	sbc a,0					; subtract Carry only (if any)												;043e	de 00 	. .
 1423 0440 67           	ld h,a					; hl - new adrress 1 screen line up											;0440	67 	g
 1424 0441              .skipPrompt:
 1425 0441              ; -- skip all characters already the same on Screen and in Edit Buffer
 1426 0441 48           	ld c,b					; c - save Prompt/Prefix Text length										;0441	48 	H
 1427 0442              .next:
 1428 0442 1A           	ld a,(de)				; a - character from Edit Buffer											;0442	1a 	.
 1429 0443 BE           	cp (hl)					; is the same on Screen?													;0443	be 	.
 1430 0444 20 07        	jr nz,.resetLength		; no - set length of Prompt Text to 0										;0444	20 07 	  .
 1431 0446 23           	inc hl					; hl - point to next character on screen									;0446	23 	#
 1432 0447 13           	inc de					; de - point to next character in Edit Buffer								;0447	13 	.
 1433 0448 10 F8        	djnz .next				; repeat for whole Prompt/Prefix text										;0448	10 f8 	. .
 1434 044A              ; -- Prompt/Prefix didn't changed
 1435 044A C5           	push bc					; save bc - verified length of Prompt Text									;044a	c5 	.
 1436 044B 18 04        	jr .testEditor			; skip reset of length of Prompt Text 										;044b	18 04 	. .
 1437 044D              .resetLength:
 1438 044D 01 00 00     	ld bc,0					; set length of Prompt Text to 0											;044d	01 00 00 	. . .
 1439 0450 C5           	push bc					; save bc - length 0														;0450	c5 	.
 1440 0451              .testEditor:
 1441 0451 E5           	push hl					; save hl - address of begining text on Screen								;0451	e5 	.
 1442 0452 CD A8 33     	call GetEditorLineFlag	; a - Editor Line Flag/Status pointed by hl								 	;0452	cd a8 33 	. . 3
 1443 0455 E1           	pop hl					; restore hl																;0455	e1 	.
 1444 0456 C1           	pop bc					; restore bc - length of Prompt Text										;0456	c1 	.
 1445 0457 C5           	push bc					; save bc again																;0457	c5 	.
 1446 0458 FE 80        	cp $80					; is this Single Editor Line												;0458	fe 80 	. .
 1447 045A 28 0A        	jr z,.singleLine		; yes - set 32 bytes max													;045a	28 0a 	( .
 1448 045C              ; -- two-line-text
 1449 045C 3E 40        	ld a,64					; maximum 64 bytes/chars in this text										;045c	3e 40 	> @
 1450 045E 91           	sub c					; subtract detected previously Prompt length								;045e	91 	.
 1451 045F 47           	ld b,a					; b - max length of text w/o Prompt											;045f	47 	G
 1452 0460 D1           	pop de					; de - saved length of Prompt Text											;0460	d1 	.
 1453 0461 1E 00        	ld e,0					; clear LSB of length (MSB is already 0) - de = 0							;0461	1e 00 	. .
 1454 0463 D5           	push de					; push back 0 value as Prompt length										;0463	d5 	.
 1455 0464 18 05        	jr .continue			; continue with 2 lines and text length in B								;0464	18 05 	. .
 1456 0466              .singleLine:
 1457 0466 06 20        	ld b,32					; b - maximum 32 bytes/chars in this text									;0466	06 20 	.
 1458 0468 2A 20 78     	ld hl,(CURSORADDR)		; VRAM address of Cursor Position on Screen 								;0468	2a 20 78 	*   x
 1459 046B              .continue:
 1460 046B 11 E8 79     	ld de,EditLineBuf		; de - address of Editor Line Buffer										;046b	11 e8 79 	. . y
 1461 046E
 1462 046E              ; ----------------- ROM 1.2 only --------------------------------------------------------------
 1463 046E               ifdef VER_12
 1464 046E 7E           	ld a,(hl)				; a - char from Screen at Cursor location									;046e	7e 	~
 1465 046F 18 52        	jr l04c3h				;046f	18 52 	. R
 1466 0471
 1467 0471              ; ----------------- ROM 2.0 only --------------------------------------------------------------
 1468 0471               else
 1469 0471 ~             	jp l3ea8h				; Check background color													;046e	c3 a8 3e 	. . >
 1470 0471 ~            							; with green background go to 04B8H
 1471 0471 ~            							; with black background go to 3E6AH
 1472 0471               endif
 1473 0471
 1474 0471              ; ----------------- common code ---------------------------------------------------------------
 1475 0471
 1476 0471
 1477 0471
 1478 0471              ; Determine start of text address and maximum length if not INPUT command
 1479 0471              ; but user is editing BASIC Program Line or Statement
 1480 0471              l0471h:
 1481 0471              ; -- Prompt
 1482 0471 01 00 00     	ld bc,0					; bc = length of Prompt Text = 0 - (it's not INPUT Command)					;0471	01 00 00 	. . .
 1483 0474 C5           	push bc					; save bc - length of Prompt Text 											;0474	c5 	.
 1484 0475 E5           	push hl					; save hl - VRAM address of entered text									;0475	e5 	.
 1485 0476 CD A8 33     	call GetEditorLineFlag	; a - Editor Line Flag/Status pointed by hl								 	;0476	cd a8 33 	. . 3
 1486 0479 E1           	pop hl					; restore hl - VRAM address of entered text									;0479	e1 	.
 1487 047A FE 80        	cp $80					; is it single line statement?												;047a	fe 80 	. .
 1488 047C 28 0E        	jr z,.set32max			; yes - set b to 32 bytes/chars maximum										;047c	28 0e 	( .
 1489 047E FE 81        	cp $81					; is it 1st line of two-line-statement?										;047e	fe 81 	. .
 1490 0480 28 06        	jr z,.set64max			; yes - set b to 64 bytes/chars maximum										;0480	28 06 	( .
 1491 0482
 1492 0482              ; -- 2nd line of two-line-statement - move hl pointer 1 line up
 1493 0482 01 20 00     	ld bc,32				; bc - 32 bytes per line to correct start address in hl						;0482	01 20 00 	.   .
 1494 0485 B7           	or a					; clear Carry flag															;0485	b7 	.
 1495 0486 ED 42        	sbc hl,bc				; hl - address of start of 1st line of this statement						;0486	ed 42 	. B
 1496 0488              .set64max:
 1497 0488 06 40        	ld b,64					; b - maximum 64 chars this text can have									;0488	06 40 	. @
 1498 048A 18 02        	jr l048eh				; skip setting b 															;048a	18 02 	. .
 1499 048C              .set32max:
 1500 048C 06 20        	ld b,32					; b - maximum 32 chars this text can have									;048c	06 20 	.
 1501 048E
 1502 048E
 1503 048E
 1504 048E
 1505 048E              ; ----------------- ROM 1.2 only --------------------------------------------------------------
 1506 048E
 1507 048E               ifdef VER_12
 1508 048E              l048eh:
 1509 048E              ; -- transfer the data from the Screen to the I/0 buffer
 1510 048E 7E           	ld a,(hl)				; a - character from the Screen												;048e	7e 	~
 1511 048F FE 40        	cp 64					; is it >= 64 - Graphic or Inverse char?									;048f	fe 40 	. @
 1512 0491 DA B9 04     	jp c,ParseScrChar		; no - proceed with Normal Char 											;0491	da b9 04 	. . .
 1513 0494              ; -- if not INPUT, then Graphic or Inverse chars are only allowed in strings
 1514 0494 C1           	pop bc					; bc - length of Prompt Text												;0494	c1 	.
 1515 0495 11 9D 04     	ld de,EditFailExit		; push Fail Exit routine address on the stack								;0495	11 9d 04 	. . .
 1516 0498 D5           	push de																								;0498	d5 	.
 1517 0499 C5           	push bc					; push length of Prompt Text on the Stack									;0499	c5 	.
 1518 049A C3 0D 05     	jp l050dh				; Check end-of-text identification (or BREAK)								;049a	c3 0d 05 	. . .
 1519 049D              EditFailExit:
 1520 049D              ; -- Parsing failed but if BREAK was pressed we can ignore error
 1521 049D D8           	ret c					; if BREAK was pressed go back to BASIC										;049d	d8 	.
 1522 049E
 1523 049E              ; -- display SYNTAX ERROR on Screen
 1524 049E 21 1A 3E     	ld hl,TXT_SYNTAXERROR	; hl - address of "SYNTAX ERROR" text 										;049e	21 1a 3e 	! . >
 1525 04A1 CD A7 28     	call PrintBasicStr		; print 'SYNTAX ERROR' on Screen											;04a1	cd a7 28 	. . (
 1526 04A4
 1527 04A4              ; -- display next BASIC line number if AUTO is ON (ROM 1.2 only)
 1528 04A4 3A E1 78     	ld a,(AUTONUM_ON)		; a - Basic AUTO Flag 														;04a4	3a e1 78 	: . x
 1529 04A7 B7           	or a			    	; is auto number feature ON? 												;04a7	b7 	.
 1530 04A8 CA E3 03     	jp z,ReadLine			; no - go back to Read Line as typed by User								;04a8	ca e3 03 	. . .
 1531 04AB
 1532 04AB              ; -- AUTO is ON - print next BASIC Line number for User
 1533 04AB 2A E2 78     	ld hl,(AUTONUM_LINE)	; hl - line number generated by AUTO feature								;04ab	2a e2 78 	* . x
 1534 04AE CD AF 0F     	call PrintLineNo		; Print Line number from hl (16bit) on Screen								;04ae	cd af 0f 	. . .
 1535 04B1 3E 20        	ld a,' '		    	; a - Space char to separate Line number from Body 							;04b1	3e 20 	>
 1536 04B3 CD 57 31     	call sub_3157h			; send ' ' to Screen														;04b3	cd 57 31 	. W 1
 1537 04B6              ; -- go back to Editor and auire Statement from User
 1538 04B6 C3 E3 03     	jp ReadLine				; go back to Read Line as typed by User										;04b6	c3 e3 03 	. . .
 1539 04B9
 1540 04B9
 1541 04B9
 1542 04B9              ; Charcter on Screen is < 64 - NOT Graphiocs nor Inversed
 1543 04B9              ; IN: a - character from Screen to parse
 1544 04B9              ;     b - maximum number of characters (32 or 64)
 1545 04B9              ;     hl - VRAM address where is parsed char
 1546 04B9              ;     de - address of current location in Editor Line Buffer
 1547 04B9              ParseScrChar:
 1548 04B9 FE 22        	cp '"'					; is it start of String value??												;04b9	fe 22 	. "
 1549 04BB 20 31        	jr nz,l04eeh			; no - continue																;04bb	20 31 	  1
 1550 04BD              ; -- start of quoted String found
 1551 04BD 12           	ld (de),a				; save '"' Character into Editor Buffer										;04bd	12 	.
 1552 04BE 23           	inc hl					; hl points to next character on Screen										;04be	23 	#
 1553 04BF 13           	inc de					; de points to next location in Editor Buffer								;04bf	13 	.
 1554 04C0 05           	dec b					; decrement mx number of chars to parse										;04c0	05 	.
 1555 04C1 28 36        	jr z,FinishParse		; if all parsed - go Finish copying text to Edit Buffer						;04c1	28 36 	( 6
 1556 04C3
 1557 04C3              ; Parsing content of quoted String
 1558 04C3              ; IN: hl - address of char on Screen
 1559 04C3              ;     de - address of location in Editor Line Buffer
 1560 04C3              l04c3h:
 1561 04C3 7E           	ld a,(hl)				; a - next character from Screen											;04c3	7e 	~
 1562 04C4 FE 40        	cp 64					; is it >= 64 - Graphic or Inverse char?									;04c4	fe 40 	. @
 1563 04C6 DA D4 04     	jp c,l04d4h				; no - proceed with Normal Char 											;04c6	da d4 04 	. . .
 1564 04C9              ; -- Graphic or Inverse char
 1565 04C9 FE 80        	cp 128					; is it >= 128 - SemiGraphic char?											;04c9	fe 80 	. .
 1566 04CB DA D0 04     	jp c,l04d0h				; no - must be 	Inversed character											;04cb	da d0 04 	. . .
 1567 04CE              ; -- Semigraphic char - ignore Color bits
 1568 04CE E6 8F        	and %10001111			; clear color bits (6,5,4) in semigraphic character							;04ce	e6 8f 	. .
 1569 04D0              l04d0h:
 1570 04D0 F6 80        	or %10000000			; set bit 7 - flag for Semigraphic or Invered chars in String				;04d0	f6 80 	. .
 1571 04D2 18 13        	jr l04e7h				; store "in-string" character and process next ones							;04d2	18 13 	. .
 1572 04D4
 1573 04D4              ; Parsing content of quoted String - Normal char as Screen Code
 1574 04D4              l04d4h:
 1575 04D4 FE 22        	cp '"'					; is it end of quoted String?												;04d4	fe 22 	. "
 1576 04D6 20 09        	jr nz,l04e1h			; no - convert to ASCII and store in Editor Buffer							;04d6	20 09 	  .
 1577 04D8
 1578 04D8              ; -- end of quoted String - check if we procesing text for BASIC INPUT Command
 1579 04D8 E5           	push hl					; save hl - VRAM address of char											;04d8	e5 	.
 1580 04D9 21 39 78     	ld hl,SYSFLAGS			; hl address of System Flags variable										;04d9	21 39 78 	! 9 x
 1581 04DC CB 66        	bit 4,(hl)				; is bit 4 set? (BASIC INPUT Command in progress)							;04dc	cb 66 	. f
 1582 04DE E1           	pop hl					; restore hl - VRAM address of char											;04de	e1 	.
 1583 04DF 28 0D        	jr z,l04eeh				; no - continue parsing text as BASIC Statement or Line						;04df	28 0d 	( .
 1584 04E1              l04e1h:
 1585 04E1 CB 6F        	bit 5,a					; is bit 5 set? (code 20H..3FH)												;04e1	cb 6f 	. o
 1586 04E3 20 02        	jr nz,l04e7h			; yes - no need to convert - it's the same as ASCII 						;04e3	20 02 	  .
 1587 04E5 F6 40        	or $40					; add 40H to codes 00 - 1FH -> 41H..5FH - valid ASCII						;04e5	f6 40 	. @
 1588 04E7
 1589 04E7
 1590 04E7              ; store character in Edit Buffer and process next ones
 1591 04E7              l04e7h:
 1592 04E7 12           	ld (de),a				; store character in Editor Line Buffer										;04e7	12 	.
 1593 04E8 23           	inc hl					; hl points to next character on Screen										;04e8	23 	#
 1594 04E9 13           	inc de					; de points to next location in Editor Buffer								;04e9	13 	.
 1595 04EA 10 D7        	djnz l04c3h				; decrement max number of chars to parse									;04ea	10 d7 	. .
 1596 04EC 18 0B        	jr FinishParse		;04ec	18 0b 	. .
 1597 04EE
 1598 04EE
 1599 04EE              ; Parsing text as BASIC Statement or Line (no Inverse nor Semigraphics allowed)
 1600 04EE              l04eeh:
 1601 04EE CB 6F        	bit 5,a					; is bit 5 set? (code 20H..3FH)												;04ee	cb 6f 	. o
 1602 04F0 20 02        	jr nz,l04f4h			; yes - no need to convert - it's the same as ASCII 						;04f0	20 02 	  .
 1603 04F2 F6 40        	or $40					; add 40H to codes 00 - 1FH -> 41H..5FH - valid ASCII						;04f2	f6 40 	. @
 1604 04F4              l04f4h:
 1605 04F4 12           	ld (de),a				; store character in Editor Line Buffer										;04f4	12 	.
 1606 04F5 23           	inc hl					; hl points to next character on Screen										;04f5	23 	#
 1607 04F6 13           	inc de					; de points to next location in Editor Buffer								;04f6	13 	.
 1608 04F7 10 95        	djnz l048eh				; decrement max number of chars to parse									;04f7	10 95 	. .
 1609 04F9
 1610 04F9              ; Copying finished, complete buffer content
 1611 04F9              FinishParse:
 1612 04F9              ; -- trim trailing spaces (if any)
 1613 04F9 1B           	dec de					; de - points to last character inserted into Editor Buffer					;04f9	1b 	.
 1614 04FA 7A           	ld a,d					; MSB of character address 													;04fa	7a 	z
 1615 04FB FE 79        	cp $79					; is it MSB of Buffer address?												;04fb	fe 79 	. y
 1616 04FD 20 06        	jr nz,l0505h			; no - test Space char in Buffer											;04fd	20 06 	  .
 1617 04FF 7B           	ld a,e					; LSB of character address 													;04ff	7b 	{
 1618 0500 FE E8        	cp $e8					; is DE < address of Editor Buffer?											;0500	fe e8 	. .
 1619 0502 DA 0A 05     	jp c,l050ah				; yes - done - put String Terminator (0) at the end							;0502	da 0a 05 	. . .
 1620 0505              l0505h:
 1621 0505 1A           	ld a,(de)				; a - character from Edit Buffer											;0505	1a 	.
 1622 0506 FE 20        	cp ' '					; is it Space char?															;0506	fe 20 	.
 1623 0508 28 EF        	jr z,FinishParse		; yes - continue trimming Spaces											;0508	28 ef 	( .
 1624 050A
 1625 050A              l050ah:
 1626 050A              ; -- put String Terminator (0) at the end of trimmed text
 1627 050A 13           	inc de					; de - address just after last char in Edit Buffer							;050a	13 	.
 1628 050B AF           	xor a					; string terminator (0)														;050b	af 	.
 1629 050C 12           	ld (de),a				; store into Editor Line Buffer												;050c	12 	.
 1630 050D
 1631 050D              l050dh:
 1632 050D              ; -- move Screen Cursor to line after text (1 or 2 lines down)
 1633 050D CD A8 33     	call GetEditorLineFlag	; a - Editor Line Flag/Status pointed by hl									;050d	cd a8 33 	. . 3
 1634 0510 2A 20 78     	ld hl,(CURSORADDR)		; hl - VRAM address of Screen Cursor										;0510	2a 20 78 	*   x
 1635 0513 FE 81        	cp $81					; is Cursor in 1st line of two-line-statment?								;0513	fe 81 	. .
 1636 0515 CD 53 00     	call SetCursorFromHL	; refresh Cursor Char at cursor position									;0515	cd 53 00 	. S .
 1637 0518 20 04        	jr nz,.advCursor		; no - it's single line	text - move 1 line only 							;0518	20 04 	  .
 1638 051A              ; -- advance Screen Cursor to begining of next Screen Line
 1639 051A AF           	xor a					; a - control character 0													;051a	af 	.
 1640 051B CD 8B 30     	call ScrPrintChar		; send character to Screen/Editor											;051b	cd 8b 30 	. . 0
 1641 051E              .advCursor:
 1642 051E              ; -- advance Screen Cursor to begining of next Screen Line
 1643 051E AF           	xor a					; a - control character 0													;051e	af 	.
 1644 051F CD 8B 30     	call ScrPrintChar		; send character to Screen/Editor											;051f	cd 8b 30 	. . 0
 1645 0522
 1646 0522              ; -- remove INVERSE mode from Keyboard State
 1647 0522 3A 38 78     	ld a,(KEYSFLAGS)		; get Keyboard's current State 												;0522	3a 38 78 	: 8 x
 1648 0525 E6 FD        	and %11111101		    ; clear bit 1 - INVERSE Flag 												;0525	e6 fd 	. .
 1649 0527 32 38 78     	ld (KEYSFLAGS),a		; store modified Keyboard State back 										;0527	32 38 78 	2 8 x
 1650 052A
 1651 052A              ; -- check if User pressed BREAK key (canceled edit)
 1652 052A 21 39 78     	ld hl,SYSFLAGS			; hl - address of System Flags variable										;052a	21 39 78 	! 9 x
 1653 052D CB 56        	bit 2,(hl)				; is bit 2 set (BREAK Key pressed)?											;052d	cb 56 	. V
 1654 052F 28 05        	jr z,.commitState		; no - set state to Commit edits and continue  								;052f	28 05 	( .
 1655 0531              ; -- set state to Abort edits - BREAK pressed
 1656 0531 3E 01        	ld a,1					; a=1 - BREAK key pressed													;0531	3e 01 	> .
 1657 0533 37           	scf						; set Carry Flag - Abort													;0533	37 	7
 1658 0534 18 01        	jr .skip				; skip setting state														;0534	18 01 	. .
 1659 0536              .commitState:
 1660 0536              ; -- set state to Commit edits - RETURN pressed
 1661 0536 AF           	xor a					; a=0 - no BREAK, Carry=0 - Commit											;0536	af 	.
 1662 0537              .skip:
 1663 0537              ; -- clear flag - BASIC INPUT Command is no longer in progress
 1664 0537 21 39 78     	ld hl,SYSFLAGS			; hl - address of System Flags variable										;0537	21 39 78 	! 9 x
 1665 053A CB A6        	res 4,(hl)				; Reset INPUT Command flag													;053a	cb a6 	. .
 1666 053C              ; -- set start of text inside Buffer
 1667 053C 21 E8 79     	ld hl,EditLineBuf		; address of Editor Line Buffer												;053c	21 e8 79 	! . y
 1668 053F C1           	pop bc					; length of Prompt text (in case INPUT was processed)						;053f	c1 	.
 1669 0540 F5           	push af					; save Commit/Abort state on the Stack										;0540	f5 	.
 1670 0541 09           	add hl,bc				; add Prefix length - hl points to start of entered text					;0541	09 	.
 1671 0542              ; -- make sure Buffer contains at least 1 char - add Space if needed and return
 1672 0542 C3 29 3E     	jp l3e29h				; chack Edit Buffer and correct if needed									;0542	c3 29 3e 	. ) >
 1673 0545
 1674 0545
 1675 0545
 1676 0545              ; *********************************************************************************************************
 1677 0545              ; COPY TEXT FROM SCREEN TO BUFFER AND TO INPUT
 1678 0545              ; *********************************************************************************************************
 1679 0545              ; Part of the BASIC INPUT command routine reading a line into the Editor Line Buffer
 1680 0545              ; Maximum allowable text length is 64 characters. End of text is marked by 0 in buffer.
 1681 0545              ; OUT: hl - location prior to first character in Editor Buffer
 1682 0545              ;      CY=1 - Input was aborted by pressing BREAK key
 1683 0545              ; -- Wait until entered text is completed (by RETURN) or aborted (by BREAK)
 1684 0545              ;GetUserInputText:
 1685 0545              ;	ld a,(07aafh)			; a - number of characters in Edit Buffer left to process					;0545	3a af 7a 	: . z
 1686 0545              ;	or a					; is it 0 (buffer empty)?													;0548	b7 	.
 1687 0545              ;	jr nz,GetUserInputText	; no - wait for all chars copied											;0549	20 fa 	  .
 1688 0545              ;; -- clear BASIC Edit Line Buffer (64 chars)
 1689 0545              ;	ld b,64					; buffer length - 64 chars 													;054b	06 40 	. @
 1690 0545              ;	ld hl,EditLineBuf		; hl - address of Editor Line Buffer										;054d	21 e8 79 	! . y
 1691 0545              ;	ld a,' '				; a - Space char to fill buffer with										;0550	3e 20 	>
 1692 0545              ;.loop:
 1693 0545              ;	ld (hl),a				; store Space char into buffer												;0552	77 	w
 1694 0545              ;	inc hl					; points to next char location in buffer									;0553	23 	#
 1695 0545              ;	djnz .loop				; fill all 64 bytes															;0554	10 fc 	. .
 1696 0545              ;; -- terminate text with byte 0
 1697 0545              ;	xor a					; text terminator 0															;0556	af 	.
 1698 0545              ;	ld (hl),a				; store at the end of buffer												;0557	77 	w
 1699 0545              ;; -- correct Cursor Position if Cursor is on 2nd line of two-line-text
 1700 0545              ;	call GetEditorLineFlag	; a - Editor Line Flag														;0558	cd a8 33 	. . 3
 1701 0545              ;	or a					; is it 2nd line of two-line-text?											;055b	b7 	.
 1702 0545              ;	ld a,(CURSORPOS)		; a - current position of Cursor in Edited line	(column)					;055c	3a a6 78 	: . x
 1703 0545              ;	jr nz,.skip				; it's not 2nd line - skip adjustment										;055f	20 02 	  .
 1704 0545              ;	add a,32				; add 32 to Cursor in text position (one screen line)						;0561	c6 20 	.
 1705 0545              ;.skip:
 1706 0545              ;; -- calculate length of text based on Cursor position
 1707 0545              ;	ld c,a					; c - Cursor position in line as length LSB 								;0563	4f 	O
 1708 0545              ;	xor a					; a = 0 as difference MSB													;0564	af 	.
 1709 0545              ;	ld b,a					; bc - text length - difference beetween Cursor and begining of 1st line	;0565	47 	G
 1710 0545              ;	ld hl,(CURSORADDR)		; absolute address of Cursor 												;0566	2a 20 78 	*   x
 1711 0545              ;; -- source address
 1712 0545              ;	sbc hl,bc				; hl - absolute address of begining of text									;0569	ed 42 	. B
 1713 0545              ;; -- destination address
 1714 0545              ;	ld de,EditLineBuf		; de - address of Editor Line Buffer										;056b	11 e8 79 	. . y
 1715 0545              ;; -- copy text from VRAM (Screen)  to Edit Buffer
 1716 0545              ;	push bc					; save bc - length of text													;056e	c5 	.
 1717 0545              ;	ldir					; copy bc bytes from VRAM to Edit Buffer									;056f	ed b0 	. .
 1718 0545              ;	pop bc					; restore bc - length of text												;0571	c1 	.
 1719 0545              ;; -- set flag meaning BASIC INPUT Command is in progress
 1720 0545              ;	ld hl,SYSFLAGS			; hl - address of System Flags variable										;0572	21 39 78 	! 9 x
 1721 0545              ;	set 4,(hl)				; set BASIC INPUT Command flag												;0575	cb e6 	. .
 1722 0545              ;; -- create/update BASIC variable from text
 1723 0545              ;	call ReadLine			; Process text in Edit Buffer												;0577	cd e3 03 	. . .
 1724 0545              ;	ret						; return 																	;057a	c9 	.
 1725 0545
 1726 0545               ;endif ; VER_12
 1727 0545
 1728 0545              ; *********************************************************************************************************
 1729 0545              ; CONST TEXT USED BY AUTORUN FEATURE
 1730 0545              ; *********************************************************************************************************
 1731 0545              ;TXT_RUN:            db "RUN",0      																	;057b	52 55 4e 00 	.
 1732 0545
 1733 0545              ; ifdef VER_12
 1734 0545              ; ASSERT($=0x057f)
 1735 0545              ; endif
 1736 0545
 1737 0545
 1738 0545
 1739 0545
 1740 0545
 1741 0545              ; ifdef VER_12
 1742 0545              ; *********************************************************************************************************
 1743 0545              ; --- unknown deprecated data or code – not used ----
 1744 0545              ; *********************************************************************************************************
 1745 0545              ; Probably garbage data or code left from previous versions of ROM
 1746 0545              ;	defb 019h
 1747 0545
 1748 0545
 1749 0545
 1750 0545
 1751 0545               ; ----------------- ROM 2.0 only --------------------------------------------------------------
 1752 0545
 1753 0545               else ; VER_20
 1754 0545 ~
 1755 0545 ~            l048eh:
 1756 0545 ~            	ld a,(07818h)			; Check background color													;048e	3a 18 78 	: . x
 1757 0545 ~            	or a					; 0 = green, 1 = black														;0491	b7 	.
 1758 0545 ~            	jp z,l3e40h				; with green background go to 3E40H											;0492	ca 40 3e 	. @ >
 1759 0545 ~            l0495h:
 1760 0545 ~            ; -- transfer the data from the Screen to the I/0 buffer
 1761 0545 ~            	ld a,(hl)				; a - character from the Screen												;0495	7e 	~
 1762 0545 ~            	cp 64					; is it >= 64 - Graphic or Inverse char?									;0496	fe 40 	. @
 1763 0545 ~            	jp c,ParseScrChar		; no - proceed with Normal Char 											;0498	da ae 04 	. . .
 1764 0545 ~            ; -- if not INPUT, then Graphic or Inverse chars are only allowed in strings
 1765 0545 ~            	pop bc					; bc - length of Prompt Text												;049b	c1 	.
 1766 0545 ~            	ld de,EditFailExit		; push Fail Exit routine address on the Stack								;049c	11 a4 04 	. . .
 1767 0545 ~            	push de																								;049f	d5 	.
 1768 0545 ~            	push bc					; push length of Prompt Text on the Stack									;04a0	c5 	.
 1769 0545 ~            	jp l0502h				; Check end-of-text identification (or BREAK)								;04a1	c3 02 05 	. . .
 1770 0545 ~            EditFailExit:
 1771 0545 ~            ; -- Parsing failed but if BREAK was pressed we can ignore error
 1772 0545 ~            	ret c					; if BREAK was pressed go back to BASIC										;04a4	d8 	.
 1773 0545 ~            ; -- display SYNTAX ERROR on Screen
 1774 0545 ~            	ld hl,TXT_SYNTAXERROR	; hl - address of "SYNTAX ERROR" text 										;04a5	21 1a 3e 	! . >
 1775 0545 ~            	call PrintBasicStr		; print 'SYNTAX ERROR' on Screen											;04a8	cd a7 28 	. . (
 1776 0545 ~            ; -- go back to Editor and auire Statement from User
 1777 0545 ~            	jp ReadLine				; go back to Read Line as typed by User										;04ab	c3 e3 03 	. . .
 1778 0545 ~
 1779 0545 ~
 1780 0545 ~
 1781 0545 ~            ; Charcter on Screen is < 64 - NOT Graphiocs nor Inversed
 1782 0545 ~            ; IN: a - character from Screen to parse
 1783 0545 ~            ;     b - maximum number of characters (32 or 64)
 1784 0545 ~            ;     hl - VRAM address where is parsed char
 1785 0545 ~            ;     de - address of current location in Editor Line Buffer
 1786 0545 ~            ParseScrChar:
 1787 0545 ~            	cp '"'					; is it start of String value??												;04ae	fe 22 	. "
 1788 0545 ~            	jr nz,l04e3h			; no - continue																;04b0	20 31 	  1
 1789 0545 ~            ; -- start of quoted String found
 1790 0545 ~            	ld (de),a				; save '"' Character into Editor Buffer										;04b2	12 	.
 1791 0545 ~            	inc hl					; hl points to next character on Screen										;04b3	23 	#
 1792 0545 ~            	inc de					; de points to next location in Editor Buffer								;04b4	13 	.
 1793 0545 ~            	dec b					; decrement max number of chars to parse									;04b5	05 	.
 1794 0545 ~            	jr z,FinishParse		; if all parsed - go Finish copying text to Edit Buffer						;04b6	28 36 	( 6
 1795 0545 ~
 1796 0545 ~            ; Parsing content of quoted String
 1797 0545 ~            ; IN: hl - address of char on Screen
 1798 0545 ~            ;     de - address of location in Editor Line Buffer
 1799 0545 ~            l04b8h:
 1800 0545 ~            	ld a,(hl)				; a - next character from Screen											;04b8	7e 	~
 1801 0545 ~            	cp 64					; is it >= 64 - Graphic or Inverse char?									;04b9	fe 40 	. @
 1802 0545 ~            	jp c,l04c9h				; no - proceed with Normal Char 											;04bb	da c9 04 	. . .
 1803 0545 ~            ; -- Graphic or Inverse char
 1804 0545 ~            	cp 128					; is it >= 128 - SemiGraphic char?											;04be	fe 80 	. .
 1805 0545 ~            	jp c,l04c5h				; no - must be 	Inversed character											;04c0	da c5 04 	. . .
 1806 0545 ~            ; -- Semigraphic char - ignore Color bits
 1807 0545 ~            	and %10001111			; clear color bits (6,5,4) in semigraphic character							;04c3	e6 8f 	. .
 1808 0545 ~            l04c5h:
 1809 0545 ~            	or %10000000			; set bit 7 - flag for Semigraphic or Invered chars in String				;04c5	f6 80 	. .
 1810 0545 ~            	jr l04dch				; store "in-string" character and process next ones							;04c7	18 13 	. .
 1811 0545 ~
 1812 0545 ~            ; Parsing content of quoted String - Normal char as Screen Code
 1813 0545 ~            l04c9h:
 1814 0545 ~            	cp '"'					; is it end of quoted String?												String limiter '"'?							;04c9	fe 22 	. "
 1815 0545 ~            	jr nz,l04d6h			; no - convert to ASCII and store in Editor Buffer							;04cb	20 09 	  .
 1816 0545 ~
 1817 0545 ~            ; -- end of quoted String - check if we procesing text for BASIC INPUT Command
 1818 0545 ~            	push hl					; save hl - VRAM address of char											;04cd	e5 	.
 1819 0545 ~            	ld hl,SYSFLAGS			; hl address of System Flags variable										;04ce	21 39 78 	! 9 x
 1820 0545 ~            	bit 4,(hl)				; is bit 4 set? (BASIC INPUT Command in progress)							;04d1	cb 66 	. f
 1821 0545 ~            	pop hl					; restore hl - VRAM address of char											;04d3	e1 	.
 1822 0545 ~            	jr z,l04e3h				; no - continue parsing text as BASIC Statement or Line						;04d4	28 0d 	( .
 1823 0545 ~            l04d6h:
 1824 0545 ~            ; -- convert to ASCII if Screen code in range 00H..1Fh ('@'..'_')
 1825 0545 ~            	bit 5,a					; is bit 5 set? (code 20H..3FH)												;04d6	cb 6f 	. o
 1826 0545 ~            	jr nz,l04dch			; yes - no need to convert - it's the same as ASCII 						;04d8	20 02 	  .
 1827 0545 ~            	or $40					; add 40H to codes 00 - 1FH -> 41H..5FH - valid ASCII						;04da	f6 40 	. @
 1828 0545 ~
 1829 0545 ~
 1830 0545 ~            ; store character in Edit Buffer and process next ones
 1831 0545 ~            l04dch:
 1832 0545 ~            	ld (de),a				; store character in Editor Line Buffer										;04dc	12 	.
 1833 0545 ~            	inc hl					; hl points to next character on Screen										;04dd	23 	#
 1834 0545 ~            	inc de					; de points to next location in Editor Buffer								;04de	13 	.
 1835 0545 ~            	djnz l04b8h				; decrement max number of chars to parse									;04df	10 d7 	. .
 1836 0545 ~            	jr FinishParse			; = 0, done										;04e1	18 0b 	. .
 1837 0545 ~
 1838 0545 ~
 1839 0545 ~            ; Parsing text as BASIC Statement or Line (no Inverse nor Semigraphics allowed)
 1840 0545 ~            l04e3h:
 1841 0545 ~            	bit 5,a					; is bit 5 set? (code 20H..3FH)												;04e3	cb 6f 	. o
 1842 0545 ~            	jr nz,l04e9h			; yes - no need to convert - it's the same as ASCII 						;04e5	20 02 	  .
 1843 0545 ~            	or $40					; add 40H to codes 00 - 1FH -> 41H..5FH - valid ASCII						;04e7	f6 40 	. @
 1844 0545 ~            l04e9h:
 1845 0545 ~            	ld (de),a				; store character in Editor Line Buffer										;04e9	12 	.
 1846 0545 ~            	inc hl					; hl points to next character on Screen										;04ea	23 	#
 1847 0545 ~            	inc de					; de points to next location in Editor Buffer								;04eb	13 	.
 1848 0545 ~            	djnz l0495h				; decrement max number of chars to parse									;04ec	10 a7 	. .
 1849 0545 ~
 1850 0545 ~            ; Copying finished, complete buffer content
 1851 0545 ~            FinishParse:
 1852 0545 ~            ; -- trim trailing spaces (if any)
 1853 0545 ~            	dec de					; de - points to last character inserted into Editor Buffer					;04ee	1b 	.
 1854 0545 ~            ; -- check if DE points to start of Editor Buffer (79E8H)
 1855 0545 ~            	ld a,d					; MSB of character address 													;04ef	7a 	z
 1856 0545 ~            	cp $79					; is it same as MSB of Buffer address?										;04f0	fe 79 	. y
 1857 0545 ~            	jr nz,l04fah			; no - test Space char in Buffer											;04f2	20 06 	  .
 1858 0545 ~            	ld a,e					; LSB of character address 													;04f4	7b 	{
 1859 0545 ~            	cp $e8					; is DE < address of Editor Buffer?											;04f5	fe e8 	. .
 1860 0545 ~            	jp c,l04ffh				; yes - done - put String Terminator (0) at the end							;04f7	da ff 04 	. . .
 1861 0545 ~            l04fah:
 1862 0545 ~            ; -- check if we have trailing space
 1863 0545 ~            	ld a,(de)				; a - character from Edit Buffer											;04fa	1a 	.
 1864 0545 ~            	cp ' '					; is it Space char?															;04fb	fe 20 	.
 1865 0545 ~            	jr z,FinishParse		; yes - continue trimming Spaces											;04fd	28 ef 	( .
 1866 0545 ~
 1867 0545 ~            l04ffh:
 1868 0545 ~            ; -- put String Terminator (0) at the end of trimmed text
 1869 0545 ~            	inc de					; de - address just after last char in Edit Buffer							;04ff	13 	.
 1870 0545 ~            	xor a					; string terminator (0)														;0500	af 	.
 1871 0545 ~            	ld (de),a				; store into Editor Line Buffer												;0501	12 	.
 1872 0545 ~
 1873 0545 ~
 1874 0545 ~            l0502h:
 1875 0545 ~            ; -- move Screen Cursor to line after text (1 or 2 lines down)
 1876 0545 ~            	call GetEditorLineFlag	; a - Editor Line Flag/Status pointed by hl									;0502	cd a8 33 	. . 3
 1877 0545 ~            	ld hl,(CURSORADDR)		; hl - VRAM address of Screen Cursor										;0505	2a 20 78 	*   x
 1878 0545 ~            	cp $81					; is Cursor in 1st line of two-line-statment?								;0508	fe 81 	. .
 1879 0545 ~            	call SetCursorFromHL	; refresh Cursor Char at cursor position									;050a	cd 53 00 	. S .
 1880 0545 ~            	jr nz,.advCursor		; no - it's single line	text - move 1 line only 							;050d	20 04 	  .
 1881 0545 ~            ; -- advance Screen Cursor to begining of next Screen Line
 1882 0545 ~            	xor a					; a - control character 0													;050f	af 	.
 1883 0545 ~            	call ScrPrintChar		; send character to Screen/Editor											;0510	cd 8b 30 	. . 0
 1884 0545 ~            .advCursor:
 1885 0545 ~            ; -- advance Screen Cursor to begining of next Screen Line
 1886 0545 ~            	xor a					; a - control character 0													;0513	af 	.
 1887 0545 ~            	call ScrPrintChar		; send character to Screen/Editor											;0514	cd 8b 30 	. . 0
 1888 0545 ~
 1889 0545 ~            ; -- remove INVERSE mode from Keyboard State
 1890 0545 ~            	ld a,(KEYSFLAGS)		; get Keyboard's current State 												;0517	3a 38 78 	: 8 x
 1891 0545 ~            	and %11111101			; clear bit 1 - INVERSE Flag 												;051a	e6 fd 	. .
 1892 0545 ~            	ld (KEYSFLAGS),a		; store modified Keyboard State back 										;051c	32 38 78 	2 8 x
 1893 0545 ~
 1894 0545 ~            ; -- check if User pressed BREAK key (canceled edit)
 1895 0545 ~            	ld hl,SYSFLAGS			; hl - address of System Flags variable										;051f	21 39 78 	! 9 x
 1896 0545 ~            	bit 2,(hl)				; is bit 2 set (BREAK Key pressed)?											;0522	cb 56 	. V
 1897 0545 ~            	jr z,.commitState		; no - set state to Commit editsand continue  								;0524	28 05 	( .
 1898 0545 ~            ; -- set state to Abort edits - BREAK pressed
 1899 0545 ~            	ld a,1					; a=1 - BREAK key pressed													;0526	3e 01 	> .
 1900 0545 ~            	scf						; set Carry Flag - Abort													;0528	37 	7
 1901 0545 ~            	jr .skip				; skip setting state														;0529	18 01 	. .
 1902 0545 ~            .commitState:
 1903 0545 ~            ; -- set state to Commit edits - RETURN pressed
 1904 0545 ~            	xor a					; a=0 - no BREAK, Carry=0 - Commit											;052b	af 	.
 1905 0545 ~            .skip:
 1906 0545 ~            ; -- clear flag - BASIC INPUT Command is no longer in progress
 1907 0545 ~            	ld hl,SYSFLAGS			; hl - address of System Flags variable										;052c	21 39 78 	! 9 x
 1908 0545 ~            	res 4,(hl)				; Reset INPUT Command flag													;052f	cb a6 	. .
 1909 0545 ~            ; -- set start of text inside Buffer
 1910 0545 ~            	ld hl,EditLineBuf		; address of Editor Line Buffer												;0531	21 e8 79 	! . y
 1911 0545 ~            	pop bc					; length of Prompt text (in case INPUT was processed)						;0534	c1 	.
 1912 0545 ~            	push af					; save Commit/Abort state on the Stack										;0535	f5 	.
 1913 0545 ~            	add hl,bc				; add Prefix length - hl points to start of entered text					;0536	09 	.
 1914 0545 ~            ; -- make sure Buffer contains at least 1 char - add Space if needed and return
 1915 0545 ~            	jp l3e29h				; chack Edit Buffer and correct if needed									;0537	c3 29 3e 	. ) >
 1916 0545 ~
 1917 0545               endif ; VER_20
 1918 0545
 1919 0545              ; *********************************************************************************************************
 1920 0545              ; COPY TEXT FROM SCREEN TO BUFFER AND TO INPUT
 1921 0545              ; *********************************************************************************************************
 1922 0545              ; Part of the BASIC INPUT command routine reading a line into the Editor Line Buffer
 1923 0545              ; Maximum allowable text length is 64 characters. End of text is marked by 0 in buffer.
 1924 0545              ; OUT: hl - location prior to first character in Editor Buffer
 1925 0545              ;      CY=1 - Input was aborted by pressing BREAK key
 1926 0545              GetUserInputText:
 1927 0545              ; -- Wait until entered text is completed (by RETURN) or aborted (by BREAK)
 1928 0545 3A AF 7A     	ld a,(07aafh)			; a - number of characters in Edit Buffer left to process					;053a	3a af 7a 	: . z
 1929 0548 B7           	or a					; is it 0 (buffer empty)?													;053d	b7 	.
 1930 0549 20 FA        	jr nz,GetUserInputText			; no - wait for all chars copied											;053e	20 fa 	  .
 1931 054B              ; -- clear BASIC Edit Line Buffer (64 chars)
 1932 054B 06 40        	ld b,64					; buffer length - 64 chars 													;0540	06 40 	. @
 1933 054D 21 E8 79     	ld hl,EditLineBuf		; hl - address of Editor Line Buffer										;0542	21 e8 79 	! . y
 1934 0550 3E 20        	ld a,' '				; a - Space char to fill buffer with										;0545	3e 20 	>
 1935 0552              .loop:
 1936 0552 77           	ld (hl),a				; store Space char into buffer												;0547	77 	w
 1937 0553 23           	inc hl					; points to next char location in buffer									;0548	23 	#
 1938 0554 10 FC        	djnz .loop				; fill all 64 bytes															;0549	10 fc 	. .
 1939 0556              ; -- terminate text with byte 0
 1940 0556 AF           	xor a					; text terminator 0															;054b	af 	.
 1941 0557 77           	ld (hl),a				; store at the end of buffer												;054c	77 	w
 1942 0558              ; -- correct Cursor Position if Cursor is on 2nd line of two-line-text
 1943 0558 CD A8 33     	call GetEditorLineFlag	; a - Editor Line Flag														;054d	cd a8 33 	. . 3
 1944 055B B7           	or a					; is it 2nd line of two-line-text?											;0550	b7 	.
 1945 055C 3A A6 78     	ld a,(CURSORPOS)		; a - current position of Cursor in Edited line	(column)					;0551	3a a6 78 	: . x
 1946 055F 20 02        	jr nz,.skip				; it's not 2nd line - skip adjustment										;0554	20 02 	  .
 1947 0561 C6 20        	add a,32				; add 32 to Cursor in text position (one screen line)						;0556	c6 20 	.
 1948 0563              .skip:
 1949 0563              ; -- calculate length of text based on Cursor position
 1950 0563 4F           	ld c,a					; c - Cursor position in line as length LSB 								;0558	4f 	O
 1951 0564 AF           	xor a					; a = 0 as difference MSB													;0559	af 	.
 1952 0565 47           	ld b,a					; bc - text length - difference beetween Cursor and begining of 1st line	;055a	47 	G
 1953 0566 2A 20 78     	ld hl,(CURSORADDR)		; absolute address of Cursor 												;055b	2a 20 78 	*   x
 1954 0569              ; -- source address
 1955 0569 ED 42        	sbc hl,bc				; hl - absolute address of begining of text									;055e	ed 42 	. B
 1956 056B              ; -- destination address
 1957 056B 11 E8 79     	ld de,EditLineBuf		; de - address of Editor Line Buffer										;0560	11 e8 79 	. . y
 1958 056E              ; -- copy text from VRAM (Screen)  to Edit Buffer
 1959 056E C5           	push bc					; save bc - length of text													;0563	c5 	.
 1960 056F ED B0        	ldir					; copy bc bytes from VRAM to Edit Buffer									;0564	ed b0 	. .
 1961 0571 C1           	pop bc					; restore bc - length of text												;0566	c1 	.
 1962 0572              ; -- set flag meaning BASIC INPUT Command is in progress
 1963 0572 21 39 78     	ld hl,SYSFLAGS			; hl - address of System Flags variable										;0567	21 39 78 	! 9 x
 1964 0575 CB E6        	set 4,(hl)				; set BASIC INPUT Command flag												;056a	cb e6 	. .
 1965 0577              ; -- create/update BASIC variable from text
 1966 0577 CD E3 03     	call ReadLine			; Process text in Edit Buffer												;056c	cd e3 03 	. . .
 1967 057A C9           	ret						; return 																	;056f	c9 	.
 1968 057B
 1969 057B
 1970 057B
 1971 057B
 1972 057B
 1973 057B              ; *********************************************************************************************************
 1974 057B              ; CONST TEXT USED BY AUTORUN FEATURE
 1975 057B              ; *********************************************************************************************************
 1976 057B              ; Text is copied to Edit buffer and executed when BASIC CRUN Command is used
 1977 057B 52 55 4E 00  TXT_RUN:            db "RUN",0      																	;0570	52 55 4e 	N
 1978 057F
 1979 057F               ifdef VER_20
 1980 057F ~             	ASSERT($=0x0574)
 1981 057F               endif
 1982 057F               ifdef VER_12
 1983 057F               	ASSERT($=0x057f)
 1984 057F               endif
 1985 057F
 1986 057F              ; *********************************************************************************************************
 1987 057F              ; --- unknown deprecated data or code – not used ----
 1988 057F              ; *********************************************************************************************************
 1989 057F              ; Probably garbage data or code left from previous versions of ROM
 1990 057F               ifdef VER_12
 1991 057F 19           	dh "19"
 1992 0580               else ; VER_20
 1993 0580 ~            	dh "c4 33 32"			; call nz,03233h - not used -												;0574	c4 33 32 	. 3 2
 1994 0580 ~            	dh "cd a3 1a"			; call 01aa3h    - not used -												;0577	cd a3 1a 	. . .
 1995 0580 ~            	dh "cd d8 17"			; call 017d8h	 - not used -												;057a	cd d8 17 	. . .
 1996 0580 ~            	dh "cd 0d 19"			; call 0190dh	 - not used -												;057d	cd 0d 19 	. . .
 1997 0580 ~
 1998 0580               endif
 1999 0580              ; ----------------- common code ---------------------------------------------------------------
 2000 0580
 2001 0580
 2002 0580
 2003 0580              ; *********************************************************************************************************
 2004 0580              ; --- unknown deprecated data or code – not used ----
 2005 0580              ; *********************************************************************************************************
 2006 0580              ; Probably garbage data or code left from previous versions of ROM
 2007 0580 CA 5A 12     	dh "ca 5a 12"			; jp z,0125ah																;0580	ca 5a 12 	. Z .
 2008 0583 CD 49 1F     	dh "cd 49 1f"			; call sub_1f49h															;0583	cd 49 1f 	. I .
 2009 0586 38 18        	dh "38 18"				; jr c,$+26																	;0586	38 18 	8 .
 2010 0588 EF           	dh "ef"					; rst 28h																	;0588	ef 	.
 2011 0589 3A 38 04     	dh "3a 38 04"			; ld a,(00438h)																;0589	3a 38 04 	: 8 .
 2012 058C DD           	dh "dd"					;illegal sequence															;058c	dd  	. y .
 2013 058D
 2014 058D
 2015 058D
 2016 058D              ; *********************************************************************************************************
 2017 058D              ; PRINTER DRIVER
 2018 058D              ; *********************************************************************************************************
 2019 058D              ; Printer Device Handler routine
 2020 058D              ; IN: ix - Device Control Block
 2021 058D              ;     b - operation
 2022 058D              ;     c - data to send (if 0 only request Printer Status)
 2023 058D              ;     [ix+3] - defined number of Lines per Page
 2024 058D              ;     [ix+4] - number of Lines already printed on this Page
 2025 058D              PRN_DevHandler:			ASSERT( $ == 0x058d)
 2026 058D              ; -- test if send 0 - only get Printer Status
 2027 058D 79           	ld a,c					; a - data to send															;058d	79 	y .
 2028 058E B7           	or a					; is this 0 - only request Printer Status									;058e	b7 	.
 2029 058F 28 33        	jr z,GetPrinterStatus	; yes - read Printer Status and return to caller							;058f	28 33 	( 3
 2030 0591
 2031 0591              ; -- test if send 0BH or 0CH - FormFeed is requested
 2032 0591 FE 0B        	cp #0b					; is this FormFeed (0B) control char?										;0591	fe 0b 	. .
 2033 0593 28 0A        	jr z,.formFeed			; yes - set New Page on Printer												;0593	28 0a 	( .
 2034 0595 FE 0C        	cp #0c					; is this FormFeed (0C) control char?										;0595	fe 0c 	. .
 2035 0597 20 14        	jr nz,.printChar		; no - print char															;0597	20 14 	  .
 2036 0599
 2037 0599              ; -- FormFeed - send multiple CR if Lines Per Page defined
 2038 0599 AF           	xor a					; a = 0 - char to print if no Lines Per Page defined						;0599	af 	.
 2039 059A DD B6 03     	or (ix+3)				; is Lines Per Page defined? (or continuous print)							;059a	dd b6 03 	. . .
 2040 059D 28 0E        	jr z,.printChar			; no - send Control Char (0) directly to Printer							;059d	28 0e 	( .
 2041 059F              .formFeed:
 2042 059F              ; -- calculate how many lines we need to skip
 2043 059F DD 7E 03     	ld a,(ix+3)				; a - defined number of Lines per Page										;059f	dd 7e 03 	. ~ .
 2044 05A2 DD 96 04     	sub (ix+4)				; subtract number of lines already printed									;05a2	dd 96 04 	. . .
 2045 05A5
 2046 05A5              ; -- send multiple CR to make Form Feed
 2047 05A5 47           	ld b,a					; set as loop counter - number of CR to send to Printer						;05a5	47 	G
 2048 05A6              .sendCRloop:
 2049 05A6 CD E2 3A     	call sub_3ae2h			; send CR to Printer 														;05a6	cd e2 3a 	. . :
 2050 05A9 10 FB        	djnz .sendCRloop		; repeat until Printer is at top of New Page (b times)						;05a9	10 fb 	. .
 2051 05AB 18 12        	jr .clrLinesPrinted		; reset number of lines already printed on this Page to 0 and return		;05ab	18 12 	. .
 2052 05AD
 2053 05AD              .printChar:
 2054 05AD CD B6 3A     	call sub_3ab6h			; send Char from A to Printer												;05ad	cd b6 3a 	. . :
 2055 05B0              ; -- update number of printed Lines if CR was sent to Printer
 2056 05B0 79           	ld a,c					; a - last printed char														;05b0	79 	y
 2057 05B1 FE 0D        	cp #0d					; is printed char was CR/LF (need increment Lines Printed counter)?			;05b1	fe 0d 	. .
 2058 05B3 C0           	ret nz					; no - return to caller --------------------------------------- 			;05b3	c0 	.
 2059 05B4              ; -- update number of lines printed on this Page
 2060 05B4 DD 34 04     	inc (ix+4)				; increment number of printed lines											;05b4	dd 34 04 	. 4 .
 2061 05B7 DD 7E 04     	ld a,(ix+4)				; a - number of printed lines												;05b7	dd 7e 04 	. ~ .
 2062 05BA DD BE 03     	cp (ix+3)				; is this equal to number of defined lines per page?						;05ba	dd be 03 	. . .
 2063 05BD 79           	ld a,c					; a - last printed char														;05bd	79 	y
 2064 05BE C0           	ret nz					; no - return to caller with Printer Status ------------------- 			;05be	c0 	.
 2065 05BF              .clrLinesPrinted:
 2066 05BF DD 36 04 00  	ld (ix+4),0				; set Number of Lines Printed on Page to 0									;05bf	dd 36 04 00 	. 6 . .
 2067 05C3 C9           	ret						; ------------------ End of Proc ------------------------------ 			;05c3	c9 	.
 2068 05C4
 2069 05C4
 2070 05C4
 2071 05C4
 2072 05C4              ; *********************************************************************************************************
 2073 05C4              ; GET PRINTER STATUS
 2074 05C4              ; *********************************************************************************************************
 2075 05C4              ; Read Printer hardware Port (00H) to get Status.
 2076 05C4              ; OUT: a - Printer Status Busy (1) or Ready (0)
 2077 05C4              GetPrinterStatus:
 2078 05C4 DB 00        	in a,($00)				; read Printer I/O Port - get Status										;05c4	db 00 	. .
 2079 05C6 E6 01        	and %00000001			; only bit 0 is valid - 0=ready, 1=busy										;05c6	e6 01 	. .
 2080 05C8 C9           	ret						; ---------- return Printer Status -------------------- 					;05c8	c9 	.
 2081 05C9
 2082 05C9
 2083 05C9
 2084 05C9
 2085 05C9              ; *********************************************************************************************************
 2086 05C9              ; FILL PRINT BUFFER
 2087 05C9              ; *********************************************************************************************************
 2088 05C9              ; Fill 4-byte Print Buffer for graphics printing with value given in A
 2089 05C9              ; IN: a - byte/char to fill buffer with
 2090 05C9              FillPrnBuffer:
 2091 05C9 C5           	push bc					; save bc																	;05c9	c5 	.
 2092 05CA E5           	push hl					; save hl																	;05ca	e5 	.
 2093 05CB 06 04        	ld b,4					; b - init byte counter to 4 bytes											;05cb	06 04 	. .
 2094 05CD 21 D2 7A     	ld hl,PRINTBUFFER		; hl - address of Print Buffer to fill 										;05cd	21 d2 7a 	! . z
 2095 05D0              .next:
 2096 05D0 77           	ld (hl),a				; put byte/char into buffer													;05d0	77 	w
 2097 05D1 23           	inc hl					; hl points to next byte													;05d1	23 	#
 2098 05D2 10 FC        	djnz .next				; repeat until 4 bytes was filled											;05d2	10 fc 	. .
 2099 05D4 E1           	pop hl					; restore hl																;05d4	e1 	.
 2100 05D5 C1           	pop bc					; restore bc																;05d5	c1 	.
 2101 05D6 C9           	ret						; ------------------- End of Proc ---------------------------------			;05d6	c9 	.
 2102 05D7
 2103 05D7
 2104 05D7
 2105 05D7              ; *********************************************************************************************************
 2106 05D7              ; HANDLE KEYBOARD ROLLOVER
 2107 05D7              ; *********************************************************************************************************
 2108 05D7              ; Part of the keyboard query. Handles pressing a second key before the first one was released (rollover).
 2109 05D7              ; In KEYS_STATE variable (7838H), bits 3 and 4 are used to flag the status of the two keyboard buffers
 2110 05D7              ; KEYCODE1 (7836H) and KEYCODE2 (7837H):
 2111 05D7              ;	bit4 bit3
 2112 05D7              ;    0    0		both KEYCODE1 and KEYCODE2 are empty (no key pressed)
 2113 05D7              ;    0    1		KEYCODE1 has a valid key pressed, KEYCODE2 is empty
 2114 05D7              ;    1    0		KEYCODE1 is empty, KEYCODE2 has a valid key pressed
 2115 05D7              ;    1    1		both KEYCODE1 and KEYCODE2 have a valid keys pressed
 2116 05D7              ; IN: a - KeyCode of pressed key
 2117 05D7              ;     e - byte value just read from Keyboard Matrix
 2118 05D7              ; OUT:a - KeyCOde accepted or 0 if
 2119 05D7              l05d7h:
 2120 05D7 21 38 78     	ld hl,KEYSFLAGS			; hl - address of Keyboard State variable									;05d7	21 38 78 	! 8 x
 2121 05DA CB 56        	bit 2,(hl)				; is bit 2 set (Function Active)?					    					;05da	cb 56 	. V
 2122 05DC 28 15        	jr z,.noFnActive		; no - ;05dc	28 15 	( .
 2123 05DE
 2124 05DE              ; -- keyboard Function is Active (Ctrl+RETURN was pressed just before)
 2125 05DE 57           	ld d,a			    	; d - save key detected 													;05de	57 	W
 2126 05DF 3A 3A 78     	ld a,(KEYS_DEBOUNCER)	; a - debounce delay counter 												;05df	3a 3a 78 	: : x
 2127 05E2 B7           	or a					; is it 0 (key was detected just now)?										;05e2	b7 	.
 2128 05E3 28 0F        	jr z,l05f4h				; yes - store KeyCode to one of key buffer									;05e3	28 0f 	( .
 2129 05E5
 2130 05E5              ; -- process debounce key - check if delay time elapsed: PAL - 0.84 sec., NTSC - 0.7 sec.
 2131 05E5 3C           	inc a					; increment delay counter (once per frame)									;05e5	3c 	<
 2132 05E6 32 3A 78     	ld (KEYS_DEBOUNCER),a	; update debounce delay counter												;05e6	32 3a 78 	2 : x
 2133 05E9 FE 2A        	cp 42					; is it 42 frames (0.84|0.7 sek.)?											;05e9	fe 2a 	. *
 2134 05EB 28 02        	jr z,.exitClear			; yes - clear Function Active flag and return with no key					;05eb	28 02 	( .
 2135 05ED              ; -- ignore until delay elapsed
 2136 05ED AF           	xor a					; a - 0 - no valid key pressed (yet)										;05ed	af 	.
 2137 05EE C9           	ret						; ----------------------- End of Proc -----------------------------------	;05ee	c9 	.
 2138 05EF              .exitClear:
 2139 05EF CB 96        	res 2,(hl)				; clear Function Active flag in KEYSFLAGS variable							;05ef	cb 96 	. .
 2140 05F1 AF           	xor a					; a - 0 - no valid key pressed (yet)										;05f1	af 	.
 2141 05F2 C9           	ret						; ----------------------- End of Proc -----------------------------------	;05f2	c9 	.
 2142 05F3
 2143 05F3              .noFnActive:
 2144 05F3              ; -- keyboard Function is NOT Active (Ctrl+RETURN wasn't pressed just before)
 2145 05F3 57           	ld d,a					; d - save key detected 													;05f3	57 	W
 2146 05F4
 2147 05F4              l05f4h:
 2148 05F4              ; -- store KeyCode to one of 2 key buffers: KEYCODE1 or KEYCODE2
 2149 05F4 21 38 78     	ld hl,KEYSFLAGS			; hl - address of Keyboard State variable									;05f4	21 38 78 	! 8 x
 2150 05F7 7E           	ld a,(hl)				; a - Keyboard Flags														;05f7	7e 	~
 2151 05F8 E6 18        	and %00011000			; test bit 3 and 4 - any of Key Buffers contains KeyCode? 					;05f8	e6 18 	. .
 2152 05FA 20 0B        	jr nz,l0607h			; yes - ;05fa	20 0b 	  .
 2153 05FC              ; -- both KEYCODE1 and KEYCODE2 are empty - store new key code in KEYCODE1
 2154 05FC CB DE        	set 3,(hl)				; set Flag - KEYCODE1 contains valid key code								;05fc	cb de 	. .
 2155 05FE AF           	xor a					; a = 0 - no key code														;05fe	af 	.
 2156 05FF 32 37 78     	ld (KEYCODE2),a			; clear 2nd Key buffer														;05ff	32 37 78 	2 7 x
 2157 0602              ; -- store new Key Code in 1st Key Buffer
 2158 0602 7A           	ld a,d					; a - key detected															;0602	7a 	z
 2159 0603 32 36 78     	ld (KEYCODE1),a			; store detected key in 1st Key Buffer										;0603	32 36 78 	2 6 x
 2160 0606 C9           	ret						; ----------------------- End of Proc -----------------------------------	;0606	c9 	.
 2161 0607              l0607h:
 2162 0607 CB 66        	bit 4,(hl)		    	; is bit 4 set (KEYCODE2 has value)? 										;0607	cb 66 	. f
 2163 0609 20 2A        	jr nz,l0635h			; yes - ;0609	20 2a 	  *
 2164 060B
 2165 060B              ; -- Key Buffer KEYCODE2 is empty, KEYCODE1 has value -
 2166 060B 3A 36 78     	ld a,(KEYCODE1)			; a - key stored before in 1st buffer										;060b	3a 36 78 	: 6 x
 2167 060E BA           	cp d					; is the same as just detected?												;060e	ba 	.
 2168 060F 20 21        	jr nz,.storeNewInB2		; no - new key detected	- store new Key Code in KEYCODE2					;060f	20 21 	  !
 2169 0611              ; -- detected key is the same as before - scan for other keys
 2170 0611 ED 4B 42 78  	ld bc,(KEYS_SCAN_COORDS); bc - currently scanned Row and Column counters							;0611	ed 4b 42 78 	. K B x
 2171 0615 2A 44 78     	ld hl,(KEYS_SCAN_ROWADR); hl - currently scanned Keyboard Matrix address							;0615	2a 44 78 	* D x
 2172 0618 7B           	ld a,e					; a - value just read from Keyboard Matrix									;0618	7b 	{
 2173 0619 CD 35 2F     	call sub_2f35h			; continue scan Keyboard Matrix from point where it was stopped 			;0619	cd 35 2f 	. 5 /
 2174 061C BA           	cp d					; is the same as before?													;061c	ba 	.
 2175 061D CA D7 2F     	jp z,l2fd7h				; yes - try confim key pressed												;061d	ca d7 2f 	. . /
 2176 0620 FE 00        	cp 0					; no more keys detected?													;0620	fe 00 	. .
 2177 0622 CA D7 2F     	jp z,l2fd7h				; yes - try confim key pressed												;0622	ca d7 2f 	. . /
 2178 0625
 2179 0625              ; -- IN: a = new key press detected
 2180 0625              .storeInB2:
 2181 0625              ; -- store new Key Code in KEYCODE2 - update KEYSFLAGS
 2182 0625 21 38 78     	ld hl,KEYSFLAGS			; hl - address of Keyboard State variable									;0625	21 38 78 	! 8 x
 2183 0628 CB DE        	set 3,(hl)		    	; set bit 3 - KEYCODE1 has stored Key Code 									;0628	cb de 	. .
 2184 062A CB E6        	set 4,(hl)		    	; set bit 4 - KEYCODE2 has stored Key Code 									;062a	cb e6 	. .
 2185 062C CB 96        	res 2,(hl)		    	; clear bit 2 - inactive Keyboard Function Mode 							;062c	cb 96 	. .
 2186 062E 32 37 78     	ld (KEYCODE2),a			; put Key Code into 2nd Buffer 												;062e	32 37 78 	2 7 x
 2187 0631 C9           	ret						; ----------------------- End of Proc -----------------------------------	;0631	c9 	.
 2188 0632
 2189 0632              .storeNewInB2:
 2190 0632              ; -- store new Key Code in KEYCODE2
 2191 0632 7A           	ld a,d					; a - key detected															;0632	7a 	z
 2192 0633 18 F0        	jr .storeInB2			; store Key Code in KEYCODE2 												;0633	18 f0 	. .
 2193 0635
 2194 0635
 2195 0635              l0635h:
 2196 0635              ; -- Key Buffer KEYCODE1 has value (if?) KEYCODE2 has value -
 2197 0635 3A 36 78     	ld a,(KEYCODE1)			; a - Key Kode stored before in 1st Buffer									;0635	3a 36 78 	: 6 x
 2198 0638 BA           	cp d					; is the same as detected?													;0638	ba 	.
 2199 0639 28 08        	jr z,l0643h				; yes - ;0639	28 08 	( .
 2200 063B 3A 37 78     	ld a,(KEYCODE2)			; a - Key Kode stored before in 1st Buffer									;063b	3a 37 78 	: 7 x
 2201 063E BA           	cp d					; is the same as detected?													;063e	ba 	.
 2202 063F 28 02        	jr z,l0643h				; yes - ;063f	28 02 	( .
 2203 0641              ; -- new Key Code is 3rd Key pressed - ignore it
 2204 0641 AF           	xor a					; return value - no key pressed												;0641	af 	.
 2205 0642 C9           	ret						; ----------------------- End of Proc -----------------------------------	;0642	c9 	.
 2206 0643              l0643h:
 2207 0643              ; -- detected key is the same as before - scan for other keys
 2208 0643 ED 4B 42 78  	ld bc,(KEYS_SCAN_COORDS); bc - currently scanned Row and Column counters							;0643	ed 4b 42 78 	. K B x
 2209 0647 2A 44 78     	ld hl,(KEYS_SCAN_ROWADR); hl - currently scanned Keyboard Matrix address							;0647	2a 44 78 	* D x
 2210 064A 7B           	ld a,e					; a - value just read from Keyboard Matrix									;064a	7b 	{
 2211 064B CD 35 2F     	call sub_2f35h			; continue scan Keyboard Matrix from point where it was stopped 			;064b	cd 35 2f 	. 5 /
 2212 064E BA           	cp d					; is the same as before?													;064e	ba 	.
 2213 064F 28 05        	jr z,l0656h				; yes - try confim key pressed												;064f	28 05 	( .
 2214 0651 FE 00        	cp 0					; no more keys detected?													;0651	fe 00 	. .
 2215 0653 C2 D7 2F     	jp nz,l2fd7h			; yes - try confim key pressed												;0653	c2 d7 2f 	. . /
 2216 0656              l0656h:
 2217 0656 21 38 78     	ld hl,KEYSFLAGS			; hl - address of Keyboard State variable									;0656	21 38 78 	! 8 x
 2218 0659 CB DE        	set 3,(hl)		    	; set bit 3 - KEYCODE1 has stored Key Code 									;0659	cb de 	. .
 2219 065B CB A6        	res 4,(hl)		    	; clear bit 4 - KEYCODE2 is empty		 									;065b	cb a6 	. .
 2220 065D 3A 36 78     	ld a,(KEYCODE1)			; a - key code stored before												;065d	3a 36 78 	: 6 x
 2221 0660 BA           	cp d					; is the same as detected?													;0660	ba 	.
 2222 0661 20 05        	jr nz,.move				; no - move KEYCODE2 to KEYCODE1 and clear KEYCODE2							;0661	20 05 	  .
 2223 0663              .clearB2:
 2224 0663 AF           	xor a					; a - return value - no key pressed											;0663	af 	.
 2225 0664 32 37 78     	ld (KEYCODE2),a			; clear 2nd buffer															;0664	32 37 78 	2 7 x
 2226 0667 C9           	ret						; ----------------------- End of Proc -----------------------------------	;0667	c9 	.
 2227 0668              .move:
 2228 0668 3A 37 78     	ld a,(KEYCODE2)			; a - previous Key Code stored in 2nd buffer								;0668	3a 37 78 	: 7 x
 2229 066B 32 36 78     	ld (KEYCODE1),a			; move to 1st buffer														;066b	32 36 78 	2 6 x
 2230 066E 18 F3        	jr .clearB2				; go clear 2nd buffer														;066e	18 f3 	. .
 2231 0670
 2232 0670
 2233 0670
 2234 0670              ; *********************************************************************************************************
 2235 0670              ; --- unknown deprecated data or code – not used ----
 2236 0670              ; *********************************************************************************************************
 2237 0670              ; Probably garbage data or code left from previous versions of ROM
 2238 0670
 2239 0670 DD CB 09 D6  	dh "dd cb 09 d6"			; unknown unused data													;0670	dd cb 09 d6 	. . . .
 2240 0674
 2241 0674
 2242 0674
 2243 0674
 2244 0674
 2245 0674              ; *********************************************************************************************************
 2246 0674              ; SYSTEM INITIALIZATION ROUTINE - POWER UP
 2247 0674              ; *********************************************************************************************************
 2248 0674              ; Initialize DCBs (Device Control Blocs), RCA BASIC values and Self Modified Code (SMC) routines.
 2249 0674              SysInit:
 2250 0674 00           	nop
 2250 0675 00             nop					; [TRS] out (FFH),a - clear I/O register for video/cassette (click)		;0675	00 	.
 2251 0676
 2252 0676
 2253 0676              ; -- copy default values defined in ROM (06D2H..0707H) to RCA Area (7800H..7835H)
 2254 0676              ; -- repeated 128 times - probably  to ensure corectness (or to provide delay for other components stabilization).
 2255 0676              .loop:
 2256 0676 21 D2 06     	ld hl,VectorsAndDCBInitData	; hl - address of default values of Vectors and DCBs (source)			;0676	21 d2 06 	! . .
 2257 0679 11 00 78     	ld de,RAMCommArea			; de - address of RAM Communication Area (destination)					;0679	11 00 78 	. . x
 2258 067C 01 36 00     	ld bc,54					; bc - size of block to copy (54 bytes)									;067c	01 36 00 	. 6 .
 2259 067F ED B0        	ldir						; bulk copy 54 bytes													;067f	ed b0 	. .
 2260 0681 3D           	dec a						; decrement loop counter												;0681	3d 	=
 2261 0682 3D           	dec a						; decrement loop counter												;0682	3d 	=
 2262 0683 20 F1        	jr nz,.loop					; repeat copy 128 times													;0683	20 f1 	  .
 2263 0685
 2264 0685              ; -- clear RCA Area (7836H-785CH) - Variables for Keyboard, Cursor, etc
 2265 0685              ; IN: a - value to fill with = 0
 2266 0685              ;     de - destination address = 7836
 2267 0685              BAS_ResetClear:
 2268 0685 06 27        	ld b,39						; size of memory block to clear (39 bytes)								;0685	06 27 	. '
 2269 0687              .loop:
 2270 0687 12           	ld (de),a					; store 0 																;0687	12 	.
 2271 0688 13           	inc de						; increment destination address											;0688	13 	.
 2272 0689 10 FC        	djnz .loop					; repeat 39 times														;0689	10 fc 	. .
 2273 068B
 2274 068B              ; -- continue System Initialization
 2275 068B C3 75 00     	jp BasicInit				; initialize RCA BASIC variables 										;068b	c3 75 00 	. u .
 2276 068E
 2277 068E
 2278 068E
 2279 068E
 2280 068E              ; *********************************************************************************************************
 2281 068E              ; CARTRIDGES TEST AND INITIALIZATION ROUTINE
 2282 068E              ; *********************************************************************************************************
 2283 068E              ; Check Cartridges if they exists at defined Memory Slots: $4000, $6000 and $8000
 2284 068E              ; If valid Cartrighe is detected then
 2285 068E
 2286 068E              SysCartTest:
 2287 068E 21 00 40     	ld hl,$4000					; hl - address of First Cart Slot (DOS)									;068e	21 00 40 	! . @
 2288 0691 CD A4 06     	call SysCartInit			; Init Cart if exists													;0691	cd a4 06 	. . .
 2289 0694 21 00 60     	ld hl,$6000					; hl - address of Second Cart Slot (Other Devices)						;0694	21 00 60 	! . `
 2290 0697 CD A4 06     	call SysCartInit			; Init Cart if exists													;0697	cd a4 06 	. . .
 2291 069A 21 00 80     	ld hl,$8000					; hl - address of Third Cart Slot (Game)								;069a	21 00 80 	! . .
 2292 069D CD A4 06     	call SysCartInit			; Init Cart if exists													;069d	cd a4 06 	. . .
 2293 06A0              ; -- all cartridges tested and initialized
 2294 06A0 FB           	ei							; enable interrupt 														;06a0	fb 	.
 2295 06A1 C3 19 1A     	jp BasicREADY				; jump to Basic Ready and display prompt to user 	          			;06a1	c3 19 1a 	. . .
 2296 06A4
 2297 06A4              ; -- validate Cartridge Header Sequence: AA 55 E7 18
 2298 06A4              SysCartInit:
 2299 06A4 3E AA        	ld a,$aa					; 1st byte of Cart Signature AA											;06a4	3e aa 	> .
 2300 06A6 BE           	cp (hl)						; is expected value?													;06a6	be 	.
 2301 06A7 23           	inc hl						; address of 2nd byte													;06a7	23 	#
 2302 06A8 C0           	ret nz						; no - end of proc														;06a8	c0 	.
 2303 06A9 2F           	cpl							; 2nd byte of Cart Signature 55 (AA inverted)							;06a9	2f 	/
 2304 06AA BE           	cp (hl)						; is expected value														;06aa	be 	.
 2305 06AB 23           	inc hl						; address of 3rd byte													;06ab	23 	#
 2306 06AC C0           	ret nz						; no - end of proc 														;06ac	c0 	.
 2307 06AD 3E E7        	ld a,$e7					; 3rd byte of Cart Signature E7											;06ad	3e e7 	> .
 2308 06AF BE           	cp (hl)						; is expected value														;06af	be 	.
 2309 06B0 23           	inc hl						; address of 4th byte													;06b0	23 	#
 2310 06B1 C0           	ret nz						; no - end of proc														;06b1	c0 	.
 2311 06B2 2F           	cpl							; 4th byte of Cart Signature 18 (E7 inverted)							;06b2	2f 	/
 2312 06B3 BE           	cp (hl)						; is expected value														;06b3	be 	.
 2313 06B4 23           	inc hl						; address of Init Routine on Cart										;06b4	23 	#
 2314 06B5 C0           	ret nz						; no - end of proc 														;06b5	c0 	.
 2315 06B6 FB           	ei							; enable interrupts														;06b6	fb 	.
 2316 06B7 E9           	jp (hl)						; Initialize Cartridge													;06b7	e9 	.
 2317 06B8
 2318 06B8
 2319 06B8
 2320 06B8              ; ********************************************************************************************
 2321 06B8              ; --- unknown deprecated data or code – not used ----
 2322 06B8              ; ********************************************************************************************
 2323 06B8
 2324 06B8 0E 02        	ld c,002h		;06b8	0e 02 	. .
 2325 06BA CD 59 1A     	call 01a59h		;06ba	cd 59 1a 	. Y .
 2326 06BD CD B8 34     	call 034b8h		;06bd	cd b8 34 	. . 4
 2327 06C0 CD E3 18     	call sub_18e3h		;06c0	cd e3 18 	. . .
 2328 06C3 28 C0        	jr z,BAS_ResetClear		;06c3	28 c0 	( .
 2329 06C5 EF           	rst 28h			;06c5	ef 	.
 2330 06C6 2C           	inc l			;06c6	2c 	,
 2331 06C7 28 14        	jr z,$+22		;06c7	28 14 	( .
 2332 06C9 CD F1 34     	call 034f1h		;06c9	cd f1 34 	. . 4
 2333 06CC
 2334 06CC
 2335 06CC              ; *********************************************************************************************************
 2336 06CC              ; ALTERNATIVE RE-ENTRY POINT ITO BASIC
 2337 06CC              ; *********************************************************************************************************
 2338 06CC              ; Re-entry point to BASIC
 2339 06CC              BAS_ReEntry:
 2340 06CC 01 18 1A     	ld bc,BAS_ReadyPopBC	; address of routine BasicREADY (with pop bc)							;06cc	01 18 1a 	. . .
 2341 06CF C3 AE 19     	jp BasicEntryPoint		; set BasicREADY as exit initialize BASIC variables						;06cf	c3 ae 19 	. . .
 2342 06D2
 2343 06D2
 2344 06D2
 2345 06D2
 2346 06D2              ; *********************************************************************************************************
 2347 06D2              ; RCA INIT DATA
 2348 06D2              ; *********************************************************************************************************
 2349 06D2              ; Default values for System Variables (RAM Communication Adresses) at $7800 - $7835
 2350 06D2              VectorsAndDCBInitData:
 2351 06D2              ; -- Default RST Vectors
 2352 06D2 C3 96 1C     	jp AssertToken		    ; [$7800] called by RST 08 												;06d2	c3 96 1c 	. . .
 2353 06D5 C3 78 1D     	jp NextToken			; [$7803] called by RST 10												;06d5	c3 78 1d 	. x .
 2354 06D8 C3 90 1C     	jp CmpHLDE		        ; [$7806] called by RST 18												;06d8	c3 90 1c 	. . .
 2355 06DB C3 D9 25     	jp TestNTF			    ; [$7809] called by RST 20												;06db	c3 d9 25 	. . %
 2356 06DE C9           	ret
 2356 06DF 00             nop
 2356 06E0 00             nop			; [$780c] called by RST 28	[TRS] (jump to 4BA2H for DOS)				;06de	c9 	.
 2357 06E1 C9           	ret
 2357 06E2 00             nop
 2357 06E3 00             nop			; [$780f] called by RST 30	[TRS] (jump to 44B4H for DOS)				;06e1	c9 	.
 2358 06E4 FB           	ei
 2358 06E5 C9             ret
 2358 06E6 00             nop			; [$7812] 					[TRS] (jump to 4518H for DOS)				;06e4	fb 	.
 2359 06E7
 2360 06E7              ; -- Default Keyboard DCB (Device Control Block) at $7815 - $781c
 2361 06E7 01           	dg .......1				; [$7815] Device Capabilities = 1 (read only)							;06e7	01
 2362 06E8 F4 2E        	dw KBD_DevHandler		; [$7816] Device Handler Address										;06e8	f4 2e 	. . .
 2363 06EA 00           	db 0					; [$7818] Key Inverse Screen (TODO)										;06ea	00 	.
 2364 06EB 00           	db 0					; [$7819] Key Inverse Typing (TODO)										;06eb	00 	.
 2365 06EC 00           	db 0					; [$781a] TRS 0 (in Model III, time counting byte for blinking cursor)	;06ec	00 	.
 2366 06ED 4B 49        	db "KI"					; [$781b] Device Id (Keyboard Input)									;06ed	4b 49	K I
 2367 06EF
 2368 06EF              ; -- Default Video DCB (Device Control Block) at $781d - $7824 (used partially by ROM 1.2)
 2369 06EF 00           	dg ........				; [$781d] Device Capabilities = 0 (none)								;06ef	00 	.
 2370 06F0 00 00        	dw $0000				; [$781e] Device Handler Address (not exists)							;06f0	00 00	.
 2371 06F2 00 70        	dw VRAM					; [$7820] Cursor VRAM Address 											;06f2	00 70	.
 2372 06F4 00           	db 0					; [$7822] Device Custom Data Byte (not used)							;06f4	00 	.
 2373 06F5 00 00        	dw $0000				; [$7823] Device Id (none)	(used as TapeDataChecksum)					;06f5	00 00 	.
 2374 06F7
 2375 06F7              ; -- Default Printer DCB (Device Control Block) at $7825 - $782c
 2376 06F7 06           	dg .....11.				; [$7825] Device Capabilities = 6 (write only)							;06f7	06 	. .
 2377 06F8 8D 05        	dw PRN_DevHandler		; [$7826] Device Handler Address										;06f8	8d 05 	.
 2378 06FA 43           	db 67					; [$7828] LinesPerPage													;06fa	43 	C
 2379 06FB 00           	db 0					; [$7829] LinesPrinted													;06fb	00 	.
 2380 06FC 00           	db 0					; [$782a] CharsInLinePrinted (not used by ROM 1.2)						;06fc	00 	.
 2381 06FD 50 52        	db "PR"					; [$782b] DeviceId (Printer)											;06fd	50 52	P R
 2382 06FF
 2383 06FF              ; DOS Vectors (???)
 2384 06FF C3 00 50     	jp $5000				; [$782d] DOS ReEntry Jump												;06ff	c3 00 50 	. . P
 2385 0702 C7           	rst 0
 2385 0703 00             nop
 2385 0704 00             nop		; [$7830] Abnormal DOS ReEntry											;0702	c7 00 00	.
 2386 0705 3E 00        	ld a,0
 2386 0707 C9             ret			; [$7833] DOS Device Vectoring Routine									;0705	3e 00 	> .
 2387 0708              ;---------------------------------------------------------------------------------------
 2388 0708              							ASSERT( 54 == $ - VectorsAndDCBInitData)
 2389 0708              ;---------------------------------------------------------------------------------------
 2390 0708
 2391 0708
 2392 0708              ; *********************************************************************************************************
 2393 0708              ; SINGLE PRECISION ADDITION 0.5 TO ACC
 2394 0708              ; *********************************************************************************************************
 2395 0708              ; Math : ACC = ACC + 0.5 (Single)
 2396 0708              sngACCadd05:
 2397 0708 21 80 13     	ld hl,sngConst_05		; Constant Value 0.5 (Single)              								;0708	21 80 13 	! . .
 2398 070B
 2399 070B              ; *********************************************************************************************************
 2400 070B              ; SINGLE PRECISION ADDITION
 2401 070B              ; *********************************************************************************************************
 2402 070B              ; Math : ACC = (HL) + ACC (Single)
 2403 070B              sngHLaddACC_DBL:
 2404 070B CD C2 09     	call HLToBCDE	 		; Copy value from (HL) to BCDE (Single)   								;070b	cd c2 09 	. . .
 2405 070E 18 06        	jr sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 			;070e	18 06 	. .
 2406 0710
 2407 0710
 2408 0710              ; *********************************************************************************************************
 2409 0710              ; SINGLE PRECISION SUBTRACTION
 2410 0710              ; *********************************************************************************************************
 2411 0710              ; Math : ACC = (HL) - ACC (Single)
 2412 0710              sngHLsubACC_DBL:
 2413 0710 CD C2 09     	call HLToBCDE			; Copy value from (HL) to BCDE (Single)  								;0710	cd c2 09 	. . .
 2414 0713
 2415 0713
 2416 0713              ; *********************************************************************************************************
 2417 0713              ; SINGLE PRECISION SUBTRACTION
 2418 0713              ; *********************************************************************************************************
 2419 0713              ; Math : ACC = BCDE - ACC (Single)
 2420 0713              sngBCDEsubACC_DBL:
 2421 0713 CD 82 09     	call sngACCnegate		; ACC = -ACC (Single) 													;0713	cd 82 09 	. . .
 2422 0716
 2423 0716
 2424 0716              ; *********************************************************************************************************
 2425 0716              ; SINGLE PRECISION ADDITION
 2426 0716              ; *********************************************************************************************************
 2427 0716              ; Math : ACC = BCDE + ACC (Single)
 2428 0716              sngBCDEaddACC_DBL:
 2429 0716              ; -- test if BCDE == 0 - adding 0 doesn't change ACC
 2430 0716 78           	ld a,b					; a - Exponent of BCDE value											;0716	78 	x
 2431 0717 B7           	or a					; is it 0 (means BCDE value == 0)										;0717	b7 	.
 2432 0718 C8           	ret z					; return (result already in ACC)										;0718	c8 	.
 2433 0719              ; -- test if ACC == 0 - no addition needed just copy BCDE to ACC
 2434 0719 3A 24 79     	ld a,(MATH_ACC_EXP)		; a - Exponent of ACC value												;0719	3a 24 79 	: $ y
 2435 071C B7           	or a					; is it 0 (means ACC value == 0)										;071c	b7 	.
 2436 071D CA B4 09     	jp z,BCDEToACC_DBL		; skip addition code - copy value from BCDE to ACC (Single)				;071d	ca b4 09 	. . .
 2437 0720              ; -- compare Exponents - calkulate difference in magnitude
 2438 0720 90           	sub b					; subtract/compare Exponets (ACC < BCDE)?								;0720	90 	.
 2439 0721 30 0C        	jr nc,.skipSwap			; yes - skip swap														;0721	30 0c 	0 .
 2440 0723              ; -- negate Exponents difference (make it positive)
 2441 0723 2F           	cpl						; flip bits																;0723	2f 	/
 2442 0724 3C           	inc a					; add 1 - it makes negate 8 bit value									;0724	3c 	<
 2443 0725              ; -- swap ACC and BCDE values
 2444 0725 EB           	ex de,hl				; save de register (will be used by Push routine)						;0725	eb 	.
 2445 0726 CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)									;0726	cd a4 09 	. . .
 2446 0729 EB           	ex de,hl				; restore de register													;0729	eb 	.
 2447 072A CD B4 09     	call BCDEToACC_DBL		; copy BCDE value to ACC (Single)										;072a	cd b4 09 	. . .
 2448 072D C1           	pop bc					; get bc from stack														;072d	c1 	.
 2449 072E D1           	pop de					; now BCDE has Single value from Stack (previous ACC)					;072e	d1 	.
 2450 072F              .skipSwap:
 2451 072F              ; -- if Exp difference is bigger than 24 the values cannot be added
 2452 072F FE 19        	cp 25					; is diff > 24															;072f	fe 19 	. .
 2453 0731 D0           	ret nc					; yes - adding BCDE won't change ACC - result ready						;0731	d0 	.
 2454 0732              ; -- compare ACC and BCDE signs
 2455 0732 F5           	push af					; save Exp difference on Stack											;0732	f5 	.
 2456 0733 CD DF 09     	call MAT_sCmpSetSign	; compare signs - bit 7 of a = 1 if ACC and BCDE have same sign			;0733	cd df 09 	. . .
 2457 0736 67           	ld h,a					; h - save result of sign comparision									;0736	67 	g
 2458 0737 F1           	pop af					; rstore Exponents difference											;0737	f1 	.
 2459 0738              ; -- line up ACC and BCDE values to the same magnitude
 2460 0738 CD D7 07     	call sub_07d7h			; roll BCDE right by difference (align magnitudes)						;0738	cd d7 07 	. . .
 2461 073B              ; -- after roll register b contains bits shifted out from register e
 2462 073B B4           	or h					; are signs equal? (both positive or negative)							;073b	b4 	.
 2463 073C 21 21 79     	ld hl,ACC_SNG	 		; hl - address of Single value in ACC (4 bytes): 						;073c	21 21 79 	! ! y
 2464 073F F2 54 07     	jp p,l0754h				; jump if signs are different - perform subtraction of mantissas		;073f	f2 54 07 	. T .
 2465 0742              ; -- signs are the same - perform addition
 2466 0742 CD B7 07     	call sub_07b7h			; add 24 bit mantisa values of [hl] and BCDE							;0742	cd b7 07 	. . .
 2467 0745 D2 96 07     	jp nc,l0796h			; jump if no Carry from 24bit addition									;0745	d2 96 07 	. . .
 2468 0748              ; -- Carry from 24bit add - increment Exponent of ACC
 2469 0748 23           	inc hl					; hl - address of ACC Exponent											;0748	23 	#
 2470 0749 34           	inc (hl)				; increment Exponent													;0749	34 	4
 2471 074A CA B2 07     	jp z,ErrRaiseOverflow	; if Exp rollover to 0 Raise OVERFLOW Error								;074a	ca b2 07 	. . .
 2472 074D              ; -- Carry from 24bit add - shift right Mantissa of ACC
 2473 074D 2E 01        	ld l,1					; l = shift by 1 bit 													;074d	2e 01 	. .
 2474 074F CD EB 07     	call sub_07ebh			; shift Mantissa of ACC by 1 bit										;074f	cd eb 07 	. . .
 2475 0752 18 42        	jr l0796h		;0752	18 42 	. B
 2476 0754
 2477 0754
 2478 0754              l0754h:
 2479 0754              ; -- signs are different - subtraction of the 24bit mantissas
 2480 0754 AF           	xor a					; a - 0 value 															;0754	af 	.
 2481 0755 90           	sub b					; a = 0 - b																;0755	90 	.
 2482 0756 47           	ld b,a					; store back b = -b														;0756	47 	G
 2483 0757 7E           	ld a,(hl)				; a - LSB of Single value in ACC 										;0757	7e 	~
 2484 0758 9B           	sbc a,e					; subtract LSB of Single value in BCDE									;0758	9b 	.
 2485 0759 5F           	ld e,a					; store back into e														;0759	5f 	_
 2486 075A 23           	inc hl					; hl - points to middle byte of value in ACC							;075a	23 	#
 2487 075B 7E           	ld a,(hl)				; a - middle byte														;075b	7e 	~
 2488 075C 9A           	sbc a,d					; subtract middle byte of value in BCDE									;075c	9a 	.
 2489 075D 57           	ld d,a					; store back into d														;075d	57 	W
 2490 075E 23           	inc hl					; hl - points to MSB of value in ACC						 			;075e	23 	#
 2491 075F 7E           	ld a,(hl)				; a - MSB of Single value in ACC										;075f	7e 	~
 2492 0760 99           	sbc a,c					; subtract MSB of Single value in BCDE									;0760	99 	.
 2493 0761 4F           	ld c,a					; store back into c														;0761	4f 	O
 2494 0762              l0762h:
 2495 0762 DC C3 07     	call c,sub_07c3h		; if CY make mantissa negative 											;0762	dc c3 07 	. . .
 2496 0765
 2497 0765
 2498 0765              ; Normalize mantisa extended to 32 bits - CDEB
 2499 0765              l0765h:
 2500 0765 68           	ld l,b					; l - Extended LSB of mantissa											;0765	68 	h
 2501 0766 63           	ld h,e					; h - LSB of Mantissa - now mantisa is packed in CDHL					;0766	63 	c
 2502 0767              ; -- if possible shift 8 bit at once
 2503 0767 AF           	xor a					; shift counter/exponent difference  = 0								;0767	af 	.
 2504 0768              l0768h:
 2505 0768 47           	ld b,a					; b - current value of exponent diff									;0768	47 	G
 2506 0769 79           	ld a,c					; a - MSB of mantissa													;0769	79 	y
 2507 076A B7           	or a					; is it 0 (can be reduced)?												;076a	b7 	.
 2508 076B 20 18        	jr nz,l0785h			; no - go normalize 1 bit at the time									;076b	20 18 	  .
 2509 076D              ; -- shift left mantissa by 8bit (1byte) at once
 2510 076D 4A           	ld c,d					; c - middle byte of mantissa to MSB 									;076d	4a 	J
 2511 076E 54           	ld d,h					; d - LSB of mantissa to middle byte									;076e	54 	T
 2512 076F 65           	ld h,l					; h - extended LSB of 32bit mantissa to LSB								;076f	65 	e
 2513 0770 6F           	ld l,a					; l - new extended LSB = 0												;0770	6f 	o
 2514 0771 78           	ld a,b					; a - current exponent 													;0771	78 	x
 2515 0772 D6 08        	sub 8					; subtract 8 - number of 'decimal' places we shifted mantissa			;0772	d6 08 	. .
 2516 0774 FE E0        	cp $e0					; is it -32? (we shifted 32 bits and mantissa equals 0)?				;0774	fe e0 	. .
 2517 0776 20 F0        	jr nz,l0768h			; no - try again to shift 8 bits at once								;0776	20 f0 	  .
 2518 0778
 2519 0778
 2520 0778
 2521 0778              ; *********************************************************************************************************
 2522 0778              ; SINGLE PRECISION SET ZERO
 2523 0778              ; *********************************************************************************************************
 2524 0778              ; Math : ACC = 0 (Single or Double)
 2525 0778              ; Sets ACC value to 0. Normalized Single or Double Floating Point Number has Exponent set to 0
 2526 0778              ; and values stored as Mantissa don't matter.
 2527 0778              MAT_sdSetACC_0:
 2528 0778 AF           	xor a					; value of Exponent of Single value equals 0							;0778	af 	.
 2529 0779              l0779h:
 2530 0779 32 24 79     	ld (MATH_ACC_EXP),a		; store Exponent = 0													;0779	32 24 79 	2 $ y
 2531 077C C9           	ret						; return 																;077c	c9 	.
 2532 077D
 2533 077D
 2534 077D              ; -- part of Floating Point Number normalization - 1bit at the time
 2535 077D              l077dh:
 2536 077D 05           	dec b					; decrement Exponent by 1												;077d	05 	.
 2537 077E 29           	add hl,hl				; shift left == multiply by 2 kow 16bit of CDHL							;077e	29 	)
 2538 077F 7A           	ld a,d					; a - middle byte of mantissa											;077f	7a 	z
 2539 0780 17           	rla						; shift left == mul by 2 middle byte									;0780	17 	.
 2540 0781 57           	ld d,a					; store back as middle byte												;0781	57 	W
 2541 0782 79           	ld a,c					; a - MSB of mantissa													;0782	79 	y
 2542 0783 8F           	adc a,a					; shift left == mul by 2 MSB											;0783	8f 	.
 2543 0784 4F           	ld c,a					; store back as MSB														;0784	4f 	O
 2544 0785              l0785h:
 2545 0785 F2 7D 07     	jp p,l077dh				; continue if bit7 of MSB is 0 - can be reduced							;0785	f2 7d 07 	. } .
 2546 0788              ; --
 2547 0788 78           	ld a,b					; a - Exponent correction (negative number of shifted bits)				;0788	78 	x
 2548 0789 5C           	ld e,h					; e - LSB of CDHL - 32bit mantissa										;0789	5c 	\
 2549 078A 45           	ld b,l					; now CDHL is stored back to CDEB										;078a	45 	E
 2550 078B              l078bh:
 2551 078B B7           	or a					; is Exponent correction = 0? (no bits shifted) 						;078b	b7 	.
 2552 078C 28 08        	jr z,l0796h				; yes - skip exponnent correction 										;078c	28 08 	( .
 2553 078E              ; -- correct Exponent of Single Value in ACC before storing Mantissa
 2554 078E 21 24 79     	ld hl,MATH_ACC_EXP		; hl - address of ACC Exponent											;078e	21 24 79 	! $ y
 2555 0791 86           	add a,(hl)				; add Exponent of current value											;0791	86 	.
 2556 0792 77           	ld (hl),a				; store back modified Exponent of new Value								;0792	77 	w
 2557 0793 30 E3        	jr nc,MAT_sdSetACC_0	; if Uunderflow go set ACC value to 0									;0793	30 e3 	0 .
 2558 0795 C8           	ret z					; if sored Exponent = 0 we done - ACC value is already 0				;0795	c8 	.
 2559 0796              l0796h:
 2560 0796 78           	ld a,b					; a - Extended LSB of 32bit mantissa									;0796	78 	x
 2561 0797              l0797h:
 2562 0797 21 24 79     	ld hl,MATH_ACC_EXP		; hl - address of ACC Exponent											;0797	21 24 79 	! $ y
 2563 079A B7           	or a					; test bit 7 of Ext LSB - the only bit matters 							;079a	b7 	.
 2564 079B FC A8 07     	call m,sub_07a8h		; if bit 7=1 round up 24bit mantissa (CDE)								;079b	fc a8 07 	. . .
 2565 079E 46           	ld b,(hl)				; b - Exponent of ACC value												;079e	46 	F
 2566 079F 23           	inc hl					; hl - address of ACC MSB (having sign bit)								;079f	23 	#
 2567 07A0 7E           	ld a,(hl)				; a - MSB with Sign bit													;07a0	7e 	~
 2568 07A1 E6 80        	and %10000000			; isolate Sign bit														;07a1	e6 80 	. .
 2569 07A3 A9           	xor c					; xor with Sign bit from CDE mantissa									;07a3	a9 	.
 2570 07A4 4F           	ld c,a					; store back as Mantissa MSB (CDE)										;07a4	4f 	O
 2571 07A5 C3 B4 09     	jp BCDEToACC_DBL		; copy value from BCDE to ACC (Single)									;07a5	c3 b4 09 	. . .
 2572 07A8
 2573 07A8
 2574 07A8
 2575 07A8              ; *********************************************************************************************************
 2576 07A8              ; SINGLE PRECISION ROUNDUP 24BIT VALUE (CDE)
 2577 07A8              ; *********************************************************************************************************
 2578 07A8              ; Increment by 1 value stored in CDE (24bit) with Overflow detection.
 2579 07A8              sub_07a8h:
 2580 07A8 1C           	inc e					; increment LSB of 24bit value											;07a8	1c 	.
 2581 07A9 C0           	ret nz					; return if not 0 														;07a9	c0 	.
 2582 07AA 14           	inc d					; increment middle byte													;07aa	14 	.
 2583 07AB C0           	ret nz					; return if not 0														;07ab	c0 	.
 2584 07AC 0C           	inc c					; increment MSB of 24bit value											;07ac	0c 	.
 2585 07AD C0           	ret nz					; return if not 0														;07ad	c0 	.
 2586 07AE              ; -- MSB was = ff so force negative mantissa and increment Exponent
 2587 07AE 0E 80        	ld c,$80				; set Sign bit to 1 (negative)											;07ae	0e 80 	. .
 2588 07B0 34           	inc (hl)				; increment ACC Exponent by 1											;07b0	34 	4
 2589 07B1 C0           	ret nz					; return if not 0 - otherwise it is Overflow							;07b1	c0 	.
 2590 07B2
 2591 07B2
 2592 07B2
 2593 07B2              ; *********************************************************************************************************
 2594 07B2              ; RAISE OVERFLOW ERROR
 2595 07B2              ; *********************************************************************************************************
 2596 07B2              ErrRaiseOverflow:
 2597 07B2 1E 0A        	ld e,#0a				; ERROR 0A - OVERFLOW													;07b2	1e 0a 	. .
 2598 07B4 C3 A2 19     	jp ErrRaiseError		; Raise OVERFLOW Error													;07b4	c3 a2 19 	. . .
 2599 07B7
 2600 07B7
 2601 07B7
 2602 07B7              ; *********************************************************************************************************
 2603 07B7              ; SINGLE PRECISION ADD 24BIT VALUES (CDE + [hl])
 2604 07B7              ; *********************************************************************************************************
 2605 07B7              ; Add Mantissas (24bit) of two Single Values: CDE = CDE + [hl]
 2606 07B7              sub_07b7h:
 2607 07B7              ; add 24 bit mantisa values of [hl] and BCDE
 2608 07B7 7E           	ld a,(hl)				; a - LSB of 24bit value from [hl] 										;07b7	7e 	~
 2609 07B8 83           	add a,e					; add LSB of 24bit value from CDE										;07b8	83 	.
 2610 07B9 5F           	ld e,a					; store back as LSB														;07b9	5f 	_
 2611 07BA 23           	inc hl					; hl - point to middle byte												;07ba	23 	#
 2612 07BB 7E           	ld a,(hl)				; a - middle byte of 24bit value										;07bb	7e 	~
 2613 07BC 8A           	adc a,d					; add middle byte of CDE value											;07bc	8a 	.
 2614 07BD 57           	ld d,a					; store back as middle byte												;07bd	57 	W
 2615 07BE 23           	inc hl					; hl - point to MSB														;07be	23 	#
 2616 07BF 7E           	ld a,(hl)				; a - MSB of 24bit value from [hl]										;07bf	7e 	~
 2617 07C0 89           	adc a,c					; add MSB of CDE value													;07c0	89 	.
 2618 07C1 4F           	ld c,a					; store back as MSB														;07c1	4f 	O
 2619 07C2 C9           	ret						; return with result in CDE plus CPU flags								;07c2	c9 	.
 2620 07C3
 2621 07C3
 2622 07C3
 2623 07C3              sub_07c3h:
 2624 07C3 21 25 79     	ld hl,MATH_ACC_SIGN		;07c3	21 25 79 	! % y
 2625 07C6 7E           	ld a,(hl)			;07c6	7e 	~
 2626 07C7 2F           	cpl			;07c7	2f 	/
 2627 07C8 77           	ld (hl),a			;07c8	77 	w
 2628 07C9 AF           	xor a			;07c9	af 	.
 2629 07CA 6F           	ld l,a			;07ca	6f 	o
 2630 07CB 90           	sub b			;07cb	90 	.
 2631 07CC 47           	ld b,a			;07cc	47 	G
 2632 07CD 7D           	ld a,l			;07cd	7d 	}
 2633 07CE 9B           	sbc a,e			;07ce	9b 	.
 2634 07CF 5F           	ld e,a			;07cf	5f 	_
 2635 07D0 7D           	ld a,l			;07d0	7d 	}
 2636 07D1 9A           	sbc a,d			;07d1	9a 	.
 2637 07D2 57           	ld d,a			;07d2	57 	W
 2638 07D3 7D           	ld a,l			;07d3	7d 	}
 2639 07D4 99           	sbc a,c			;07d4	99 	.
 2640 07D5 4F           	ld c,a			;07d5	4f 	O
 2641 07D6 C9           	ret			;07d6	c9 	.
 2642 07D7
 2643 07D7
 2644 07D7              ; Roll BCDE right
 2645 07D7              ; IN: BCDE - single value
 2646 07D7              ;     a - number of bits
 2647 07D7              ; OUT: a - status
 2648 07D7              ;     CY - status:
 2649 07D7              sub_07d7h:
 2650 07D7 06 00        	ld b,0					; b = 0 - bits will be shifted info CDE Mantissa						;07d7	06 00 	. .
 2651 07D9              .next8bits:
 2652 07D9 D6 08        	sub 8					; sub 8 bits - can we just move byte by byte?							;07d9	d6 08 	. .
 2653 07DB 38 07        	jr c,.rollBits			; no - roll by less than 8 bits											;07db	38 07 	8 .
 2654 07DD              ; -- roll right BCDE by 8 bits
 2655 07DD 43           	ld b,e					; shift right register e into register b								MSB;07dd	43 	C
 2656 07DE 5A           	ld e,d					; shift right register d into register e								;07de	5a 	Z
 2657 07DF 51           	ld d,c					; shift right register c into register d								;07df	51 	Q
 2658 07E0 0E 00        	ld c,0					; shift in 8 bits (0) into register c									;07e0	0e 00 	. .
 2659 07E2 18 F5        	jr .next8bits			; continue rolling BCDE													;07e2	18 f5 	. .
 2660 07E4              .rollBits:
 2661 07E4 C6 09        	add a,9					; rollback "sub 8" above and add 1 (to compensate dec l checking)		;07e4	c6 09 	. .
 2662 07E6 6F           	ld l,a					; l - number of bits to roll BCDE										;07e6	6f 	o
 2663 07E7              .next1bit:
 2664 07E7 AF           	xor a					; a - return value;07e7	af 	.
 2665 07E8 2D           	dec l					; decrement loop counter - number of roll to do							;07e8	2d 	-
 2666 07E9 C8           	ret z					; all done - return														;07e9	c8 	.
 2667 07EA 79           	ld a,c					; a - MSB of Mantissa (24bit)											;07ea	79 	y
 2668 07EB              sub_07ebh:
 2669 07EB              ; roll right 24bit Mantissa of BCDE by number of bit stored in l
 2670 07EB 1F           	rra						; roll right MSB														;07eb	1f 	.
 2671 07EC 4F           	ld c,a					; store back rolled MSB value											;07ec	4f 	O
 2672 07ED 7A           	ld a,d					; a - middle byte 														;07ed	7a 	z
 2673 07EE 1F           	rra						; roll right middle byte (shift in bit fallen from MSB)					;07ee	1f 	.
 2674 07EF 57           	ld d,a					; store back rolled middle byte											;07ef	57 	W
 2675 07F0 7B           	ld a,e					; a - LSB value															;07f0	7b 	{
 2676 07F1 1F           	rra						; roll right LSB byte (shift in bit fallen from middle byte)			;07f1	1f 	.
 2677 07F2 5F           	ld e,a					; store back rolled LSB													;07f2	5f 	_
 2678 07F3 78           	ld a,b					; a - bits rolled previously from LSB (register e)						;07f3	78 	x
 2679 07F4 1F           	rra						; shift in CY flag (fallen from e)										;07f4	1f 	.
 2680 07F5 47           	ld b,a					; store back bits for next loop											;07f5	47 	G
 2681 07F6 18 EF        	jr sub_07d7h.next1bit	; continue rolling 														;07f6	18 ef 	. .
 2682 07F8
 2683 07F8
 2684 07F8              CONSTs_1:
 2685 07F8 00 00 00 81  	dword #81000000		; Single Constant Value = 1								;07f8	00 00 00 81 	.
 2686 07FC              l07fch:
 2687 07FC 03           	inc bc			;07fc	03 	.
 2688 07FD AA           	xor d			;07fd	aa 	.
 2689 07FE 56           	ld d,(hl)			;07fe	56 	V
 2690 07FF 19           	add hl,de			;07ff	19 	.
 2691 0800              l0800h:
 2692 0800 80           	add a,b			;0800	80 	.
 2693 0801 F1           	pop af			;0801	f1 	.
 2694 0802 22 76 80     	ld (08076h),hl		;0802	22 76 80 	" v .
 2695 0805 45           	ld b,l			;0805	45 	E
 2696 0806 AA           	xor d			;0806	aa 	.
 2697 0807 38 82        	jr c,l078bh		;0807	38 82 	8 .
 2698 0809
 2699 0809              ; ********************************************************************************
 2700 0809              ; BASIC LOG Entry Point
 2701 0809              ; Math : ACC = LOG(ACC) (Any -> Single)
 2702 0809              MAT_sLog_ACC_DBL:
 2703 0809              FuncLOG:
 2704 0809 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0809	cd 55 09 	. U .
 2705 080C B7           	or a			    ; set flags  ;080c	b7 	.
 2706 080D EA 4A 1E     	jp pe,ErrRaiseFuncCode	; raise FUNCTION CODE Error		;080d	ea 4a 1e 	. J .
 2707 0810 21 24 79     	ld hl,MATH_ACC_EXP		;0810	21 24 79 	! $ y
 2708 0813 7E           	ld a,(hl)			;0813	7e 	~
 2709 0814 01 35 80     	ld bc,08035h		                                    ;0814	01 35 80 	. 5 .
 2710 0817 11 F3 04     	ld de,004f3h		; BCDE = Sqrt(0.5)                  ;0817	11 f3 04 	. . .
 2711 081A 90           	sub b			;081a	90 	.
 2712 081B F5           	push af			;081b	f5 	.
 2713 081C 70           	ld (hl),b			;081c	70 	p
 2714 081D D5           	push de			;081d	d5 	.
 2715 081E C5           	push bc			;081e	c5 	.
 2716 081F CD 16 07     	call sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 	;081f	cd 16 07 	. . .
 2717 0822 C1           	pop bc			;0822	c1 	.
 2718 0823 D1           	pop de			;0823	d1 	.
 2719 0824 04           	inc b			;0824	04 	.
 2720 0825 CD A2 08     	call BCDEsDivACC_DBL	; ACC = BCDE / ACC (Single)	;0825	cd a2 08 	. . .
 2721 0828 21 F8 07     	ld hl,CONSTs_1		; Constant value 1 (Single) ;0828	21 f8 07 	! . .
 2722 082B CD 10 07     	call sngHLsubACC_DBL		; ACC = 1 - ACC (Single) ;082b	cd 10 07 	. . .
 2723 082E 21 FC 07     	ld hl,l07fch		;082e	21 fc 07 	! . .
 2724 0831 CD 9A 14     	call sub_149ah		;0831	cd 9a 14 	. . .
 2725 0834 01 80 80     	ld bc,$8080		                                                                ;0834	01 80 80 	. . .
 2726 0837 11 00 00     	ld de,$0000		    ; BCDE = -0.5                                                   ;0837	11 00 00 	. . .
 2727 083A CD 16 07     	call sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 	;083a	cd 16 07 	. . .
 2728 083D F1           	pop af			;083d	f1 	.
 2729 083E CD 89 0F     	call sub_0f89h		;083e	cd 89 0f 	. . .
 2730 0841              sub_0841h:
 2731 0841 01 31 80     	ld bc,08031h		;0841	01 31 80 	. 1 .
 2732 0844 11 18 72     	ld de,07218h		;0844	11 18 72 	. . r
 2733 0847
 2734 0847
 2735 0847              // ***********************************************************************
 2736 0847              ; Math : ACC = BCDE * ACC (Single)
 2737 0847              sngBCDEmulACC_DBL:
 2738 0847 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0847	cd 55 09 	. U .
 2739 084A C8           	ret z			    ; return if ACC=0                                       ;084a	c8 	.
 2740 084B 2E 00        	ld l,000h		;084b	2e 00 	. .
 2741 084D CD 14 09     	call sub_0914h		;084d	cd 14 09 	. . .
 2742 0850 79           	ld a,c			;0850	79 	y
 2743 0851 32 4F 79     	ld (MATH_ACC3_MSB-1),a		;0851	32 4f 79 	2 O y
 2744 0854 EB           	ex de,hl			;0854	eb 	.
 2745 0855 22 50 79     	ld (MATH_ACC3_MSB),hl		;0855	22 50 79 	" P y
 2746 0858 01 00 00     	ld bc,$0000		;0858	01 00 00 	. . .
 2747 085B 50           	ld d,b			;085b	50 	P
 2748 085C 58           	ld e,b			;085c	58 	X
 2749 085D 21 65 07     	ld hl,l0765h		; address of normalize routine ;085d	21 65 07 	! e .
 2750 0860 E5           	push hl			;0860	e5 	.
 2751 0861 21 69 08     	ld hl,l0869h		;0861	21 69 08 	! i .
 2752 0864 E5           	push hl			;0864	e5 	.
 2753 0865 E5           	push hl			;0865	e5 	.
 2754 0866 21 21 79     	ld hl,ACC_SNG	 ; Int,Single,String (2 or 4 bytes): 	;0866	21 21 79 	! ! y
 2755 0869              l0869h:
 2756 0869 7E           	ld a,(hl)			;0869	7e 	~
 2757 086A 23           	inc hl			;086a	23 	#
 2758 086B B7           	or a			;086b	b7 	.
 2759 086C 28 24        	jr z,l0892h		;086c	28 24 	( $
 2760 086E E5           	push hl			;086e	e5 	.
 2761 086F 2E 08        	ld l,008h		;086f	2e 08 	. .
 2762 0871              l0871h:
 2763 0871 1F           	rra			;0871	1f 	.
 2764 0872 67           	ld h,a			;0872	67 	g
 2765 0873 79           	ld a,c			;0873	79 	y
 2766 0874 30 0B        	jr nc,l0881h		;0874	30 0b 	0 .
 2767 0876 E5           	push hl			;0876	e5 	.
 2768 0877 2A 50 79     	ld hl,(MATH_ACC3_MSB)		;0877	2a 50 79 	* P y
 2769 087A 19           	add hl,de			;087a	19 	.
 2770 087B EB           	ex de,hl			;087b	eb 	.
 2771 087C E1           	pop hl			;087c	e1 	.
 2772 087D 3A 4F 79     	ld a,(MATH_ACC3_MSB-1)		;087d	3a 4f 79 	: O y
 2773 0880 89           	adc a,c			;0880	89 	.
 2774 0881              l0881h:
 2775 0881 1F           	rra			;0881	1f 	.
 2776 0882 4F           	ld c,a			;0882	4f 	O
 2777 0883 7A           	ld a,d			;0883	7a 	z
 2778 0884 1F           	rra			;0884	1f 	.
 2779 0885 57           	ld d,a			;0885	57 	W
 2780 0886 7B           	ld a,e			;0886	7b 	{
 2781 0887 1F           	rra			;0887	1f 	.
 2782 0888 5F           	ld e,a			;0888	5f 	_
 2783 0889 78           	ld a,b			;0889	78 	x
 2784 088A 1F           	rra			;088a	1f 	.
 2785 088B 47           	ld b,a			;088b	47 	G
 2786 088C 2D           	dec l			;088c	2d 	-
 2787 088D 7C           	ld a,h			;088d	7c 	|
 2788 088E 20 E1        	jr nz,l0871h		;088e	20 e1 	  .
 2789 0890              l0890h:
 2790 0890 E1           	pop hl			;0890	e1 	.
 2791 0891 C9           	ret			;0891	c9 	.
 2792 0892              l0892h:
 2793 0892 43           	ld b,e			;0892	43 	C
 2794 0893 5A           	ld e,d			;0893	5a 	Z
 2795 0894 51           	ld d,c			;0894	51 	Q
 2796 0895 4F           	ld c,a			;0895	4f 	O
 2797 0896 C9           	ret			;0896	c9 	.
 2798 0897
 2799 0897
 2800 0897              // ***********************************************************************
 2801 0897              ; Math : ACC = ACC / 10 (Single)
 2802 0897              MAT_sDiv_10:
 2803 0897 CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;0897	cd a4 09 	. . .
 2804 089A 21 D8 0D     	ld hl,MAT_sConst_10		;089a	21 d8 0d 	! . .
 2805 089D
 2806 089D
 2807 089D              // ***********************************************************************
 2808 089D              ; Math : ACC = STACK / (HL) (Single)
 2809 089D              MAT_sDiv_STACK_HL
 2810 089D CD B1 09     	call MAT_sCopyHLToACC_DBL		;089d	cd b1 09 	. . .
 2811 08A0
 2812 08A0
 2813 08A0              // ***********************************************************************
 2814 08A0              ; Math : ACC = STACK / ACC (Single)
 2815 08A0              MAT_sDiv_STACK_ACC_DBL:
 2816 08A0 C1           	pop bc			;08a0	c1 	.
 2817 08A1 D1           	pop de			;08a1	d1 	.
 2818 08A2
 2819 08A2
 2820 08A2              // ***********************************************************************
 2821 08A2              ; Math : ACC = BCDE / ACC (Single)
 2822 08A2              BCDEsDivACC_DBL:
 2823 08A2 CD 55 09     	call sngdblACCSign	    ; Check Sign of number in ACC (Single or Double)		;08a2	cd 55 09 	. U .
 2824 08A5 CA 9A 19     	jp z,ErrRaiseDivByZero	; if ACC=0 Raise 'DIVISION BY ZERO' error	            ;08a5	ca 9a 19 	. . .
 2825 08A8 2E FF        	ld l,0ffh		;08a8	2e ff 	. .
 2826 08AA CD 14 09     	call sub_0914h		;08aa	cd 14 09 	. . .
 2827 08AD 34           	inc (hl)			;08ad	34 	4
 2828 08AE 34           	inc (hl)			;08ae	34 	4
 2829 08AF 2B           	dec hl			;08af	2b 	+
 2830 08B0 7E           	ld a,(hl)			;08b0	7e 	~
 2831 08B1 32 89 78     	ld (MAT_SubBHLArgB),a		;08b1	32 89 78 	2 . x
 2832 08B4 2B           	dec hl			;08b4	2b 	+
 2833 08B5 7E           	ld a,(hl)			;08b5	7e 	~
 2834 08B6 32 85 78     	ld (MAT_SubBHLArgH),a		;08b6	32 85 78 	2 . x
 2835 08B9 2B           	dec hl			;08b9	2b 	+
 2836 08BA 7E           	ld a,(hl)			;08ba	7e 	~
 2837 08BB 32 81 78     	ld (MAT_SubBHLArgL),a		;08bb	32 81 78 	2 . x
 2838 08BE 41           	ld b,c			;08be	41 	A
 2839 08BF EB           	ex de,hl			;08bf	eb 	.
 2840 08C0 AF           	xor a			;08c0	af 	.
 2841 08C1 4F           	ld c,a			;08c1	4f 	O
 2842 08C2 57           	ld d,a			;08c2	57 	W
 2843 08C3 5F           	ld e,a			;08c3	5f 	_
 2844 08C4 32 8C 78     	ld (MAT_SubBHLRetA),a		;08c4	32 8c 78 	2 . x
 2845 08C7              l08c7h:
 2846 08C7 E5           	push hl			;08c7	e5 	.
 2847 08C8 C5           	push bc			;08c8	c5 	.
 2848 08C9 7D           	ld a,l			;08c9	7d 	}
 2849 08CA CD 80 78     	call MAT_SubBHLCust		;08ca	cd 80 78 	. . x
 2850 08CD DE 00        	sbc a,000h		;08cd	de 00 	. .
 2851 08CF 3F           	ccf			;08cf	3f 	?
 2852 08D0 30 07        	jr nc,l08d9h		;08d0	30 07 	0 .
 2853 08D2 32 8C 78     	ld (MAT_SubBHLRetA),a		;08d2	32 8c 78 	2 . x
 2854 08D5 F1           	pop af			;08d5	f1 	.
 2855 08D6 F1           	pop af			;08d6	f1 	.
 2856 08D7 37           	scf			;08d7	37 	7
 2857 08D8 D2           	db $d2		; skips next 2 instructions - jp nc,0e1c1h never jump after scf (CY=1)		;08d8	d2 c1 e1 	. . .
 2858 08D9              l08d9h:
 2859 08D9 C1           	pop bc		;08d9	c1 	. . .
 2860 08DA E1           	pop hl		;08da	e1 	. . .
 2861 08DB 79           	ld a,c			;08db	79 	y
 2862 08DC 3C           	inc a			;08dc	3c 	<
 2863 08DD 3D           	dec a			;08dd	3d 	=
 2864 08DE 1F           	rra			;08de	1f 	.
 2865 08DF FA 97 07     	jp m,l0797h		;08df	fa 97 07 	. . .
 2866 08E2 17           	rla			;08e2	17 	.
 2867 08E3 7B           	ld a,e			;08e3	7b 	{
 2868 08E4 17           	rla			;08e4	17 	.
 2869 08E5 5F           	ld e,a			;08e5	5f 	_
 2870 08E6 7A           	ld a,d			;08e6	7a 	z
 2871 08E7 17           	rla			;08e7	17 	.
 2872 08E8 57           	ld d,a			;08e8	57 	W
 2873 08E9 79           	ld a,c			;08e9	79 	y
 2874 08EA 17           	rla			;08ea	17 	.
 2875 08EB 4F           	ld c,a			;08eb	4f 	O
 2876 08EC 29           	add hl,hl			;08ec	29 	)
 2877 08ED 78           	ld a,b			;08ed	78 	x
 2878 08EE 17           	rla			;08ee	17 	.
 2879 08EF 47           	ld b,a			;08ef	47 	G
 2880 08F0 3A 8C 78     	ld a,(MAT_SubBHLRetA)		;08f0	3a 8c 78 	: . x
 2881 08F3 17           	rla			;08f3	17 	.
 2882 08F4 32 8C 78     	ld (MAT_SubBHLRetA),a		;08f4	32 8c 78 	2 . x
 2883 08F7 79           	ld a,c			;08f7	79 	y
 2884 08F8 B2           	or d			;08f8	b2 	.
 2885 08F9 B3           	or e			;08f9	b3 	.
 2886 08FA 20 CB        	jr nz,l08c7h		;08fa	20 cb 	  .
 2887 08FC E5           	push hl			;08fc	e5 	.
 2888 08FD 21 24 79     	ld hl,MATH_ACC_EXP		;08fd	21 24 79 	! $ y
 2889 0900 35           	dec (hl)			;0900	35 	5
 2890 0901 E1           	pop hl			;0901	e1 	.
 2891 0902 20 C3        	jr nz,l08c7h		;0902	20 c3 	  .
 2892 0904 C3 B2 07     	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;0904	c3 b2 07 	. . .
 2893 0907              sub_0907h:
 2894 0907 3E FF        	ld a,0ffh		;0907	3e ff 	> .
 2895 0909 2E AF        	ld l,0afh		;0909	2e af 	. .
 2896 090B 21 2D 79     	ld hl,MATH_ACC2_MSB		;090b	21 2d 79 	! - y
 2897 090E 4E           	ld c,(hl)			;090e	4e 	N
 2898 090F 23           	inc hl			;090f	23 	#
 2899 0910 AE           	xor (hl)			;0910	ae 	.
 2900 0911 47           	ld b,a			;0911	47 	G
 2901 0912 2E 00        	ld l,000h		;0912	2e 00 	. .
 2902 0914              sub_0914h:
 2903 0914 78           	ld a,b			;0914	78 	x
 2904 0915 B7           	or a			;0915	b7 	.
 2905 0916 28 1F        	jr z,l0937h		;0916	28 1f 	( .
 2906 0918 7D           	ld a,l			;0918	7d 	}
 2907 0919 21 24 79     	ld hl,MATH_ACC_EXP		;0919	21 24 79 	! $ y
 2908 091C AE           	xor (hl)			;091c	ae 	.
 2909 091D 80           	add a,b			;091d	80 	.
 2910 091E 47           	ld b,a			;091e	47 	G
 2911 091F 1F           	rra			;091f	1f 	.
 2912 0920 A8           	xor b			;0920	a8 	.
 2913 0921 78           	ld a,b			;0921	78 	x
 2914 0922 F2 36 09     	jp p,l0936h		;0922	f2 36 09 	. 6 .
 2915 0925 C6 80        	add a,080h		;0925	c6 80 	. .
 2916 0927 77           	ld (hl),a			;0927	77 	w
 2917 0928 CA 90 08     	jp z,l0890h		;0928	ca 90 08 	. . .
 2918 092B CD DF 09     	call MAT_sCmpSetSign		;092b	cd df 09 	. . .
 2919 092E 77           	ld (hl),a			;092e	77 	w
 2920 092F              sub_092fh:
 2921 092F 2B           	dec hl			;092f	2b 	+
 2922 0930 C9           	ret			;0930	c9 	.
 2923 0931              l0931h:
 2924 0931 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)	;0931	cd 55 09 	. U .
 2925 0934 2F           	cpl			;0934	2f 	/
 2926 0935 E1           	pop hl			;0935	e1 	.
 2927 0936              l0936h:
 2928 0936 B7           	or a			;0936	b7 	.
 2929 0937              l0937h:
 2930 0937 E1           	pop hl			;0937	e1 	.
 2931 0938 F2 78 07     	jp p,MAT_sdSetACC_0		;0938	f2 78 07 	. x .
 2932 093B C3 B2 07     	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;093b	c3 b2 07 	. . .
 2933 093E
 2934 093E
 2935 093E              // ***********************************************************************
 2936 093E              ; Math : ACC = ACC * 10 (Single)
 2937 093E              sngACCmul10:
 2938 093E CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)	;093e	cd bf 09 	. . .
 2939 0941 78           	ld a,b			;0941	78 	x
 2940 0942 B7           	or a			;0942	b7 	.
 2941 0943 C8           	ret z			;0943	c8 	.
 2942 0944 C6 02        	add a,002h		;0944	c6 02 	. .
 2943 0946 DA B2 07     	jp c,ErrRaiseOverflow	; Raise OVERFLOW Error		;0946	da b2 07 	. . .
 2944 0949 47           	ld b,a			;0949	47 	G
 2945 094A CD 16 07     	call sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 ;094a	cd 16 07 	. . .
 2946 094D 21 24 79     	ld hl,MATH_ACC_EXP		;094d	21 24 79 	! $ y
 2947 0950 34           	inc (hl)			;0950	34 	4
 2948 0951 C0           	ret nz			;0951	c0 	.
 2949 0952 C3 B2 07     	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;0952	c3 b2 07 	. . .
 2950 0955
 2951 0955
 2952 0955              ; ********************************************************************************
 2953 0955              ; Math : Check Sign of number in ACC (Single or Double)
 2954 0955              ; OUT: a - -1 (negative), 0 (zero), +1 (positive)
 2955 0955              sngdblACCSign:
 2956 0955 3A 24 79     	ld a,(MATH_ACC_EXP)		;0955	3a 24 79 	: $ y
 2957 0958 B7           	or a			;0958	b7 	.
 2958 0959 C8           	ret z			;0959	c8 	.
 2959 095A 3A 23 79     	ld a,(ACC_SNG+2)	 ; Int,Single,String (2 or 4 bytes): 	;095a	3a 23 79 	: # y
 2960 095D FE 2F        	cp 02fh		;095d	fe 2f 	. /
 2961 095F              SignBitToRegA:
 2962 095F 17           	rla				; copy bit7 (sign bit) to CY flag				;095f	17 	.
 2963 0960
 2964 0960
 2965 0960              ; Convert Carry Flag to value in reg A.
 2966 0960              ; IN: CY - flag
 2967 0960              ; OUT: a - 1 (CY was 0) or -1 (CY was 1)
 2968 0960              CarryToRegA:
 2969 0960 9F           	sbc a,a			; substract a from a using CY                   ;0960	9f 	.
 2970 0961 C0           	ret nz			; return a = -1 (CY was set)                    ;0961	c0 	.
 2971 0962              ; -- CY wasn't set so reg A is 0 now
 2972 0962 3C           	inc a			; set A = 1                                     ;0962	3c 	<
 2973 0963 C9           	ret			    ; ------- End of Proc ------------------------- ;0963	c9 	.
 2974 0964
 2975 0964
 2976 0964              ; ********************************************************************************
 2977 0964              ; Math : Convert from Integer (A) to Single (ACC)
 2978 0964              MAT_iConvToSngA:
 2979 0964 06 88        	ld b,088h		;0964	06 88 	. .
 2980 0966 11 00 00     	ld de,$0000		;0966	11 00 00 	. . .
 2981 0969              l0969h:
 2982 0969 21 24 79     	ld hl,MATH_ACC_EXP		;0969	21 24 79 	! $ y
 2983 096C 4F           	ld c,a			;096c	4f 	O
 2984 096D 70           	ld (hl),b			;096d	70 	p
 2985 096E 06 00        	ld b,000h		;096e	06 00 	. .
 2986 0970 23           	inc hl			;0970	23 	#
 2987 0971 36 80        	ld (hl),080h		;0971	36 80 	6 .
 2988 0973 17           	rla			;0973	17 	.
 2989 0974 C3 62 07     	jp l0762h		;0974	c3 62 07 	. b .
 2990 0977
 2991 0977              ; **************************************************************************************************
 2992 0977              ; BASIC ABS Entry Point
 2993 0977              ; Math : ACC = ABS(ACC) (Any)
 2994 0977              ; IN: TODO
 2995 0977              FuncABS
 2996 0977 CD 94 09     	call TestACCSign	; Check Sign of number in ACC - is it positive?			;0977	cd 94 09 	. . .
 2997 097A F0           	ret p				; yes --------------- End of Proc ---------------- 		;097a	f0 	.
 2998 097B              l097bh:
 2999 097B E7           	rst #20				; test NTF - Number Type Format							;097b	e7 	.
 3000 097C FA 5B 0C     	jp m,MAT_iAbs_ACC_DBL	; Integer - ACC = ABS(ACC) (Integer)					;097c	fa 5b 0c 	. [ .
 3001 097F CA F6 0A     	jp z,ErrRaiseTypeMismatch	; String - raise TYPE MISMATCH Error			;097f	ca f6 0a 	. . .
 3002 0982
 3003 0982              // ***********************************************************************
 3004 0982              ; Math : ACC = -ACC (Single or Double)
 3005 0982              sngACCnegate:
 3006 0982 21 23 79     	ld hl,MATH_ACC_MSB	; MSB of ACC - bit 7 contain number sign				;0982	21 23 79 	! # y
 3007 0985 7E           	ld a,(hl)			; a - MSB with Sign										;0985	7e 	~
 3008 0986 EE 80        	xor %10000000		; inverse Sign 											;0986	ee 80 	. .
 3009 0988 77           	ld (hl),a			; store new value										;0988	77 	w
 3010 0989 C9           	ret					; ---------------- End of Proc ------------------------	;0989	c9 	.
 3011 098A
 3012 098A              ; ********************************************************************************
 3013 098A              ; BASIC SGN Entry Point
 3014 098A              ; Math : ACC (& HL) = SGN(ACC) (Any -> Integer)
 3015 098A              FuncSNG
 3016 098A CD 94 09     	call TestACCSign	; Check Sign of number in ACC (Any)	;098a	cd 94 09 	. . .
 3017 098D              sub_098dh:
 3018 098D 6F           	ld l,a			;098d	6f 	o
 3019 098E 17           	rla			;098e	17 	.
 3020 098F 9F           	sbc a,a			;098f	9f 	.
 3021 0990 67           	ld h,a			;0990	67 	g
 3022 0991 C3 9A 0A     	jp ACCfromHLValue	; copy value from hl to ACC as integer number	;0991	c3 9a 0a 	. . .
 3023 0994
 3024 0994
 3025 0994              ; ********************************************************************************
 3026 0994              ; Math : Check Sign of number in ACC (Any)
 3027 0994              ; OUT: a - -1 (negative), 0 (zero), +1 (positive)
 3028 0994              TestACCSign:
 3029 0994 E7           	rst #20				; test NTF (Number Type Flag)							;0994	e7 	.
 3030 0995 CA F6 0A     	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;0995	ca f6 0a 	. . .
 3031 0998 F2 55 09     	jp p,sngdblACCSign	; SIngle or Double - Check Sign of number in ACC 		;0998	f2 55 09 	. U .
 3032 099B              ;; -- Integer
 3033 099B              ; ********************************************************************************
 3034 099B              ; Math : Check Sign of number in ACC (Integer)
 3035 099B              ; OUT: a - -1 (negative), 0 (zero), +1 (positive)
 3036 099B              MAT_iTestSign
 3037 099B 2A 21 79     	ld hl,(ACC_SNG)	 ; Integer value to hl 									;099b	2a 21 79 	* ! y
 3038 099E              TestHLSign:
 3039 099E              ; -- test if it's zero
 3040 099E 7C           	ld a,h				; high byte of value									;099e	7c 	|
 3041 099F B5           	or l				; are both zero?										;099f	b5 	.
 3042 09A0 C8           	ret z				; yes ---------------- End of Proc (a=0,Z=1) ----------	;09a0	c8 	.
 3043 09A1              ; -- not zero - test sign of high byte
 3044 09A1 7C           	ld a,h				; high byte of hl value									;09a1	7c 	|
 3045 09A2 18 BB        	jr SignBitToRegA	; test sign of byte -----------------------------------	;09a2	18 bb 	. .
 3046 09A4
 3047 09A4
 3048 09A4              // ***********************************************************************
 3049 09A4              ; Math : Push value from ACC on Stack (Single)
 3050 09A4              ; Place the Single precision value from ACC on the STACK
 3051 09A4              ; (7921-7922 PUSHed first, then 7923-7924)
 3052 09A4              sngACCcopyToSPUSH:
 3053 09A4 EB           	ex de,hl			;09a4	eb 	.
 3054 09A5 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;09a5	2a 21 79 	* ! y
 3055 09A8 E3           	ex (sp),hl			;09a8	e3 	.
 3056 09A9 E5           	push hl			;09a9	e5 	.
 3057 09AA 2A 23 79     	ld hl,(ACC_SNG+2)	 ; Int,Single,String (2 or 4 bytes): 	;09aa	2a 23 79 	* # y
 3058 09AD E3           	ex (sp),hl			;09ad	e3 	.
 3059 09AE E5           	push hl			;09ae	e5 	.
 3060 09AF EB           	ex de,hl			;09af	eb 	.
 3061 09B0 C9           	ret			;09b0	c9 	.
 3062 09B1
 3063 09B1
 3064 09B1              // ***********************************************************************
 3065 09B1              ; Math : Copy value from (HL) to ACC (Single)
 3066 09B1              MAT_sCopyHLToACC_DBL:
 3067 09B1 CD C2 09     	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;09b1	cd c2 09 	. . .
 3068 09B4
 3069 09B4
 3070 09B4              // ***********************************************************************
 3071 09B4              ; Math : Copy value from BCDE to ACC (Single)
 3072 09B4              ; IN: bc,de - number (single precision)
 3073 09B4              BCDEToACC_DBL:
 3074 09B4 EB           	ex de,hl			; hl - low bytes of BCDE value							;09b4	eb 	.
 3075 09B5 22 21 79     	ld (ACC_SNG),hl	; store as low bytes into ACC (Single)					;09b5	22 21 79 	" ! y
 3076 09B8 60           	ld h,b																		;09b8	60 	`
 3077 09B9 69           	ld l,c				; hl - high bytes of BCDE value 						;09b9	69 	i
 3078 09BA 22 23 79     	ld (ACC_SNG+2),hl	; store as high bytes into ACC	(single)				;09ba	22 23 79 	" # y
 3079 09BD EB           	ex de,hl			; restore hl											;09bd	eb 	.
 3080 09BE C9           	ret					; ---------------- End of Proc ------------------------	;09be	c9 	.
 3081 09BF
 3082 09BF
 3083 09BF              // ***********************************************************************
 3084 09BF              ; Math : Copy value from ACC to BCDE (Single)
 3085 09BF              ACCToBCDE:
 3086 09BF 21 21 79     	ld hl,ACC_SNG		; address of accumulator (ACC)	Single					;09bf	21 21 79 	! ! y
 3087 09C2
 3088 09C2
 3089 09C2              // ***********************************************************************
 3090 09C2              ; Math : Copy value from (HL) to BCDE (Single)
 3091 09C2              HLToBCDE:
 3092 09C2 5E           	ld e,(hl)			; e - low byte of value									;09c2	5e 	^
 3093 09C3 23           	inc hl				; points to next byte									;09c3	23 	#
 3094 09C4              // ***********************************************************************
 3095 09C4              ; Copy 3 bytes from (HL) to BCD
 3096 09C4              HLToBCD:
 3097 09C4 56           	ld d,(hl)			; d - middle byte of value								;09c4	56 	V
 3098 09C5 23           	inc hl				; points to next byte									;09c5	23 	#
 3099 09C6 4E           	ld c,(hl)			; c - high byte of value								;09c6	4e 	N
 3100 09C7 23           	inc hl				; points to next byte									;09c7	23 	#
 3101 09C8 46           	ld b,(hl)			; b - exponent byte of value							;09c8	46 	F
 3102 09C9              inc_hl:
 3103 09C9 23           	inc hl				; points to next byte									;09c9	23 	#
 3104 09CA C9           	ret					; --------------- End of Proc -------------------------	;09ca	c9 	.
 3105 09CB
 3106 09CB
 3107 09CB              // ***********************************************************************
 3108 09CB              ; Math : Copy value from ACC to (HL) (Single)
 3109 09CB              MAT_sCopyACCToHL:
 3110 09CB 11 21 79     	ld de,ACC_SNG		 ; Int,Single,String (2 or 4 bytes): ;09cb	11 21 79 	. ! y
 3111 09CE
 3112 09CE
 3113 09CE              // ***********************************************************************
 3114 09CE              ; Math : Copy value from (DE) to (HL) (Single)
 3115 09CE              MAT_sCopyDEToHL
 3116 09CE 06 04        	ld b,004h		;09ce	06 04 	. .
 3117 09D0 18 05        	jr DEMemToHLMemLen	; Copy value from (DE) to (HL) (b bytes)	;09d0	18 05 	. .
 3118 09D2
 3119 09D2
 3120 09D2
 3121 09D2              // ***********************************************************************
 3122 09D2              ; Math : Copy value from (HL) to (DE) (Any)
 3123 09D2              HLMemToDEMem:
 3124 09D2 EB           	ex de,hl			;09d2	eb 	.
 3125 09D3
 3126 09D3
 3127 09D3              // ***********************************************************************
 3128 09D3              ; Math : Copy value from (DE) to (HL) (Any)
 3129 09D3              DEMemToHLMem:
 3130 09D3 3A AF 78     	ld a,(MATH_NTF)		;09d3	3a af 78 	: . x
 3131 09D6 47           	ld b,a			;09d6	47 	G
 3132 09D7
 3133 09D7
 3134 09D7              // ***********************************************************************
 3135 09D7              ; Math : Copy value from (DE) to (HL) (b bytes)
 3136 09D7              ; IN: de - source address
 3137 09D7              ;     hl - destination address
 3138 09D7              ;     b - number of bytes to copy
 3139 09D7              DEMemToHLMemLen:
 3140 09D7 1A           	ld a,(de)			; a - byte from source									;09d7	1a 	.
 3141 09D8 77           	ld (hl),a			; store to destination									;09d8	77 	w
 3142 09D9 13           	inc de				; increment source pointer								;09d9	13 	.
 3143 09DA 23           	inc hl				; increment destination pointer							;09da	23 	#
 3144 09DB 05           	dec b				; decrement number of bytes to copy - all copied?		;09db	05 	.
 3145 09DC 20 F9        	jr nz,DEMemToHLMemLen	; no - continue copy B bytes						;09dc	20 f9 	  .
 3146 09DE C9           	ret					; ----------------- End of Proc -----------------------	;09de	c9 	.
 3147 09DF
 3148 09DF              // ***********************************************************************
 3149 09DF              ; Math : Compare Sign and Set Sign Bits (ACC and BCDE) (Single)
 3150 09DF              ; Bit 7 of the MSB of both numbers is set (making both numbers negative).
 3151 09DF              ; Then the original Bit 7 (sign) bits of both numbers are compared.
 3152 09DF              ; If both numbers had the same sign on entry (both were positive or both
 3153 09DF              ; were negative) the Z-80 sign flag will be set (M flag set), otherwise
 3154 09DF              ; the sign flag will be reset (P flag condition).
 3155 09DF              MAT_sCmpSetSign:
 3156 09DF 21 23 79     	ld hl,MATH_ACC_MSB		;09df	21 23 79 	! # y
 3157 09E2 7E           	ld a,(hl)			;09e2	7e 	~
 3158 09E3 07           	rlca			;09e3	07 	.
 3159 09E4 37           	scf			;09e4	37 	7
 3160 09E5 1F           	rra			;09e5	1f 	.
 3161 09E6 77           	ld (hl),a			;09e6	77 	w
 3162 09E7 3F           	ccf			;09e7	3f 	?
 3163 09E8 1F           	rra			;09e8	1f 	.
 3164 09E9 23           	inc hl			;09e9	23 	#
 3165 09EA 23           	inc hl			;09ea	23 	#
 3166 09EB 77           	ld (hl),a			;09eb	77 	w
 3167 09EC 79           	ld a,c			;09ec	79 	y
 3168 09ED 07           	rlca			;09ed	07 	.
 3169 09EE 37           	scf			;09ee	37 	7
 3170 09EF 1F           	rra			;09ef	1f 	.
 3171 09F0 4F           	ld c,a			;09f0	4f 	O
 3172 09F1 1F           	rra			;09f1	1f 	.
 3173 09F2 AE           	xor (hl)			;09f2	ae 	.
 3174 09F3 C9           	ret			;09f3	c9 	.
 3175 09F4
 3176 09F4              // ***********************************************************************
 3177 09F4              ; Math : Copy value from ACC2 to ACC (Any)
 3178 09F4              ACC2ToACC_DBL:
 3179 09F4 21 27 79     	ld hl,ACC2		; address of 2nd Accumulator ;09f4	21 27 79 	! ' y
 3180 09F7
 3181 09F7
 3182 09F7              // ***********************************************************************
 3183 09F7              ; Math : Copy value from (HL) to ACC (Any)
 3184 09F7              HLMemToACC_DBL:
 3185 09F7 11 D2 09     	ld de,HLMemToDEMem	; routine - copy Math variable from (hl) to (de)	;09f7	11 d2 09 	. . .
 3186 09FA 18 06        	jr l0a02h		;09fa	18 06 	. .
 3187 09FC
 3188 09FC
 3189 09FC              // ***********************************************************************
 3190 09FC              ; Math : Copy value from ACC to ACC2 (Any)
 3191 09FC              anyACCcopyToACC2:
 3192 09FC 21 27 79     	ld hl,ACC2		; address of 2nd Accumulator ;09fc	21 27 79 	! ' y
 3193 09FF
 3194 09FF
 3195 09FF              // ***********************************************************************
 3196 09FF              ; Math : Copy value from ACC to (HL) (Any)
 3197 09FF              ACCToHLMem
 3198 09FF 11 D3 09     	ld de,DEMemToHLMem	; routine - copy math variable from (de) to (hl) mem	;09ff	11 d3 09 	. . .
 3199 0A02              l0a02h:
 3200 0A02 D5           	push de			;0a02	d5 	.
 3201 0A03              GetACCMSBPtr:
 3202 0A03 11 21 79     	ld de,ACC_SNG	; start of ACC bytes when Single, Integer or String 		;0a03	11 21 79 	. ! y
 3203 0A06 E7           	rst #20			; test NTF - is it Single, Integer or String				;0a06	e7 	.
 3204 0A07 D8           	ret c			; yes - ----------- End of Proc (de = start)				;0a07	d8 	.
 3205 0A08 11 1D 79     	ld de,ACC_DBL	; start of ACC bytes when Double  							;0a08	11 1d 79 	. . y
 3206 0A0B C9           	ret				; ----------------- End of Proc (de = start)				;0a0b	c9 	.
 3207 0A0C
 3208 0A0C              // ***********************************************************************
 3209 0A0C              ; Math : Compare ACC and BCDE (Single)
 3210 0A0C              MAT_sCmp_ACC_BCDE:
 3211 0A0C 78           	ld a,b			;0a0c	78 	x
 3212 0A0D B7           	or a			;0a0d	b7 	.
 3213 0A0E CA 55 09     	jp z,sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0a0e	ca 55 09 	. U .
 3214 0A11 21 5E 09     	ld hl,0095eh		;0a11	21 5e 09 	! ^ .
 3215 0A14 E5           	push hl			;0a14	e5 	.
 3216 0A15 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0a15	cd 55 09 	. U .
 3217 0A18 79           	ld a,c			;0a18	79 	y
 3218 0A19 C8           	ret z			;0a19	c8 	.
 3219 0A1A 21 23 79     	ld hl,ACC_SNG+2	 ; Int,Single,String (2 or 4 bytes): 	;0a1a	21 23 79 	! # y
 3220 0A1D AE           	xor (hl)			;0a1d	ae 	.
 3221 0A1E 79           	ld a,c			;0a1e	79 	y
 3222 0A1F F8           	ret m			;0a1f	f8 	.
 3223 0A20 CD 26 0A     	call sub_0a26h		;0a20	cd 26 0a 	. & .
 3224 0A23              l0a23h:
 3225 0A23 1F           	rra			;0a23	1f 	.
 3226 0A24 A9           	xor c			;0a24	a9 	.
 3227 0A25 C9           	ret			;0a25	c9 	.
 3228 0A26              sub_0a26h:
 3229 0A26 23           	inc hl			;0a26	23 	#
 3230 0A27 78           	ld a,b			;0a27	78 	x
 3231 0A28 BE           	cp (hl)			;0a28	be 	.
 3232 0A29 C0           	ret nz			;0a29	c0 	.
 3233 0A2A 2B           	dec hl			;0a2a	2b 	+
 3234 0A2B 79           	ld a,c			;0a2b	79 	y
 3235 0A2C BE           	cp (hl)			;0a2c	be 	.
 3236 0A2D C0           	ret nz			;0a2d	c0 	.
 3237 0A2E 2B           	dec hl			;0a2e	2b 	+
 3238 0A2F 7A           	ld a,d			;0a2f	7a 	z
 3239 0A30 BE           	cp (hl)			;0a30	be 	.
 3240 0A31 C0           	ret nz			;0a31	c0 	.
 3241 0A32 2B           	dec hl			;0a32	2b 	+
 3242 0A33 7B           	ld a,e			;0a33	7b 	{
 3243 0A34 96           	sub (hl)			;0a34	96 	.
 3244 0A35 C0           	ret nz			;0a35	c0 	.
 3245 0A36 E1           	pop hl			;0a36	e1 	.
 3246 0A37 E1           	pop hl			;0a37	e1 	.
 3247 0A38 C9           	ret			;0a38	c9 	.
 3248 0A39
 3249 0A39
 3250 0A39              // ***********************************************************************
 3251 0A39              ; Math : Compare HL and DE (Integer)
 3252 0A39              MAT_iCmp_HL_DE:
 3253 0A39 7A           	ld a,d			;0a39	7a 	z
 3254 0A3A AC           	xor h			;0a3a	ac 	.
 3255 0A3B 7C           	ld a,h			;0a3b	7c 	|
 3256 0A3C FA 5F 09     	jp m,SignBitToRegA		;0a3c	fa 5f 09 	. _ .
 3257 0A3F BA           	cp d			;0a3f	ba 	.
 3258 0A40 C2 60 09     	jp nz,CarryToRegA	; return with A=1 if a>d or A=-1 if a<d	        ;0a40	c2 60 09 	. ` .
 3259 0A43              ; -- compare low bytes of HL and DE
 3260 0A43 7D           	ld a,l			    ; a - low bytes of HL                               ;0a43	7d 	}
 3261 0A44 93           	sub e			    ; subtract low byte of DE                           ;0a44	93 	.
 3262 0A45 C2 60 09     	jp nz,CarryToRegA	; return with A=1 if a>e or A=-1 if a<e		    ;0a45	c2 60 09 	. ` .
 3263 0A48 C9           	ret			        ; -------- End of Proc (A=0) ------------------ ;0a48	c9 	.
 3264 0A49
 3265 0A49
 3266 0A49              // ***********************************************************************
 3267 0A49              ; Math : Compare ACC and (DE) (Double)
 3268 0A49              ACCCmpDEMem:
 3269 0A49 21 27 79     	ld hl,ACC2		; address of 2nd Accumulator ;0a49	21 27 79 	! ' y
 3270 0A4C CD D3 09     	call DEMemToHLMem	; copy math variable from (de) to ACC2		;0a4c	cd d3 09 	. . .
 3271 0A4F
 3272 0A4F
 3273 0A4F              // ***********************************************************************
 3274 0A4F              ; Math : Compare ACC and ACC2 (Double)
 3275 0A4F              ACCCmpACC2:
 3276 0A4F 11 2E 79     	ld de,MATH_ACC2_EXP		;0a4f	11 2e 79 	. . y
 3277 0A52 1A           	ld a,(de)			;0a52	1a 	.
 3278 0A53 B7           	or a			;0a53	b7 	.
 3279 0A54 CA 55 09     	jp z,sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0a54	ca 55 09 	. U .
 3280 0A57 21 5E 09     	ld hl,0095eh		;0a57	21 5e 09 	! ^ .
 3281 0A5A E5           	push hl			;0a5a	e5 	.
 3282 0A5B CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0a5b	cd 55 09 	. U .
 3283 0A5E 1B           	dec de			;0a5e	1b 	.
 3284 0A5F 1A           	ld a,(de)			;0a5f	1a 	.
 3285 0A60 4F           	ld c,a			;0a60	4f 	O
 3286 0A61 C8           	ret z			;0a61	c8 	.
 3287 0A62 21 23 79     	ld hl,ACC_SNG+2	 ; Int,Single,String (2 or 4 bytes): 	;0a62	21 23 79 	! # y
 3288 0A65 AE           	xor (hl)			;0a65	ae 	.
 3289 0A66 79           	ld a,c			;0a66	79 	y
 3290 0A67 F8           	ret m			;0a67	f8 	.
 3291 0A68 13           	inc de			;0a68	13 	.
 3292 0A69 23           	inc hl			;0a69	23 	#
 3293 0A6A 06 08        	ld b,008h		;0a6a	06 08 	. .
 3294 0A6C              l0a6ch:
 3295 0A6C 1A           	ld a,(de)			;0a6c	1a 	.
 3296 0A6D 96           	sub (hl)			;0a6d	96 	.
 3297 0A6E C2 23 0A     	jp nz,l0a23h		;0a6e	c2 23 0a 	. # .
 3298 0A71 1B           	dec de			;0a71	1b 	.
 3299 0A72 2B           	dec hl			;0a72	2b 	+
 3300 0A73 05           	dec b			;0a73	05 	.
 3301 0A74 20 F6        	jr nz,l0a6ch		;0a74	20 f6 	  .
 3302 0A76 C1           	pop bc			;0a76	c1 	.
 3303 0A77 C9           	ret			;0a77	c9 	.
 3304 0A78
 3305 0A78
 3306 0A78              // ***********************************************************************
 3307 0A78              ; Math : Compare ACC2 and ACC (Double)
 3308 0A78              MAT_dCmp_ACC2_ACC_DBL:
 3309 0A78 CD 4F 0A     	call ACCCmpACC2	;  Compare ACC and ACC2 (Double)	;0a78	cd 4f 0a 	. O .
 3310 0A7B C2 5E 09     	jp nz,0095eh		;0a7b	c2 5e 09 	. ^ .
 3311 0A7E C9           	ret			;0a7e	c9 	.
 3312 0A7F
 3313 0A7F
 3314 0A7F              ; ********************************************************************************
 3315 0A7F              ; [TRS] BASIC CINT Entry Point
 3316 0A7F              FuncCINT:
 3317 0A7F E7           	rst #20				; test NTF - check if ACC contains Integer type 		;0a7f	e7 	.
 3318 0A80 2A 21 79     	ld hl,(ACC_SNG)	; load 2 bytes as Integer value 						;0a80	2a 21 79 	* ! y
 3319 0A83              ; -- fags are set: M - Integer, Z - String, NC - Double
 3320 0A83 F8           	ret m				; Integer ----------------- End of Proc ---------------	;0a83	f8 	.
 3321 0A84 CA F6 0A     	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;0a84	ca f6 0a 	. . .
 3322 0A87 D4 B9 0A     	call nc,DblToSng	; Double - Convert from Double to Single 				;0a87	d4 b9 0a 	. . .
 3323 0A8A
 3324 0A8A              ; Convert from Single to Integer (ACC) (result also in HL)
 3325 0A8A 21 B2 07     	ld hl,ErrRaiseOverflow	; Raise OVERFLOW Error routine						;0a8a	21 b2 07 	! . .
 3326 0A8D E5           	push hl				; set as return address									;0a8d	e5 	.
 3327 0A8E              sub_0a8eh:
 3328 0A8E 3A 24 79     	ld a,(MATH_ACC_EXP)	; exponent part of number								;0a8e	3a 24 79 	: $ y
 3329 0A91 FE 90        	cp $90				; is it in range (-512..512) - exp < $90 				;0a91	fe 90 	. .
 3330 0A93 30 0E        	jr nc,l0aa3h		; no - ;0a93	30 0e 	0 .
 3331 0A95 CD FB 0A     	call sub_0afbh		;0a95	cd fb 0a 	. . .
 3332 0A98 EB           	ex de,hl			;0a98	eb 	.
 3333 0A99              l0a99h:
 3334 0A99 D1           	pop de			;0a99	d1 	.
 3335 0A9A
 3336 0A9A              // ***********************************************************************
 3337 0A9A              ; Math : Copy value from HL to ACC (Integer)
 3338 0A9A              ; Routine sets NTF to 2 (Integer)
 3339 0A9A              ACCfromHLValue:
 3340 0A9A 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;0a9a	22 21 79 	" ! y
 3341 0A9D
 3342 0A9D
 3343 0A9D              ; ********************************************************************************
 3344 0A9D              ; Math : Set NTF to Integer (ACC)
 3345 0A9D              SetNTFInt
 3346 0A9D 3E 02        	ld a,2		; Number Type Integer							;0a9d	3e 02 	> .
 3347 0A9F              SetNTF:
 3348 0A9F 32 AF 78     	ld (MATH_NTF),a		;0a9f	32 af 78 	2 . x
 3349 0AA2 C9           	ret			;0aa2	c9 	.
 3350 0AA3              l0aa3h:
 3351 0AA3 01 80 90     	ld bc,$9080		;0aa3	01 80 90 	. . .
 3352 0AA6 11 00 00     	ld de,$0000		; BCDE = -32768 (minimum 16bit integer value)	;0aa6	11 00 00 	. . .
 3353 0AA9 CD 0C 0A     	call MAT_sCmp_ACC_BCDE	; Compare ACC and BCDE (Single)	;0aa9	cd 0c 0a 	. . .
 3354 0AAC C0           	ret nz			;0aac	c0 	.
 3355 0AAD 61           	ld h,c			;0aad	61 	a
 3356 0AAE 6A           	ld l,d			;0aae	6a 	j
 3357 0AAF 18 E8        	jr l0a99h		;0aaf	18 e8 	. .
 3358 0AB1
 3359 0AB1              ; ********************************************************************************
 3360 0AB1              ; [TRS] BASIC CSNG Entry Point
 3361 0AB1              FuncCSNG:
 3362 0AB1 E7           	rst #20			; test NTF (Number Type Format) 							;0ab1	e7 	.
 3363 0AB2 E0           	ret po			; Single ----------- End of Proc --------------------------	;0ab2	e0 	.
 3364 0AB3 FA CC 0A     	jp m,MAT_iConvToSng	; Integer - Convert from Integer to Single (ACC)		;0ab3	fa cc 0a 	. . .
 3365 0AB6 CA F6 0A     	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;0ab6	ca f6 0a 	. . .
 3366 0AB9              ; -- Double
 3367 0AB9              ; ********************************************************************************
 3368 0AB9              ; Math : Convert from Double to Single (ACC)
 3369 0AB9              DblToSng:
 3370 0AB9 CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (High part of Double)			;0ab9	cd bf 09 	. . .
 3371 0ABC CD EF 0A     	call SetNTFToSng; set Number Type Flag to Single 							;0abc	cd ef 0a 	. . .
 3372 0ABF 78           	ld a,b			;0abf	78 	x
 3373 0AC0 B7           	or a			;0ac0	b7 	.
 3374 0AC1 C8           	ret z			;0ac1	c8 	.
 3375 0AC2 CD DF 09     	call MAT_sCmpSetSign		;0ac2	cd df 09 	. . .
 3376 0AC5 21 20 79     	ld hl,07920h		;0ac5	21 20 79 	!   y
 3377 0AC8 46           	ld b,(hl)			;0ac8	46 	F
 3378 0AC9 C3 96 07     	jp l0796h		;0ac9	c3 96 07 	. . .
 3379 0ACC
 3380 0ACC
 3381 0ACC              ; ********************************************************************************
 3382 0ACC              ; Math : Convert from Integer to Single (ACC)
 3383 0ACC              MAT_iConvToSng:
 3384 0ACC 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;0acc	2a 21 79 	* ! y
 3385 0ACF
 3386 0ACF              ; ********************************************************************************
 3387 0ACF              ; Math : Convert from Integer (HL) to Single (ACC)
 3388 0ACF              MAT_iConvToSngHL:
 3389 0ACF CD EF 0A     	call SetNTFToSng		;0acf	cd ef 0a 	. . .
 3390 0AD2 7C           	ld a,h			;0ad2	7c 	|
 3391 0AD3 55           	ld d,l			;0ad3	55 	U
 3392 0AD4 1E 00        	ld e,000h		;0ad4	1e 00 	. .
 3393 0AD6 06 90        	ld b,090h		;0ad6	06 90 	. .
 3394 0AD8 C3 69 09     	jp l0969h		;0ad8	c3 69 09 	. i .
 3395 0ADB
 3396 0ADB              ; ********************************************************************************
 3397 0ADB              ; [TRS] BASIC CDBL Entry Point
 3398 0ADB              FuncCDBL:
 3399 0ADB E7           	rst #20			; test NTF (Number Type Flag)								;0adb	e7 	.
 3400 0ADC D0           	ret nc			; Double ------------ End of Proc -------------------------	;0adc	d0 	.
 3401 0ADD CA F6 0A     	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;0add	ca f6 0a 	. . .
 3402 0AE0 FC CC 0A     	call m,MAT_iConvToSng	; Integer - Convert from Integer to Single (ACC)	;0ae0	fc cc 0a 	. . .
 3403 0AE3              ; -- now it's Single - convert it to Double
 3404 0AE3
 3405 0AE3              ; ********************************************************************************
 3406 0AE3              ; Math : Convert ACC from Single to Double
 3407 0AE3              sngACCconvToDbl:
 3408 0AE3 21 00 00     	ld hl,$0000		; extra precision bytes of Double value 					;0ae3	21 00 00 	! . .
 3409 0AE6 22 1D 79     	ld (ACC_DBL),hl		; store into Accumulator 									;0ae6	22 1d 79 	" . y
 3410 0AE9 22 1F 79     	ld (ACC_DBL+2),hl	; store into Accumulator									;0ae9	22 1f 79 	" . y
 3411 0AEC              ; -- extra digits set to zero - mark ACC as Double value
 3412 0AEC
 3413 0AEC              ; ********************************************************************************
 3414 0AEC              ; Math : Set NTF to Double (ACC)
 3415 0AEC              SetNTFDbl:
 3416 0AEC 3E 08        	ld a,8			; Number Type Double 										;0aec	3e 08 	> .
 3417 0AEE 01           	db $01			; trick byte - with next constructs irrevelant ld bc,l043eh	;0aee	01 3e 04 	. > .
 3418 0AEF              SetNTFToSng
 3419 0AEF 3E 04        	ld a,4			; Number Type Single										;0aef	3e 04 	. > .
 3420 0AF1 C3 9F 0A     	jp SetNTF		; set NTF to 4 (Single)										;0af1	c3 9f 0a 	. . .
 3421 0AF4
 3422 0AF4              ; ********************************************************************************
 3423 0AF4              ; String : Assert ACC contains String
 3424 0AF4              AssertACCIsString:
 3425 0AF4 E7           	rst #20			; test NTF (Number Type Format) is it String				;0af4	e7 	.
 3426 0AF5 C8           	ret z			; String ----------------- End of Proc -------------------- ;0af5	c8 	.
 3427 0AF6              ; -- ACC is not String - raise error
 3428 0AF6              ErrRaiseTypeMismatch:
 3429 0AF6 1E 18        	ld e,#18		; ERROR 18 - TYPE MISMATCH									;0af6	1e 18 	. .
 3430 0AF8 C3 A2 19     	jp ErrRaiseError; Raise TYPE MISMATCH Error	-------------------------------	;0af8	c3 a2 19 	. . .
 3431 0AFB              sub_0afbh:
 3432 0AFB 47           	ld b,a			;0afb	47 	G
 3433 0AFC 4F           	ld c,a			;0afc	4f 	O
 3434 0AFD 57           	ld d,a			;0afd	57 	W
 3435 0AFE 5F           	ld e,a			;0afe	5f 	_
 3436 0AFF B7           	or a			;0aff	b7 	.
 3437 0B00 C8           	ret z			;0b00	c8 	.
 3438 0B01 E5           	push hl			;0b01	e5 	.
 3439 0B02 CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;0b02	cd bf 09 	. . .
 3440 0B05 CD DF 09     	call MAT_sCmpSetSign		;0b05	cd df 09 	. . .
 3441 0B08 AE           	xor (hl)			;0b08	ae 	.
 3442 0B09 67           	ld h,a			;0b09	67 	g
 3443 0B0A FC 1F 0B     	call m,sub_0b1fh		;0b0a	fc 1f 0b 	. . .
 3444 0B0D 3E 98        	ld a,098h		;0b0d	3e 98 	> .
 3445 0B0F 90           	sub b			;0b0f	90 	.
 3446 0B10 CD D7 07     	call sub_07d7h		;0b10	cd d7 07 	. . .
 3447 0B13 7C           	ld a,h			;0b13	7c 	|
 3448 0B14 17           	rla			;0b14	17 	.
 3449 0B15 DC A8 07     	call c,sub_07a8h		;0b15	dc a8 07 	. . .
 3450 0B18 06 00        	ld b,000h		;0b18	06 00 	. .
 3451 0B1A DC C3 07     	call c,sub_07c3h		;0b1a	dc c3 07 	. . .
 3452 0B1D E1           	pop hl			;0b1d	e1 	.
 3453 0B1E C9           	ret			;0b1e	c9 	.
 3454 0B1F              sub_0b1fh:
 3455 0B1F 1B           	dec de			;0b1f	1b 	.
 3456 0B20 7A           	ld a,d			;0b20	7a 	z
 3457 0B21 A3           	and e			;0b21	a3 	.
 3458 0B22 3C           	inc a			;0b22	3c 	<
 3459 0B23 C0           	ret nz			;0b23	c0 	.
 3460 0B24              sub_0b24h:
 3461 0B24 0B           	dec bc			;0b24	0b 	.
 3462 0B25 C9           	ret			;0b25	c9 	.
 3463 0B26
 3464 0B26
 3465 0B26              ; ********************************************************************************
 3466 0B26              ; [TRS] BASIC FIX Entry Point
 3467 0B26              ; Math : ACC = FIX(ACC) (Any)
 3468 0B26              ; IN: hl - current executed command parser
 3469 0B26              ;     a - command byte
 3470 0B26              ;     Z = 1 - end of statement ('\0' or ':' found)
 3471 0B26              ;     CY = 1 - char is digit
 3472 0B26              FuncFIX
 3473 0B26 E7           	rst #20			; test NTF (Number Type Format) 							;0b26	e7 	.
 3474 0B27 F8           	ret m			; Integer --------------- End of Proc ---------------------	;0b27	f8 	.
 3475 0B28 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0b28	cd 55 09 	. U .
 3476 0B2B F2 37 0B     	jp p,FuncINT		; positive number - convert ACC to Integer type			;0b2b	f2 37 0b 	. 7 .
 3477 0B2E              ; -- number is negative - invert sign and then convert to Integer
 3478 0B2E CD 82 09     	call sngACCnegate	;  ACC = -ACC (Single) 									;0b2e	cd 82 09 	. . .
 3479 0B31 CD 37 0B     	call FuncINT		; convert ACC to Integer type							;0b31	cd 37 0b 	. 7 .
 3480 0B34 C3 7B 09     	jp l097bh		;0b34	c3 7b 09 	. { .
 3481 0B37
 3482 0B37              ; ********************************************************************************
 3483 0B37              ; [TRS] BASIC INT Entry Point
 3484 0B37              FuncINT:
 3485 0B37 E7           	rst #20			; test NTF (Number Type Format)								;0b37	e7 	.
 3486 0B38 F8           	ret m			; Integer - ------------- End of Proc ---------------------	;0b38	f8 	.
 3487 0B39 30 1E        	jr nc,MAT_dInt_ACC_DBL	; Double - truncate to Integer [ACC = INT(ACC)]	-------	;0b39	30 1e 	0 .
 3488 0B3B 28 B9        	jr z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error ----------	;0b3b	28 b9 	( .
 3489 0B3D              ; -- ACC is Single - truncate to Integer
 3490 0B3D
 3491 0B3D              ; ********************************************************************************
 3492 0B3D              ; Math : ACC = INT(ACC) (Single)
 3493 0B3D              MAT_sInt_ACC_DBL:
 3494 0B3D CD 8E 0A     	call sub_0a8eh	; convert Double to Single	;0b3d	cd 8e 0a 	. . .
 3495 0B40              sub_0b40h:
 3496 0B40 21 24 79     	ld hl,MATH_ACC_EXP		;0b40	21 24 79 	! $ y
 3497 0B43 7E           	ld a,(hl)			;0b43	7e 	~
 3498 0B44 FE 98        	cp 098h		;0b44	fe 98 	. .
 3499 0B46 3A 21 79     	ld a,(ACC_SNG)		 ; Int,Single,String (2 or 4 bytes): ;0b46	3a 21 79 	: ! y
 3500 0B49 D0           	ret nc			;0b49	d0 	.
 3501 0B4A 7E           	ld a,(hl)			;0b4a	7e 	~
 3502 0B4B CD FB 0A     	call sub_0afbh		;0b4b	cd fb 0a 	. . .
 3503 0B4E 36 98        	ld (hl),098h		;0b4e	36 98 	6 .
 3504 0B50 7B           	ld a,e			;0b50	7b 	{
 3505 0B51 F5           	push af			;0b51	f5 	.
 3506 0B52 79           	ld a,c			;0b52	79 	y
 3507 0B53 17           	rla			;0b53	17 	.
 3508 0B54 CD 62 07     	call l0762h		;0b54	cd 62 07 	. b .
 3509 0B57 F1           	pop af			;0b57	f1 	.
 3510 0B58 C9           	ret			;0b58	c9 	.
 3511 0B59
 3512 0B59              ; ********************************************************************************
 3513 0B59              ; Math : ACC = INT(ACC) (Double)
 3514 0B59              MAT_dInt_ACC_DBL:
 3515 0B59 21 24 79     	ld hl,MATH_ACC_EXP		;0b59	21 24 79 	! $ y
 3516 0B5C 7E           	ld a,(hl)			;0b5c	7e 	~
 3517 0B5D FE 90        	cp 090h		;0b5d	fe 90 	. .
 3518 0B5F DA 7F 0A     	jp c,FuncCINT		; convert ACC to integer	;0b5f	da 7f 0a 	.  .
 3519 0B62 20 14        	jr nz,l0b78h		;0b62	20 14 	  .
 3520 0B64 4F           	ld c,a			;0b64	4f 	O
 3521 0B65 2B           	dec hl			;0b65	2b 	+
 3522 0B66 7E           	ld a,(hl)			;0b66	7e 	~
 3523 0B67 EE 80        	xor 080h		;0b67	ee 80 	. .
 3524 0B69 06 06        	ld b,006h		;0b69	06 06 	. .
 3525 0B6B              l0b6bh:
 3526 0B6B 2B           	dec hl			;0b6b	2b 	+
 3527 0B6C B6           	or (hl)			;0b6c	b6 	.
 3528 0B6D 05           	dec b			;0b6d	05 	.
 3529 0B6E 20 FB        	jr nz,l0b6bh		;0b6e	20 fb 	  .
 3530 0B70 B7           	or a			;0b70	b7 	.
 3531 0B71 21 00 80     	ld hl,$8000		; hl = -32768 (max negative 16bit value)                ;0b71	21 00 80 	! . .
 3532 0B74 CA 9A 0A     	jp z,ACCfromHLValue	; copy value from hl to ACC as integer number		;0b74	ca 9a 0a 	. . .
 3533 0B77 79           	ld a,c			;0b77	79 	y
 3534 0B78              l0b78h:
 3535 0B78 FE B8        	cp 0b8h		;0b78	fe b8 	. .
 3536 0B7A D0           	ret nc			;0b7a	d0 	.
 3537 0B7B              sub_0b7bh:
 3538 0B7B F5           	push af			;0b7b	f5 	.
 3539 0B7C CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;0b7c	cd bf 09 	. . .
 3540 0B7F CD DF 09     	call MAT_sCmpSetSign		;0b7f	cd df 09 	. . .
 3541 0B82 AE           	xor (hl)			;0b82	ae 	.
 3542 0B83 2B           	dec hl			;0b83	2b 	+
 3543 0B84 36 B8        	ld (hl),0b8h		;0b84	36 b8 	6 .
 3544 0B86 F5           	push af			;0b86	f5 	.
 3545 0B87 FC A0 0B     	call m,sub_0ba0h		;0b87	fc a0 0b 	. . .
 3546 0B8A 21 23 79     	ld hl,ACC_SNG+2		 ; Int,Single,String (2 or 4 bytes): ;0b8a	21 23 79 	! # y
 3547 0B8D 3E B8        	ld a,0b8h		;0b8d	3e b8 	> .
 3548 0B8F 90           	sub b			;0b8f	90 	.
 3549 0B90 CD 69 0D     	call sub_0d69h		;0b90	cd 69 0d 	. i .
 3550 0B93 F1           	pop af			;0b93	f1 	.
 3551 0B94 FC 20 0D     	call m,sub_0d20h		;0b94	fc 20 0d 	.   .
 3552 0B97 AF           	xor a			;0b97	af 	.
 3553 0B98 32 1C 79     	ld (MATH_ACC_CY),a		;0b98	32 1c 79 	2 . y
 3554 0B9B F1           	pop af			;0b9b	f1 	.
 3555 0B9C D0           	ret nc			;0b9c	d0 	.
 3556 0B9D C3 D8 0C     	jp l0cd8h		;0b9d	c3 d8 0c 	. . .
 3557 0BA0              sub_0ba0h:
 3558 0BA0 21 1D 79     	ld hl,ACC_DBL	; addres of Accumulator (Double) ;0ba0	21 1d 79 	! . y
 3559 0BA3              l0ba3h:
 3560 0BA3 7E           	ld a,(hl)			;0ba3	7e 	~
 3561 0BA4 35           	dec (hl)			;0ba4	35 	5
 3562 0BA5 B7           	or a			;0ba5	b7 	.
 3563 0BA6 23           	inc hl			;0ba6	23 	#
 3564 0BA7 28 FA        	jr z,l0ba3h		;0ba7	28 fa 	( .
 3565 0BA9 C9           	ret			;0ba9	c9 	.
 3566 0BAA
 3567 0BAA
 3568 0BAA              // ***********************************************************************
 3569 0BAA              ; Math : DE = BC * DE (Unsigned Integer)
 3570 0BAA              MAT_iMul_BC_DE:
 3571 0BAA E5           	push hl			;0baa	e5 	.
 3572 0BAB 21 00 00     	ld hl,$0000		;0bab	21 00 00 	! . .
 3573 0BAE 78           	ld a,b			;0bae	78 	x
 3574 0BAF B1           	or c			;0baf	b1 	.
 3575 0BB0 28 12        	jr z,l0bc4h		;0bb0	28 12 	( .
 3576 0BB2 3E 10        	ld a,010h		;0bb2	3e 10 	> .
 3577 0BB4              l0bb4h:
 3578 0BB4 29           	add hl,hl			;0bb4	29 	)
 3579 0BB5 DA 3D 27     	jp c,ErrRaiseBadSubscript	; raise BAD SUBSCRIPT ERROR		;0bb5	da 3d 27 	. = '
 3580 0BB8 EB           	ex de,hl			;0bb8	eb 	.
 3581 0BB9 29           	add hl,hl			;0bb9	29 	)
 3582 0BBA EB           	ex de,hl			;0bba	eb 	.
 3583 0BBB 30 04        	jr nc,l0bc1h		;0bbb	30 04 	0 .
 3584 0BBD 09           	add hl,bc			;0bbd	09 	.
 3585 0BBE DA 3D 27     	jp c,ErrRaiseBadSubscript	; raise BAD SUBSCRIPT ERROR		;0bbe	da 3d 27 	. = '
 3586 0BC1              l0bc1h:
 3587 0BC1 3D           	dec a			;0bc1	3d 	=
 3588 0BC2 20 F0        	jr nz,l0bb4h		;0bc2	20 f0 	  .
 3589 0BC4              l0bc4h:
 3590 0BC4 EB           	ex de,hl			;0bc4	eb 	.
 3591 0BC5 E1           	pop hl			;0bc5	e1 	.
 3592 0BC6 C9           	ret			;0bc6	c9 	.
 3593 0BC7
 3594 0BC7
 3595 0BC7
 3596 0BC7              // ***********************************************************************
 3597 0BC7              ; Math : ACC = DE - HL (Integer)
 3598 0BC7              MAT_iSub_DEHL
 3599 0BC7 7C           	ld a,h			;0bc7	7c 	|
 3600 0BC8 17           	rla			;0bc8	17 	.
 3601 0BC9 9F           	sbc a,a			;0bc9	9f 	.
 3602 0BCA 47           	ld b,a			;0bca	47 	G
 3603 0BCB CD 51 0C     	call sub_0c51h		;0bcb	cd 51 0c 	. Q .
 3604 0BCE 79           	ld a,c			;0bce	79 	y
 3605 0BCF 98           	sbc a,b			;0bcf	98 	.
 3606 0BD0 18 03        	jr l0bd5h		;0bd0	18 03 	. .
 3607 0BD2
 3608 0BD2              // ***********************************************************************
 3609 0BD2              ; Math : ACC = DE + HL (Integer)
 3610 0BD2              MAT_iAdd_DEHL:
 3611 0BD2 7C           	ld a,h			;0bd2	7c 	|
 3612 0BD3 17           	rla			;0bd3	17 	.
 3613 0BD4 9F           	sbc a,a			;0bd4	9f 	.
 3614 0BD5              l0bd5h:
 3615 0BD5 47           	ld b,a			;0bd5	47 	G
 3616 0BD6 E5           	push hl			;0bd6	e5 	.
 3617 0BD7 7A           	ld a,d			;0bd7	7a 	z
 3618 0BD8 17           	rla			;0bd8	17 	.
 3619 0BD9 9F           	sbc a,a			;0bd9	9f 	.
 3620 0BDA 19           	add hl,de			;0bda	19 	.
 3621 0BDB 88           	adc a,b			;0bdb	88 	.
 3622 0BDC 0F           	rrca			;0bdc	0f 	.
 3623 0BDD AC           	xor h			;0bdd	ac 	.
 3624 0BDE F2 99 0A     	jp p,l0a99h		;0bde	f2 99 0a 	. . .
 3625 0BE1 C5           	push bc			;0be1	c5 	.
 3626 0BE2 EB           	ex de,hl			;0be2	eb 	.
 3627 0BE3 CD CF 0A     	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)	;0be3	cd cf 0a 	. . .
 3628 0BE6 F1           	pop af			;0be6	f1 	.
 3629 0BE7 E1           	pop hl			;0be7	e1 	.
 3630 0BE8 CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;0be8	cd a4 09 	. . .
 3631 0BEB EB           	ex de,hl			;0beb	eb 	.
 3632 0BEC CD 6B 0C     	call sub_0c6bh		;0bec	cd 6b 0c 	. k .
 3633 0BEF C3 8F 0F     	jp l0f8fh		;0bef	c3 8f 0f 	. . .
 3634 0BF2
 3635 0BF2
 3636 0BF2              // ***********************************************************************
 3637 0BF2              ; Math : ACC = DE * HL (Integer)
 3638 0BF2              MAT_iMul_DEHL
 3639 0BF2 7C           	ld a,h			;0bf2	7c 	|
 3640 0BF3 B5           	or l			;0bf3	b5 	.
 3641 0BF4 CA 9A 0A     	jp z,ACCfromHLValue	; copy value from hl to ACC as integer number		;0bf4	ca 9a 0a 	. . .
 3642 0BF7 E5           	push hl			;0bf7	e5 	.
 3643 0BF8 D5           	push de			;0bf8	d5 	.
 3644 0BF9 CD 45 0C     	call sub_0c45h		;0bf9	cd 45 0c 	. E .
 3645 0BFC C5           	push bc			;0bfc	c5 	.
 3646 0BFD 44           	ld b,h			;0bfd	44 	D
 3647 0BFE 4D           	ld c,l			;0bfe	4d 	M
 3648 0BFF 21 00 00     	ld hl,$0000		;0bff	21 00 00 	! . .
 3649 0C02 3E 10        	ld a,010h		;0c02	3e 10 	> .
 3650 0C04              l0c04h:
 3651 0C04 29           	add hl,hl			;0c04	29 	)
 3652 0C05 38 1F        	jr c,$+33		;0c05	38 1f 	8 .
 3653 0C07 EB           	ex de,hl			;0c07	eb 	.
 3654 0C08 29           	add hl,hl			;0c08	29 	)
 3655 0C09 EB           	ex de,hl			;0c09	eb 	.
 3656 0C0A 30 04        	jr nc,l0c10h		;0c0a	30 04 	0 .
 3657 0C0C 09           	add hl,bc			;0c0c	09 	.
 3658 0C0D DA 26 0C     	jp c,00c26h		;0c0d	da 26 0c 	. & .
 3659 0C10              l0c10h:
 3660 0C10 3D           	dec a			;0c10	3d 	=
 3661 0C11 20 F1        	jr nz,l0c04h		;0c11	20 f1 	  .
 3662 0C13 C1           	pop bc			;0c13	c1 	.
 3663 0C14 D1           	pop de			;0c14	d1 	.
 3664 0C15 7C           	ld a,h			;0c15	7c 	|
 3665 0C16 B7           	or a			;0c16	b7 	.
 3666 0C17 FA 1F 0C     	jp m,l0c1fh		;0c17	fa 1f 0c 	. . .
 3667 0C1A D1           	pop de			;0c1a	d1 	.
 3668 0C1B 78           	ld a,b			;0c1b	78 	x
 3669 0C1C C3 4D 0C     	jp l0c4dh		;0c1c	c3 4d 0c 	. M .
 3670 0C1F              l0c1fh:
 3671 0C1F EE 80        	xor 080h		;0c1f	ee 80 	. .
 3672 0C21 B5           	or l			;0c21	b5 	.
 3673 0C22 28 13        	jr z,l0c37h		;0c22	28 13 	( .
 3674 0C24 EB           	ex de,hl			;0c24	eb 	.
 3675 0C25 01 C1 E1     	ld bc,0e1c1h		;0c25	01 c1 e1 	. . .
 3676 0C28 CD CF 0A     	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;0c28	cd cf 0a 	. . .
 3677 0C2B E1           	pop hl			;0c2b	e1 	.
 3678 0C2C CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;0c2c	cd a4 09 	. . .
 3679 0C2F CD CF 0A     	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;0c2f	cd cf 0a 	. . .
 3680 0C32
 3681 0C32              ; ********************************************************************************
 3682 0C32              ; Math : ACC = (SP) * ACC (Single)
 3683 0C32              sngSPOPmulACC_DBL:
 3684 0C32 C1           	pop bc			;0c32	c1 	.
 3685 0C33 D1           	pop de			;0c33	d1 	.
 3686 0C34 C3 47 08     	jp sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;0c34	c3 47 08 	. G .
 3687 0C37              l0c37h:
 3688 0C37 78           	ld a,b			;0c37	78 	x
 3689 0C38 B7           	or a			;0c38	b7 	.
 3690 0C39 C1           	pop bc			;0c39	c1 	.
 3691 0C3A FA 9A 0A     	jp m,ACCfromHLValue	; copy value from hl to ACC as integer number		;0c3a	fa 9a 0a 	. . .
 3692 0C3D D5           	push de			;0c3d	d5 	.
 3693 0C3E CD CF 0A     	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;0c3e	cd cf 0a 	. . .
 3694 0C41 D1           	pop de			;0c41	d1 	.
 3695 0C42 C3 82 09     	jp sngACCnegate		; ACC = -ACC (Single) ;0c42	c3 82 09 	. . .
 3696 0C45              sub_0c45h:
 3697 0C45 7C           	ld a,h			;0c45	7c 	|
 3698 0C46 AA           	xor d			;0c46	aa 	.
 3699 0C47 47           	ld b,a			;0c47	47 	G
 3700 0C48 CD 4C 0C     	call sub_0c4ch		;0c48	cd 4c 0c 	. L .
 3701 0C4B EB           	ex de,hl			;0c4b	eb 	.
 3702 0C4C              sub_0c4ch:
 3703 0C4C 7C           	ld a,h			;0c4c	7c 	|
 3704 0C4D              l0c4dh:
 3705 0C4D B7           	or a			;0c4d	b7 	.
 3706 0C4E F2 9A 0A     	jp p,ACCfromHLValue	; copy value from hl to ACC as integer number		;0c4e	f2 9a 0a 	. . .
 3707 0C51              sub_0c51h:
 3708 0C51 AF           	xor a			;0c51	af 	.
 3709 0C52 4F           	ld c,a			;0c52	4f 	O
 3710 0C53 95           	sub l			;0c53	95 	.
 3711 0C54 6F           	ld l,a			;0c54	6f 	o
 3712 0C55 79           	ld a,c			;0c55	79 	y
 3713 0C56 9C           	sbc a,h			;0c56	9c 	.
 3714 0C57 67           	ld h,a			;0c57	67 	g
 3715 0C58 C3 9A 0A     	jp ACCfromHLValue	; copy value from hl to ACC as integer number		;0c58	c3 9a 0a 	. . .
 3716 0C5B
 3717 0C5B
 3718 0C5B              ; ********************************************************************************
 3719 0C5B              ; Math : ACC = ABS(ACC) (Integer)
 3720 0C5B              MAT_iAbs_ACC_DBL:
 3721 0C5B 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;0c5b	2a 21 79 	* ! y
 3722 0C5E CD 51 0C     	call sub_0c51h		;0c5e	cd 51 0c 	. Q .
 3723 0C61 7C           	ld a,h			;0c61	7c 	|
 3724 0C62 EE 80        	xor 080h		;0c62	ee 80 	. .
 3725 0C64 B5           	or l			;0c64	b5 	.
 3726 0C65 C0           	ret nz			;0c65	c0 	.
 3727 0C66              sub_0c66h:
 3728 0C66 EB           	ex de,hl			;0c66	eb 	.
 3729 0C67 CD EF 0A     	call SetNTFToSng		;0c67	cd ef 0a 	. . .
 3730 0C6A AF           	xor a			;0c6a	af 	.
 3731 0C6B              sub_0c6bh:
 3732 0C6B 06 98        	ld b,098h		;0c6b	06 98 	. .
 3733 0C6D C3 69 09     	jp l0969h		;0c6d	c3 69 09 	. i .
 3734 0C70
 3735 0C70
 3736 0C70              // ***********************************************************************
 3737 0C70              ; Math : ACC = ACC - ACC2 (Double)
 3738 0C70              MAT_dSub_ACC2
 3739 0C70 21 2D 79     	ld hl,MATH_ACC2_MSB		;0c70	21 2d 79 	! - y
 3740 0C73 7E           	ld a,(hl)			;0c73	7e 	~
 3741 0C74 EE 80        	xor 080h		;0c74	ee 80 	. .
 3742 0C76 77           	ld (hl),a			;0c76	77 	w
 3743 0C77
 3744 0C77
 3745 0C77              // ***********************************************************************
 3746 0C77              ; Math : ACC = ACC + ACC2 (Double)
 3747 0C77              ACCAddACC2:
 3748 0C77 21 2E 79     	ld hl,MATH_ACC2_EXP		;0c77	21 2e 79 	! . y
 3749 0C7A 7E           	ld a,(hl)			;0c7a	7e 	~
 3750 0C7B B7           	or a			;0c7b	b7 	.
 3751 0C7C C8           	ret z			;0c7c	c8 	.
 3752 0C7D 47           	ld b,a			;0c7d	47 	G
 3753 0C7E 2B           	dec hl			;0c7e	2b 	+
 3754 0C7F 4E           	ld c,(hl)			;0c7f	4e 	N
 3755 0C80 11 24 79     	ld de,MATH_ACC_EXP		;0c80	11 24 79 	. $ y
 3756 0C83 1A           	ld a,(de)			;0c83	1a 	.
 3757 0C84 B7           	or a			;0c84	b7 	.
 3758 0C85 CA F4 09     	jp z,ACC2ToACC_DBL	; Copy value from ACC2 to ACC (Any)	;0c85	ca f4 09 	. . .
 3759 0C88 90           	sub b			;0c88	90 	.
 3760 0C89 30 16        	jr nc,l0ca1h		;0c89	30 16 	0 .
 3761 0C8B 2F           	cpl			;0c8b	2f 	/
 3762 0C8C 3C           	inc a			;0c8c	3c 	<
 3763 0C8D F5           	push af			;0c8d	f5 	.
 3764 0C8E 0E 08        	ld c,008h		;0c8e	0e 08 	. .
 3765 0C90 23           	inc hl			;0c90	23 	#
 3766 0C91 E5           	push hl			;0c91	e5 	.
 3767 0C92              l0c92h:
 3768 0C92 1A           	ld a,(de)			;0c92	1a 	.
 3769 0C93 46           	ld b,(hl)			;0c93	46 	F
 3770 0C94 77           	ld (hl),a			;0c94	77 	w
 3771 0C95 78           	ld a,b			;0c95	78 	x
 3772 0C96 12           	ld (de),a			;0c96	12 	.
 3773 0C97 1B           	dec de			;0c97	1b 	.
 3774 0C98 2B           	dec hl			;0c98	2b 	+
 3775 0C99 0D           	dec c			;0c99	0d 	.
 3776 0C9A 20 F6        	jr nz,l0c92h		;0c9a	20 f6 	  .
 3777 0C9C E1           	pop hl			;0c9c	e1 	.
 3778 0C9D 46           	ld b,(hl)			;0c9d	46 	F
 3779 0C9E 2B           	dec hl			;0c9e	2b 	+
 3780 0C9F 4E           	ld c,(hl)			;0c9f	4e 	N
 3781 0CA0 F1           	pop af			;0ca0	f1 	.
 3782 0CA1              l0ca1h:
 3783 0CA1 FE 39        	cp 039h		;0ca1	fe 39 	. 9
 3784 0CA3 D0           	ret nc			;0ca3	d0 	.
 3785 0CA4 F5           	push af			;0ca4	f5 	.
 3786 0CA5 CD DF 09     	call MAT_sCmpSetSign		;0ca5	cd df 09 	. . .
 3787 0CA8 23           	inc hl			;0ca8	23 	#
 3788 0CA9 36 00        	ld (hl),000h		;0ca9	36 00 	6 .
 3789 0CAB 47           	ld b,a			;0cab	47 	G
 3790 0CAC F1           	pop af			;0cac	f1 	.
 3791 0CAD 21 2D 79     	ld hl,MATH_ACC2_MSB		;0cad	21 2d 79 	! - y
 3792 0CB0 CD 69 0D     	call sub_0d69h		;0cb0	cd 69 0d 	. i .
 3793 0CB3 3A 26 79     	ld a,(MATH_ACC2_CY)		;0cb3	3a 26 79 	: & y
 3794 0CB6 32 1C 79     	ld (MATH_ACC_CY),a		;0cb6	32 1c 79 	2 . y
 3795 0CB9 78           	ld a,b			;0cb9	78 	x
 3796 0CBA B7           	or a			;0cba	b7 	.
 3797 0CBB F2 CF 0C     	jp p,l0ccfh		;0cbb	f2 cf 0c 	. . .
 3798 0CBE CD 33 0D     	call ACCAddACC2_MO	; Math : ACC = ACC + ACC2 (Double) MANTISSA only	;0cbe	cd 33 0d 	. 3 .
 3799 0CC1 D2 0E 0D     	jp nc,l0d0eh		;0cc1	d2 0e 0d 	. . .
 3800 0CC4 EB           	ex de,hl			;0cc4	eb 	.
 3801 0CC5 34           	inc (hl)			;0cc5	34 	4
 3802 0CC6 CA B2 07     	jp z,ErrRaiseOverflow	; Raise OVERFLOW Error		;0cc6	ca b2 07 	. . .
 3803 0CC9 CD 90 0D     	call sub_0d90h		;0cc9	cd 90 0d 	. . .
 3804 0CCC C3 0E 0D     	jp l0d0eh		;0ccc	c3 0e 0d 	. . .
 3805 0CCF              l0ccfh:
 3806 0CCF CD 45 0D     	call MAT_dSub_ACC2_mo	; ACC = ACC - ACC2 (Double) MANTISSA ONLY	;0ccf	cd 45 0d 	. E .
 3807 0CD2 21 25 79     	ld hl,MATH_ACC_SIGN		;0cd2	21 25 79 	! % y
 3808 0CD5 DC 57 0D     	call c,sub_0d57h		;0cd5	dc 57 0d 	. W .
 3809 0CD8              l0cd8h:
 3810 0CD8 AF           	xor a			;0cd8	af 	.
 3811 0CD9              l0cd9h:
 3812 0CD9 47           	ld b,a			;0cd9	47 	G
 3813 0CDA 3A 23 79     	ld a,(ACC_SNG+2)	 ; Int,Single,String (2 or 4 bytes): 	;0cda	3a 23 79 	: # y
 3814 0CDD B7           	or a			;0cdd	b7 	.
 3815 0CDE 20 1E        	jr nz,l0cfeh		;0cde	20 1e 	  .
 3816 0CE0 21 1C 79     	ld hl,MATH_ACC_CY		;0ce0	21 1c 79 	! . y
 3817 0CE3 0E 08        	ld c,008h		;0ce3	0e 08 	. .
 3818 0CE5              l0ce5h:
 3819 0CE5 56           	ld d,(hl)			;0ce5	56 	V
 3820 0CE6 77           	ld (hl),a			;0ce6	77 	w
 3821 0CE7 7A           	ld a,d			;0ce7	7a 	z
 3822 0CE8 23           	inc hl			;0ce8	23 	#
 3823 0CE9 0D           	dec c			;0ce9	0d 	.
 3824 0CEA 20 F9        	jr nz,l0ce5h		;0cea	20 f9 	  .
 3825 0CEC 78           	ld a,b			;0cec	78 	x
 3826 0CED D6 08        	sub 008h		;0ced	d6 08 	. .
 3827 0CEF FE C0        	cp 0c0h		;0cef	fe c0 	. .
 3828 0CF1 20 E6        	jr nz,l0cd9h		;0cf1	20 e6 	  .
 3829 0CF3 C3 78 07     	jp MAT_sdSetACC_0		;0cf3	c3 78 07 	. x .
 3830 0CF6              l0cf6h:
 3831 0CF6 05           	dec b			;0cf6	05 	.
 3832 0CF7 21 1C 79     	ld hl,MATH_ACC_CY		;0cf7	21 1c 79 	! . y
 3833 0CFA CD 97 0D     	call sub_0d97h		;0cfa	cd 97 0d 	. . .
 3834 0CFD B7           	or a			;0cfd	b7 	.
 3835 0CFE              l0cfeh:
 3836 0CFE F2 F6 0C     	jp p,l0cf6h		;0cfe	f2 f6 0c 	. . .
 3837 0D01 78           	ld a,b			;0d01	78 	x
 3838 0D02 B7           	or a			;0d02	b7 	.
 3839 0D03 28 09        	jr z,l0d0eh		;0d03	28 09 	( .
 3840 0D05 21 24 79     	ld hl,MATH_ACC_EXP		;0d05	21 24 79 	! $ y
 3841 0D08 86           	add a,(hl)			;0d08	86 	.
 3842 0D09 77           	ld (hl),a			;0d09	77 	w
 3843 0D0A D2 78 07     	jp nc,MAT_sdSetACC_0		;0d0a	d2 78 07 	. x .
 3844 0D0D C8           	ret z			;0d0d	c8 	.
 3845 0D0E              l0d0eh:
 3846 0D0E 3A 1C 79     	ld a,(MATH_ACC_CY)		;0d0e	3a 1c 79 	: . y
 3847 0D11              l0d11h:
 3848 0D11 B7           	or a			;0d11	b7 	.
 3849 0D12 FC 20 0D     	call m,sub_0d20h		;0d12	fc 20 0d 	.   .
 3850 0D15 21 25 79     	ld hl,MATH_ACC_SIGN		;0d15	21 25 79 	! % y
 3851 0D18 7E           	ld a,(hl)			;0d18	7e 	~
 3852 0D19 E6 80        	and 080h		;0d19	e6 80 	. .
 3853 0D1B 2B           	dec hl			;0d1b	2b 	+
 3854 0D1C 2B           	dec hl			;0d1c	2b 	+
 3855 0D1D AE           	xor (hl)			;0d1d	ae 	.
 3856 0D1E 77           	ld (hl),a			;0d1e	77 	w
 3857 0D1F C9           	ret			;0d1f	c9 	.
 3858 0D20              sub_0d20h:
 3859 0D20 21 1D 79     	ld hl,ACC_DBL	; addres of Accumulator (Double) ;0d20	21 1d 79 	! . y
 3860 0D23 06 07        	ld b,007h		;0d23	06 07 	. .
 3861 0D25              l0d25h:
 3862 0D25 34           	inc (hl)			;0d25	34 	4
 3863 0D26 C0           	ret nz			;0d26	c0 	.
 3864 0D27 23           	inc hl			;0d27	23 	#
 3865 0D28 05           	dec b			;0d28	05 	.
 3866 0D29 20 FA        	jr nz,l0d25h		;0d29	20 fa 	  .
 3867 0D2B 34           	inc (hl)			;0d2b	34 	4
 3868 0D2C CA B2 07     	jp z,ErrRaiseOverflow	; Raise OVERFLOW Error		;0d2c	ca b2 07 	. . .
 3869 0D2F 2B           	dec hl			;0d2f	2b 	+
 3870 0D30 36 80        	ld (hl),080h		;0d30	36 80 	6 .
 3871 0D32 C9           	ret			;0d32	c9 	.
 3872 0D33
 3873 0D33              // ***********************************************************************
 3874 0D33              ; Math : ACC = ACC + ACC2 (Double)
 3875 0D33              ; Routine operates on the MANTISSA ONLY (exponent byte ignored)
 3876 0D33              ACCAddACC2_MO:
 3877 0D33 21 27 79     	ld hl,ACC2		; address of 2nd Accumulator 								;0d33	21 27 79 	! ' y
 3878 0D36              ACCAddHLMem_MO:
 3879 0D36 11 1D 79     	ld de,ACC_DBL	; addres of Accumulator (Double) 									;0d36	11 1d 79 	. . y
 3880 0D39              DEMemAddHLMem_MO:
 3881 0D39 0E 07        	ld c,7			; 7 bytes words to add										;0d39	0e 07 	. .
 3882 0D3B AF           	xor a			; clear CY flag												;0d3b	af 	.
 3883 0D3C              .next:
 3884 0D3C 1A           	ld a,(de)		; a - byte from ACC											;0d3c	1a 	.
 3885 0D3D 8E           	adc a,(hl)		; add byte from ACC2										;0d3d	8e 	.
 3886 0D3E 12           	ld (de),a		; store result into ACC										;0d3e	12 	.
 3887 0D3F 13           	inc de			; increment source address									;0d3f	13 	.
 3888 0D40 23           	inc hl			; increment destination address								;0d40	23 	#
 3889 0D41 0D           	dec c			; decrement bytes counter - all added?						;0d41	0d 	.
 3890 0D42 20 F8        	jr nz,.next		; no - all all 7 bytes										;0d42	20 f8 	  .
 3891 0D44 C9           	ret				; --------------- End of Proc -----------------------------	;0d44	c9 	.
 3892 0D45
 3893 0D45
 3894 0D45              // ***********************************************************************
 3895 0D45              ; Math : ACC = ACC - ACC2 (Double)
 3896 0D45              ; Routine operates on the MANTISSA ONLY (exponent byte ignored)
 3897 0D45              MAT_dSub_ACC2_mo:
 3898 0D45 21 27 79     	ld hl,ACC2		; address of 2nd Accumulator ;0d45	21 27 79 	! ' y
 3899 0D48              sub_0d48h:
 3900 0D48 11 1D 79     	ld de,ACC_DBL	; addres of Accumulator (Double) ;0d48	11 1d 79 	. . y
 3901 0D4B              sub_0d4bh:
 3902 0D4B 0E 07        	ld c,007h		;0d4b	0e 07 	. .
 3903 0D4D AF           	xor a			;0d4d	af 	.
 3904 0D4E              l0d4eh:
 3905 0D4E 1A           	ld a,(de)			;0d4e	1a 	.
 3906 0D4F 9E           	sbc a,(hl)			;0d4f	9e 	.
 3907 0D50 12           	ld (de),a			;0d50	12 	.
 3908 0D51 13           	inc de			;0d51	13 	.
 3909 0D52 23           	inc hl			;0d52	23 	#
 3910 0D53 0D           	dec c			;0d53	0d 	.
 3911 0D54 20 F8        	jr nz,l0d4eh		;0d54	20 f8 	  .
 3912 0D56 C9           	ret			;0d56	c9 	.
 3913 0D57              sub_0d57h:
 3914 0D57 7E           	ld a,(hl)			;0d57	7e 	~
 3915 0D58 2F           	cpl			;0d58	2f 	/
 3916 0D59 77           	ld (hl),a			;0d59	77 	w
 3917 0D5A 21 1C 79     	ld hl,MATH_ACC_CY		;0d5a	21 1c 79 	! . y
 3918 0D5D 06 08        	ld b,008h		;0d5d	06 08 	. .
 3919 0D5F AF           	xor a			;0d5f	af 	.
 3920 0D60              l0d60h:
 3921 0D60 4F           	ld c,a			;0d60	4f 	O
 3922 0D61              l0d61h:
 3923 0D61 79           	ld a,c			;0d61	79 	y
 3924 0D62 9E           	sbc a,(hl)			;0d62	9e 	.
 3925 0D63 77           	ld (hl),a			;0d63	77 	w
 3926 0D64 23           	inc hl			;0d64	23 	#
 3927 0D65 05           	dec b			;0d65	05 	.
 3928 0D66 20 F9        	jr nz,l0d61h		;0d66	20 f9 	  .
 3929 0D68 C9           	ret			;0d68	c9 	.
 3930 0D69              sub_0d69h:
 3931 0D69 71           	ld (hl),c			;0d69	71 	q
 3932 0D6A E5           	push hl			;0d6a	e5 	.
 3933 0D6B              l0d6bh:
 3934 0D6B D6 08        	sub 008h		;0d6b	d6 08 	. .
 3935 0D6D 38 0E        	jr c,l0d7dh		;0d6d	38 0e 	8 .
 3936 0D6F E1           	pop hl			;0d6f	e1 	.
 3937 0D70              sub_0d70h:
 3938 0D70 E5           	push hl			;0d70	e5 	.
 3939 0D71 11 00 08     	ld de,l0800h		;0d71	11 00 08 	. . .
 3940 0D74              l0d74h:
 3941 0D74 4E           	ld c,(hl)			;0d74	4e 	N
 3942 0D75 73           	ld (hl),e			;0d75	73 	s
 3943 0D76 59           	ld e,c			;0d76	59 	Y
 3944 0D77 2B           	dec hl			;0d77	2b 	+
 3945 0D78 15           	dec d			;0d78	15 	.
 3946 0D79 20 F9        	jr nz,l0d74h		;0d79	20 f9 	  .
 3947 0D7B 18 EE        	jr l0d6bh		;0d7b	18 ee 	. .
 3948 0D7D              l0d7dh:
 3949 0D7D C6 09        	add a,009h		;0d7d	c6 09 	. .
 3950 0D7F 57           	ld d,a			;0d7f	57 	W
 3951 0D80              l0d80h:
 3952 0D80 AF           	xor a			;0d80	af 	.
 3953 0D81 E1           	pop hl			;0d81	e1 	.
 3954 0D82 15           	dec d			;0d82	15 	.
 3955 0D83 C8           	ret z			;0d83	c8 	.
 3956 0D84              l0d84h:
 3957 0D84 E5           	push hl			;0d84	e5 	.
 3958 0D85 1E 08        	ld e,008h		;0d85	1e 08 	. .
 3959 0D87              l0d87h:
 3960 0D87 7E           	ld a,(hl)			;0d87	7e 	~
 3961 0D88 1F           	rra			;0d88	1f 	.
 3962 0D89 77           	ld (hl),a			;0d89	77 	w
 3963 0D8A 2B           	dec hl			;0d8a	2b 	+
 3964 0D8B 1D           	dec e			;0d8b	1d 	.
 3965 0D8C 20 F9        	jr nz,l0d87h		;0d8c	20 f9 	  .
 3966 0D8E 18 F0        	jr l0d80h		;0d8e	18 f0 	. .
 3967 0D90              sub_0d90h:
 3968 0D90 21 23 79     	ld hl,ACC_SNG+2	 ; Int,Single,String (2 or 4 bytes): 	;0d90	21 23 79 	! # y
 3969 0D93 16 01        	ld d,001h		;0d93	16 01 	. .
 3970 0D95 18 ED        	jr l0d84h		;0d95	18 ed 	. .
 3971 0D97              sub_0d97h:
 3972 0D97 0E 08        	ld c,008h		;0d97	0e 08 	. .
 3973 0D99              l0d99h:
 3974 0D99 7E           	ld a,(hl)			;0d99	7e 	~
 3975 0D9A 17           	rla			;0d9a	17 	.
 3976 0D9B 77           	ld (hl),a			;0d9b	77 	w
 3977 0D9C 23           	inc hl			;0d9c	23 	#
 3978 0D9D 0D           	dec c			;0d9d	0d 	.
 3979 0D9E 20 F9        	jr nz,l0d99h		;0d9e	20 f9 	  .
 3980 0DA0 C9           	ret			;0da0	c9 	.
 3981 0DA1
 3982 0DA1
 3983 0DA1              // ***********************************************************************
 3984 0DA1              ; Math : ACC = ACC * ACC2 (Double)
 3985 0DA1              dblACCmulACC2:
 3986 0DA1 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0da1	cd 55 09 	. U .
 3987 0DA4 C8           	ret z			    ; return if ACC=0 (Result must be 0)                    ;0da4	c8 	.
 3988 0DA5 CD 0A 09     	call 0090ah		;0da5	cd 0a 09 	. . .
 3989 0DA8 CD 39 0E     	call sub_0e39h		;0da8	cd 39 0e 	. 9 .
 3990 0DAB 71           	ld (hl),c			;0dab	71 	q
 3991 0DAC 13           	inc de			;0dac	13 	.
 3992 0DAD 06 07        	ld b,007h		;0dad	06 07 	. .
 3993 0DAF              l0dafh:
 3994 0DAF 1A           	ld a,(de)			;0daf	1a 	.
 3995 0DB0 13           	inc de			;0db0	13 	.
 3996 0DB1 B7           	or a			;0db1	b7 	.
 3997 0DB2 D5           	push de			;0db2	d5 	.
 3998 0DB3 28 17        	jr z,l0dcch		;0db3	28 17 	( .
 3999 0DB5 0E 08        	ld c,008h		;0db5	0e 08 	. .
 4000 0DB7              l0db7h:
 4001 0DB7 C5           	push bc			;0db7	c5 	.
 4002 0DB8 1F           	rra			;0db8	1f 	.
 4003 0DB9 47           	ld b,a			;0db9	47 	G
 4004 0DBA DC 33 0D     	call c,ACCAddACC2_MO	; Math : ACC = ACC + ACC2 (Double) MANTISSA only	;0dba	dc 33 0d 	. 3 .
 4005 0DBD CD 90 0D     	call sub_0d90h		;0dbd	cd 90 0d 	. . .
 4006 0DC0 78           	ld a,b			;0dc0	78 	x
 4007 0DC1 C1           	pop bc			;0dc1	c1 	.
 4008 0DC2 0D           	dec c			;0dc2	0d 	.
 4009 0DC3 20 F2        	jr nz,l0db7h		;0dc3	20 f2 	  .
 4010 0DC5              l0dc5h:
 4011 0DC5 D1           	pop de			;0dc5	d1 	.
 4012 0DC6 05           	dec b			;0dc6	05 	.
 4013 0DC7 20 E6        	jr nz,l0dafh		;0dc7	20 e6 	  .
 4014 0DC9 C3 D8 0C     	jp l0cd8h		;0dc9	c3 d8 0c 	. . .
 4015 0DCC              l0dcch:
 4016 0DCC 21 23 79     	ld hl,ACC_SNG+2	 ; Int,Single,String (2 or 4 bytes): 	;0dcc	21 23 79 	! # y
 4017 0DCF CD 70 0D     	call sub_0d70h		;0dcf	cd 70 0d 	. p .
 4018 0DD2 18 F1        	jr l0dc5h		;0dd2	18 f1 	. .
 4019 0DD4              dblConst_10:
 4020 0DD4 00 00 00 00  	dword #00000000			; along with followin 4 bytes makes Double 10	;0dd4	00 00 00 00 	.
 4021 0DD8              MAT_sConst_10:
 4022 0DD8 00 00 20 84  	dword #84200000			; Single 10 constant							;0dd8	00 00 20 84 	  .
 4023 0DDC
 4024 0DDC
 4025 0DDC              // ***********************************************************************
 4026 0DDC              ; Math : ACC = ACC / 10 (Double)
 4027 0DDC              ACCDiv10:
 4028 0DDC 11 D4 0D     	ld de,dblConst_10	; constant double value = 10.0					;0ddc	11 d4 0d 	. . .
 4029 0DDF 21 27 79     	ld hl,ACC2			; address of 2nd Accumulator 					;0ddf	21 27 79 	! ' y
 4030 0DE2 CD D3 09     	call DEMemToHLMem	; copy 10.0D to ACC2							;0de2	cd d3 09 	. . .
 4031 0DE5
 4032 0DE5
 4033 0DE5
 4034 0DE5              // ***********************************************************************
 4035 0DE5              ; Math : ACC = ACC / ACC2 (Double)
 4036 0DE5              ACCDivACC2
 4037 0DE5 3A 2E 79     	ld a,(MATH_ACC2_EXP)		;0de5	3a 2e 79 	: . y
 4038 0DE8 B7           	or a			        ; is Exponent = 0 ;0de8	b7 	.
 4039 0DE9 CA 9A 19     	jp z,ErrRaiseDivByZero	; yes - Raise 'DIVISION BY ZERO' error		;0de9	ca 9a 19 	. . .
 4040 0DEC CD 07 09     	call sub_0907h		;0dec	cd 07 09 	. . .
 4041 0DEF 34           	inc (hl)			;0def	34 	4
 4042 0DF0 34           	inc (hl)			;0df0	34 	4
 4043 0DF1 CD 39 0E     	call sub_0e39h		;0df1	cd 39 0e 	. 9 .
 4044 0DF4 21 51 79     	ld hl,MATH_ACC3_EXP		;0df4	21 51 79 	! Q y
 4045 0DF7 71           	ld (hl),c			;0df7	71 	q
 4046 0DF8 41           	ld b,c			;0df8	41 	A
 4047 0DF9              l0df9h:
 4048 0DF9 11 4A 79     	ld de,MATH_ACC3_DBL		;0df9	11 4a 79 	. J y
 4049 0DFC 21 27 79     	ld hl,ACC2		; address of 2nd Accumulator ;0dfc	21 27 79 	! ' y
 4050 0DFF CD 4B 0D     	call sub_0d4bh		;0dff	cd 4b 0d 	. K .
 4051 0E02 1A           	ld a,(de)			;0e02	1a 	.
 4052 0E03 99           	sbc a,c			;0e03	99 	.
 4053 0E04 3F           	ccf			;0e04	3f 	?
 4054 0E05 38 0B        	jr c,$+13		;0e05	38 0b 	8 .
 4055 0E07 11 4A 79     	ld de,MATH_ACC3_DBL		;0e07	11 4a 79 	. J y
 4056 0E0A 21 27 79     	ld hl,ACC2		; address of 2nd Accumulator ;0e0a	21 27 79 	! ' y
 4057 0E0D CD 39 0D     	call DEMemAddHLMem_MO	; ACC = [DE] + [HL] - MANTISSA only		;0e0d	cd 39 0d 	. 9 .
 4058 0E10 AF           	xor a			;0e10	af 	.
 4059 0E11 DA 12 04     	jp c,00412h		;0e11	da 12 04 	. . .
 4060 0E14 3A 23 79     	ld a,(ACC_SNG+2)	 ; Int,Single,String (2 or 4 bytes): 	;0e14	3a 23 79 	: # y
 4061 0E17 3C           	inc a			;0e17	3c 	<
 4062 0E18 3D           	dec a			;0e18	3d 	=
 4063 0E19 1F           	rra			;0e19	1f 	.
 4064 0E1A FA 11 0D     	jp m,l0d11h		;0e1a	fa 11 0d 	. . .
 4065 0E1D 17           	rla			;0e1d	17 	.
 4066 0E1E 21 1D 79     	ld hl,ACC_DBL		; addres of Accumulator (Double) ;0e1e	21 1d 79 	! . y
 4067 0E21 0E 07        	ld c,007h		;0e21	0e 07 	. .
 4068 0E23 CD 99 0D     	call l0d99h		;0e23	cd 99 0d 	. . .
 4069 0E26 21 4A 79     	ld hl,MATH_ACC3_DBL		;0e26	21 4a 79 	! J y
 4070 0E29 CD 97 0D     	call sub_0d97h		;0e29	cd 97 0d 	. . .
 4071 0E2C 78           	ld a,b			;0e2c	78 	x
 4072 0E2D B7           	or a			;0e2d	b7 	.
 4073 0E2E 20 C9        	jr nz,l0df9h		;0e2e	20 c9 	  .
 4074 0E30 21 24 79     	ld hl,MATH_ACC_EXP		;0e30	21 24 79 	! $ y
 4075 0E33 35           	dec (hl)			;0e33	35 	5
 4076 0E34 20 C3        	jr nz,l0df9h		;0e34	20 c3 	  .
 4077 0E36 C3 B2 07     	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;0e36	c3 b2 07 	. . .
 4078 0E39              sub_0e39h:
 4079 0E39 79           	ld a,c			;0e39	79 	y
 4080 0E3A              l0e3ah:
 4081 0E3A 32 2D 79     	ld (MATH_ACC2_MSB),a		;0e3a	32 2d 79 	2 - y
 4082 0E3D 2B           	dec hl			;0e3d	2b 	+
 4083 0E3E 11 50 79     	ld de,MATH_ACC3_MSB		;0e3e	11 50 79 	. P y
 4084 0E41 01 00 07     	ld bc,00700h		;0e41	01 00 07 	. . .
 4085 0E44              l0e44h:
 4086 0E44 7E           	ld a,(hl)			;0e44	7e 	~
 4087 0E45 12           	ld (de),a			;0e45	12 	.
 4088 0E46 71           	ld (hl),c			;0e46	71 	q
 4089 0E47 1B           	dec de			;0e47	1b 	.
 4090 0E48 2B           	dec hl			;0e48	2b 	+
 4091 0E49 05           	dec b			;0e49	05 	.
 4092 0E4A 20 F8        	jr nz,l0e44h		;0e4a	20 f8 	  .
 4093 0E4C C9           	ret			;0e4c	c9 	.
 4094 0E4D
 4095 0E4D
 4096 0E4D              // ***********************************************************************
 4097 0E4D              ; Math : ACC = ACC * 10 (Double)
 4098 0E4D              dblACCmul10:
 4099 0E4D CD FC 09     	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;0e4d	cd fc 09 	. . .
 4100 0E50 EB           	ex de,hl			;0e50	eb 	.
 4101 0E51 2B           	dec hl			;0e51	2b 	+
 4102 0E52 7E           	ld a,(hl)			;0e52	7e 	~
 4103 0E53 B7           	or a			;0e53	b7 	.
 4104 0E54 C8           	ret z			;0e54	c8 	.
 4105 0E55 C6 02        	add a,002h		;0e55	c6 02 	. .
 4106 0E57 DA B2 07     	jp c,ErrRaiseOverflow	; Raise OVERFLOW Error		;0e57	da b2 07 	. . .
 4107 0E5A 77           	ld (hl),a			;0e5a	77 	w
 4108 0E5B E5           	push hl			;0e5b	e5 	.
 4109 0E5C CD 77 0C     	call ACCAddACC2	; Math : ACC = ACC + ACC2 (Double)	;0e5c	cd 77 0c 	. w .
 4110 0E5F E1           	pop hl			;0e5f	e1 	.
 4111 0E60 34           	inc (hl)			;0e60	34 	4
 4112 0E61 C0           	ret nz			;0e61	c0 	.
 4113 0E62 C3 B2 07     	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;0e62	c3 b2 07 	. . .
 4114 0E65
 4115 0E65
 4116 0E65              ; ********************************************************************************
 4117 0E65              ; Math : Convert from ASCII const (HL) to Double (ACC)
 4118 0E65              ; IN: hl - Address of Ascii string
 4119 0E65              StrToDbl:
 4120 0E65 CD 78 07     	call MAT_sdSetACC_0		;0e65	cd 78 07 	. x .
 4121 0E68 CD EC 0A     	call SetNTFDbl		;0e68	cd ec 0a 	. . .
 4122 0E6B F6           	db $f6				; trick byte - with next constructs irrevelant "or $af"		;0e6b	f6 af 	. .
 4123 0E6C
 4124 0E6C              ; ********************************************************************************
 4125 0E6C              ; Math : Convert from ASCII const (HL) to Any (ACC)
 4126 0E6C              ; Evaluate a numeric string that begins at the address pointed to by the HL register pair,
 4127 0E6C              ; store it in ACC and set the NTF,
 4128 0E6C              ; This routine stops as soon as it encounters a character that is not part of the number
 4129 0E6C              ; (it will return a value of zero if no valid numeric characters are found).
 4130 0E6C              ; It will accept signed values in Integer, Real or Scientific Notation.
 4131 0E6C              ; Number returned will be in Integer format if possible, else single precision
 4132 0E6C              ; unless the string has over seven digits (not including exponent), in which case
 4133 0E6C              ; number will be returned as Double precision.
 4134 0E6C              ; IN: hl - Address of Ascii string
 4135 0E6C              StrToNum:
 4136 0E6C AF           	xor a				;0e6c	af 	. .
 4137 0E6D EB           	ex de,hl			;0e6d	eb 	.
 4138 0E6E 01 FF 00     	ld bc,00ffh		;0e6e	01 ff 00 	. . .
 4139 0E71 60           	ld h,b			;0e71	60 	`
 4140 0E72 68           	ld l,b			;0e72	68 	h
 4141 0E73 CC 9A 0A     	call z,ACCfromHLValue	; copy value from hl to ACC as integer number		;0e73	cc 9a 0a 	. . .
 4142 0E76 EB           	ex de,hl			;0e76	eb 	.
 4143 0E77 7E           	ld a,(hl)			;0e77	7e 	~
 4144 0E78 FE 2D        	cp 02dh		;0e78	fe 2d 	. -
 4145 0E7A F5           	push af			;0e7a	f5 	.
 4146 0E7B CA 83 0E     	jp z,l0e83h		;0e7b	ca 83 0e 	. . .
 4147 0E7E FE 2B        	cp 02bh		;0e7e	fe 2b 	. +
 4148 0E80 28 01        	jr z,l0e83h		;0e80	28 01 	( .
 4149 0E82 2B           	dec hl			;0e82	2b 	+
 4150 0E83              l0e83h:
 4151 0E83 D7           	rst $10			; move hl to next Basic token	;0e83	d7 	.
 4152 0E84 DA 29 0F     	jp c,l0f29h		; call if found numeric constant ;0e84	da 29 0f 	. ) .
 4153 0E87 FE 2E        	cp '.'		    ; is it '.' char - next is fractional part ;0e87	fe 2e 	. .
 4154 0E89 CA E4 0E     	jp z,l0ee4h		; yes - ;0e89	ca e4 0e 	. . .
 4155 0E8C FE 45        	cp 'E'		    ; is it 'E' char - next is exponent part ;0e8c	fe 45 	. E
 4156 0E8E 28 14        	jr z,l0ea4h		; yes - ;0e8e	28 14 	( .
 4157 0E90 FE 25        	cp '%'		    ; is it '%' char - (???) modulo/binary ;0e90	fe 25 	. %
 4158 0E92 CA EE 0E     	jp z,l0eeeh		; yes - ;0e92	ca ee 0e 	. . .
 4159 0E95 FE 23        	cp '#'		    ; is it '#' char - ;0e95	fe 23 	. #
 4160 0E97 CA F5 0E     	jp z,l0ef5h		; yes - ;0e97	ca f5 0e 	. . .
 4161 0E9A FE 21        	cp '!'		    ; is it '!' char - (???) ;0e9a	fe 21 	. !
 4162 0E9C CA F6 0E     	jp z,l0ef6h		; yes - ;0e9c	ca f6 0e 	. . .
 4163 0E9F FE 44        	cp 'D'		    ; is it 'D' char - ;0e9f	fe 44 	. D
 4164 0EA1 20 24        	jr nz,l0ec7h	; yes - ;0ea1	20 24 	  $
 4165 0EA3 B7           	or a			;0ea3	b7 	.
 4166 0EA4
 4167 0EA4              ; -- found 'E' char
 4168 0EA4              l0ea4h:
 4169 0EA4 CD FB 0E     	call sub_0efbh		;0ea4	cd fb 0e 	. . .
 4170 0EA7 E5           	push hl			;0ea7	e5 	.
 4171 0EA8 21 BD 0E     	ld hl,l0ebdh		;0ea8	21 bd 0e 	! . .
 4172 0EAB E3           	ex (sp),hl			;0eab	e3 	.
 4173 0EAC D7           	rst $10			; move hl to next Basic token		;0eac	d7 	.
 4174 0EAD 15           	dec d			;0ead	15 	.
 4175 0EAE FE CE        	cp $ce		    ; is it Basic '-' token ;0eae	fe ce 	. .
 4176 0EB0 C8           	ret z			; yes - ;0eb0	c8 	.
 4177 0EB1 FE 2D        	cp '-'		    ; is it '-' char? ;0eb1	fe 2d 	. -
 4178 0EB3 C8           	ret z			; yes - ;0eb3	c8 	.
 4179 0EB4 14           	inc d			;0eb4	14 	.
 4180 0EB5 FE CD        	cp $cd		    ; is it Basic '+' token ;0eb5	fe cd 	. .
 4181 0EB7 C8           	ret z			; yes - ;0eb7	c8 	.
 4182 0EB8 FE 2B        	cp '+'		    ; is it '+' char ? ;0eb8	fe 2b 	. +
 4183 0EBA C8           	ret z			; yes - ;0eba	c8 	.
 4184 0EBB 2B           	dec hl			;0ebb	2b 	+
 4185 0EBC F1           	pop af			;0ebc	f1 	.
 4186 0EBD              l0ebdh:
 4187 0EBD D7           	rst $10			; move hl to next Basic token		;0ebd	d7 	.
 4188 0EBE DA 94 0F     	jp c,l0f94h		; jump if found numeric constant ;0ebe	da 94 0f 	. . .
 4189 0EC1 14           	inc d			;0ec1	14 	.
 4190 0EC2 20 03        	jr nz,l0ec7h		;0ec2	20 03 	  .
 4191 0EC4 AF           	xor a			;0ec4	af 	.
 4192 0EC5 93           	sub e			;0ec5	93 	.
 4193 0EC6 5F           	ld e,a			;0ec6	5f 	_
 4194 0EC7              ; -- found 'D' char
 4195 0EC7              l0ec7h:
 4196 0EC7 E5           	push hl			;0ec7	e5 	.
 4197 0EC8 7B           	ld a,e			;0ec8	7b 	{
 4198 0EC9 90           	sub b			;0ec9	90 	.
 4199 0ECA              l0ecah:
 4200 0ECA F4 0A 0F     	call p,MAT_sdMul_10		;0eca	f4 0a 0f 	. . .
 4201 0ECD FC 18 0F     	call m,MAT_sdDiv_10		;0ecd	fc 18 0f 	. . .
 4202 0ED0 20 F8        	jr nz,l0ecah		;0ed0	20 f8 	  .
 4203 0ED2 E1           	pop hl			;0ed2	e1 	.
 4204 0ED3 F1           	pop af			;0ed3	f1 	.
 4205 0ED4 E5           	push hl			;0ed4	e5 	.
 4206 0ED5 CC 7B 09     	call z,l097bh		;0ed5	cc 7b 09 	. { .
 4207 0ED8 E1           	pop hl			;0ed8	e1 	.
 4208 0ED9 E7           	rst #20			; test NTF (Number Type Format) - is it Single? ;0ed9	e7 	.
 4209 0EDA E8           	ret pe			; no - ;0eda	e8 	.
 4210 0EDB E5           	push hl			;0edb	e5 	.
 4211 0EDC 21 90 08     	ld hl,l0890h		;0edc	21 90 08 	! . .
 4212 0EDF E5           	push hl			;0edf	e5 	.
 4213 0EE0 CD A3 0A     	call l0aa3h		;0ee0	cd a3 0a 	. . .
 4214 0EE3 C9           	ret			;0ee3	c9 	.
 4215 0EE4              ; -- found '.' char
 4216 0EE4              l0ee4h:
 4217 0EE4 E7           	rst #20			; test NTF (Number Type Format) ;0ee4	e7 	.
 4218 0EE5 0C           	inc c			;0ee5	0c 	.
 4219 0EE6 20 DF        	jr nz,l0ec7h		;0ee6	20 df 	  .
 4220 0EE8 DC FB 0E     	call c,sub_0efbh	; call if NTF is not Double	;0ee8	dc fb 0e 	. . .
 4221 0EEB C3 83 0E     	jp l0e83h		;0eeb	c3 83 0e 	. . .
 4222 0EEE              ; -- found '%' char
 4223 0EEE              l0eeeh:
 4224 0EEE E7           	rst #20			; test NTF (Number Type Format)  ;0eee	e7 	.
 4225 0EEF F2 97 19     	jp p,ErrRaiseSyntax	; Single or Double - Raise 'SYNTAX ERROR'	;0eef	f2 97 19 	. . .
 4226 0EF2              l0ef2h:
 4227 0EF2 23           	inc hl			;0ef2	23 	#
 4228 0EF3 18 D2        	jr l0ec7h		;0ef3	18 d2 	. .
 4229 0EF5              ; -- found '#' char
 4230 0EF5              l0ef5h:
 4231 0EF5 B7           	or a			;0ef5	b7 	.
 4232 0EF6              ; -- found '!' char
 4233 0EF6              l0ef6h:
 4234 0EF6 CD FB 0E     	call sub_0efbh		;0ef6	cd fb 0e 	. . .
 4235 0EF9 18 F7        	jr l0ef2h		;0ef9	18 f7 	. .
 4236 0EFB              sub_0efbh:
 4237 0EFB E5           	push hl			;0efb	e5 	.
 4238 0EFC D5           	push de			;0efc	d5 	.
 4239 0EFD C5           	push bc			;0efd	c5 	.
 4240 0EFE F5           	push af			;0efe	f5 	.
 4241 0EFF CC B1 0A     	call z,FuncCSNG		; convert ACC to Single value	;0eff	cc b1 0a 	. . .
 4242 0F02 F1           	pop af			;0f02	f1 	.
 4243 0F03 C4 DB 0A     	call nz,FuncCDBL	; convert ACC to Double value	;0f03	c4 db 0a 	. . .
 4244 0F06 C1           	pop bc			;0f06	c1 	.
 4245 0F07 D1           	pop de			;0f07	d1 	.
 4246 0F08 E1           	pop hl			;0f08	e1 	.
 4247 0F09 C9           	ret			;0f09	c9 	.
 4248 0F0A
 4249 0F0A              // ***********************************************************************
 4250 0F0A              ; Math : ACC = ACC * 10 (Single or Double)
 4251 0F0A              MAT_sdMul_10:
 4252 0F0A C8           	ret z			;0f0a	c8 	.
 4253 0F0B              sub_0f0bh:
 4254 0F0B F5           	push af			;0f0b	f5 	.
 4255 0F0C E7           	rst #20			; test NTF (Number Type Format)  ;0f0c	e7 	.
 4256 0F0D F5           	push af			; save af - Number Type Format ;0f0d	f5 	.
 4257 0F0E E4 3E 09     	call po,sngACCmul10	; Single - ACC = ACC * 10 (Single) 	;0f0e	e4 3e 09 	. > .
 4258 0F11 F1           	pop af			;0f11	f1 	.
 4259 0F12 EC 4D 0E     	call pe,dblACCmul10	; ACC = ACC * 10 (Double)	;0f12	ec 4d 0e 	. M .
 4260 0F15 F1           	pop af			;0f15	f1 	.
 4261 0F16              sub_0f16h:
 4262 0F16 3D           	dec a			;0f16	3d 	=
 4263 0F17 C9           	ret			;0f17	c9 	.
 4264 0F18
 4265 0F18              // ***********************************************************************
 4266 0F18              ; Math : ACC = ACC / 10 (Single or Double)
 4267 0F18              MAT_sdDiv_10:
 4268 0F18 D5           	push de			;0f18	d5 	.
 4269 0F19 E5           	push hl			;0f19	e5 	.
 4270 0F1A F5           	push af			;0f1a	f5 	.
 4271 0F1B E7           	rst #20			; test NTF (Number Type Format) ;0f1b	e7 	.
 4272 0F1C F5           	push af			; save af - Number Type Format	;0f1c	f5 	.
 4273 0F1D E4 97 08     	call po,MAT_sDiv_10	; Single - 	;0f1d	e4 97 08 	. . .
 4274 0F20 F1           	pop af			; restore af ;0f20	f1 	.
 4275 0F21 EC DC 0D     	call pe,ACCDiv10; Double -  ACC = ACC / 10 (Double)	;0f21	ec dc 0d 	. . .
 4276 0F24 F1           	pop af			;0f24	f1 	.
 4277 0F25 E1           	pop hl			;0f25	e1 	.
 4278 0F26 D1           	pop de			;0f26	d1 	.
 4279 0F27 3C           	inc a			;0f27	3c 	<
 4280 0F28 C9           	ret			;0f28	c9 	.
 4281 0F29              ; -- found numeric constant (hl)
 4282 0F29              l0f29h:
 4283 0F29 D5           	push de			;0f29	d5 	.
 4284 0F2A 78           	ld a,b			;0f2a	78 	x
 4285 0F2B 89           	adc a,c			;0f2b	89 	.
 4286 0F2C 47           	ld b,a			;0f2c	47 	G
 4287 0F2D C5           	push bc			;0f2d	c5 	.
 4288 0F2E E5           	push hl			;0f2e	e5 	.
 4289 0F2F 7E           	ld a,(hl)			;0f2f	7e 	~
 4290 0F30 D6 30        	sub 030h		;0f30	d6 30 	. 0
 4291 0F32 F5           	push af			;0f32	f5 	.
 4292 0F33 E7           	rst #20			; test NTF (Number Type Format) - is it Single or Double?	;0f33	e7 	.
 4293 0F34 F2 5D 0F     	jp p,l0f5dh		; yes - ;0f34	f2 5d 0f 	. ] .
 4294 0F37 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;0f37	2a 21 79 	* ! y
 4295 0F3A 11 CD 0C     	ld de,00ccdh		;0f3a	11 cd 0c 	. . .
 4296 0F3D DF           	rst #18			; Compare HL and DE ;0f3d	df 	.
 4297 0F3E 30 19        	jr nc,l0f59h		;0f3e	30 19 	0 .
 4298 0F40 54           	ld d,h			;0f40	54 	T
 4299 0F41 5D           	ld e,l			;0f41	5d 	]
 4300 0F42 29           	add hl,hl			;0f42	29 	)
 4301 0F43 29           	add hl,hl			;0f43	29 	)
 4302 0F44 19           	add hl,de			;0f44	19 	.
 4303 0F45 29           	add hl,hl			;0f45	29 	)
 4304 0F46 F1           	pop af			;0f46	f1 	.
 4305 0F47 4F           	ld c,a			;0f47	4f 	O
 4306 0F48 09           	add hl,bc			;0f48	09 	.
 4307 0F49 7C           	ld a,h			;0f49	7c 	|
 4308 0F4A B7           	or a			;0f4a	b7 	.
 4309 0F4B FA 57 0F     	jp m,l0f57h		;0f4b	fa 57 0f 	. W .
 4310 0F4E 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;0f4e	22 21 79 	" ! y
 4311 0F51              l0f51h:
 4312 0F51 E1           	pop hl			;0f51	e1 	.
 4313 0F52 C1           	pop bc			;0f52	c1 	.
 4314 0F53 D1           	pop de			;0f53	d1 	.
 4315 0F54 C3 83 0E     	jp l0e83h		;0f54	c3 83 0e 	. . .
 4316 0F57              l0f57h:
 4317 0F57 79           	ld a,c			;0f57	79 	y
 4318 0F58 F5           	push af			;0f58	f5 	.
 4319 0F59              l0f59h:
 4320 0F59 CD CC 0A     	call MAT_iConvToSng	; Convert from Integer to Single (ACC)		;0f59	cd cc 0a 	. . .
 4321 0F5C 37           	scf			;0f5c	37 	7
 4322 0F5D
 4323 0F5D
 4324 0F5D              ld_BCDE:	macro Val32bit
 4325 0F5D ~            			ld bc,Val32bit >> 16
 4326 0F5D ~            			ld de,Val32bit & 0xffff
 4327 0F5D              		endm
 4328 0F5D
 4329 0F5D
 4330 0F5D              l0f5dh:
 4331 0F5D 30 18        	jr nc,l0f77h		;0f5d	30 18 	0 .
 4332 0F5F              	;ld bc,$9474		;0f5f	01 74 94 	. t .
 4333 0F5F              	;ld de,$2400		;0f62	11 00 24 	. . $
 4334 0F5F              	ld_BCDE $94742400
 4334 0F5F 01 74 94    >			ld bc,$94742400 >> 16
 4334 0F62 11 00 24    >			ld de,$94742400 & 0xffff
 4335 0F65 CD 0C 0A     	call MAT_sCmp_ACC_BCDE	; Compare ACC and BCDE (Single)		;0f65	cd 0c 0a 	. . .
 4336 0F68 F2 74 0F     	jp p,l0f74h		;0f68	f2 74 0f 	. t .
 4337 0F6B CD 3E 09     	call sngACCmul10	; ACC = ACC * 10 (Single) 		;0f6b	cd 3e 09 	. > .
 4338 0F6E F1           	pop af			;0f6e	f1 	.
 4339 0F6F CD 89 0F     	call sub_0f89h		;0f6f	cd 89 0f 	. . .
 4340 0F72 18 DD        	jr l0f51h		;0f72	18 dd 	. .
 4341 0F74              l0f74h:
 4342 0F74 CD E3 0A     	call sngACCconvToDbl	; Convert ACC from Single to Double	;0f74	cd e3 0a 	. . .
 4343 0F77              l0f77h:
 4344 0F77 CD 4D 0E     	call dblACCmul10	        ; ACC = ACC * 10 (Double)	;0f77	cd 4d 0e 	. M .
 4345 0F7A CD FC 09     	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;0f7a	cd fc 09 	. . .
 4346 0F7D F1           	pop af			;0f7d	f1 	.
 4347 0F7E CD 64 09     	call MAT_iConvToSngA	; Convert from Integer (A) to Single (ACC)	;0f7e	cd 64 09 	. d .
 4348 0F81 CD E3 0A     	call sngACCconvToDbl	; Convert ACC from Single to Double	;0f81	cd e3 0a 	. . .
 4349 0F84 CD 77 0C     	call ACCAddACC2		; Math : ACC = ACC + ACC2 (Double);0f84	cd 77 0c 	. w .
 4350 0F87 18 C8        	jr l0f51h		;0f87	18 c8 	. .
 4351 0F89              sub_0f89h:
 4352 0F89 CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;0f89	cd a4 09 	. . .
 4353 0F8C CD 64 09     	call MAT_iConvToSngA	; Convert from Integer (A) to Single (ACC)	;0f8c	cd 64 09 	. d .
 4354 0F8F              l0f8fh:
 4355 0F8F C1           	pop bc			;0f8f	c1 	.
 4356 0F90 D1           	pop de			;0f90	d1 	.
 4357 0F91 C3 16 07     	jp sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 ;0f91	c3 16 07 	. . .
 4358 0F94              l0f94h:
 4359 0F94 7B           	ld a,e			;0f94	7b 	{
 4360 0F95 FE 0A        	cp 00ah		;0f95	fe 0a 	. .
 4361 0F97 30 09        	jr nc,$+11		;0f97	30 09 	0 .
 4362 0F99 07           	rlca			;0f99	07 	.
 4363 0F9A 07           	rlca			;0f9a	07 	.
 4364 0F9B 83           	add a,e			;0f9b	83 	.
 4365 0F9C 07           	rlca			;0f9c	07 	.
 4366 0F9D 86           	add a,(hl)			;0f9d	86 	.
 4367 0F9E D6 30        	sub 030h		;0f9e	d6 30 	. 0
 4368 0FA0 5F           	ld e,a			;0fa0	5f 	_
 4369 0FA1 FA 1E 32     	jp m,0321eh		;0fa1	fa 1e 32 	. . 2
 4370 0FA4 C3 BD 0E     	jp l0ebdh		;0fa4	c3 bd 0e 	. . .
 4371 0FA7
 4372 0FA7              ; ********************************************************************************
 4373 0FA7              ; Display "IN xxxxx" (line number)
 4374 0FA7              ; IN: hl - line number
 4375 0FA7              PrintINLINE:
 4376 0FA7 E5           	push hl			        ; save hl                                               ;0fa7	e5 	.
 4377 0FA8 21 24 19     	ld hl,TXT_INLINE		; text "IN "                                            ;0fa8	21 24 19 	! $ .
 4378 0FAB CD A7 28     	call PrintBasicStr		; print "IN " text on Screen                            ;0fab	cd a7 28 	. . (
 4379 0FAE E1           	pop hl			        ; restore hl                                            ;0fae	e1 	.
 4380 0FAF              ; ********************************************************************************
 4381 0FAF              ; Print Line number (any unsigned 16 bit integer)
 4382 0FAF              ; IN: hl - line number
 4383 0FAF              PrintLineNo:
 4384 0FAF CD 9A 0A     	call ACCfromHLValue	; copy value from h; to ACC as integer number           ;0faf	cd 9a 0a 	. . .
 4385 0FB2 AF           	xor a			;0fb2	af 	.
 4386 0FB3 CD 34 10     	call sub_1034h		;0fb3	cd 34 10 	. 4 .
 4387 0FB6 B6           	or (hl)			;0fb6	b6 	.
 4388 0FB7 CD D9 0F     	call sub_0fd9h		;0fb7	cd d9 0f 	. . .
 4389 0FBA C3 A6 28     	jp BAS_SendStringInc	; print null terminated string (CStr) from [hl+1]	;0fba	c3 a6 28 	. . (
 4390 0FBD
 4391 0FBD
 4392 0FBD              ; ********************************************************************************
 4393 0FBD              ; Math: Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)
 4394 0FBD              ; Converts number in ACCUM to ASCII string stored in buffer, and HL register
 4395 0FBD              ; will point to last leading space (that is, the space just before the first
 4396 0FBD              ; non-space character of the created string).
 4397 0FBD              ; When positive integers greater than zero (such as BASIC line numbers) are converted,,
 4398 0FBD              ; the area from 7930 to 7936 is used, and the string is stored right justified
 4399 0FBD              ; with leading spaces (7930 always contains a space character), while 7936
 4400 0FBD              ; always contains a zero byte to terminate the string. Other number types
 4401 0FBD              ; may be converted and stored differently within the buffer.
 4402 0FBD              ; IN: b - number of digits to left of decimal point (include commas)
 4403 0FBD              ;         but exclude space and sign character
 4404 0FBD              ;     c - number of digits to right of decimal point plus one (for dec point)
 4405 0FBD              NumToStr:
 4406 0FBD AF           	xor a			;0fbd	af 	.
 4407 0FBE              ; ********************************************************************************
 4408 0FBE              ; Math: Convert value from ACC (Any) to String in Buffer (7930-7941)
 4409 0FBE              ; Description above except additional formating flags are included in A:
 4410 0FBE              ;	bit 7 - perform edit
 4411 0FBE              ;   bit 6 - include commas
 4412 0FBE              ;	bit 5 - asterix fill
 4413 0FBE              ;	bit 4 - precede by $
 4414 0FBE              ;	bit 3 - force sign (+ or -)
 4415 0FBE              ;	bit 2 - trailing sign
 4416 0FBE              ;	bit 1 - ???
 4417 0FBE              ;	bit 0 - scientific notation
 4418 0FBE              ; IN: b - number of digits to left of decimal point (include commas)
 4419 0FBE              ;         but exclude space and sign character
 4420 0FBE              ;     c - number of digits to right of decimal point plus one (for dec point)
 4421 0FBE              ;     a - format flags on bits 7..0
 4422 0FBE              NumToStrFmt:
 4423 0FBE CD 34 10     	call sub_1034h		;0fbe	cd 34 10 	. 4 .
 4424 0FC1 E6 08        	and 008h		;0fc1	e6 08 	. .
 4425 0FC3 28 02        	jr z,l0fc7h		;0fc3	28 02 	( .
 4426 0FC5 36 2B        	ld (hl),02bh		;0fc5	36 2b 	6 +
 4427 0FC7              l0fc7h:
 4428 0FC7 EB           	ex de,hl			;0fc7	eb 	.
 4429 0FC8 CD 94 09     	call TestACCSign	; Check Sign of number in ACC (Any)		;0fc8	cd 94 09 	. . .
 4430 0FCB EB           	ex de,hl			;0fcb	eb 	.
 4431 0FCC F2 D9 0F     	jp p,sub_0fd9h		;0fcc	f2 d9 0f 	. . .
 4432 0FCF 36 2D        	ld (hl),02dh		;0fcf	36 2d 	6 -
 4433 0FD1 C5           	push bc			;0fd1	c5 	.
 4434 0FD2 E5           	push hl			;0fd2	e5 	.
 4435 0FD3 CD 7B 09     	call l097bh		;0fd3	cd 7b 09 	. { .
 4436 0FD6 E1           	pop hl			;0fd6	e1 	.
 4437 0FD7 C1           	pop bc			;0fd7	c1 	.
 4438 0FD8 B4           	or h			;0fd8	b4 	.
 4439 0FD9              sub_0fd9h:
 4440 0FD9 23           	inc hl			;0fd9	23 	#
 4441 0FDA 36 30        	ld (hl),030h		;0fda	36 30 	6 0
 4442 0FDC 3A D8 78     	ld a,(BAS_TempFlags)	; temporary byte	;0fdc	3a d8 78 	: . x
 4443 0FDF 57           	ld d,a			;0fdf	57 	W
 4444 0FE0 17           	rla			;0fe0	17 	.
 4445 0FE1 3A AF 78     	ld a,(MATH_NTF)		;0fe1	3a af 78 	: . x
 4446 0FE4 DA 9A 10     	jp c,l109ah		;0fe4	da 9a 10 	. . .
 4447 0FE7 CA 92 10     	jp z,l1092h		;0fe7	ca 92 10 	. . .
 4448 0FEA FE 04        	cp 004h		;0fea	fe 04 	. .
 4449 0FEC D2 3D 10     	jp nc,l103dh		;0fec	d2 3d 10 	. = .
 4450 0FEF 01 00 00     	ld bc,$0000		;0fef	01 00 00 	. . .
 4451 0FF2 CD 2F 13     	call sub_132fh		;0ff2	cd 2f 13 	. / .
 4452 0FF5              sub_0ff5h:
 4453 0FF5 21 30 79     	ld hl,SysConvBuffer		;0ff5	21 30 79 	! 0 y
 4454 0FF8 46           	ld b,(hl)			;0ff8	46 	F
 4455 0FF9 0E 20        	ld c,020h		;0ff9	0e 20 	.
 4456 0FFB 3A D8 78     	ld a,(BAS_TempFlags)	; temporary byte	;0ffb	3a d8 78 	: . x
 4457 0FFE 5F           	ld e,a			;0ffe	5f 	_
 4458 0FFF E6 20        	and 020h		;0fff	e6 20 	.
 4459 1001 28 07        	jr z,l100ah		;1001	28 07 	( .
 4460 1003 78           	ld a,b			;1003	78 	x
 4461 1004 B9           	cp c			;1004	b9 	.
 4462 1005 0E 2A        	ld c,02ah		;1005	0e 2a 	. *
 4463 1007 20 01        	jr nz,l100ah		;1007	20 01 	  .
 4464 1009 41           	ld b,c			;1009	41 	A
 4465 100A              l100ah:
 4466 100A 71           	ld (hl),c			;100a	71 	q
 4467 100B D7           	rst $10			; move hl to next Basic token		;100b	d7 	.
 4468 100C 28 14        	jr z,l1022h		; jump if '\0' or ':' - end of statement found ;100c	28 14 	( .
 4469 100E FE 45        	cp 'E'		    ; is it 'E' char ? ;100e	fe 45 	. E
 4470 1010 28 10        	jr z,l1022h		; yes - ;1010	28 10 	( .
 4471 1012 FE 44        	cp 'D'		    ; is it 'D' char ? ;1012	fe 44 	. D
 4472 1014 28 0C        	jr z,l1022h		; yes - ;1014	28 0c 	( .
 4473 1016 FE 30        	cp '0'		    ; is iot '0' char? ;1016	fe 30 	. 0
 4474 1018 28 F0        	jr z,l100ah		; yes - continue ...;1018	28 f0 	( .
 4475 101A FE 2C        	cp ','		    ; is it ',' char ;101a	fe 2c 	. ,
 4476 101C 28 EC        	jr z,l100ah		; yes - continue ...;101c	28 ec 	( .
 4477 101E FE 2E        	cp '.'		    ; is it '.' char ;101e	fe 2e 	. .
 4478 1020 20 03        	jr nz,l1025h	; no - 	;1020	20 03 	  .
 4479 1022              ; -- found '\0', ':', 'E' or 'D'
 4480 1022              l1022h:
 4481 1022 2B           	dec hl			;1022	2b 	+
 4482 1023 36 30        	ld (hl),'0'		;1023	36 30 	6 0
 4483 1025              l1025h:
 4484 1025 7B           	ld a,e			;1025	7b 	{
 4485 1026 E6 10        	and 010h		;1026	e6 10 	. .
 4486 1028 28 03        	jr z,l102dh		;1028	28 03 	( .
 4487 102A 2B           	dec hl			;102a	2b 	+
 4488 102B 36 24        	ld (hl),024h		;102b	36 24 	6 $
 4489 102D              l102dh:
 4490 102D 7B           	ld a,e			;102d	7b 	{
 4491 102E E6 04        	and 004h		;102e	e6 04 	. .
 4492 1030 C0           	ret nz			;1030	c0 	.
 4493 1031 2B           	dec hl			;1031	2b 	+
 4494 1032 70           	ld (hl),b			;1032	70 	p
 4495 1033 C9           	ret			;1033	c9 	.
 4496 1034              sub_1034h:
 4497 1034 32 D8 78     	ld (BAS_TempFlags),a	; temporary byte	;1034	32 d8 78 	2 . x
 4498 1037 21 30 79     	ld hl,SysConvBuffer		;1037	21 30 79 	! 0 y
 4499 103A 36 20        	ld (hl),' '		;103a	36 20 	6
 4500 103C C9           	ret			;103c	c9 	.
 4501 103D
 4502 103D              ; IN - a - NTF (4 for Single or 8 for Double)
 4503 103D              l103dh:
 4504 103D FE 05        	cp 5			; set CY=1 if Single										;103d	fe 05 	. .
 4505 103F E5           	push hl			; save hl ;103f	e5 	.
 4506 1040 DE 00        	sbc a,0			; a - 3 for single, 8 for double ;1040	de 00 	. .
 4507 1042 17           	rla				; a - 1 for single, 4 for double ;1042	17 	.
 4508 1043 57           	ld d,a			; d - 1 for single, 4 for double ;1043	57 	W
 4509 1044 14           	inc d			; d - 2 for single, 5 for double ;1044	14 	.
 4510 1045 CD 01 12     	call sub_1201h		;1045	cd 01 12 	. . .
 4511 1048 01 00 03     	ld bc,$0300		;1048	01 00 03 	. . .
 4512 104B 82           	add a,d			;104b	82 	.
 4513 104C FA 57 10     	jp m,l1057h		;104c	fa 57 10 	. W .
 4514 104F 14           	inc d			;104f	14 	.
 4515 1050 BA           	cp d			;1050	ba 	.
 4516 1051 30 04        	jr nc,l1057h		;1051	30 04 	0 .
 4517 1053 3C           	inc a			;1053	3c 	<
 4518 1054 47           	ld b,a			;1054	47 	G
 4519 1055 3E 02        	ld a,002h		;1055	3e 02 	> .
 4520 1057              l1057h:
 4521 1057 D6 02        	sub 002h		;1057	d6 02 	. .
 4522 1059 E1           	pop hl			;1059	e1 	.
 4523 105A F5           	push af			;105a	f5 	.
 4524 105B CD 91 12     	call sub_1291h		;105b	cd 91 12 	. . .
 4525 105E 36 30        	ld (hl),030h		;105e	36 30 	6 0
 4526 1060 CC C9 09     	call z,inc_hl		;1060	cc c9 09 	. . .
 4527 1063 CD A4 12     	call sub_12a4h		;1063	cd a4 12 	. . .
 4528 1066              l1066h:
 4529 1066 2B           	dec hl			;1066	2b 	+
 4530 1067 7E           	ld a,(hl)			;1067	7e 	~
 4531 1068 FE 30        	cp 030h		;1068	fe 30 	. 0
 4532 106A 28 FA        	jr z,l1066h		;106a	28 fa 	( .
 4533 106C FE 2E        	cp 02eh		;106c	fe 2e 	. .
 4534 106E C4 C9 09     	call nz,inc_hl		;106e	c4 c9 09 	. . .
 4535 1071 F1           	pop af			;1071	f1 	.
 4536 1072 28 1F        	jr z,l1093h		;1072	28 1f 	( .
 4537 1074              sub_1074h:
 4538 1074 F5           	push af			;1074	f5 	.
 4539 1075 E7           	rst #20			; test NTF (Number Type Format) ;1075	e7 	.
 4540 1076 3E 22        	ld a,022h		;1076	3e 22 	> "
 4541 1078 8F           	adc a,a			;1078	8f 	.
 4542 1079 77           	ld (hl),a			;1079	77 	w
 4543 107A 23           	inc hl			;107a	23 	#
 4544 107B F1           	pop af			;107b	f1 	.
 4545 107C 36 2B        	ld (hl),02bh		;107c	36 2b 	6 +
 4546 107E F2 85 10     	jp p,l1085h		;107e	f2 85 10 	. . .
 4547 1081 36 2D        	ld (hl),02dh		;1081	36 2d 	6 -
 4548 1083 2F           	cpl			;1083	2f 	/
 4549 1084 3C           	inc a			;1084	3c 	<
 4550 1085              l1085h:
 4551 1085 06 2F        	ld b,02fh		;1085	06 2f 	. /
 4552 1087              l1087h:
 4553 1087 04           	inc b			;1087	04 	.
 4554 1088 D6 0A        	sub 00ah		;1088	d6 0a 	. .
 4555 108A 30 FB        	jr nc,l1087h		;108a	30 fb 	0 .
 4556 108C C6 3A        	add a,03ah		;108c	c6 3a 	. :
 4557 108E 23           	inc hl			;108e	23 	#
 4558 108F 70           	ld (hl),b			;108f	70 	p
 4559 1090 23           	inc hl			;1090	23 	#
 4560 1091 77           	ld (hl),a			;1091	77 	w
 4561 1092              l1092h:
 4562 1092 23           	inc hl			;1092	23 	#
 4563 1093              l1093h:
 4564 1093 36 00        	ld (hl),000h		;1093	36 00 	6 .
 4565 1095 EB           	ex de,hl			;1095	eb 	.
 4566 1096 21 30 79     	ld hl,SysConvBuffer		;1096	21 30 79 	! 0 y
 4567 1099 C9           	ret			;1099	c9 	.
 4568 109A              l109ah:
 4569 109A 23           	inc hl			;109a	23 	#
 4570 109B C5           	push bc			;109b	c5 	.
 4571 109C FE 04        	cp 004h		;109c	fe 04 	. .
 4572 109E 7A           	ld a,d			;109e	7a 	z
 4573 109F D2 09 11     	jp nc,l1109h		;109f	d2 09 11 	. . .
 4574 10A2 1F           	rra			;10a2	1f 	.
 4575 10A3 DA A3 11     	jp c,l11a3h		;10a3	da a3 11 	. . .
 4576 10A6 01 03 06     	ld bc,0603h		;10a6	01 03 06 	. . .
 4577 10A9 CD 89 12     	call sub_1289h		;10a9	cd 89 12 	. . .
 4578 10AC D1           	pop de			;10ac	d1 	.
 4579 10AD 7A           	ld a,d			;10ad	7a 	z
 4580 10AE D6 05        	sub 005h		;10ae	d6 05 	. .
 4581 10B0 F4 69 12     	call p,sub_1269h		;10b0	f4 69 12 	. i .
 4582 10B3 CD 2F 13     	call sub_132fh		;10b3	cd 2f 13 	. / .
 4583 10B6              l10b6h:
 4584 10B6 7B           	ld a,e			;10b6	7b 	{
 4585 10B7 B7           	or a			;10b7	b7 	.
 4586 10B8 CC 2F 09     	call z,sub_092fh		;10b8	cc 2f 09 	. / .
 4587 10BB 3D           	dec a			;10bb	3d 	=
 4588 10BC F4 69 12     	call p,sub_1269h		;10bc	f4 69 12 	. i .
 4589 10BF              l10bfh:
 4590 10BF E5           	push hl			;10bf	e5 	.
 4591 10C0 CD F5 0F     	call sub_0ff5h		;10c0	cd f5 0f 	. . .
 4592 10C3 E1           	pop hl			;10c3	e1 	.
 4593 10C4 28 02        	jr z,l10c8h		;10c4	28 02 	( .
 4594 10C6 70           	ld (hl),b			;10c6	70 	p
 4595 10C7 23           	inc hl			;10c7	23 	#
 4596 10C8              l10c8h:
 4597 10C8 36 00        	ld (hl),000h		;10c8	36 00 	6 .
 4598 10CA 21 2F 79     	ld hl,0792fh		;10ca	21 2f 79 	! / y
 4599 10CD              l10cdh:
 4600 10CD 23           	inc hl			;10cd	23 	#
 4601 10CE              l10ceh:
 4602 10CE 3A F3 78     	ld a,(BAS_ExprTmpPtr)	;		;10ce	3a f3 78 	: . x
 4603 10D1 95           	sub l			;10d1	95 	.
 4604 10D2 92           	sub d			;10d2	92 	.
 4605 10D3 C8           	ret z			;10d3	c8 	.
 4606 10D4 7E           	ld a,(hl)			;10d4	7e 	~
 4607 10D5 FE 20        	cp 020h		;10d5	fe 20 	.
 4608 10D7 28 F4        	jr z,l10cdh		;10d7	28 f4 	( .
 4609 10D9 FE 2A        	cp 02ah		;10d9	fe 2a 	. *
 4610 10DB 28 F0        	jr z,l10cdh		;10db	28 f0 	( .
 4611 10DD 2B           	dec hl			;10dd	2b 	+
 4612 10DE E5           	push hl			;10de	e5 	.
 4613 10DF              l10dfh:
 4614 10DF F5           	push af			;10df	f5 	.
 4615 10E0 01 DF 10     	ld bc,l10dfh		;10e0	01 df 10 	. . .
 4616 10E3 C5           	push bc			;10e3	c5 	.
 4617 10E4 D7           	rst $10			; move hl to next Basic token			;10e4	d7 	.
 4618 10E5 FE 2D        	cp '-'		    ; is it '-' char ? ;10e5	fe 2d 	. -
 4619 10E7 C8           	ret z			; yes - continue ... ;10e7	c8 	.
 4620 10E8 FE 2B        	cp '+'		    ; is it '+' char ? ;10e8	fe 2b 	. +
 4621 10EA C8           	ret z			; yes - continue ... ;10ea	c8 	.
 4622 10EB FE 24        	cp '$'		    ; is it '$' char ? ;10eb	fe 24 	. $
 4623 10ED C8           	ret z			; yes - continue ...;10ed	c8 	.
 4624 10EE C1           	pop bc			;10ee	c1 	.
 4625 10EF FE 30        	cp '0'		    ; is it '0' char ;10ef	fe 30 	. 0
 4626 10F1 20 0F        	jr nz,l1102h	; no - 	;10f1	20 0f 	  .
 4627 10F3 23           	inc hl			;10f3	23 	#
 4628 10F4 D7           	rst $10			; move hl to next Basic token			;10f4	d7 	.
 4629 10F5 30 0B        	jr nc,l1102h	; jump if Letter found  	;10f5	30 0b 	0 .
 4630 10F7 2B           	dec hl			;10f7	2b 	+
 4631 10F8              ; -- fake opcode to skip
 4632 10F8                  ;ld bc,0772bh		;10f8	01 2b 77 	. + w
 4633 10F8 01               db $01		    ;10f8	01	.
 4634 10F9              l10f9h:
 4635 10F9 2B               dec hl          ;10f9	2b 	+
 4636 10FA 77               ld (hl),a		;10fa	77 	. + w
 4637 10FB F1           	pop af			;10fb	f1 	.
 4638 10FC 28 FB        	jr z,l10f9h		;10fc	28 fb 	( .
 4639 10FE C1           	pop bc			;10fe	c1 	.
 4640 10FF C3 CE 10     	jp l10ceh		;10ff	c3 ce 10 	. . .
 4641 1102              l1102h:
 4642 1102 F1           	pop af			;1102	f1 	.
 4643 1103 28 FD        	jr z,l1102h		;1103	28 fd 	( .
 4644 1105 E1           	pop hl			;1105	e1 	.
 4645 1106 36 25        	ld (hl),025h		;1106	36 25 	6 %
 4646 1108 C9           	ret			;1108	c9 	.
 4647 1109              l1109h:
 4648 1109 E5           	push hl			;1109	e5 	.
 4649 110A 1F           	rra			;110a	1f 	.
 4650 110B DA AA 11     	jp c,l11aah		;110b	da aa 11 	. . .
 4651 110E 28 14        	jr z,l1124h		;110e	28 14 	( .
 4652 1110 11 84 13     	ld de,l1384h		;1110	11 84 13 	. . .
 4653 1113 CD 49 0A     	call ACCCmpDEMem	; Compare ACC and (DE) (Double)	;1113	cd 49 0a 	. I .
 4654 1116 16 10        	ld d,010h		;1116	16 10 	. .
 4655 1118 FA 32 11     	jp m,l1132h		;1118	fa 32 11 	. 2 .
 4656 111B              l111bh:
 4657 111B E1           	pop hl			;111b	e1 	.
 4658 111C C1           	pop bc			;111c	c1 	.
 4659 111D CD BD 0F     	call NumToStr	; Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)	;111d	cd bd 0f 	. . .
 4660 1120 2B           	dec hl			;1120	2b 	+
 4661 1121 36 25        	ld (hl),025h		;1121	36 25 	6 %
 4662 1123 C9           	ret			;1123	c9 	.
 4663 1124              l1124h:
 4664 1124 01 0E B6     	ld bc,0b60eh		;1124	01 0e b6 	. . .
 4665 1127 11 CA 1B     	ld de,l1bcah		;1127	11 ca 1b 	. . .
 4666 112A CD 0C 0A     	call MAT_sCmp_ACC_BCDE		;112a	cd 0c 0a 	. . .
 4667 112D F2 1B 11     	jp p,l111bh		;112d	f2 1b 11 	. . .
 4668 1130 16 06        	ld d,006h		;1130	16 06 	. .
 4669 1132              l1132h:
 4670 1132 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;1132	cd 55 09 	. U .
 4671 1135 C4 01 12     	call nz,sub_1201h		;1135	c4 01 12 	. . .
 4672 1138 E1           	pop hl			;1138	e1 	.
 4673 1139 C1           	pop bc			;1139	c1 	.
 4674 113A FA 57 11     	jp m,l1157h		;113a	fa 57 11 	. W .
 4675 113D C5           	push bc			;113d	c5 	.
 4676 113E 5F           	ld e,a			;113e	5f 	_
 4677 113F 78           	ld a,b			;113f	78 	x
 4678 1140 92           	sub d			;1140	92 	.
 4679 1141 93           	sub e			;1141	93 	.
 4680 1142 F4 69 12     	call p,sub_1269h		;1142	f4 69 12 	. i .
 4681 1145 CD 7D 12     	call sub_127dh		;1145	cd 7d 12 	. } .
 4682 1148 CD A4 12     	call sub_12a4h		;1148	cd a4 12 	. . .
 4683 114B B3           	or e			;114b	b3 	.
 4684 114C C4 77 12     	call nz,sub_1277h		;114c	c4 77 12 	. w .
 4685 114F B3           	or e			;114f	b3 	.
 4686 1150 C4 91 12     	call nz,sub_1291h		;1150	c4 91 12 	. . .
 4687 1153 D1           	pop de			;1153	d1 	.
 4688 1154 C3 B6 10     	jp l10b6h		;1154	c3 b6 10 	. . .
 4689 1157              l1157h:
 4690 1157 5F           	ld e,a			;1157	5f 	_
 4691 1158 79           	ld a,c			;1158	79 	y
 4692 1159 B7           	or a			;1159	b7 	.
 4693 115A C4 16 0F     	call nz,sub_0f16h		;115a	c4 16 0f 	. . .
 4694 115D 83           	add a,e			;115d	83 	.
 4695 115E FA 62 11     	jp m,l1162h		;115e	fa 62 11 	. b .
 4696 1161 AF           	xor a			;1161	af 	.
 4697 1162              l1162h:
 4698 1162 C5           	push bc			;1162	c5 	.
 4699 1163 F5           	push af			;1163	f5 	.
 4700 1164              l1164h:
 4701 1164 FC 18 0F     	call m,MAT_sdDiv_10		;1164	fc 18 0f 	. . .
 4702 1167 FA 64 11     	jp m,l1164h		;1167	fa 64 11 	. d .
 4703 116A C1           	pop bc			;116a	c1 	.
 4704 116B 7B           	ld a,e			;116b	7b 	{
 4705 116C 90           	sub b			;116c	90 	.
 4706 116D C1           	pop bc			;116d	c1 	.
 4707 116E 5F           	ld e,a			;116e	5f 	_
 4708 116F 82           	add a,d			;116f	82 	.
 4709 1170 78           	ld a,b			;1170	78 	x
 4710 1171 FA 7F 11     	jp m,l117fh		;1171	fa 7f 11 	.  .
 4711 1174 92           	sub d			;1174	92 	.
 4712 1175 93           	sub e			;1175	93 	.
 4713 1176 F4 69 12     	call p,sub_1269h		;1176	f4 69 12 	. i .
 4714 1179 C5           	push bc			;1179	c5 	.
 4715 117A CD 7D 12     	call sub_127dh		;117a	cd 7d 12 	. } .
 4716 117D 18 11        	jr l1190h		;117d	18 11 	. .
 4717 117F              l117fh:
 4718 117F CD 69 12     	call sub_1269h		;117f	cd 69 12 	. i .
 4719 1182 79           	ld a,c			;1182	79 	y
 4720 1183 CD 94 12     	call sub_1294h		;1183	cd 94 12 	. . .
 4721 1186 4F           	ld c,a			;1186	4f 	O
 4722 1187 AF           	xor a			;1187	af 	.
 4723 1188 92           	sub d			;1188	92 	.
 4724 1189 93           	sub e			;1189	93 	.
 4725 118A CD 69 12     	call sub_1269h		;118a	cd 69 12 	. i .
 4726 118D C5           	push bc			;118d	c5 	.
 4727 118E 47           	ld b,a			;118e	47 	G
 4728 118F 4F           	ld c,a			;118f	4f 	O
 4729 1190              l1190h:
 4730 1190 CD A4 12     	call sub_12a4h		;1190	cd a4 12 	. . .
 4731 1193 C1           	pop bc			;1193	c1 	.
 4732 1194 B1           	or c			;1194	b1 	.
 4733 1195 20 03        	jr nz,l119ah		;1195	20 03 	  .
 4734 1197 2A F3 78     	ld hl,(BAS_ExprTmpPtr)	; [TRS] expression parser current position	;1197	2a f3 78 	* . x
 4735 119A              l119ah:
 4736 119A 83           	add a,e			;119a	83 	.
 4737 119B 3D           	dec a			;119b	3d 	=
 4738 119C F4 69 12     	call p,sub_1269h		;119c	f4 69 12 	. i .
 4739 119F 50           	ld d,b			;119f	50 	P
 4740 11A0 C3 BF 10     	jp l10bfh		;11a0	c3 bf 10 	. . .
 4741 11A3              l11a3h:
 4742 11A3 E5           	push hl			;11a3	e5 	.
 4743 11A4 D5           	push de			;11a4	d5 	.
 4744 11A5 CD CC 0A     	call MAT_iConvToSng	; Convert from Integer to Single (ACC)		;11a5	cd cc 0a 	. . .
 4745 11A8 D1           	pop de			;11a8	d1 	.
 4746 11A9 AF           	xor a			;11a9	af 	.
 4747 11AA              l11aah:
 4748 11AA CA B0 11     	jp z,011b0h		;11aa	ca b0 11 	. . .
 4749 11AD 1E 10        	ld e,010h		;11ad	1e 10 	. .
 4750 11AF 01 1E 06     	ld bc,0061eh		;11af	01 1e 06 	. . .
 4751 11B2 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;11b2	cd 55 09 	. U .
 4752 11B5 37           	scf			;11b5	37 	7
 4753 11B6 C4 01 12     	call nz,sub_1201h		;11b6	c4 01 12 	. . .
 4754 11B9 E1           	pop hl			;11b9	e1 	.
 4755 11BA C1           	pop bc			;11ba	c1 	.
 4756 11BB F5           	push af			;11bb	f5 	.
 4757 11BC 79           	ld a,c			;11bc	79 	y
 4758 11BD B7           	or a			;11bd	b7 	.
 4759 11BE F5           	push af			;11be	f5 	.
 4760 11BF C4 16 0F     	call nz,sub_0f16h		;11bf	c4 16 0f 	. . .
 4761 11C2 80           	add a,b			;11c2	80 	.
 4762 11C3 4F           	ld c,a			;11c3	4f 	O
 4763 11C4 7A           	ld a,d			;11c4	7a 	z
 4764 11C5 E6 04        	and 004h		;11c5	e6 04 	. .
 4765 11C7 FE 01        	cp 001h		;11c7	fe 01 	. .
 4766 11C9 9F           	sbc a,a			;11c9	9f 	.
 4767 11CA 57           	ld d,a			;11ca	57 	W
 4768 11CB 81           	add a,c			;11cb	81 	.
 4769 11CC 4F           	ld c,a			;11cc	4f 	O
 4770 11CD 93           	sub e			;11cd	93 	.
 4771 11CE F5           	push af			;11ce	f5 	.
 4772 11CF C5           	push bc			;11cf	c5 	.
 4773 11D0              l11d0h:
 4774 11D0 FC 18 0F     	call m,MAT_sdDiv_10		;11d0	fc 18 0f 	. . .
 4775 11D3 FA D0 11     	jp m,l11d0h		;11d3	fa d0 11 	. . .
 4776 11D6 C1           	pop bc			;11d6	c1 	.
 4777 11D7 F1           	pop af			;11d7	f1 	.
 4778 11D8 C5           	push bc			;11d8	c5 	.
 4779 11D9 F5           	push af			;11d9	f5 	.
 4780 11DA FA DE 11     	jp m,l11deh		;11da	fa de 11 	. . .
 4781 11DD AF           	xor a			;11dd	af 	.
 4782 11DE              l11deh:
 4783 11DE 2F           	cpl			;11de	2f 	/
 4784 11DF 3C           	inc a			;11df	3c 	<
 4785 11E0 80           	add a,b			;11e0	80 	.
 4786 11E1 3C           	inc a			;11e1	3c 	<
 4787 11E2 82           	add a,d			;11e2	82 	.
 4788 11E3 47           	ld b,a			;11e3	47 	G
 4789 11E4 0E 00        	ld c,000h		;11e4	0e 00 	. .
 4790 11E6 CD A4 12     	call sub_12a4h		;11e6	cd a4 12 	. . .
 4791 11E9 F1           	pop af			;11e9	f1 	.
 4792 11EA F4 71 12     	call p,sub_1271h		;11ea	f4 71 12 	. q .
 4793 11ED C1           	pop bc			;11ed	c1 	.
 4794 11EE F1           	pop af			;11ee	f1 	.
 4795 11EF CC 2F 09     	call z,sub_092fh		;11ef	cc 2f 09 	. / .
 4796 11F2 F1           	pop af			;11f2	f1 	.
 4797 11F3 38 03        	jr c,l11f8h		;11f3	38 03 	8 .
 4798 11F5 83           	add a,e			;11f5	83 	.
 4799 11F6 90           	sub b			;11f6	90 	.
 4800 11F7 92           	sub d			;11f7	92 	.
 4801 11F8              l11f8h:
 4802 11F8 C5           	push bc			;11f8	c5 	.
 4803 11F9 CD 74 10     	call sub_1074h		;11f9	cd 74 10 	. t .
 4804 11FC EB           	ex de,hl			;11fc	eb 	.
 4805 11FD D1           	pop de			;11fd	d1 	.
 4806 11FE C3 BF 10     	jp l10bfh		;11fe	c3 bf 10 	. . .
 4807 1201              sub_1201h:
 4808 1201 D5           	push de			;1201	d5 	.
 4809 1202 AF           	xor a			;1202	af 	.
 4810 1203 F5           	push af			;1203	f5 	.
 4811 1204 E7           	rst #20			; test NTF (Number Type Format)	- is it Single?	;1204	e7 	.
 4812 1205 E2 22 12     	jp po,l1222h	; yes -	;1205	e2 22 12 	. " .
 4813 1208              l1208h:
 4814 1208 3A 24 79     	ld a,(MATH_ACC_EXP)		;1208	3a 24 79 	: $ y
 4815 120B FE 91        	cp 091h		;120b	fe 91 	. .
 4816 120D D2 22 12     	jp nc,l1222h		;120d	d2 22 12 	. " .
 4817 1210 11 64 13     	ld de,CONSTd_1e10	; constant double value 1e10	;1210	11 64 13 	. d .
 4818 1213 21 27 79     	ld hl,ACC2		; address of 2nd Accumulator ;1213	21 27 79 	! ' y
 4819 1216 CD D3 09     	call DEMemToHLMem	; copy math variable from (de) to (hl) mem			;1216	cd d3 09 	. . .
 4820 1219 CD A1 0D     	call dblACCmulACC2	; ACC = ACC * ACC2 (Double)	;1219	cd a1 0d 	. . .
 4821 121C F1           	pop af			;121c	f1 	.
 4822 121D D6 0A        	sub 00ah		;121d	d6 0a 	. .
 4823 121F F5           	push af			;121f	f5 	.
 4824 1220 18 E6        	jr l1208h		;1220	18 e6 	. .
 4825 1222              l1222h:
 4826 1222 CD 4F 12     	call sub_124fh		;1222	cd 4f 12 	. O .
 4827 1225              l1225h:
 4828 1225 E7           	rst #20			; test NTF (Number Type Format) ;1225	e7 	.
 4829 1226 EA 34 12     	jp pe,l1234h	; Double - 	;1226	ea 34 12 	. 4 .
 4830 1229              ; -- Single
 4831 1229 01 43 91     	ld bc,$9143		;1229	01 43 91 	. C .
 4832 122C 11 F9 4F     	ld de,$4ff9		; BCDE = 99999.9	;122c	11 f9 4f 	. . O
 4833 122F CD 0C 0A     	call MAT_sCmp_ACC_BCDE		;122f	cd 0c 0a 	. . .
 4834 1232 18 06        	jr l123ah		;1232	18 06 	. .
 4835 1234              l1234h:
 4836 1234 11 6C 13     	ld de,CONSTd_1e15	; constant double value 1e15	;1234	11 6c 13 	. l .
 4837 1237 CD 49 0A     	call ACCCmpDEMem	; Compare ACC and (DE) (Double)		;1237	cd 49 0a 	. I .
 4838 123A              l123ah:
 4839 123A F2 4C 12     	jp p,l124ch		;123a	f2 4c 12 	. L .
 4840 123D F1           	pop af			;123d	f1 	.
 4841 123E CD 0B 0F     	call sub_0f0bh		;123e	cd 0b 0f 	. . .
 4842 1241 F5           	push af			;1241	f5 	.
 4843 1242 18 E1        	jr l1225h		;1242	18 e1 	. .
 4844 1244              l1244h:
 4845 1244 F1           	pop af			;1244	f1 	.
 4846 1245 CD 18 0F     	call MAT_sdDiv_10		;1245	cd 18 0f 	. . .
 4847 1248 F5           	push af			;1248	f5 	.
 4848 1249 CD 4F 12     	call sub_124fh		;1249	cd 4f 12 	. O .
 4849 124C              l124ch:
 4850 124C F1           	pop af			;124c	f1 	.
 4851 124D D1           	pop de			;124d	d1 	.
 4852 124E C9           	ret			;124e	c9 	.
 4853 124F              sub_124fh:
 4854 124F E7           	rst #20			; test NTF (Number Type Format) ;124f	e7 	.
 4855 1250 EA 5E 12     	jp pe,l125eh	; Double - 	;1250	ea 5e 12 	. ^ .
 4856 1253              ; -- Single
 4857 1253 01 74 94     	ld bc,$9474		;1253	01 74 94 	. t .
 4858 1256 11 F8 23     	ld de,$23f8		; BCDE = 999999,5 ;1256	11 f8 23 	. . #
 4859 1259 CD 0C 0A     	call MAT_sCmp_ACC_BCDE		;1259	cd 0c 0a 	. . .
 4860 125C 18 06        	jr l1264h		;125c	18 06 	. .
 4861 125E              l125eh:
 4862 125E 11 74 13     	ld de,CONSTd_1e16	; constant double value	= 1e16	;125e	11 74 13 	. t .
 4863 1261 CD 49 0A     	call ACCCmpDEMem	; Compare ACC and (DE) (Double)		;1261	cd 49 0a 	. I .
 4864 1264              l1264h:
 4865 1264 E1           	pop hl			;1264	e1 	.
 4866 1265 F2 44 12     	jp p,l1244h		;1265	f2 44 12 	. D .
 4867 1268 E9           	jp (hl)			;1268	e9 	.
 4868 1269              sub_1269h:
 4869 1269 B7           	or a			;1269	b7 	.
 4870 126A              l126ah:
 4871 126A C8           	ret z			;126a	c8 	.
 4872 126B 3D           	dec a			;126b	3d 	=
 4873 126C 36 30        	ld (hl),030h		;126c	36 30 	6 0
 4874 126E 23           	inc hl			;126e	23 	#
 4875 126F 18 F9        	jr l126ah		;126f	18 f9 	. .
 4876 1271              sub_1271h:
 4877 1271 20 04        	jr nz,sub_1277h		;1271	20 04 	  .
 4878 1273              l1273h:
 4879 1273 C8           	ret z			;1273	c8 	.
 4880 1274 CD 91 12     	call sub_1291h		;1274	cd 91 12 	. . .
 4881 1277              sub_1277h:
 4882 1277 36 30        	ld (hl),030h		;1277	36 30 	6 0
 4883 1279 23           	inc hl			;1279	23 	#
 4884 127A 3D           	dec a			;127a	3d 	=
 4885 127B 18 F6        	jr l1273h		;127b	18 f6 	. .
 4886 127D              sub_127dh:
 4887 127D 7B           	ld a,e			;127d	7b 	{
 4888 127E 82           	add a,d			;127e	82 	.
 4889 127F 3C           	inc a			;127f	3c 	<
 4890 1280 47           	ld b,a			;1280	47 	G
 4891 1281 3C           	inc a			;1281	3c 	<
 4892 1282              l1282h:
 4893 1282 D6 03        	sub 003h		;1282	d6 03 	. .
 4894 1284 30 FC        	jr nc,l1282h		;1284	30 fc 	0 .
 4895 1286 C6 05        	add a,005h		;1286	c6 05 	. .
 4896 1288 4F           	ld c,a			;1288	4f 	O
 4897 1289              sub_1289h:
 4898 1289 3A D8 78     	ld a,(BAS_TempFlags)	; temporary byte	;1289	3a d8 78 	: . x
 4899 128C E6 40        	and 040h		;128c	e6 40 	. @
 4900 128E C0           	ret nz			;128e	c0 	.
 4901 128F 4F           	ld c,a			;128f	4f 	O
 4902 1290 C9           	ret			;1290	c9 	.
 4903 1291              sub_1291h:
 4904 1291 05           	dec b			;1291	05 	.
 4905 1292 20 08        	jr nz,l129ch		;1292	20 08 	  .
 4906 1294              sub_1294h:
 4907 1294 36 2E        	ld (hl),02eh		;1294	36 2e 	6 .
 4908 1296 22 F3 78     	ld (BAS_ExprTmpPtr),hl	; [TRS] expression parser current position		;1296	22 f3 78 	" . x
 4909 1299 23           	inc hl			;1299	23 	#
 4910 129A 48           	ld c,b			;129a	48 	H
 4911 129B C9           	ret			;129b	c9 	.
 4912 129C              l129ch:
 4913 129C 0D           	dec c			;129c	0d 	.
 4914 129D C0           	ret nz			;129d	c0 	.
 4915 129E 36 2C        	ld (hl),02ch		;129e	36 2c 	6 ,
 4916 12A0 23           	inc hl			;12a0	23 	#
 4917 12A1 0E 03        	ld c,003h		;12a1	0e 03 	. .
 4918 12A3 C9           	ret			;12a3	c9 	.
 4919 12A4              sub_12a4h:
 4920 12A4 D5           	push de			;12a4	d5 	.
 4921 12A5 E7           	rst #20			; test NTF (Number Type Format) ;12a5	e7 	.
 4922 12A6 E2 EA 12     	jp po,l12eah	; Single - 	;12a6	e2 ea 12 	. . .
 4923 12A9 C5           	push bc			;12a9	c5 	.
 4924 12AA E5           	push hl			;12aa	e5 	.
 4925 12AB CD FC 09     	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;12ab	cd fc 09 	. . .
 4926 12AE 21 7C 13     	ld hl,sngConst_0		; Constant value 0 (Single) ;12ae	21 7c 13 	! | .
 4927 12B1 CD F7 09     	call HLMemToACC_DBL	; Copy value from (HL) to ACC (Any)	;12b1	cd f7 09 	. . .
 4928 12B4 CD 77 0C     	call ACCAddACC2	; Math : ACC = ACC + ACC2 (Double)	;12b4	cd 77 0c 	. w .
 4929 12B7 AF           	xor a			;12b7	af 	.
 4930 12B8 CD 7B 0B     	call sub_0b7bh		;12b8	cd 7b 0b 	. { .
 4931 12BB E1           	pop hl			;12bb	e1 	.
 4932 12BC C1           	pop bc			;12bc	c1 	.
 4933 12BD 11 8C 13     	ld de,l138ch		;12bd	11 8c 13 	. . .
 4934 12C0 3E 0A        	ld a,00ah		;12c0	3e 0a 	> .
 4935 12C2              l12c2h:
 4936 12C2 CD 91 12     	call sub_1291h		;12c2	cd 91 12 	. . .
 4937 12C5 C5           	push bc			;12c5	c5 	.
 4938 12C6 F5           	push af			;12c6	f5 	.
 4939 12C7 E5           	push hl			;12c7	e5 	.
 4940 12C8 D5           	push de			;12c8	d5 	.
 4941 12C9 06 2F        	ld b,02fh		;12c9	06 2f 	. /
 4942 12CB              l12cbh:
 4943 12CB 04           	inc b			;12cb	04 	.
 4944 12CC E1           	pop hl			;12cc	e1 	.
 4945 12CD E5           	push hl			;12cd	e5 	.
 4946 12CE CD 48 0D     	call sub_0d48h		;12ce	cd 48 0d 	. H .
 4947 12D1 30 F8        	jr nc,l12cbh		;12d1	30 f8 	0 .
 4948 12D3 E1           	pop hl			;12d3	e1 	.
 4949 12D4 CD 36 0D     	call ACCAddHLMem_MO	; ACC = ACC + [HL] - MANTISSA only	;12d4	cd 36 0d 	. 6 .
 4950 12D7 EB           	ex de,hl			;12d7	eb 	.
 4951 12D8 E1           	pop hl			;12d8	e1 	.
 4952 12D9 70           	ld (hl),b			;12d9	70 	p
 4953 12DA 23           	inc hl			;12da	23 	#
 4954 12DB F1           	pop af			;12db	f1 	.
 4955 12DC C1           	pop bc			;12dc	c1 	.
 4956 12DD 3D           	dec a			;12dd	3d 	=
 4957 12DE 20 E2        	jr nz,l12c2h		;12de	20 e2 	  .
 4958 12E0 C5           	push bc			;12e0	c5 	.
 4959 12E1 E5           	push hl			;12e1	e5 	.
 4960 12E2 21 1D 79     	ld hl,ACC_DBL		; addres of Accumulator (Double);12e2	21 1d 79 	! . y
 4961 12E5 CD B1 09     	call MAT_sCopyHLToACC_DBL		;12e5	cd b1 09 	. . .
 4962 12E8 18 0C        	jr l12f6h		;12e8	18 0c 	. .
 4963 12EA              l12eah:
 4964 12EA C5           	push bc			;12ea	c5 	.
 4965 12EB E5           	push hl			;12eb	e5 	.
 4966 12EC CD 08 07     	call sngACCadd05	; ACC = ACC + 0.5 (Single)	;12ec	cd 08 07 	. . .
 4967 12EF 3C           	inc a			;12ef	3c 	<
 4968 12F0 CD FB 0A     	call sub_0afbh		;12f0	cd fb 0a 	. . .
 4969 12F3 CD B4 09     	call BCDEToACC_DBL		; copy value from BCDE to ACC (Single)	;12f3	cd b4 09 	. . .
 4970 12F6              l12f6h:
 4971 12F6 E1           	pop hl			;12f6	e1 	.
 4972 12F7 C1           	pop bc			;12f7	c1 	.
 4973 12F8 AF           	xor a			;12f8	af 	.
 4974 12F9 11 D2 13     	ld de,l13d2h		;12f9	11 d2 13 	. . .
 4975 12FC              l12fch:
 4976 12FC 3F           	ccf			;12fc	3f 	?
 4977 12FD CD 91 12     	call sub_1291h		;12fd	cd 91 12 	. . .
 4978 1300 C5           	push bc			;1300	c5 	.
 4979 1301 F5           	push af			;1301	f5 	.
 4980 1302 E5           	push hl			;1302	e5 	.
 4981 1303 D5           	push de			;1303	d5 	.
 4982 1304 CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;1304	cd bf 09 	. . .
 4983 1307 E1           	pop hl			;1307	e1 	.
 4984 1308 06 2F        	ld b,02fh		;1308	06 2f 	. /
 4985 130A              l130ah:
 4986 130A 04           	inc b			;130a	04 	.
 4987 130B 7B           	ld a,e			;130b	7b 	{
 4988 130C 96           	sub (hl)			;130c	96 	.
 4989 130D 5F           	ld e,a			;130d	5f 	_
 4990 130E 23           	inc hl			;130e	23 	#
 4991 130F 7A           	ld a,d			;130f	7a 	z
 4992 1310 9E           	sbc a,(hl)			;1310	9e 	.
 4993 1311 57           	ld d,a			;1311	57 	W
 4994 1312 23           	inc hl			;1312	23 	#
 4995 1313 79           	ld a,c			;1313	79 	y
 4996 1314 9E           	sbc a,(hl)			;1314	9e 	.
 4997 1315 4F           	ld c,a			;1315	4f 	O
 4998 1316 2B           	dec hl			;1316	2b 	+
 4999 1317 2B           	dec hl			;1317	2b 	+
 5000 1318 30 F0        	jr nc,l130ah		;1318	30 f0 	0 .
 5001 131A CD B7 07     	call sub_07b7h		;131a	cd b7 07 	. . .
 5002 131D 23           	inc hl			;131d	23 	#
 5003 131E CD B4 09     	call BCDEToACC_DBL	; copy value from BCDE to ACC (Single)		;131e	cd b4 09 	. . .
 5004 1321 EB           	ex de,hl			;1321	eb 	.
 5005 1322 E1           	pop hl			;1322	e1 	.
 5006 1323 70           	ld (hl),b			;1323	70 	p
 5007 1324 23           	inc hl			;1324	23 	#
 5008 1325 F1           	pop af			;1325	f1 	.
 5009 1326 C1           	pop bc			;1326	c1 	.
 5010 1327 38 D3        	jr c,l12fch		;1327	38 d3 	8 .
 5011 1329 13           	inc de			;1329	13 	.
 5012 132A 13           	inc de			;132a	13 	.
 5013 132B 3E 04        	ld a,004h		;132b	3e 04 	> .
 5014 132D 18 06        	jr l1335h		;132d	18 06 	. .
 5015 132F              sub_132fh:
 5016 132F D5           	push de			;132f	d5 	.
 5017 1330 11 D8 13     	ld de,l13d8h		;1330	11 d8 13 	. . .
 5018 1333 3E 05        	ld a,005h		;1333	3e 05 	> .
 5019 1335              l1335h:
 5020 1335 CD 91 12     	call sub_1291h		;1335	cd 91 12 	. . .
 5021 1338 C5           	push bc			;1338	c5 	.
 5022 1339 F5           	push af			;1339	f5 	.
 5023 133A E5           	push hl			;133a	e5 	.
 5024 133B EB           	ex de,hl			;133b	eb 	.
 5025 133C 4E           	ld c,(hl)			;133c	4e 	N
 5026 133D 23           	inc hl			;133d	23 	#
 5027 133E 46           	ld b,(hl)			;133e	46 	F
 5028 133F C5           	push bc			;133f	c5 	.
 5029 1340 23           	inc hl			;1340	23 	#
 5030 1341 E3           	ex (sp),hl			;1341	e3 	.
 5031 1342 EB           	ex de,hl			;1342	eb 	.
 5032 1343 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;1343	2a 21 79 	* ! y
 5033 1346 06 2F        	ld b,02fh		;1346	06 2f 	. /
 5034 1348              l1348h:
 5035 1348 04           	inc b			;1348	04 	.
 5036 1349              l1349h:
 5037 1349 7D           	ld a,l			;1349	7d 	}
 5038 134A 93           	sub e			;134a	93 	.
 5039 134B 6F           	ld l,a			;134b	6f 	o
 5040 134C 7C           	ld a,h			;134c	7c 	|
 5041 134D 9A           	sbc a,d			;134d	9a 	.
 5042 134E 67           	ld h,a			;134e	67 	g
 5043 134F 30 F7        	jr nc,l1348h		;134f	30 f7 	0 .
 5044 1351 19           	add hl,de			;1351	19 	.
 5045 1352 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;1352	22 21 79 	" ! y
 5046 1355 D1           	pop de			;1355	d1 	.
 5047 1356 E1           	pop hl			;1356	e1 	.
 5048 1357 70           	ld (hl),b			;1357	70 	p
 5049 1358 23           	inc hl			;1358	23 	#
 5050 1359 F1           	pop af			;1359	f1 	.
 5051 135A C1           	pop bc			;135a	c1 	.
 5052 135B 3D           	dec a			;135b	3d 	=
 5053 135C 20 D7        	jr nz,l1335h		;135c	20 d7 	  .
 5054 135E CD 91 12     	call sub_1291h		;135e	cd 91 12 	. . .
 5055 1361 77           	ld (hl),a			;1361	77 	w
 5056 1362 D1           	pop de			;1362	d1 	.
 5057 1363 C9           	ret			;1363	c9 	.
 5058 1364
 5059 1364
 5060 1364              CONSTd_1e10: // Double Value = 10 000 000 000
 5061 1364 00 00 00 00  	dword	$00000000			;1364	00 00 00 00 	.
 5062 1368 F9 02 15 A2  	dword 	$a21502f9			;1368	f9 02 15 a2 	.
 5063 136C              CONSTd_1e15: // Double Value = 999 999 999 999 999,9
 5064 136C FD FF 9F 31  	dword 	$319ffffd			;136c	fd ff 9f 31	. . .
 5065 1370 A9 5F 63 B2  	dword 	$b2635fa9			;1370	a9 5f 63 b2 	.
 5066 1374              CONSTd_1e16: // Double Value = 9 999 999 999 999 998
 5067 1374 FE FF 03 BF  	dword 	$bf03fffe			;1374	fe ff 03 bf 	.
 5068 1378 C9 1B 0E B6  	dword	$b60e1bc9			;1378	c9 1b 0e b6 	. .
 5069 137C
 5070 137C              ; ********************************************************************************
 5071 137C              ; Math : Constant Value 0 (Single)
 5072 137C              sngConst_0:
 5073 137C 00 00 00 00  	dword #00000000			;137c	00 00 00 00 	.
 5074 1380
 5075 1380              ; ********************************************************************************
 5076 1380              ; Math : Constant Value 0.5 (Single)
 5077 1380              sngConst_05:
 5078 1380 00 00 00 80  	dword #80000000			;1380	00 00 00 80 	.
 5079 1384              l1384h: // Double Value = 10 000 000 000 000 000
 5080 1384 00           	nop			;1384	00 	.
 5081 1385 00           	nop			;1385	00 	.
 5082 1386 04           	inc b			;1386	04 	.
 5083 1387 BF           	cp a			;1387	bf 	.
 5084 1388 C9           	ret			;1388	c9 	.
 5085 1389 1B           	dec de			;1389	1b 	.
 5086 138A 0E B6        	ld c,0b6h		;138a	0e b6 	. .
 5087 138C              l138ch:
 5088 138C 00           	nop			;138c	00 	.
 5089 138D 80           	add a,b			;138d	80 	.
 5090 138E C6 A4        	add a,0a4h		;138e	c6 a4 	. .
 5091 1390 7E           	ld a,(hl)			;1390	7e 	~
 5092 1391 8D           	adc a,l			;1391	8d 	.
 5093 1392 03           	inc bc			;1392	03 	.
 5094 1393 00           	nop			;1393	00 	.
 5095 1394 40           	ld b,b			;1394	40 	@
 5096 1395 7A           	ld a,d			;1395	7a 	z
 5097 1396 10 F3        	djnz $-11		;1396	10 f3 	. .
 5098 1398 5A           	ld e,d			;1398	5a 	Z
 5099 1399 00           	nop			;1399	00 	.
 5100 139A 00           	nop			;139a	00 	.
 5101 139B A0           	and b			;139b	a0 	.
 5102 139C 72           	ld (hl),d			;139c	72 	r
 5103 139D 4E           	ld c,(hl)			;139d	4e 	N
 5104 139E 18 09        	jr l13a9h		;139e	18 09 	. .
 5105 13A0 00           	nop			;13a0	00 	.
 5106 13A1 00           	nop			;13a1	00 	.
 5107 13A2 10 A5        	djnz l1349h		;13a2	10 a5 	. .
 5108 13A4 D4 E8 00     	call nc,sub_00e8h		;13a4	d4 e8 00 	. . .
 5109 13A7 00           	nop			;13a7	00 	.
 5110 13A8 00           	nop			;13a8	00 	.
 5111 13A9              l13a9h:
 5112 13A9 E8           	ret pe			;13a9	e8 	.
 5113 13AA 76           	halt			;13aa	76 	v
 5114 13AB 48           	ld c,b			;13ab	48 	H
 5115 13AC 17           	rla			;13ac	17 	.
 5116 13AD 00           	nop			;13ad	00 	.
 5117 13AE 00           	nop			;13ae	00 	.
 5118 13AF 00           	nop			;13af	00 	.
 5119 13B0 E4 0B 54     	call po,0540bh		;13b0	e4 0b 54 	. . T
 5120 13B3 02           	ld (bc),a			;13b3	02 	.
 5121 13B4 00           	nop			;13b4	00 	.
 5122 13B5 00           	nop			;13b5	00 	.
 5123 13B6 00           	nop			;13b6	00 	.
 5124 13B7 CA 9A 3B     	db $ca,$9a,$3b		;13b7	ca 9a 3b 	. . ;
 5125 13BA 00           	nop			;13ba	00 	.
 5126 13BB 00           	nop			;13bb	00 	.
 5127 13BC 00           	nop			;13bc	00 	.
 5128 13BD 00           	nop			;13bd	00 	.
 5129 13BE E1           	pop hl			;13be	e1 	.
 5130 13BF F5           	push af			;13bf	f5 	.
 5131 13C0 05           	dec b			;13c0	05 	.
 5132 13C1 00           	nop			;13c1	00 	.
 5133 13C2 00           	nop			;13c2	00 	.
 5134 13C3 00           	nop			;13c3	00 	.
 5135 13C4 80           	add a,b			;13c4	80 	.
 5136 13C5 96           	sub (hl)			;13c5	96 	.
 5137 13C6 98           	sbc a,b			;13c6	98 	.
 5138 13C7 00           	nop			;13c7	00 	.
 5139 13C8 00           	nop			;13c8	00 	.
 5140 13C9 00           	nop			;13c9	00 	.
 5141 13CA 00           	nop			;13ca	00 	.
 5142 13CB 40           	ld b,b			;13cb	40 	@
 5143 13CC 42           	ld b,d			;13cc	42 	B
 5144 13CD 0F           	rrca			;13cd	0f 	.
 5145 13CE 00           	nop			;13ce	00 	.
 5146 13CF 00           	nop			;13cf	00 	.
 5147 13D0 00           	nop			;13d0	00 	.
 5148 13D1 00           	nop			;13d1	00 	.
 5149 13D2              l13d2h:
 5150 13D2 A0           	and b			;13d2	a0 	.
 5151 13D3 86           	add a,(hl)			;13d3	86 	.
 5152 13D4 01 10 27     	ld bc,l2710h		;13d4	01 10 27 	. . '
 5153 13D7 00           	nop			;13d7	00 	.
 5154 13D8              l13d8h:
 5155 13D8 10 27        	djnz l1401h		;13d8	10 27 	. '
 5156 13DA E8           	ret pe			;13da	e8 	.
 5157 13DB 03           	inc bc			;13db	03 	.
 5158 13DC 64           	ld h,h			;13dc	64 	d
 5159 13DD 00           	nop			;13dd	00 	.
 5160 13DE 0A           	ld a,(bc)			;13de	0a 	.
 5161 13DF 00           	nop			;13df	00 	.
 5162 13E0 01 00 21     	ld bc,l2100h		;13e0	01 00 21 	. . !
 5163 13E3 82           	add a,d			;13e3	82 	.
 5164 13E4 09           	add hl,bc			;13e4	09 	.
 5165 13E5 E3           	ex (sp),hl			;13e5	e3 	.
 5166 13E6 E9           	jp (hl)			;13e6	e9 	.
 5167 13E7
 5168 13E7              ; ********************************************************************************
 5169 13E7              ; [TRS] BASIC SQR Entry Point
 5170 13E7              ; Math : ACC = SQR(ACC) (Any -> Single)
 5171 13E7              FuncSQR
 5172 13E7 CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;13e7	cd a4 09 	. . .
 5173 13EA 21 80 13     	ld hl,sngConst_05	; Constant Value 0.5 (Single)	;13ea	21 80 13 	! . .
 5174 13ED CD B1 09     	call MAT_sCopyHLToACC_DBL		;13ed	cd b1 09 	. . .
 5175 13F0 18 03        	jr SPsPowACC_DBL		;13f0	18 03 	. .
 5176 13F2
 5177 13F2              ; ********************************************************************************
 5178 13F2              ; Math : ACC = STACK ^ ACC (Any -> Single)
 5179 13F2              STACKPowACC_DBL:
 5180 13F2 CD B1 0A     	call FuncCSNG	; convert ACC to Single value		;13f2	cd b1 0a 	. . .
 5181 13F5
 5182 13F5              ; ********************************************************************************
 5183 13F5              ; Math : ACC = (STACK) ^ ACC (Single)
 5184 13F5              SPsPowACC_DBL:
 5185 13F5 C1           	pop bc			;13f5	c1 	.
 5186 13F6 D1           	pop de			;13f6	d1 	.
 5187 13F7
 5188 13F7              ; ********************************************************************************
 5189 13F7              ; Math : ACC = BCDE ^ ACC (Single)
 5190 13F7              BCDEsPowACC_DBL
 5191 13F7 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;13f7	cd 55 09 	. U .
 5192 13FA 78           	ld a,b			;13fa	78 	x
 5193 13FB 28 3C        	jr z,FuncEXP		; compute EXP function		;13fb	28 3c 	( <
 5194 13FD F2 04 14     	jp p,l1404h		;13fd	f2 04 14 	. . .
 5195 1400 B7           	or a			;1400	b7 	.
 5196 1401              l1401h:
 5197 1401 CA 9A 19     	jp z,ErrRaiseDivByZero	; if a = 0 Raise 'DIVISION BY ZERO' error	;1401	ca 9a 19 	. . .
 5198 1404              l1404h:
 5199 1404 B7           	or a			;1404	b7 	.
 5200 1405 CA 79 07     	jp z,l0779h		;1405	ca 79 07 	. y .
 5201 1408 D5           	push de			;1408	d5 	.
 5202 1409 C5           	push bc			;1409	c5 	.
 5203 140A 79           	ld a,c			;140a	79 	y
 5204 140B F6 7F        	or 07fh		;140b	f6 7f 	. 
 5205 140D CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;140d	cd bf 09 	. . .
 5206 1410 F2 21 14     	jp p,l1421h		;1410	f2 21 14 	. ! .
 5207 1413 D5           	push de			;1413	d5 	.
 5208 1414 C5           	push bc			;1414	c5 	.
 5209 1415 CD 40 0B     	call sub_0b40h		;1415	cd 40 0b 	. @ .
 5210 1418 C1           	pop bc			;1418	c1 	.
 5211 1419 D1           	pop de			;1419	d1 	.
 5212 141A F5           	push af			;141a	f5 	.
 5213 141B CD 0C 0A     	call MAT_sCmp_ACC_BCDE		;141b	cd 0c 0a 	. . .
 5214 141E              l141eh:
 5215 141E E1           	pop hl			;141e	e1 	.
 5216 141F 7C           	ld a,h			;141f	7c 	|
 5217 1420 1F           	rra			;1420	1f 	.
 5218 1421              l1421h:
 5219 1421 E1           	pop hl			;1421	e1 	.
 5220 1422 22 23 79     	ld (ACC_SNG+2),hl	 ; Int,Single,String (2 or 4 bytes): 	;1422	22 23 79 	" # y
 5221 1425 E1           	pop hl			;1425	e1 	.
 5222 1426 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;1426	22 21 79 	" ! y
 5223 1429 DC E2 13     	call c,013e2h		;1429	dc e2 13 	. . .
 5224 142C CC 82 09     	call z,sngACCnegate		;  ACC = -ACC (Single) ;142c	cc 82 09 	. . .
 5225 142F D5           	push de			;142f	d5 	.
 5226 1430 C5           	push bc			;1430	c5 	.
 5227 1431 CD 09 08     	call FuncLOG		; compute LOG function ;1431	cd 09 08 	. . .
 5228 1434 C1           	pop bc			;1434	c1 	.
 5229 1435 D1           	pop de			;1435	d1 	.
 5230 1436 CD 47 08     	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;1436	cd 47 08 	. G .
 5231 1439
 5232 1439              ; ********************************************************************************
 5233 1439              ; [TRS] BASIC EXP Entry Point
 5234 1439              ; Math : ACC = EXP(ACC) (Any -> Single)
 5235 1439              FuncEXP:
 5236 1439 CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;1439	cd a4 09 	. . .
 5237 143C 01 38 81     	ld bc,$8138		                        ;143c	01 38 81 	. 8 .
 5238 143F 11 3B AA     	ld de,$aa3b		    ; BCDE = Log2(e)        ;143f	11 3b aa 	. ; .
 5239 1442 CD 47 08     	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;1442	cd 47 08 	. G .
 5240 1445 3A 24 79     	ld a,(MATH_ACC_EXP)		;1445	3a 24 79 	: $ y
 5241 1448 FE 88        	cp 088h		;1448	fe 88 	. .
 5242 144A D2 31 09     	jp nc,l0931h		;144a	d2 31 09 	. 1 .
 5243 144D CD 40 0B     	call sub_0b40h		;144d	cd 40 0b 	. @ .
 5244 1450 C6 80        	add a,080h		;1450	c6 80 	. .
 5245 1452 C6 02        	add a,002h		;1452	c6 02 	. .
 5246 1454 DA 31 09     	jp c,l0931h		;1454	da 31 09 	. 1 .
 5247 1457 F5           	push af			;1457	f5 	.
 5248 1458 21 F8 07     	ld hl,CONSTs_1	; Constant value 1 (Single)	;1458	21 f8 07 	! . .
 5249 145B CD 0B 07     	call sngHLaddACC_DBL	; ACC = ACC + 1 (Single)	;145b	cd 0b 07 	. . .
 5250 145E CD 41 08     	call sub_0841h		;145e	cd 41 08 	. A .
 5251 1461 F1           	pop af			;1461	f1 	.
 5252 1462 C1           	pop bc			;1462	c1 	.
 5253 1463 D1           	pop de			;1463	d1 	.
 5254 1464 F5           	push af			;1464	f5 	.
 5255 1465 CD 13 07     	call sngBCDEsubACC_DBL	; ACC = BCDE - ACC (Single)	;1465	cd 13 07 	. . .
 5256 1468 CD 82 09     	call sngACCnegate		;  ACC = -ACC (Single) ;1468	cd 82 09 	. . .
 5257 146B 21 79 14     	ld hl,l1479h		;146b	21 79 14 	! y .
 5258 146E CD A9 14     	call sub_14a9h		;146e	cd a9 14 	. . .
 5259 1471 11 00 00     	ld de,$0000		;1471	11 00 00 	. . .
 5260 1474 C1           	pop bc			;1474	c1 	.
 5261 1475 4A           	ld c,d			;1475	4a 	J
 5262 1476 C3 47 08     	jp sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;1476	c3 47 08 	. G .
 5263 1479              l1479h:
 5264 1479 08           	ex af,af'			;1479	08 	.
 5265 147A 40           	ld b,b			;147a	40 	@
 5266 147B 2E 94        	ld l,094h		;147b	2e 94 	. .
 5267 147D 74           	ld (hl),h			;147d	74 	t
 5268 147E 70           	ld (hl),b			;147e	70 	p
 5269 147F 4F           	ld c,a			;147f	4f 	O
 5270 1480 2E 77        	ld l,077h		;1480	2e 77 	. w
 5271 1482 6E           	ld l,(hl)			;1482	6e 	n
 5272 1483 02           	ld (bc),a			;1483	02 	.
 5273 1484 88           	adc a,b			;1484	88 	.
 5274 1485 7A           	ld a,d			;1485	7a 	z
 5275 1486 E6 A0        	and 0a0h		;1486	e6 a0 	. .
 5276 1488 2A 7C 50     	ld hl,(0507ch)		;1488	2a 7c 50 	* | P
 5277 148B AA           	xor d			;148b	aa 	.
 5278 148C AA           	xor d			;148c	aa 	.
 5279 148D 7E           	ld a,(hl)			;148d	7e 	~
 5280 148E FF           	rst 38h			;148e	ff 	.
 5281 148F FF           	rst 38h			;148f	ff 	.
 5282 1490 7F           	ld a,a			;1490	7f 	
 5283 1491 7F           	ld a,a			;1491	7f 	
 5284 1492 00           	nop			;1492	00 	.
 5285 1493 00           	nop			;1493	00 	.
 5286 1494 80           	add a,b			;1494	80 	.
 5287 1495 81           	add a,c			;1495	81 	.
 5288 1496
 5289 1496              ; ********************************************************************************
 5290 1496              ; Math : Constant value 1 (Single)
 5291 1496
 5292 1496 00 00 00 81  	dword #81000000		;1496	00 00 00 81 	.
 5293 149A              sub_149ah:
 5294 149A CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;149a	cd a4 09 	. . .
 5295 149D 11 32 0C     	ld de,sngSPOPmulACC_DBL	; routine ACC = (SP) * ACC (Single)	;149d	11 32 0c 	. 2 .
 5296 14A0 D5           	push de			;14a0	d5 	.
 5297 14A1 E5           	push hl			;14a1	e5 	.
 5298 14A2 CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;14a2	cd bf 09 	. . .
 5299 14A5 CD 47 08     	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;14a5	cd 47 08 	. G .
 5300 14A8 E1           	pop hl			;14a8	e1 	.
 5301 14A9              sub_14a9h:
 5302 14A9 CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;14a9	cd a4 09 	. . .
 5303 14AC 7E           	ld a,(hl)			;14ac	7e 	~
 5304 14AD 23           	inc hl			;14ad	23 	#
 5305 14AE CD B1 09     	call MAT_sCopyHLToACC_DBL		;14ae	cd b1 09 	. . .
 5306 14B1 06 F1        	ld b,0f1h		;14b1	06 f1 	. .
 5307 14B3 C1           	pop bc			;14b3	c1 	.
 5308 14B4 D1           	pop de			;14b4	d1 	.
 5309 14B5 3D           	dec a			;14b5	3d 	=
 5310 14B6 C8           	ret z			;14b6	c8 	.
 5311 14B7 D5           	push de			;14b7	d5 	.
 5312 14B8 C5           	push bc			;14b8	c5 	.
 5313 14B9 F5           	push af			;14b9	f5 	.
 5314 14BA E5           	push hl			;14ba	e5 	.
 5315 14BB CD 47 08     	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;14bb	cd 47 08 	. G .
 5316 14BE E1           	pop hl			;14be	e1 	.
 5317 14BF CD C2 09     	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;14bf	cd c2 09 	. . .
 5318 14C2 E5           	push hl			;14c2	e5 	.
 5319 14C3 CD 16 07     	call sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 	;14c3	cd 16 07 	. . .
 5320 14C6 E1           	pop hl			;14c6	e1 	.
 5321 14C7 18 E9        	jr $-21		;14c7	18 e9 	. .
 5322 14C9
 5323 14C9              ; ********************************************************************************
 5324 14C9              ; BASIC RND Entry Point
 5325 14C9              ; Math : ACC = RND(ACC) (Any -> Single)
 5326 14C9              FuncRND
 5327 14C9 CD 7F 0A     	call FuncCINT		; convert ACC to integer	;14c9	cd 7f 0a 	.  .
 5328 14CC 7C           	ld a,h			;14cc	7c 	|
 5329 14CD B7           	or a			;14cd	b7 	.
 5330 14CE FA 4A 1E     	jp m,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;14ce	fa 4a 1e 	. J .
 5331 14D1 B5           	or l			;14d1	b5 	.
 5332 14D2 CA F0 14     	jp z,MAT_sRnd_0		;14d2	ca f0 14 	. . .
 5333 14D5 E5           	push hl			;14d5	e5 	.
 5334 14D6 CD F0 14     	call MAT_sRnd_0		;14d6	cd f0 14 	. . .
 5335 14D9 CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;14d9	cd bf 09 	. . .
 5336 14DC EB           	ex de,hl			;14dc	eb 	.
 5337 14DD E3           	ex (sp),hl			;14dd	e3 	.
 5338 14DE C5           	push bc			;14de	c5 	.
 5339 14DF CD CF 0A     	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;14df	cd cf 0a 	. . .
 5340 14E2 C1           	pop bc			;14e2	c1 	.
 5341 14E3 D1           	pop de			;14e3	d1 	.
 5342 14E4 CD 47 08     	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;14e4	cd 47 08 	. G .
 5343 14E7 21 F8 07     	ld hl,CONSTs_1	; Constant value 1 (Single)		;14e7	21 f8 07 	! . .
 5344 14EA CD 0B 07     	call sngHLaddACC_DBL	; ACC = ACC + 1 (Single)	;14ea	cd 0b 07 	. . .
 5345 14ED C3 40 0B     	jp sub_0b40h		;14ed	c3 40 0b 	. @ .
 5346 14F0              ; ********************************************************************************
 5347 14F0              ; Math : ACC = RND(0) (Single)
 5348 14F0              MAT_sRnd_0:
 5349 14F0 21 90 78     	ld hl,07890h		;14f0	21 90 78 	! . x
 5350 14F3 E5           	push hl			;14f3	e5 	.
 5351 14F4 11 00 00     	ld de,$0000		;14f4	11 00 00 	. . .
 5352 14F7 4B           	ld c,e			;14f7	4b 	K
 5353 14F8 26 03        	ld h,003h		;14f8	26 03 	& .
 5354 14FA              l14fah:
 5355 14FA 2E 08        	ld l,008h		;14fa	2e 08 	. .
 5356 14FC              l14fch:
 5357 14FC EB           	ex de,hl			;14fc	eb 	.
 5358 14FD 29           	add hl,hl			;14fd	29 	)
 5359 14FE EB           	ex de,hl			;14fe	eb 	.
 5360 14FF 79           	ld a,c			;14ff	79 	y
 5361 1500 17           	rla			;1500	17 	.
 5362 1501 4F           	ld c,a			;1501	4f 	O
 5363 1502 E3           	ex (sp),hl			;1502	e3 	.
 5364 1503 7E           	ld a,(hl)			;1503	7e 	~
 5365 1504 07           	rlca			;1504	07 	.
 5366 1505 77           	ld (hl),a			;1505	77 	w
 5367 1506 E3           	ex (sp),hl			;1506	e3 	.
 5368 1507 D2 16 15     	jp nc,l1516h		;1507	d2 16 15 	. . .
 5369 150A E5           	push hl			;150a	e5 	.
 5370 150B 2A AA 78     	ld hl,(078aah)		;150b	2a aa 78 	* . x
 5371 150E 19           	add hl,de			;150e	19 	.
 5372 150F EB           	ex de,hl			;150f	eb 	.
 5373 1510 3A AC 78     	ld a,(078ach)		;1510	3a ac 78 	: . x
 5374 1513 89           	adc a,c			;1513	89 	.
 5375 1514 4F           	ld c,a			;1514	4f 	O
 5376 1515 E1           	pop hl			;1515	e1 	.
 5377 1516              l1516h:
 5378 1516 2D           	dec l			;1516	2d 	-
 5379 1517 C2 FC 14     	jp nz,l14fch		;1517	c2 fc 14 	. . .
 5380 151A E3           	ex (sp),hl			;151a	e3 	.
 5381 151B 23           	inc hl			;151b	23 	#
 5382 151C E3           	ex (sp),hl			;151c	e3 	.
 5383 151D 25           	dec h			;151d	25 	%
 5384 151E C2 FA 14     	jp nz,l14fah		;151e	c2 fa 14 	. . .
 5385 1521 E1           	pop hl			;1521	e1 	.
 5386 1522 21 65 B0     	ld hl,$b065		;1522	21 65 b0 	! e .
 5387 1525 19           	add hl,de			;1525	19 	.
 5388 1526 22 AA 78     	ld (078aah),hl		;1526	22 aa 78 	" . x
 5389 1529 CD EF 0A     	call SetNTFToSng		;1529	cd ef 0a 	. . .
 5390 152C 3E 05        	ld a,005h		;152c	3e 05 	> .
 5391 152E 89           	adc a,c			;152e	89 	.
 5392 152F 32 AC 78     	ld (078ach),a		;152f	32 ac 78 	2 . x
 5393 1532 EB           	ex de,hl			;1532	eb 	.
 5394 1533 06 80        	ld b,080h		;1533	06 80 	. .
 5395 1535 21 25 79     	ld hl,MATH_ACC_SIGN		;1535	21 25 79 	! % y
 5396 1538 70           	ld (hl),b			;1538	70 	p
 5397 1539 2B           	dec hl			;1539	2b 	+
 5398 153A 70           	ld (hl),b			;153a	70 	p
 5399 153B 4F           	ld c,a			;153b	4f 	O
 5400 153C 06 00        	ld b,000h		;153c	06 00 	. .
 5401 153E C3 65 07     	jp l0765h			; Normalize Single Value ;153e	c3 65 07 	. e .
 5402 1541
 5403 1541              ; ********************************************************************************
 5404 1541              ; BASIC COS Entry Point
 5405 1541              ; Math : ACC = COS(ACC) (Any -> Single)
 5406 1541              MAT_sCos_ACC_DBL:
 5407 1541              FuncCOS:
 5408 1541 21 8B 15     	ld hl,CONSTs_PiDiv2	; Constant value Pi/2	;1541	21 8b 15 	! . .
 5409 1544 CD 0B 07     	call sngHLaddACC_DBL		; ACC = ACC + Pi/2 ;1544	cd 0b 07 	. . .
 5410 1547
 5411 1547              ; ********************************************************************************
 5412 1547              ; BASIC SIN Entry Point
 5413 1547              ; Math : ACC = SIN(ACC) (Any -> Single)
 5414 1547              MAT_sSin_ACC_DBL:
 5415 1547              FuncSIN:
 5416 1547 CD A4 09     	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;1547	cd a4 09 	. . .
 5417 154A 01 49 83     	ld bc,$8349		                ;154a	01 49 83 	. I .
 5418 154D 11 DB 0F     	ld de,$0fdb		; BCDE = 2*Pi   ;154d	11 db 0f 	. . .
 5419 1550 CD B4 09     	call BCDEToACC_DBL		; copy value from BCDE to ACC (Single)	;1550	cd b4 09 	. . .
 5420 1553 C1           	pop bc			;1553	c1 	.
 5421 1554 D1           	pop de			;1554	d1 	.
 5422 1555 CD A2 08     	call BCDEsDivACC_DBL	; ACC = BCDE / ACC (Single)		;1555	cd a2 08 	. . .
 5423 1558 CD A4 09     	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;1558	cd a4 09 	. . .
 5424 155B CD 40 0B     	call sub_0b40h		;155b	cd 40 0b 	. @ .
 5425 155E C1           	pop bc			;155e	c1 	.
 5426 155F D1           	pop de			;155f	d1 	.
 5427 1560 CD 13 07     	call sngBCDEsubACC_DBL	; ACC = BCDE - ACC (Single)		;1560	cd 13 07 	. . .
 5428 1563 21 8F 15     	ld hl,CONSTs_025	; Constant value 0.25 (Single) 	                        ;1563	21 8f 15 	! . .
 5429 1566 CD 10 07     	call sngHLsubACC_DBL		; ACC = 0.25 - ACC (Single)                             ;1566	cd 10 07 	. . .
 5430 1569 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;1569	cd 55 09 	. U .
 5431 156C 37           	scf			;156c	37 	7
 5432 156D F2 77 15     	jp p,l1577h		;156d	f2 77 15 	. w .
 5433 1570 CD 08 07     	call sngACCadd05	    ; ACC = ACC + 0.5 (Single)	                            ;1570	cd 08 07 	. . .
 5434 1573 CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;1573	cd 55 09 	. U .
 5435 1576 B7           	or a			;1576	b7 	.
 5436 1577              l1577h:
 5437 1577 F5           	push af			;1577	f5 	.
 5438 1578 F4 82 09     	call p,sngACCnegate		;  ACC = -ACC (Single) ;1578	f4 82 09 	. . .
 5439 157B 21 8F 15     	ld hl,CONSTs_025	; Constant value 0.25 (Single)	;157b	21 8f 15 	! . .
 5440 157E CD 0B 07     	call sngHLaddACC_DBL		; ACC = ACC + 0.25  ;157e	cd 0b 07 	. . .
 5441 1581 F1           	pop af			;1581	f1 	.
 5442 1582 D4 82 09     	call nc,sngACCnegate		;  ACC = -ACC (Single) ;1582	d4 82 09 	. . .
 5443 1585 21 93 15     	ld hl,l1593h		;1585	21 93 15 	! . .
 5444 1588 C3 9A 14     	jp sub_149ah		;1588	c3 9a 14 	. . .
 5445 158B              CONSTs_PiDiv2:
 5446 158B DB 0F 49 81  	dword #81490fdb		; Single constant value = Pi/2							;158b	db 0f 49 81 	.
 5447 158F              CONSTs_025:
 5448 158F 00 00 00 7F  	dword #7f000000		; Single constant value = 0.25							;158f	00 00 00 7f 	
 5449 1593              l1593h:
 5450 1593 05           	dec b			;1593	05 	.
 5451 1594 BA           	cp d			;1594	ba 	.
 5452 1595 D7           	rst $10			; move hl to next Basic token				;1595	d7 	.
 5453 1596 1E 86        	ld e,086h		;1596	1e 86 	. .
 5454 1598 64           	ld h,h			;1598	64 	d
 5455 1599 26 99        	ld h,099h		;1599	26 99 	& .
 5456 159B 87           	add a,a			;159b	87 	.
 5457 159C 58           	ld e,b			;159c	58 	X
 5458 159D 34           	inc (hl)			;159d	34 	4
 5459 159E 23           	inc hl			;159e	23 	#
 5460 159F 87           	add a,a			;159f	87 	.
 5461 15A0 E0           	ret po			;15a0	e0 	.
 5462 15A1 5D           	ld e,l			;15a1	5d 	]
 5463 15A2 A5           	and l			;15a2	a5 	.
 5464 15A3 86           	add a,(hl)			;15a3	86 	.
 5465 15A4 DA 0F 49     	jp c,0490fh		;15a4	da 0f 49 	. . I
 5466 15A7 83           	add a,e			;15a7	83 	.
 5467 15A8
 5468 15A8
 5469 15A8              ; ********************************************************************************
 5470 15A8              ; BASIC TAN Entry Point
 5471 15A8              ; Math : ACC = TAN(ACC) (Any -> Single)
 5472 15A8              MAT_sTan_ACC_DBL:
 5473 15A8              FuncTAN
 5474 15A8 CD A4 09     	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;15a8	cd a4 09 	. . .
 5475 15AB CD 47 15     	call FuncSIN				; calculate SIN function				;15ab	cd 47 15 	. G .
 5476 15AE C1           	pop bc			;15ae	c1 	.
 5477 15AF E1           	pop hl			;15af	e1 	.
 5478 15B0 CD A4 09     	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;15b0	cd a4 09 	. . .
 5479 15B3 EB           	ex de,hl			;15b3	eb 	.
 5480 15B4 CD B4 09     	call BCDEToACC_DBL		; copy value from BCDE to ACC (Single)	;15b4	cd b4 09 	. . .
 5481 15B7 CD 41 15     	call FuncCOS		; calculate COS function	;15b7	cd 41 15 	. A .
 5482 15BA C3 A0 08     	jp MAT_sDiv_STACK_ACC_DBL		;15ba	c3 a0 08 	. . .
 5483 15BD
 5484 15BD
 5485 15BD              ; ********************************************************************************
 5486 15BD              ; BASIC ATN Entry Point
 5487 15BD              ; Math : ACC = ATN(ACC) (Any -> Single)
 5488 15BD              FuncATN:
 5489 15BD CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;15bd	cd 55 09 	. U .
 5490 15C0 FC E2 13     	call m,013e2h		; call ??? if ACC < 0 ;15c0	fc e2 13 	. . .
 5491 15C3 FC 82 09     	call m,sngACCnegate		;  ACC = -ACC (Single) ;15c3	fc 82 09 	. . .
 5492 15C6 3A 24 79     	ld a,(MATH_ACC_EXP)		;15c6	3a 24 79 	: $ y
 5493 15C9 FE 81        	cp 081h		;15c9	fe 81 	. .
 5494 15CB 38 0C        	jr c,l15d9h		;15cb	38 0c 	8 .
 5495 15CD 01 00 81     	ld bc,08100h		;15cd	01 00 81 	. . .
 5496 15D0 51           	ld d,c			;15d0	51 	Q
 5497 15D1 59           	ld e,c			;15d1	59 	Y
 5498 15D2 CD A2 08     	call BCDEsDivACC_DBL	; ACC = BCDE / ACC (Single)		;15d2	cd a2 08 	. . .
 5499 15D5 21 10 07     	ld hl,sngHLsubACC_DBL		; address of routine ACC = (HL) - ACC (Single) ;15d5	21 10 07 	! . .
 5500 15D8 E5           	push hl			;15d8	e5 	.
 5501 15D9              l15d9h:
 5502 15D9 21 E3 15     	ld hl,l15e3h		;15d9	21 e3 15 	! . .
 5503 15DC CD 9A 14     	call sub_149ah		;15dc	cd 9a 14 	. . .
 5504 15DF 21 8B 15     	ld hl,CONSTs_PiDiv2	; Constant value Pi/2		;15df	21 8b 15 	! . .
 5505 15E2 C9           	ret			;15e2	c9 	.
 5506 15E3              l15e3h:
 5507 15E3 09           	add hl,bc			;15e3	09 	.
 5508 15E4 4A           	ld c,d			;15e4	4a 	J
 5509 15E5 D7           	rst $10			; move hl to next Basic token			;15e5	d7 	.
 5510 15E6 3B           	dec sp			;15e6	3b 	;
 5511 15E7 78           	ld a,b			;15e7	78 	x
 5512 15E8 02           	ld (bc),a			;15e8	02 	.
 5513 15E9 6E           	ld l,(hl)			;15e9	6e 	n
 5514 15EA 84           	add a,h			;15ea	84 	.
 5515 15EB 7B           	ld a,e			;15eb	7b 	{
 5516 15EC FE C1        	cp 0c1h		;15ec	fe c1 	. .
 5517 15EE 2F           	cpl			;15ee	2f 	/
 5518 15EF 7C           	ld a,h			;15ef	7c 	|
 5519 15F0 74           	ld (hl),h			;15f0	74 	t
 5520 15F1 31 9A 7D     	ld sp,07d9ah		;15f1	31 9a 7d 	1 . }
 5521 15F4 84           	add a,h			;15f4	84 	.
 5522 15F5 3D           	dec a			;15f5	3d 	=
 5523 15F6 5A           	ld e,d			;15f6	5a 	Z
 5524 15F7 7D           	ld a,l			;15f7	7d 	}
 5525 15F8 C8           	ret z			;15f8	c8 	.
 5526 15F9 7F           	ld a,a			;15f9	7f 	
 5527 15FA 91           	sub c			;15fa	91 	.
 5528 15FB 7E           	ld a,(hl)			;15fb	7e 	~
 5529 15FC E4 BB 4C     	call po,04cbbh		;15fc	e4 bb 4c 	. . L
 5530 15FF 7E           	ld a,(hl)			;15ff	7e 	~
 5531 1600 6C           	ld l,h			;1600	6c 	l
 5532 1601 AA           	xor d			;1601	aa 	.
 5533 1602 AA           	xor d			;1602	aa 	.
 5534 1603 7F           	ld a,a			;1603	7f 	
 5535 1604 00           	nop			;1604	00 	.
 5536 1605 00           	nop			;1605	00 	.
 5537 1606 00           	nop			;1606	00 	.
 5538 1607 81           	add a,c			;1607	81 	.
 5539 1608
 5540 1608
 5541 1608              ;******************************************************************************************
 5542 1608              ; Table with pointers for Basic Functions
 5543 1608              BasicFuncPointers:
 5544 1608 8A 09        	dw FuncSNG					; D7 SNG			;1608	8a 09
 5545 160A 37 0B        	dw FuncINT					; D8 INT 			;160a	37 0b 	.
 5546 160C 77 09        	dw FuncABS					; D9 ABS			;160c	77 09 	.
 5547 160E D4 27        	dw FuncFRE					; DA {FRE}			;160e	d4 27 	. ' .
 5548 1610 EF 2A        	dw FuncINP					; DB INP			;1610	ef 2a 	. ' .
 5549 1612 F5 27        	dw FuncPOS					; DC {POS}			;1611	f5 27 	* . '
 5550 1614 E7 13        	dw FuncSQR					; DD SQR			;1614	e7 13 	.
 5551 1616 C9 14        	dw FuncRND					; DE RND			;1616	c9 14 	.
 5552 1618 09 08        	dw FuncLOG					; DF LOG			;1618	09 08 	.
 5553 161A 39 14        	dw FuncEXP					; E0 EXP			;161a	39 14 	.
 5554 161C 41 15        	dw FuncCOS					; E1 COS			;161c	41 15 	.
 5555 161E 47 15        	dw FuncSIN					; E2 SIN			;161e	47 15 	.
 5556 1620 A8 15        	dw FuncTAN					; E3 TAN			;1620	a8 15 	.
 5557 1622 BD 15        	dw FuncATN					; E4 ATN			;1622	bd 15 	.
 5558 1624 AA 2C        	dw FuncPEEK					; E5 PEEK			;1624	aa 2c 	,
 5559 1626 52 79        	dw SysDosCVI				; E6 {CVI}			;1626	52 79 	y
 5560 1628 58 79        	dw SysDosCVS				; E7 {CVS}			;1628	58 79 	y
 5561 162A 5E 79        	dw SysDosCVD				; E8 {CVD}			;162a	5e 79 	y
 5562 162C 61 79        	dw SysDosEOF				; E9 {EOF}			;162c	61 79 	y
 5563 162E 64 79        	dw SysDosLOC				; EA {LOC}			;162e	64 79 	y
 5564 1630 67 79        	dw SysDosLOF				; EB {LOF}			;1630	67 79 	y
 5565 1632 6A 79        	dw SysDosMKIS				; EC {MKI$}			;1632	6a 79 	y
 5566 1634 6D 79        	dw SysDosMKSS				; ED {MKS$}			;1634	6d 79 	y
 5567 1636 70 79        	dw SysDosMKDS				; EE {MKD$}			;1636	70 79 	y
 5568 1638 7F 0A        	dw FuncCINT					; EF {CINT}			;1638	7f 0a 	.
 5569 163A B1 0A        	dw FuncCSNG					; F0 {CSNG}			;163a	b1 0a 	.
 5570 163C DB 0A        	dw FuncCDBL					; F1 {CDBL}			;163c	db 0a 	. .
 5571 163E 26 0B        	dw FuncFIX					; F2 {FIX}			;163e	26 0b 	& .
 5572 1640 03 2A        	dw FuncLEN					; F3 LEN			;1640	03 2a	.
 5573 1642 36 28        	dw FuncSTRS					; F4 STR$			;1642	36 28 	* 6 (
 5574 1644 C5 2A        	dw FuncVAL					; F5 VAL			;1644	c5 2a	.
 5575 1646 0F 2A        	dw FuncASC					; F6 ASC			;1646	0f 2a 	* . *
 5576 1648 1F 2A        	dw FuncCHRS					; F7 CHR$			;1648	1f 2a	.
 5577 164A 61 2A        	dw FuncLEFTS				; F8 LEFT$			;164a	61 2a 	* a *
 5578 164C 91 2A        	dw FuncRIGHTS				; F9 RIGHT$			;164c	91 2a	.
 5579 164E 9A 2A        	dw FuncMIDS					; FA MID$			;164e	9a 2a 	* . *
 5580 1650
 5581 1650              ; ***********************************************************************************
 5582 1650              ; BASIC Commands and Function Names for Parser
 5583 1650              ; First byte of Name has bit 7 set to 1. End of table is marked with byte $80 (0 with 7th bit set).
 5584 1650              ; Some entries are removed and replaced with placeholder sequence $81,0,0,..0
 5585 1650              BasicCmdNames:
 5586 1650 C5 4E 44     	db $80|'E','ND'				; 80 END			;1650	c5 4e 44 	D
 5587 1653 C6 4F 52     	db $80|'F','OR'				; 81 FOR			;1653	c6 4f 52 	R
 5588 1656 D2 45 53 45  	db $80|'R','ESET'			; 82 RESET			;1656	d2 45 53 45 54 	T
 5588 165A 54
 5589 165B D3 45 54     	db $80|'S','ET'				; 83 SET			;165b	d3 45 54 	T
 5590 165E C3 4C 53     	db $80|'C','LS'				; 84 CLS			;165e	c3 4c 53 	. L S
 5591 1661 81 00 00     	db $80|1,0,0				; 85 {CMD}			;1661	81 00 00 	.
 5592 1664 81 00 00 00  	db $80|1,0,0,0,0,0			; 86 {RANDOM}		;1664	81 00 00 00 00 00 	.
 5592 1668 00 00
 5593 166A CE 45 58 54  	db $80|'N','EXT'			; 87 NEXT			;166a	ce 45 58 54 	T
 5594 166E C4 41 54 41  	db $80|'D','ATA'			; 88 DATA			;166e	c4 41 54 41 	A
 5595 1672 C9 4E 50 55      db $80|'I','NPUT'          	; 89 INPUT         	;1672 	c9 4e 50 55 54
 5595 1676 54
 5596 1677 C4 49 4D         db $80|'D','IM'            	; 8A DIM           	;1677 	c4 49 4d
 5597 167A D2 45 41 44      db $80|'R','EAD'           	; 8B READ          	;167a 	d2 45 41 44
 5598 167E CC 45 54         db $80|'L','ET'            	; 8C LET           	;167e 	cc 45 54
 5599 1681 C7 4F 54 4F      db $80|'G','OTO'           	; 8D GOTO          	;1681 	c7 4f 54 4f
 5600 1685 D2 55 4E         db $80|'R','UN'            	; 8E RUN           	;1685 	d2 55 4e
 5601 1688 C9 46            db $80|'I','F'             	; 8F IF            	;1688 	c9 46
 5602 168A D2 45 53 54      db $80|'R','ESTORE'        	; 90 RESTORE       	;168a 	d2 45 53 54 4f 52 45
 5602 168E 4F 52 45
 5603 1691 C7 4F 53 55      db $80|'G','OSUB'          	; 91 GOSUB         	;1691 	c7 4f 53 55 42
 5603 1695 42
 5604 1696 D2 45 54 55      db $80|'R','ETURN'         	; 92 RETURN        	;1696 	d2 45 54 55 52 4e
 5604 169A 52 4E
 5605 169C D2 45 4D         db $80|'R','EM'            	; 93 REM           	;169c 	d2 45 4d
 5606 169F D3 54 4F 50      db $80|'S','TOP'           	; 94 STOP          	;169f 	d3 54 4f 50
 5607 16A3 C5 4C 53 45      db $80|'E','LSE'           	; 95 ELSE          	;16a3 	c5 4c 53 45
 5608 16A7 C3 4F 50 59      db $80|'C','OPY'           	; 96 COPY          	;16a7 	c3 4f 50 59
 5609 16AB C3 4F 4C 4F      db $80|'C','OLOR'          	; 97 COLOR         	;16ab 	c3 4f 4c 4f 52
 5609 16AF 52
 5610 16B0 D6 45 52 49      db $80|'V','ERIFY'         	; 98 VERIFY        	;16b0 	d6 45 52 49 46 59
 5610 16B4 46 59
 5611 16B6 81 00 00 00      db $80| 1,0,0,0,0,0        	; 99 {DEFINT}      	;16b6 	81 00 00 00 00 00
 5611 16BA 00 00
 5612 16BC 81 00 00 00      db $80| 1,0,0,0,0,0        	; 9A {DEFSNG}      	;16bc 	81 00 00 00 00 00
 5612 16C0 00 00
 5613 16C2 81 00 00 00      db $80| 1,0,0,0,0,0        	; 9B {DEFDBL}      	;16c2 	81 00 00 00 00 00
 5613 16C6 00 00
 5614 16C8 C3 52 55 4E      db $80|'C','RUN'           	; 9C CRUN          	;16c8 	c3 52 55 4e
 5615 16CC CD 4F 44 45      db $80|'M','ODE'           	; 9D MODE          	;16cc 	cd 4f 44 45
 5616 16D0 D3 4F 55 4E      db $80|'S','OUND'          	; 9E SOUND         	;16d0 	d3 4f 55 4e 44
 5616 16D4 44
 5617 16D5 81 00 00 00      db $80| 1, 0,0,0,0,0       	; 9F {RESUME}      	;16d5 	81 00 00 00 00 00
 5617 16D9 00 00
 5618 16DB CF 55 54         db $80|'O','UT'            	; A0 OUT           	;16db 	cf 55 54
 5619 16DE 81 00            db $80| 1,0                	; A1 {ON}          	;16de 	81 00
 5620 16E0 81 00 00 00      db $80| 1,0,0,0            	; A2 [OPEN]        	;16e0 	81 00 00 00
 5621 16E4 81 00 00 00      db $80| 1,0,0,0,0          	; A3 [FIELD]       	;16e4 	81 00 00 00 00
 5621 16E8 00
 5622 16E9 81 00 00         db $80| 1,0,0              	; A4 [GET]         	;16e9 	81 00 00
 5623 16EC 81 00 00         db $80| 1,0,0              	; A5 [PUT]         	;16ec 	81 00 00
 5624 16EF 81 00 00 00      db $80| 1,0,0,0,0          	; A6 [CLOSE]       	;16ef 	81 00 00 00 00
 5624 16F3 00
 5625 16F4 81 00 00 00      db $80| 1,0,0,0            	; A7 [LOAD]        	;16f4 	81 00 00 00
 5626 16F8 81 00 00 00      db $80| 1,0,0,0,0          	; A8 [MERGE]       	;16f8 	81 00 00 00 00
 5626 16FC 00
 5627 16FD 81 00 00 00      db $80| 1,0,0,0            	; A9 [NAME]        	;16fd 	81 00 00 00
 5628 1701 81 00 00 00      db $80| 1,0,0,0            	; AA [KILL]        	;1701 	81 00 00 00
 5629 1705 81 00 00 00      db $80| 1,0,0,0            	; AB [LSET]        	;1705 	81 00 00 00
 5630 1709 81 00 00 00      db $80| 1,0,0,0            	; AC [RSET]        	;1709 	81 00 00 00
 5631 170D 81 00 00 00      db $80| 1,0,0,0            	; AD [SAVE]        	;170d 	81 00 00 00
 5632 1711 81 00 00 00      db $80| 1,0,0,0,0,0        	; AE [SYSTEM]      	;1711 	81 00 00 00 00 00
 5632 1715 00 00
 5633 1717 CC 50 52 49      db $80|'L','PRINT'         	; AF LPRINT        	;1717 	cc 50 52 49 4e 54
 5633 171B 4E 54
 5634 171D 81 00 00         db $80| 1,0,0              	; B0 [DEF]         	;171d 	81 00 00
 5635 1720 D0 4F 4B 45      db $80|'P','OKE'           	; B1 POKE          	;1720 	d0 4f 4b 45
 5636 1724 D0 52 49 4E      db $80|'P','RINT'          	; B2 PRINT         	;1724 	d0 52 49 4e 54
 5636 1728 54
 5637 1729 C3 4F 4E 54      db $80|'C','ONT'           	; B3 CONT          	;1729 	c3 4f 4e 54
 5638 172D CC 49 53 54      db $80|'L','IST'           	; B4 LIST          	;172d 	cc 49 53 54
 5639 1731 CC 4C 49 53      db $80|'L','LIST'          	; B5 LLIST         	;1731 	cc 4c 49 53 54
 5639 1735 54
 5640 1736 81 00 00 00      db $80| 1,0,0,0,0,0        	; B6 {DELETE}      	;1736 	81 00 00 00 00 00
 5640 173A 00 00
 5641 173C 81 00 00 00      db $80| 1,0,0,0            	; B7 {AUTO}        	;173c 	81 00 00 00
 5642 1740 C3 4C 45 41      db $80|'C','LEAR'          	; B8 CLEAR         	;1740 	c3 4c 45 41 52
 5642 1744 52
 5643 1745 C3 4C 4F 41      db $80|'C','LOAD'          	; B9 CLOAD         	;1745 	c3 4c 4f 41 44
 5643 1749 44
 5644 174A C3 53 41 56      db $80|'C','SAVE'          	; BA CSAVE         	;174a 	c3 53 41 56 45
 5644 174E 45
 5645 174F CE 45 57         db $80|'N','EW'            	; BB NEW           	;174f 	ce 45 57
 5646 1752              ;----------------------------------------------------------------------------------------------------------------------
 5647 1752 D4 41 42 28      db $80|'T','AB('           	; BC TAB(          	;1752	d4 41 42 28
 5648 1756 D4 4F            db $80|'T','O'             	; BD TO            	;1756	d4 4f
 5649 1758 81 00            db $80| 1,0                	; BE [FN]          	;1758	81 00
 5650 175A D5 53 49 4E      db $80|'U','SING'          	; BF USING         	;175a	d5 53 49 4e 47
 5650 175E 47
 5651 175F 81 00 00 00      db $80| 1,0,0,0,0,0        	; C0 {VARPTR}      	;175f	81 00 00 00 00 00
 5651 1763 00 00
 5652 1765 D5 53 52         db $80|'U','SR'            	; C1 USR           	;1765	d5 53 52
 5653 1768 81 00 00         db $80| 1,0,0              	; C2 {ERL}         	;1768	81 00 00
 5654 176B 81 00 00         db $80| 1,0,0              	; C3 {ERR}         	;176b	81 00 00
 5655 176E 81 00 00 00      db $80| 1,0,0,0,0,0,0      	; C4 {STRING$}     	;176e	81 00 00 00 00 00 00
 5655 1772 00 00 00
 5656 1775 81 00 00 00      db $80| 1,0,0,0,0          	; C5 [INSTR]       	;1775	81 00 00 00 00
 5656 1779 00
 5657 177A D0 4F 49 4E      db $80|'P','OINT'          	; C6 POINT         	;177a	d0 4f 49 4e 54
 5657 177E 54
 5658 177F 81 00 00 00      db $80| 1,0,0,0,0          	; C7 [TIME$]       	;177f	81 00 00 00 00
 5658 1783 00
 5659 1784 81 00 00         db $80| 1,0,0              	; C8 {MEM}         	;1784	81 00 00
 5660 1787 C9 4E 4B 45      db $80|'I','NKEY$'         	; C9 INKEY$        	;1787	c9 4e 4b 45 59 24
 5660 178B 59 24
 5661 178D D4 48 45 4E      db $80|'T','HEN'           	; CA THEN          	;178d	d4 48 45 4e
 5662 1791 CE 4F 54         db $80|'N','OT'            	; CB NOT           	;1791	ce 4f 54
 5663 1794 D3 54 45 50      db $80|'S','TEP'           	; CC STEP          	;1794	d3 54 45 50
 5664 1798 AB               db $80|'+'                 	; CD +             	;1798	ab
 5665 1799 AD               db $80|'-'                 	; CE -             	;1799	ad
 5666 179A AA               db $80|'*'                 	; CF *             	;179a	aa
 5667 179B AF               db $80|'/'                 	; D0 /             	;179b	af
 5668 179C DE               db $80|'^'                 	; D1 ^             	;179c	de
 5669 179D C1 4E 44         db $80|'A','ND'            	; D2 AND           	;179d	c1 4e 44
 5670 17A0 CF 52            db $80|'O','R'             	; D3 OR            	;17a0	cf 52
 5671 17A2 BE               db $80|'>'                 	; D4 >             	;17a2	be
 5672 17A3 BD               db $80|'='                 	; D5 =             	;17a3	bd
 5673 17A4 BC               db $80|'<'                 	; D6 <             	;17a4	bc
 5674 17A5              ;----------------------------------------------------------------------------------------------------------------------
 5675 17A5 D3 47 4E         db $80|'S','GN'            	; D7 SGN           	;17a5	d3 47 4e
 5676 17A8 C9 4E 54         db $80|'I','NT'            	; D8 INT           	;17a8	c9 4e 54
 5677 17AB C1 42 53         db $80|'A','BS'            	; D9 ABS           	;17ab	c1 42 53
 5678 17AE 81 00 00         db $80| 1,0,0              	; DA {FRE}         	;17ae	81 00 00
 5679 17B1 C9 4E 50         db $80|'I','NP'            	; DB INP           	;17b1	c9 4e 50
 5680 17B4 81 00 00         db $80| 1,0,0              	; DC {POS}         	;17b4	81 00 00
 5681 17B7 D3 51 52         db $80|'S','QR'            	; DD SQR           	;17b7	d3 51 52
 5682 17BA D2 4E 44         db $80|'R','ND'            	; DE RND           	;17ba	d2 4e 44
 5683 17BD CC 4F 47         db $80|'L','OG'            	; DF LOG           	;17bd	cc 4f 47
 5684 17C0 C5 58 50         db $80|'E','XP'            	; E0 EXP           	;17c0	c5 58 50
 5685 17C3 C3 4F 53         db $80|'C','OS'            	; E1 COS           	;17c3	c3 4f 53
 5686 17C6 D3 49 4E         db $80|'S','IN'            	; E2 SIN           	;17c6	d3 49 4e
 5687 17C9 D4 41 4E         db $80|'T','AN'            	; E3 TAN           	;17c9	d4 41 4e
 5688 17CC C1 54 4E         db $80|'A','TN'            	; E4 ATN           	;17cc	c1 54 4e
 5689 17CF D0 45 45 4B      db $80|'P','EEK'           	; E5 PEEK          	;17cf	d0 45 45 4b
 5690 17D3 81 00 00         db $80| 1,0,0              	; E6 [CVI]         	;17d3	81 00 00
 5691 17D6 81 00 00         db $80| 1,0,0              	; E7 [CVS]         	;17d6	81 00 00
 5692 17D9 81 00 00         db $80| 1,0,0              	; E8 [CVD]         	;17d9	81 00 00
 5693 17DC 81 00 00         db $80| 1,0,0              	; E9 [EOF]         	;17dc	81 00 00
 5694 17DF 81 00 00         db $80| 1,0,0              	; EA [LOC]         	;17df	81 00 00
 5695 17E2 81 00 00         db $80| 1,0,0              	; EB [LOF]         	;17e2	81 00 00
 5696 17E5 81 00 00 00      db $80| 1,0,0,0            	; EC [MKI$]        	;17e5	81 00 00 00
 5697 17E9 81 00 00 00      db $80| 1,0,0,0            	; ED [MKS$]        	;17e9	81 00 00 00
 5698 17ED 81 00 00 00      db $80| 1,0,0,0            	; EE [MKD$]        	;17ed	81 00 00 00
 5699 17F1 81 00 00 00      db $80| 1,0,0,0            	; EF {CINT}        	;17f1	81 00 00 00
 5700 17F5 81 00 00 00      db $80| 1,0,0,0            	; F0 {CSNG}        	;17f5	81 00 00 00
 5701 17F9 81 00 00 00      db $80| 1,0,0,0            	; F1 {CDBL}        	;17f9	81 00 00 00
 5702 17FD 81 00 00         db $80| 1,0,0              	; F2 {FIX}         	;17fd	81 00 00
 5703 1800 CC 45 4E         db $80|'L','EN'            	; F3 LEN           	;1800	cc 45 4e
 5704 1803 D3 54 52 24      db $80|'S','TR$'           	; F4 STR$          	;1803	d3 54 52 24
 5705 1807 D6 41 4C         db $80|'V','AL'            	; F5 VAL           	;1807	d6 41 4c
 5706 180A C1 53 43         db $80|'A','SC'            	; F6 ASC           	;180a	c1 53 43
 5707 180D C3 48 52 24      db $80|'C','HR$'           	; F7 CHR$          	;180d	c3 48 52 24
 5708 1811 CC 45 46 54      db $80|'L','EFT$'          	; F8 LEFT$         	;1811	cc 45 46 54 24
 5708 1815 24
 5709 1816 D2 49 47 48      db $80|'R','IGHT$'         	; F9 RIGHT$        	;1816	d2 49 47 48 54 24
 5709 181A 54 24
 5710 181C CD 49 44 24      db $80|'M','ID$'           	; FA MID$          	;181c	cd 49 44 24
 5711 1820
 5712 1820 A7               db $80|"'"                 	; FB ' (REM)  		;1820	a7
 5713 1821 80               db $80| 0                  	; end of table  	;1821	80
 5714 1822              BasicCmdPointers:
 5715 1822 AE 1D        	dw CmdEND					; 80 END			;1822	ae 1d 	.
 5716 1824 A1 1C        	dw CmdFOR					; 81 FOR			;1824	a1 1c 	.
 5717 1826 38 01        	dw CmdRESET					; 82 RESET			;1826	38 01 	8 .
 5718 1828 35 01        	dw CmdSET					; 83 SET 			;1828	35 01	5
 5719 182A C9 01        	dw CmdCLS					; 84 CLS			;182a	c9 01 	. . .
 5720 182C 73 79        	dw SysDosCMD				; 85 {CMD}			;182c	73 79 	y
 5721 182E D3 01        	dw CmdRANDOM				; 86 {RANDOM}		;182e	d3 01 	. .
 5722 1830 B6 22        	dw CmdNEXT					; 87 NEXT			;1830	b6 22	.
 5723 1832 05 1F        	dw CmdDATA					; 88 DATA			;1832	05 1f 	" . .
 5724 1834 9A 21        	dw CmdINPUT					; 89 INPUT			;1834	9a 21	.
 5725 1836 08 26        	dw CmdDIM					; 8A DIM			;1836	08 26 	! . &
 5726 1838 EF 21        	dw CmdREAD					; 8B READ			;1838	ef 21	.
 5727 183A 21 1F        	dw CmdLET					; 8C LET			;183a	21 1f 	! ! .
 5728 183C C2 1E        	dw CmdGOTO					; 8D GOTO			;183c	c2 1e 	. . .
 5729 183E A3 1E        	dw CmdRUN					; 8E RUN			;183e	a3 1e  	. 9
 5730 1840 39 20        	dw CmdIF					; 8F IF				;1840	39 20   .
 5731 1842 91 1D        	dw CmdRESTORE				; 90 RESTORE		;1842	91 1d 	.
 5732 1844 B1 1E        	dw CmdGOSUB					; 91 GOSUB			;1844	b1 1e	.
 5733 1846 DE 1E        	dw CmdRETURN				; 92 RETURN			;1846	de 1e	. .
 5734 1848 07 1F        	dw CmdREM					; 93 REM			;1848	07 1f 	. .
 5735 184A A9 1D        	dw CmdSTOP					; 94 STOP			;184a	a9 1d 	.
 5736 184C 07 1F        	dw CmdELSE					; 95 ELSE			;184c	07 1f 	.
 5737 184E 12 39        	dw CmdCOPY					; 96 COPY			;184e	12 39 	9
 5738 1850 9D 38        	dw CmdCOLOR					; 97 COLOR			;1850	9d 38	.
 5739 1852 38 37        	dw CmdVERIFY				; 98 VERIFY			;1852	38 37 	7
 5740 1854 03 1E        	dw CmdDEFINT				; 99 {DEFINT}		;1854	03 1e	.
 5741 1856 06 1E        	dw CmdDEFSNG				; 9A {DEFSNG}		;1856	06 1e	. .
 5742 1858 09 1E        	dw CmdDEFDBL				; 9B {DEFDBL}		;1858	09 1e	. .
 5743 185A 2E 37        	dw CmdCRUN					; 9C CRUN			;185a	2e 37 	7
 5744 185C 63 2E        	dw CmdMODE					; 9D MODE			;185c	63 2e	c
 5745 185E F5 2B        	dw CmdSOUND					; 9E SOUND			;185e	f5 2b 	+
 5746 1860 AF 1F        	dw CmdRESUME				; 9F {RESUME}		;1860	af 1f 	.
 5747 1862 FB 2A        	dw CmdOUT					; A0 OUT			;1862	fb 2a	.
 5748 1864 6C 1F        	dw CmdON					; A1 {ON}			;1864	6c 1f 	* l .
 5749 1866 79 79        	dw SysDosOPEN				; A2 {OPEN}			;1866	79 79 	y
 5750 1868 7C 79        	dw SysDosFIELD				; A3 {FIELD}		;1868	7c 79 	y
 5751 186A 7F 79        	dw SysDosGET				; A4 {GET}			;186a	7f 79 	y
 5752 186C 82 79        	dw SysDosPUT				; A5 {PUT}			;186c	82 79 	y
 5753 186E 85 79        	dw SysDosCLOSE				; A6 {CLOSE}		;186e	85 79 	y
 5754 1870 88 79        	dw SysDosLOAD				; A7 {LOAD}			;1870	88 79 	y
 5755 1872 8B 79        	dw SysDosMERGE				; A8 {MERGE}		;1872	8b 79 	y
 5756 1874 8E 79        	dw SysDosNAME				; A9 {NAME}			;1874	8e 79 	y
 5757 1876 91 79        	dw SysDosKILL				; AA {KILL}			;1876	91 79 	y
 5758 1878 97 79        	dw SysDosLSET				; AB {LSET}			;1878	97 79 	y
 5759 187A 9A 79        	dw SysDosRSET				; AC {RSET}			;187a	9a 79 	y
 5760 187C A0 79        	dw SysDosSAVE				; AD {SAVE}			;187c	a0 79 	y
 5761 187E 00 00        	dw SysReset			    	; AE {SYSTEM}		;187e	00 00 	.
 5762 1880 67 20        	dw CmdLPRINT				; AF LPRINT			;1880	67 20	g
 5763 1882 5B 79        	dw SysDosDEF				; B0 {DEF}			;1882	5b 79 	y
 5764 1884 B1 2C        	dw CmdPOKE					; B1 POKE			;1884	b1 2c 	,
 5765 1886 6F 20        	dw CmdPRINT					; B2 PRINT			;1886	6f 20	o
 5766 1888 E4 1D        	dw CmdCONT					; B3 CONT			;1888	e4 1d 	.
 5767 188A 2E 2B        	dw CmdLIST					; B4 LIST			;188a	2e 2b 	. +
 5768 188C 29 2B        	dw CmdLLIST					; B5 LLIST			;188c	29 2b 	+
 5769 188E C6 2B        	dw CmdDELETE				; B6 {DELETE}		;188e	c6 2b 	. +
 5770 1890 08 20        	dw CmdAUTO					; B7 {AUTO}			;1890	08 20	.
 5771 1892 7A 1E        	dw CmdCLEAR					; B8 CLEAR			;1892	7a 1e	  z
 5772 1894 56 36        	dw CmdCLOAD					; B9 CLOAD			;1894	56 36	. V
 5773 1896 A9 34        	dw CmdCSAVE					; BA CSAVE			;1896	a9 34 	4
 5774 1898 49 1B        	dw CmdNEW					; BB NEW			;1898	49 1b 	.
 5775 189A              l189ah:
 5776 189A 79           	ld a,c			;189a	79 	y
 5777 189B 79           	ld a,c			;189b	79 	y
 5778 189C 7C           	ld a,h			;189c	7c 	|
 5779 189D 7C           	ld a,h			;189d	7c 	|
 5780 189E 7F           	ld a,a			;189e	7f 	
 5781 189F 50           	ld d,b			;189f	50 	P
 5782 18A0 46           	ld b,(hl)			;18a0	46 	F
 5783 18A1
 5784 18A1              ; 8 addresses Table for ???
 5785 18A1              l18a1h:
 5786 18A1 DB 0A        	dw FuncCDBL				; convert ACC to Double value		;18a1	db 0a 	. .
 5787 18A3 00 00        	dw SysReset	    		; SYSTEM cmd						;18a3	00 00 	.
 5788 18A5 7F 0A        	dw FuncCINT				; convert ACC to integer			;18a5	7f 0a 	.
 5789 18A7 F4 0A        	dw AssertACCIsString 	; Assert ACC contains String		;18a7	f4 0a 	. . .
 5790 18A9 B1 0A        	dw FuncCSNG				; convert ACC to Single value		;18a9	b1 0a 	.
 5791 18AB              l18abh:
 5792 18AB 77           	ld (hl),a			;18ab	77 	w
 5793 18AC 0C           	inc c			;18ac	0c 	.
 5794 18AD 70           	ld (hl),b			;18ad	70 	p
 5795 18AE 0C           	inc c			;18ae	0c 	.
 5796 18AF A1           	and c			;18af	a1 	.
 5797 18B0 0D           	dec c			;18b0	0d 	.
 5798 18B1 E5           	push hl			;18b1	e5 	.
 5799 18B2 0D           	dec c			;18b2	0d 	.
 5800 18B3 78           	ld a,b			;18b3	78 	x
 5801 18B4 0A           	ld a,(bc)			;18b4	0a 	.
 5802 18B5              l18b5h:
 5803 18B5 16 07        	ld d,007h		;18b5	16 07 	. .
 5804 18B7 13           	inc de			;18b7	13 	.
 5805 18B8 07           	rlca			;18b8	07 	.
 5806 18B9 47           	ld b,a			;18b9	47 	G
 5807 18BA 08           	ex af,af'			;18ba	08 	.
 5808 18BB A2           	and d			;18bb	a2 	.
 5809 18BC 08           	ex af,af'			;18bc	08 	.
 5810 18BD 0C           	inc c			;18bd	0c 	.
 5811 18BE 0A           	ld a,(bc)			;18be	0a 	.
 5812 18BF              l18bfh:
 5813 18BF D2 0B C7     	jp nc,0c70bh		;18bf	d2 0b c7 	. . .
 5814 18C2 0B           	dec bc			;18c2	0b 	.
 5815 18C3 F2 0B 90     	jp p,0900bh		;18c3	f2 0b 90 	. . .
 5816 18C6 24           	inc h			;18c6	24 	$
 5817 18C7 39           	add hl,sp			;18c7	39 	9
 5818 18C8 0A           	ld a,(bc)			;18c8	0a 	.
 5819 18C9 4E           	ld c,(hl)			;18c9	4e 	N
 5820 18CA 46           	ld b,(hl)			;18ca	46 	F
 5821 18CB 53           	ld d,e			;18cb	53 	S
 5822 18CC 4E           	ld c,(hl)			;18cc	4e 	N
 5823 18CD 52           	ld d,d			;18cd	52 	R
 5824 18CE 47           	ld b,a			;18ce	47 	G
 5825 18CF 4F           	ld c,a			;18cf	4f 	O
 5826 18D0 44           	ld b,h			;18d0	44 	D
 5827 18D1 46           	ld b,(hl)			;18d1	46 	F
 5828 18D2 43           	ld b,e			;18d2	43 	C
 5829 18D3 4F           	ld c,a			;18d3	4f 	O
 5830 18D4 56           	ld d,(hl)			;18d4	56 	V
 5831 18D5 4F           	ld c,a			;18d5	4f 	O
 5832 18D6 4D           	ld c,l			;18d6	4d 	M
 5833 18D7 55           	ld d,l			;18d7	55 	U
 5834 18D8 4C           	ld c,h			;18d8	4c 	L
 5835 18D9 42           	ld b,d			;18d9	42 	B
 5836 18DA 53           	ld d,e			;18da	53 	S
 5837 18DB 44           	ld b,h			;18db	44 	D
 5838 18DC 44           	ld b,h			;18dc	44 	D
 5839 18DD 2F           	cpl			;18dd	2f 	/
 5840 18DE 30 49        	jr nc,TXT_READY		;18de	30 49 	0 I
 5841 18E0 44           	ld b,h			;18e0	44 	D
 5842 18E1 54           	ld d,h			;18e1	54 	T
 5843 18E2 4D           	ld c,l			;18e2	4d 	M
 5844 18E3              sub_18e3h:
 5845 18E3 4F           	ld c,a			;18e3	4f 	O
 5846 18E4 53           	ld d,e			;18e4	53 	S
 5847 18E5 4C           	ld c,h			;18e5	4c 	L
 5848 18E6 53           	ld d,e			;18e6	53 	S
 5849 18E7 53           	ld d,e			;18e7	53 	S
 5850 18E8 54           	ld d,h			;18e8	54 	T
 5851 18E9 43           	ld b,e			;18e9	43 	C
 5852 18EA 4E           	ld c,(hl)			;18ea	4e 	N
 5853 18EB 4E           	ld c,(hl)			;18eb	4e 	N
 5854 18EC 52           	ld d,d			;18ec	52 	R
 5855 18ED 52           	ld d,d			;18ed	52 	R
 5856 18EE 57           	ld d,a			;18ee	57 	W
 5857 18EF 55           	ld d,l			;18ef	55 	U
 5858 18F0 45           	ld b,l			;18f0	45 	E
 5859 18F1 4D           	ld c,l			;18f1	4d 	M
 5860 18F2 4F           	ld c,a			;18f2	4f 	O
 5861 18F3 46           	ld b,(hl)			;18f3	46 	F
 5862 18F4 44           	ld b,h			;18f4	44 	D
 5863 18F5 4C           	ld c,h			;18f5	4c 	L
 5864 18F6 33           	inc sp			;18f6	33 	3
 5865 18F7
 5866 18F7              ; ***************************************************************************************
 5867 18F7              ; Initial BASIC Values for RCA: Sub, Inp, Out Routine, Basic USR Vector and BASIC state
 5868 18F7              ; ----------------------------------------------------------------------------------------
 5869 18F7              ; Routine to subtract 24 bit value from packed into 24 bit registers BHL.
 5870 18F7              ; Rotine is moved to RAM area (MAT_SubBHLCust) so SMC (Self Modifing Code) is used
 5871 18F7              ; to substract any 24bit value.
 5872 18F7              ; In order to perform subtraction before call we must set 24bit value into:
 5873 18F7              ;	7881 = LSB, 7885 = MSB, 7889 - MSB, 788c - ???
 5874 18F7              ; Call address MAT_SubBHLCust
 5875 18F7              BAS_RCAInitData:
 5876 18F7              ; Routine to subtract 24 bit value from packed into 24 bit registers BHL.
 5877 18F7 D6 00        	sub 00			;[$7880]	;18f7	d6 00 	. .
 5878 18F9 6F           	ld l,a			;[$7882]	;18f9	6f 	o
 5879 18FA 7C           	ld a,h			;[$7883]	;18fa	7c 	|
 5880 18FB DE 00        	sbc a,00		;[$7884]	;18fb	de 00 	. .
 5881 18FD 67           	ld h,a			;[$7886]	;18fd	67 	g
 5882 18FE 78           	ld a,b			;[$7887]	;18fe	78 	x
 5883 18FF DE 00        	sbc a,00		;[$7888]	;18ff	de 00 	. .
 5884 1901 47           	ld b,a			;[$788a]	;1901	47 	G
 5885 1902 3E 00        	ld a,00			;[$788b]	;1902	3e 00 	> .
 5886 1904 C9           	ret				;[$788d]	;1904	c9 	.
 5887 1905
 5888 1905              ; Jump Vector
 5889 1905 4A 1E        	dw ErrRaiseFuncCode	; [$788e] BASIC USR default run address						;1905	4a 1e	J
 5890 1907
 5891 1907              ; Random number seed initial bytes
 5892 1907 40 E6 4D     	db $40,$e6,$4d		;[$7890] Random Seed Value									;1907	40 e6 4d 	. @
 5893 190A
 5894 190A
 5895 190A              ; Routine to read any port into register a
 5896 190A              ; Rotine is moved to RAM area (7893-7895) so SMC (Self Modifing Code) is used
 5897 190A              ; to set port number to read from.
 5898 190A              ; In order to read port before call we must set port number into: 7894
 5899 190A              	DISP $7893		; Call address 7893
 5900 7893              smcPortInAddr	equ smcPortIn+1
 5901 7893              smcPortIn:
 5902 7893 DB 00        	in a,(0)		;[$7893]	;190a	db 00 	. .
 5903 7895 C9           	ret				;[$7895]	;190c	c9 	.
 5904 7896              	ENT
 5905 190D
 5906 190D              ; Routine to write to any port value from register a
 5907 190D              ; Rotine is moved to RAM area (7896-7898) so SMC (Self Modifing Code) is used
 5908 190D              ; to set port number to write to.
 5909 190D              ; In order to write to port before call we must set port number into: 7897
 5910 190D              	DISP $7896		; Call address 7896
 5911 7896              smcPortOutAddr	equ smcPortOut+1
 5912 7896              smcPortOut:
 5913 7896 D3 00        	out (0),a		;[$7896]	;190d	d3 00 	. .
 5914 7898 C9           	ret				;[$7898]	;190f	c9 	.
 5915 7899
 5916 7899              	ENT
 5917 1910 00           	db 0			;[$7899]	;1910	00 	.
 5918 1911 00           	db 0			;[$789a]	;1911	00 	.
 5919 1912 00           	db 0			;[$789b]	;1912	00 	.
 5920 1913 00           	db 0			;[$789c]	SysCurOutDev = Screen ;1913	00 	.
 5921 1914 40           	db 64		;[$789d] 	ScrLineMaxLen ;1914	40 	@
 5922 1915 30           	db 48 		;[$789e]	ScrPrintZones ;1915	30 .
 5923 1916 00           	db 0		;[$789f] ;1916	00
 5924 1917              	ASSERT( $ == 0x1917)
 5925 1917
 5926 1917              ; Basic initial values
 5927 1917              l1917h:
 5928 1917 4C 7B        	dw SysMinMemory		;[$78a0] Basic Stack Address					;1917	4c 	L
 5929 1919 FE FF        	dw $fffe		;[$78a2] Current Basic Line Number (none)		;1919	fe ff 	. .
 5930 191B E9 7A        	dw BAS_PrgMemory		;[$78a4] Program Start Address					;191b	e9 7a	.
 5931 191D
 5932 191D              ; ----------------------------------------------------------------------------------------
 5933 191D              	ASSERT( $ == 0x191d)
 5934 191D
 5935 191D              TXT_EMPTY			equ		$1928		; pointer to char '\0'
 5936 191D 20 45 52 52  TXT_ERRORSUFFIX:	db " ERROR",0		;191d	20 45 52 52 4f 52 00 	.
 5936 1921 4F 52 00
 5937 1924 20 49 4E 20  TXT_INLINE:			db " IN ",0			;1924	20 49 4e 20 00 	  .
 5937 1928 00
 5938 1929 52 45 41 44  TXT_READY:			db "READY",$0d,0	;1929	52 45 41 44 59 0d 00 	.
 5938 192D 59 0D 00
 5939 1930 42 52 45 41  TXT_BREAK:			db "BREAK",0		;1930	42 52 45 41 4b 00 	.
 5939 1934 4B 00
 5940 1936              sub_1936h:
 5941 1936 21 04 00     	ld hl,00004h		;1936	21 04 00 	! . .
 5942 1939 39           	add hl,sp			;1939	39 	9
 5943 193A              l193ah:
 5944 193A 7E           	ld a,(hl)			;193a	7e 	~
 5945 193B 23           	inc hl			;193b	23 	#
 5946 193C FE 81        	cp 081h		;193c	fe 81 	. .
 5947 193E C0           	ret nz			;193e	c0 	.
 5948 193F 4E           	ld c,(hl)			;193f	4e 	N
 5949 1940 23           	inc hl			;1940	23 	#
 5950 1941 46           	ld b,(hl)			;1941	46 	F
 5951 1942 23           	inc hl			;1942	23 	#
 5952 1943 E5           	push hl			;1943	e5 	.
 5953 1944 69           	ld l,c			;1944	69 	i
 5954 1945 60           	ld h,b			;1945	60 	`
 5955 1946 7A           	ld a,d			;1946	7a 	z
 5956 1947 B3           	or e			;1947	b3 	.
 5957 1948 EB           	ex de,hl			;1948	eb 	.
 5958 1949 28 02        	jr z,l194dh		;1949	28 02 	( .
 5959 194B EB           	ex de,hl			;194b	eb 	.
 5960 194C DF           	rst #18			; Compare HL and DE ;194c	df 	.
 5961 194D              l194dh:
 5962 194D 01 0E 00     	ld bc,$000e		;194d	01 0e 00 	. . .
 5963 1950 E1           	pop hl			;1950	e1 	.
 5964 1951 C8           	ret z			;1951	c8 	.
 5965 1952 09           	add hl,bc			;1952	09 	.
 5966 1953 18 E5        	jr l193ah		;1953	18 e5 	. .
 5967 1955              sub_1955h:
 5968 1955 CD 6C 19     	call 0196ch		;1955	cd 6c 19 	. l .
 5969 1958              sub_1958h:
 5970 1958 C5           	push bc			;1958	c5 	.
 5971 1959 E3           	ex (sp),hl			;1959	e3 	.
 5972 195A C1           	pop bc			;195a	c1 	.
 5973 195B              l195bh:
 5974 195B DF           	rst #18			; Compare HL and DE ;195b	df 	.
 5975 195C 7E           	ld a,(hl)			;195c	7e 	~
 5976 195D 02           	ld (bc),a			;195d	02 	.
 5977 195E C8           	ret z			;195e	c8 	.
 5978 195F 0B           	dec bc			;195f	0b 	.
 5979 1960 2B           	dec hl			;1960	2b 	+
 5980 1961 18 F8        	jr l195bh		;1961	18 f8 	. .
 5981 1963              sub_1963h:
 5982 1963 E5           	push hl			;1963	e5 	.
 5983 1964              l1964h:
 5984 1964 2A FD 78     	ld hl,(ArrEndPtr)	; address of End of Basic Array area	;1964	2a fd 78 	* . x
 5985 1967 06 00        	ld b,000h		;1967	06 00 	. .
 5986 1969 09           	add hl,bc			;1969	09 	.
 5987 196A 09           	add hl,bc			;196a	09 	.
 5988 196B 3E E5        	ld a,0e5h		;196b	3e e5 	> .
 5989 196D 3E C6        	ld a,0c6h		;196d	3e c6 	> .
 5990 196F              l196fh:
 5991 196F 95           	sub l			;196f	95 	.
 5992 1970 6F           	ld l,a			;1970	6f 	o
 5993 1971 3E FF        	ld a,0ffh		;1971	3e ff 	> .
 5994 1973 9C           	sbc a,h			;1973	9c 	.
 5995 1974 38 04        	jr c,ErrRaiseOutOfMem	; Raise OUT OF MEMORY Error						;1974	38 04 	8 .
 5996 1976 67           	ld h,a			;1976	67 	g
 5997 1977 39           	add hl,sp			;1977	39 	9
 5998 1978 E1           	pop hl			;1978	e1 	.
 5999 1979 D8           	ret c			;1979	d8 	.
 6000 197A              ErrRaiseOutOfMem:
 6001 197A 1E 0C        	ld e,#0c			; ERROR 0C - OUT OF MEMORY		;197a	1e 0c 	. .
 6002 197C 18 24        	jr ErrRaiseError	; Raise OUT OF MEMORY Error					;197c	18 24 	. $
 6003 197E              l197eh:
 6004 197E 2A A2 78     	ld hl,(BasicLineNo)	; Current Basic Line Number 							;197e	2a a2 78 	* . x
 6005 1981 7C           	ld a,h			    ; high byte of Line Number 								;1981	7c 	|
 6006 1982 A5           	and l			    ; will be $ff (-1) only if LineNo = 0xffff 				;1982	a5 	.
 6007 1983 3C           	inc a			    ; a = 0 if Current Basic Line Number is $ffff 			;1983	3c 	<
 6008 1984 28 08        	jr z,l198eh		    ; jump if LineNo is -1 ;1984	28 08 	( .
 6009 1986 3A F2 78     	ld a,(ERRORFLAG)	; error status 	;1986	3a f2 78 	: . x
 6010 1989 B7           	or a			    ; has Error occurred ? ;1989	b7 	.
 6011 198A 1E 22        	ld e,#22			; ERROR 22 - NO RESUME ;198a	1e 22 	. "
 6012 198C 20 14        	jr nz,ErrRaiseError	; yes - Raise 'NO RESUME' Error	;198c	20 14 	  .
 6013 198E              l198eh:
 6014 198E C3 C1 1D     	jp l1dc1h		;198e	c3 c1 1d 	. . .
 6015 1991              l1991h:
 6016 1991 2A DA 78     	ld hl,(DATALineNo)	; Basic line with DATA cmd 	;1991	2a da 78 	* . x
 6017 1994 22 A2 78     	ld (BasicLineNo),hl ; set as current Basic line	number	;1994	22 a2 78 	" . x
 6018 1997
 6019 1997
 6020 1997              // ***************************************************************************
 6021 1997              ; Raise Error
 6022 1997              ; IN: STACK - <???>
 6023 1997              ErrRaiseSyntax:
 6024 1997 1E 02        	ld e,#02			; ERROR 02 - SYNTAX ERROR									;1997	1e 02 	. .
 6025 1999 01           	db $01				; trick byte - with next constructs irrevelant ld bc,l141eh ;1999	01 1e 14 	. . .
 6026 199A              ErrRaiseDivByZero:
 6027 199A 1E 14        	ld e,#14 			; ERROR 14 - DIVISION BY ZERO								;199a	1e 14 	. . .
 6028 199C 01           	db $01				; trick byte - with next constructs irrevelant ld bc,$001e	;199c	01 1e 00 	. . .
 6029 199D              ErrRaiseNextWoFor:
 6030 199D 1E 00        	ld e,#00			; ERROR 00 - NEXT WITHOUT FOR								;199d	1e 00
 6031 199F 01           	db $01				; trick byte - with next constructs irrevelant ld bc,0241eh	;199f	01 1e 24 	. . $
 6032 19A0              ErrRaiseResumeWo:
 6033 19A0 1E 24        	ld e,#24			; ERROR 24 - RESUME WITHOUT 								;19a0	1e 24 	. . $
 6034 19A2
 6035 19A2              ; ************************************************************************************
 6036 19A2              ; IN e - error number to Raise
 6037 19A2              ErrRaiseError:
 6038 19A2 2A A2 78     	ld hl,(BasicLineNo)		; Current Basic Line Number 	                        ;19a2	2a a2 78 	* . x
 6039 19A5 22 EA 78     	ld (ErrorLineNo),hl	    ; set as Line with Error	                            ;19a5	22 ea 78 	" . x
 6040 19A8 22 EC 78     	ld (EditLineNo),hl	    ; set as Edited Line	                                ;19a8	22 ec 78 	" . x
 6041 19AB              l19abh:
 6042 19AB 01 B4 19     	ld bc,l19b4h		;19ab	01 b4 19 	. . .
 6043 19AE
 6044 19AE
 6045 19AE
 6046 19AE              ; ************************************************************************************
 6047 19AE              ; ALTERNATE ENTRY TO BASIC "READY"
 6048 19AE              ; IN: bc - address of routine to exit from Basic Program execute
 6049 19AE              BasicEntryPoint:
 6050 19AE 2A E8 78     	ld hl,(BAS_StackPtr)	; top of Basic Stack	;19ae	2a e8 78 	* . x
 6051 19B1 C3 9A 1B     	jp ResetStringVars		; reset Stack and String Variables	;19b1	c3 9a 1b 	. . .
 6052 19B4              l19b4h:
 6053 19B4 C1           	pop bc			;19b4	c1 	.
 6054 19B5 7B           	ld a,e			    ; Error number ;19b5	7b 	{
 6055 19B6 4B           	ld c,e			;19b6	4b 	K
 6056 19B7 32 9A 78     	ld (LASTERRORNO),a	; set as Last Error Number occurred	;19b7	32 9a 78 	2 . x
 6057 19BA 2A E6 78     	ld hl,(BAS_TmpCharPtr)	; last byte of code executed in current line	;19ba	2a e6 78 	* . x
 6058 19BD 22 EE 78     	ld (ErrorTokenPtr),hl	; Pointer to Basic Token when error occurred	;19bd	22 ee 78 	" . x
 6059 19C0 EB           	ex de,hl			;19c0	eb 	.
 6060 19C1 2A EA 78     	ld hl,(ErrorLineNo)	; Basic Line Number with Error 	;19c1	2a ea 78 	* . x
 6061 19C4 7C           	ld a,h			    ;19c4	7c 	|
 6062 19C5 A5           	and l			;19c5	a5 	.
 6063 19C6 3C           	inc a			;19c6	3c 	<
 6064 19C7 28 07        	jr z,l19d0h		;19c7	28 07 	( .
 6065 19C9 22 F5 78     	ld (BAS_LastLineNo),hl	; last line number executed before STOP or END	;19c9	22 f5 78 	" . x
 6066 19CC EB           	ex de,hl			;19cc	eb 	.
 6067 19CD 22 F7 78     	ld (BAS_StopedPtr),hl	; set as address of Basic code executed before STOP 	;19cd	22 f7 78 	" . x
 6068 19D0              l19d0h:
 6069 19D0 2A F0 78     	ld hl,(BAS_OnErrorPtr)	; address of Error hook routine (i.e. DOS)				;19d0	2a f0 78 	* . x
 6070 19D3 7C           	ld a,h			;19d3	7c 	|
 6071 19D4 B5           	or l			;19d4	b5 	.
 6072 19D5 EB           	ex de,hl			;19d5	eb 	.
 6073 19D6 21 F2 78     	ld hl,ERRORFLAG		; error status 	;19d6	21 f2 78 	! . x
 6074 19D9 28 08        	jr z,l19e3h		;19d9	28 08 	( .
 6075 19DB A6           	and (hl)			; has Error occurred ? ;19db	a6 	.
 6076 19DC 20 05        	jr nz,l19e3h		; yes - ;19dc	20 05 	  .
 6077 19DE 35           	dec (hl)			;19de	35 	5
 6078 19DF EB           	ex de,hl			;19df	eb 	.
 6079 19E0 C3 36 1D     	jp l1d36h		;19e0	c3 36 1d 	. 6 .
 6080 19E3              l19e3h:
 6081 19E3 AF           	xor a			;19e3	af 	.
 6082 19E4 77           	ld (hl),a			;19e4	77 	w
 6083 19E5 59           	ld e,c				; e - error number 							;19e5	59 	Y
 6084 19E6 CD F9 20     	call SysNewLine		; move Cursor to begin of the line ;19e6	cd f9 20 	. .
 6085 19E9 21 EC 3C     	ld hl,ERR_TXT_TABLE	; Table with Error Texts	;19e9	21 ec 3c 	! . <
 6086 19EC CD A6 79     	call SysExtErrMsg		;19ec	cd a6 79 	. . y
 6087 19EF 57           	ld d,a			;19ef	57 	W
 6088 19F0 3E 3F        	ld a,'?'		;19f0	3e 3f 	> ?
 6089 19F2 CD 2A 03     	call PrintChar	; Print '?' char on screen	;19f2	cd 2a 03 	. * .
 6090 19F5 CD D4 3C     	call PrintErrorText		;19f5	cd d4 3c 	. . <
 6091 19F8              ; -- removed code
 6092 19F8 00           	nop																;19f8	00 	.
 6093 19F9 00           	nop																;19f9	00 	.
 6094 19FA 00           	nop																;19fa	00 	.
 6095 19FB 00           	nop																;19fb	00 	.
 6096 19FC 00           	nop																;19fc	00 	.
 6097 19FD 00           	nop																;19fd	00 	.
 6098 19FE 21 1D 19     	ld hl,TXT_ERRORSUFFIX	; text " ERROR"							;19fe	21 1d 19 	! . .
 6099 1A01 E5           	push hl					;1a01	e5 	.
 6100 1A02 2A EA 78     	ld hl,(ErrorLineNo)		; Basic Line Number with Error 		;1a02	2a ea 78 	* . x
 6101 1A05 E3           	ex (sp),hl			;1a05	e3 	.
 6102 1A06              l1a06h:
 6103 1A06 CD A7 28     	call PrintBasicStr	; print " ERROR" text on Screen	;1a06	cd a7 28 	. . (
 6104 1A09 E1           	pop hl			;1a09	e1 	.
 6105 1A0A 11 FE FF     	ld de,0fffeh		;1a0a	11 fe ff 	. . .
 6106 1A0D DF           	rst #18			; Compare HL and DE ;1a0d	df 	.
 6107 1A0E CA 74 06     	jp z,SysInit		; Warm Reset - reinitilization ;1a0e	ca 74 06 	. t .
 6108 1A11 7C           	ld a,h			;1a11	7c 	|
 6109 1A12 A5           	and l			;1a12	a5 	.
 6110 1A13 3C           	inc a			;1a13	3c 	<
 6111 1A14 C4 A7 0F     	call nz,PrintINLINE		;1a14	c4 a7 0f 	. . .
 6112 1A17 3E           	db $3e			; trick byte - with next constructs irrevelant: ;1a17	3e c1 	> .
 6113 1A18                  ; ld a,$c1
 6114 1A18                  ; ... to skip pop bc
 6115 1A18
 6116 1A18              BAS_ReadyPopBC:
 6117 1A18 C1           	pop bc			;1a18	c1 	> .
 6118 1A19
 6119 1A19              ; **************************************************************************************
 6120 1A19              ; "OFFICIAL81 RETURN TO BASIC "READY"
 6121 1A19              ; The entry point sanctioned by Radio Shack for a return the the BASIC "READY" prompt.
 6122 1A19              ; However, the disadvantage of using this entry is that it will often return
 6123 1A19              ; an "Out of Memory Error" message in response to the next command typed in from the keyboard,
 6124 1A19              ; even though an "out of memory" condition does not exist.
 6125 1A19              ; Model 1 programmers have often substituted 06CCH or 0072H as alternate entry points,
 6126 1A19              ; but as mentioned above, these will not work with the Model III. The use of the routine
 6127 1A19              ; at 19AEH is recommended.
 6128 1A19              BasicREADY:
 6129 1A19 CD 8B 03     	call SwitchPrnToScr	; Flush Printer and change current Out Device to Screeen	;1a19	cd 8b 03 	. . .
 6130 1A1C CD AC 79     	call OnBasicREADY	; External Routine Ready                                    ;1a1c	cd ac 79 	. . y
 6131 1A1F              ; -- removed stuff
 6132 1A1F 00           	nop
 6132 1A20 00             nop
 6132 1A21 00             nop		; removed TRS routine (turn off Cassette Recorder)          ;1a1f	00 00 00	.
 6133 1A22              ; -- print READY on screen
 6134 1A22 CD F9 20     	call SysNewLine		; move Cursor to new line                                   ;1a22	cd f9 20 	. .
 6135 1A25 21 29 19     	ld hl,TXT_READY		; text "READY"                                              ;1a25	21 29 19 	! ) .
 6136 1A28 CD A7 28     	call PrintBasicStr	; print 'READY" text on Screen	                            ;1a28	cd a7 28 	. . (
 6137 1A2B              ; -- check last error (probably to print it on screen)
 6138 1A2B 3A 9A 78     	ld a,(LASTERRORNO)	; Last Error Number occurred		                        ;1a2b	3a 9a 78 	: . x
 6139 1A2E              ; -- removed stuff
 6140 1A2E D6 02        	sub 2		        ; check if 'SYNTAX ERROR' (02)          					;1a2e	d6 02 	. .
 6141 1A30 00           	nop
 6141 1A31 00             nop
 6141 1A32 00             nop		; removed TRS routine - call to EDIT mode if error was 02 	;1a30	00 	.
 6142 1A33              l1a33h:
 6143 1A33              ; -- set current Basic Program line number to -1 -> Command Mode
 6144 1A33 21 FF FF     	ld hl,$ffff		    ; line number = -1 -> Command Mode                			;1a33	21 ff ff 	! . .
 6145 1A36 22 A2 78     	ld (BasicLineNo),hl	; set as Current Basic Line Number 		                    ;1a36	22 a2 78 	" . x
 6146 1A39              ; -- check AUTONUM mode
 6147 1A39 3A E1 78     	ld a,(AUTONUM_ON)	; Basic AUTO input flag [TRS].	                            ;1a39	3a e1 78 	: . x
 6148 1A3C B7           	or a			    ; is AUTO ON ?                                              ;1a3c	b7 	.
 6149 1A3D 28 3A        	jr z,l1a79h		    ; no - skip to process user input                           ;1a3d	28 3a 	( :
 6150 1A3F
 6151 1A3F              ; -- generate line number for next line
 6152 1A3F 2A E2 78     	ld hl,(AUTONUM_LINE); line number generated by AUTO				                ;1a3f	2a e2 78 	* . x
 6153 1A42 E5           	push hl			    ; save current line number                                  ;1a42	e5 	.
 6154 1A43 CD AF 0F     	call PrintLineNo	; Print Line number on screen and into Buffer 	            ;1a43	cd af 0f 	. . .
 6155 1A46 3E 20        	ld a,' '		    ; space char to separate from line body                     ;1a46	3e 20 	>
 6156 1A48 CD 2A 03     	call PrintChar	    ; Print ' ' on screen	                                    ;1a48	cd 2a 03 	. * .
 6157 1A4B D1           	pop de			    ; de - line number for edited line                          ;1a4b	d1 	.
 6158 1A4C D5           	push de			    ; save current line number                                  ;1a4c	d5 	.
 6159 1A4D CD 2C 1B     	call FindBasicLine	; find Basic line with number in de				            ;1a4d	cd 2c 1b 	. , .
 6160 1A50 DC 53 2E     	call c,PrintBasicLine	; if line is found,	print it on screen                  ;1a50	dc 53 2e 	. S .
 6161 1A53 00           	nop			                                                                    ;1a53	00 	.
 6162 1A54 CD E3 03     	call ReadLine		; Read Line as typed by User	;1a54	cd e3 03 	. . .
 6163 1A57 D1           	pop de			    ; de - line number for edited line                          ;1a57	d1 	.
 6164 1A58 30 06        	jr nc,l1a60h		;1a58	30 06 	0 .
 6165 1A5A              l1a5ah:
 6166 1A5A              ; -- turn off AUTONUM Mode and reset back to Basic READY
 6167 1A5A AF           	xor a			    ; turn Off AUTONUM flag                                     ;1a5a	af 	.
 6168 1A5B 32 E1 78     	ld (AUTONUM_ON),a	; set Basic AUTO input flag to OFF	                        ;1a5b	32 e1 78 	2 . x
 6169 1A5E 18 B9        	jr BasicREADY	 	; jump to Basic Ready and display prompt to user         	;1a5e	18 b9 	. .
 6170 1A60
 6171 1A60              l1a60h:
 6172 1A60              ; -- generate next number for next line
 6173 1A60 2A E4 78     	ld hl,(AUTONUM_INC)	; increment value for AUTONUM line number	                ;1a60	2a e4 78 	* . x
 6174 1A63 19           	add hl,de			; add it to prevoius line number                            ;1a63	19 	.
 6175 1A64 38 F4        	jr c,l1a5ah		    ; line > 65535 - turn off AUTO and display READY            ;1a64	38 f4 	8 .
 6176 1A66 D5           	push de			    ; save new line number   		                            ;1a66	d5 	.
 6177 1A67 11 F9 FF     	ld de,65529		    ; de - max Line NUmber allowed								;1a67	11 f9 ff 	. . .
 6178 1A6A DF           	rst #18			    ; is new line number is bigger than 65525 ?                 ;1a6a	df 	.
 6179 1A6B D1           	pop de			    ; de - new line number              	                    ;1a6b	d1 	.
 6180 1A6C 30 EC        	jr nc,l1a5ah		; yes - turn off AUTO and display READY                     ;1a6c	30 ec 	0 .
 6181 1A6E              ; -- new line number is less than Maximum Valid Number
 6182 1A6E 22 E2 78     	ld (AUTONUM_LINE),hl; set new line number generated by AUTO				        ;1a6e	22 e2 78 	" . x
 6183 1A71              ; -- removed stuff
 6184 1A71 00           	nop
 6184 1A72 00             nop		    ; probably set bit ???                                      ;1a71	00 00	.
 6185 1A73              ; --
 6186 1A73 21 E7 79     	ld hl,EditLineBuf-1	; address just before Line Editor Buffer	                ;1a73	21 e7 79 	! . y
 6187 1A76 C3 81 1A     	jp ParseEditBuf		; Parse text in Edit Line Buffer                                          ;1a76	c3 81 1a 	. . .
 6188 1A79
 6189 1A79
 6190 1A79
 6191 1A79              ; *****************************************************************************
 6192 1A79              ; PROCESS INPUT FROM BASIC READY PROMPT
 6193 1A79              ; Gets input from user (interractive mode), store in Buffer (??)
 6194 1A79              l1a79h:
 6195 1A79 00           	nop
 6195 1A7A 00             nop			; removed TRS code (ld a,'>' - basic prompt)				;1a79	00 00	.
 6196 1A7B CD E3 03     	call ReadLine		; Read Line as typed by User	;1a7b	cd e3 03 	. . .
 6197 1A7E              ; -- hl points to memory just prior to buffer containing input to be parsed
 6198 1A7E              ; of CY is set then Break was pressed so we should reaturn to Ready prompt
 6199 1A7E              ; without procesing input
 6200 1A7E DA 33 1A     	jp c,l1a33h		; if Break pressed go to Ready Prompt	;1a7e	da 33 1a 	. 3 .
 6201 1A81
 6202 1A81              ; *****************************************************************************
 6203 1A81              ; PROCESS INPUT FROM BASIC READY PROMPT
 6204 1A81              ; The input will be compressed (BASIC commands as one-byte Tokens)
 6205 1A81              ParseEditBuf:
 6206 1A81 D7           	rst $10			; move hl to next Basic token			                    ;1a81	d7 	.
 6207 1A82              ; -- CY = 1 if we have digit -> means user typed line number
 6208 1A82 3C           	inc a			; preincrement to test a == 0			                    ;1a82	3c 	<
 6209 1A83 3D           	dec a			; is this end of statement?                                 ;1a83	3d 	=
 6210 1A84 CA 33 1A     	jp z,l1a33h		; yes - go to Ready Prompt (nothing more to do)	            ;1a84	ca 33 1a 	. 3 .
 6211 1A87              ; -- we have edit lines to process
 6212 1A87 F5           	push af			; save af - char or token found	    						;1a87	f5 	.
 6213 1A88 CD 5A 1E     	call TextToInt	; de - convert following text into Line Number 				;1a88	cd 5a 1e 	. Z .
 6214 1A8B
 6215 1A8B
 6216 1A8B              .next:
 6217 1A8B              ; -- move back to end of parsed number
 6218 1A8B 2B           	dec hl			; decrement to previous byte								;1a8b	2b 	+
 6219 1A8C 7E           	ld a,(hl)		; a - char in buffer										;1a8c	7e 	~
 6220 1A8D FE 20        	cp ' '			; is it space char?											;1a8d	fe 20 	.
 6221 1A8F 28 FA        	jr z,.next		; yes - move back to next char								;1a8f	28 fa 	( .
 6222 1A91
 6223 1A91 23           	inc hl			; move pointer to first space after Line Number				;1a91	23 	#
 6224 1A92 7E           	ld a,(hl)		; a - char in buffer										;1a92	7e 	~
 6225 1A93 FE 20        	cp ' '			; is it space char?											;1a93	fe 20 	.
 6226 1A95 CC C9 09     	call z,inc_hl	; yes - increment parse pointer 							;1a95	cc c9 09 	. . .
 6227 1A98 D5           	push de			; save de - Line Number 									;1a98	d5 	.
 6228 1A99 CD C0 1B     	call TokenizeLine		;1a99	cd c0 1b 	. . .
 6229 1A9C D1           	pop de			; restore de 												;1a9c	d1 	.
 6230 1A9D F1           	pop af			; restore af - token at begin of line						;1a9d	f1 	.
 6231 1A9E 22 E6 78     	ld (BAS_TmpCharPtr),hl	; save pointer to tokenized line					;1a9e	22 e6 78 	" . x
 6232 1AA1 CD B2 79     	call SysExtTokenize; user external routine	after tokenize line					;1aa1	cd b2 79 	. . y
 6233 1AA4              ; - line in Buffer is tokenized - ready to store or execute
 6234 1AA4 D2 5A 1D     	jp nc,l1d5ah	; if Line in Buffer hasn't have Number - execute 			;1aa4	d2 5a 1d 	. Z .
 6235 1AA7
 6236 1AA7
 6237 1AA7              ; -- Line has Number - don't execute naw but store into Basic Program
 6238 1AA7 D5           	push de			; save de - program Line Number								;1aa7	d5 	.
 6239 1AA8 C5           	push bc			;1aa8	c5 	.
 6240 1AA9              ; -- clear input flag
 6241 1AA9 AF           	xor a			; 0 - Input Off												;1aa9	af 	.
 6242 1AAA 32 DD 78     	ld (INPUTFLAG),a; clear Flag indicates whether inputing text				;1aaa	32 dd 78 	2 . x
 6243 1AAD              ; -- check next token or End of Statement
 6244 1AAD D7           	rst $10			; move hl to next Basic token								;1aad	d7 	.
 6245 1AAE B7           	or a			; is this End of Statement? 								;1aae	b7 	.
 6246 1AAF F5           	push af			; save af - token byte and flags							;1aaf	f5 	.
 6247 1AB0              ; -- test if Basic Line with this number already exists
 6248 1AB0 EB           	ex de,hl		; hl - Basic Line Number									;1ab0	eb 	.
 6249 1AB1 22 EC 78     	ld (EditLineNo),hl	; set as current Edited Basic Line Number				;1ab1	22 ec 78 	" . x
 6250 1AB4 EB           	ex de,hl		; de - line number to find 									;1ab4	eb 	.
 6251 1AB5 CD 2C 1B     	call FindBasicLine	; find Basic line with number in de					;1ab5	cd 2c 1b 	. , .
 6252 1AB8              ; -- if LIne was found, CY=1 and bc contains address of this line and hl contains next line after that
 6253 1AB8 C5           	push bc			; save bc - address of existing line (if found)				;1ab8	c5 	.
 6254 1AB9 DC E4 2B     	call c,DelBasicLines	; delete old Basic line 							;1ab9	dc e4 2b 	. . +
 6255 1ABC D1           	pop de			; temporary pop to reach af (token and flags)				;1abc	d1 	.
 6256 1ABD F1           	pop af			; restore af - token byte and flags							;1abd	f1 	.
 6257 1ABE D5           	push de			; push back address of old line								;1abe	d5 	.
 6258 1ABF 28 27        	jr z,l1ae8h		; finalize if End of Statement 								;1abf	28 27 	( '
 6259 1AC1
 6260 1AC1              ; -- insert new line into Basic Program
 6261 1AC1 D1           	pop de			; de - address of deleted line                              ;1ac1	d1 	.
 6262 1AC2 2A F9 78     	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program				;1ac2	2a f9 78 	* . x
 6263 1AC5 E3           	ex (sp),hl		; push EOP, hl - ???						;1ac5	e3 	.
 6264 1AC6 C1           	pop bc			; bc - End of Basic Program									;1ac6	c1 	.
 6265 1AC7 09           	add hl,bc			;1ac7	09 	.
 6266 1AC8 E5           	push hl			;1ac8	e5 	.
 6267 1AC9 CD 55 19     	call sub_1955h		;1ac9	cd 55 19 	. U .
 6268 1ACC E1           	pop hl			;1acc	e1 	.
 6269 1ACD 22 F9 78     	ld (PrgEndPtr),hl	; set as address of End of Basic Program			;1acd	22 f9 78 	" . x
 6270 1AD0 EB           	ex de,hl			;1ad0	eb 	.
 6271 1AD1 74           	ld (hl),h			;1ad1	74 	t
 6272 1AD2 D1           	pop de			;1ad2	d1 	.
 6273 1AD3 E5           	push hl			;1ad3	e5 	.
 6274 1AD4 23           	inc hl			;1ad4	23 	#
 6275 1AD5 23           	inc hl			;1ad5	23 	#
 6276 1AD6 73           	ld (hl),e			;1ad6	73 	s
 6277 1AD7 23           	inc hl			;1ad7	23 	#
 6278 1AD8 72           	ld (hl),d			;1ad8	72 	r
 6279 1AD9 23           	inc hl			;1ad9	23 	#
 6280 1ADA EB           	ex de,hl			;1ada	eb 	.
 6281 1ADB 2A A7 78     	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;1adb	2a a7 78 	* . x
 6282 1ADE EB           	ex de,hl			;1ade	eb 	.
 6283 1ADF 1B           	dec de			;1adf	1b 	.
 6284 1AE0 1B           	dec de			;1ae0	1b 	.
 6285 1AE1              l1ae1h:
 6286 1AE1 1A           	ld a,(de)			;1ae1	1a 	.
 6287 1AE2 77           	ld (hl),a			;1ae2	77 	w
 6288 1AE3 23           	inc hl			;1ae3	23 	#
 6289 1AE4 13           	inc de			;1ae4	13 	.
 6290 1AE5 B7           	or a			;1ae5	b7 	.
 6291 1AE6 20 F9        	jr nz,l1ae1h		;1ae6	20 f9 	  .
 6292 1AE8              l1ae8h:
 6293 1AE8 D1           	pop de				; de - Basic line address to start from 	;1ae8	d1 	.
 6294 1AE9 CD FC 1A     	call AdjustBasLines	; Adjust BASIC line pointers ;1ae9	cd fc 1a 	. . .
 6295 1AEC CD B5 79     	call OnLineChanged	; call external OnLineChanged hook						;1aec	cd b5 79 	. . y
 6296 1AEF CD 5D 1B     	call ResetBasicPrg	; Reset Parse point, variables, arrays, strings, stack and error state		; "CLEAR" (adjust pointers)	;1aef	cd 5d 1b 	. ] .
 6297 1AF2 CD B8 79     	call OnResetBasPrg	; call external OnResetBasPrg hook						;1af2	cd b8 79 	. . y
 6298 1AF5 C3 33 1A     	jp l1a33h		; go to Ready Prompt 	;1af5	c3 33 1a 	. 3 .
 6299 1AF8
 6300 1AF8
 6301 1AF8              ; ******************************************************************************
 6302 1AF8              ; ADJUST BASIC POINTERS
 6303 1AF8              ; As stored in memory, the first two bytes of each line of BASIC program
 6304 1AF8              ; point to the first byte of the following BASIC program line.
 6305 1AF8              ; When a program has been CLOADed, or after editing, these pointers may
 6306 1AF8              ; not be correct. This routine adjusts all of these forward so that they
 6307 1AF8              ; correctly point to the beginning of the next line, atarting with the first line
 6308 1AF8              ; of the program.
 6309 1AF8 2A A4 78     	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 			;1af8	2a a4 78 	* . x
 6310 1AFB EB           	ex de,hl			; de - BASIC line address								;1afb	eb 	.
 6311 1AFC
 6312 1AFC              ; ******************************************************************************
 6313 1AFC              ; ADJUST BASIC POINTERS STARTING AT (DE)
 6314 1AFC              ; IN: de - BASIC line address to start from
 6315 1AFC              AdjustBasLines:
 6316 1AFC              ; -- copy Basic Line address to hl
 6317 1AFC 62           	ld h,d			; copy Basic Line address to hl								;1afc	62 	b
 6318 1AFD 6B           	ld l,e																		;1afd	6b 	k
 6319 1AFE              ; -- check if end of Basic lines - next line address equals 0
 6320 1AFE 7E           	ld a,(hl)		; Low byte of next line address 							;1afe	7e 	~
 6321 1AFF 23           	inc hl			; pointer to high byte										;1aff	23 	#
 6322 1B00 B6           	or (hl)			; next line address equals 0? 								;1b00	b6 	.
 6323 1B01 C8           	ret z			; yes - no more lines to adjust ------- End of Proc -------	;1b01	c8 	.
 6324 1B02 23           	inc hl			; points to  Basic Line Number								;1b02	23 	#
 6325 1B03              ; -- next Basic line exists - skip Basic Line number (16bit)
 6326 1B03 23           	inc hl			; skip Basic line number (16bit)							;1b03	23 	#
 6327 1B04 23           	inc hl																		;1b04	23 	#
 6328 1B05              ; -- find end of line (null char)
 6329 1B05 AF           	xor a			; null char to compare										;1b05	af 	.
 6330 1B06              .next:
 6331 1B06 BE           	cp (hl)			; is this null char (end of line)?							;1b06	be 	.
 6332 1B07 23           	inc hl			; points to next char or next Basic Line entry				;1b07	23 	#
 6333 1B08 20 FC        	jr nz,.next		; no - keep searching										;1b08	20 fc 	  .
 6334 1B0A              ; -- end of line found - store this addrees into previous line entry as next line address
 6335 1B0A EB           	ex de,hl		; de - address of current line entry, hl - previous line 	;1b0a	eb 	.
 6336 1B0B 73           	ld (hl),e		; store into previous line entry as next line address		;1b0b	73 	s
 6337 1B0C 23           	inc hl			; points to high address									;1b0c	23 	#
 6338 1B0D 72           	ld (hl),d		; store high byte of address								;1b0d	72 	r
 6339 1B0E 18 EC        	jr AdjustBasLines	; process next lBasic lines ---------------------------	;1b0e	18 ec 	. .
 6340 1B10
 6341 1B10
 6342 1B10
 6343 1B10              sub_1b10h:
 6344 1B10 11 00 00     	ld de,$0000		;1b10	11 00 00 	. . .
 6345 1B13 D5           	push de			;1b13	d5 	.
 6346 1B14 28 09        	jr z,$+11		;1b14	28 09 	( .
 6347 1B16 D1           	pop de			;1b16	d1 	.
 6348 1B17 CD 4F 1E     	call sub_1e4fh		;1b17	cd 4f 1e 	. O .
 6349 1B1A D5           	push de			;1b1a	d5 	.
 6350 1B1B 28 0B        	jr z,l1b28h		;1b1b	28 0b 	( .
 6351 1B1D CF           	rst $08			; Assert next token is '-' ;1b1d	cf 	.
 6352 1B1E CE           	defb $CE		; Basic '-' token ;1b1e	ce  .
 6353 1B1F 11 FA FF     	ld de, $fffa	;1b1f	11 fa ff
 6354 1B22 C4 4F 1E     	call nz,sub_1e4fh		;1b22	c4 4f 1e	O
 6355 1B25 C2 97 19     	jp nz,ErrRaiseSyntax	; Raise 'SYNTAX ERROR'	;1b25	c2 	97 19 	.
 6356 1B28              l1b28h:
 6357 1B28 EB           	ex de,hl			;1b28	eb 	.
 6358 1B29 D1           	pop de			;1b29	d1 	.
 6359 1B2A              sub_1b2ah:
 6360 1B2A E3           	ex (sp),hl			;1b2a	e3 	.
 6361 1B2B E5           	push hl			;1b2b	e5 	.
 6362 1B2C
 6363 1B2C
 6364 1B2C              ; *****************************************************************************
 6365 1B2C              ; SEARCH FOR A MATCHING BASIC LINE NUMBER
 6366 1B2C              ; IN: de - BASIC line number to find
 6367 1B2C              ; OUT: CY - 1 - line found, 0 - not found
 6368 1B2C              ;      Z - 1 - found exact or end, 0 - found line with greater number
 6369 1B2C              ;      bc - address of found line (exact or greater) or program end
 6370 1B2C              ;      hl - addres of next line after found one or program end
 6371 1B2C              ;      de - number of line searched for
 6372 1B2C              FindBasicLine:
 6373 1B2C 2A A4 78     	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;1b2c	2a a4 78 	* . x
 6374 1B2F              l1b2fh:
 6375 1B2F 44           	ld b,h			;1b2f	44 	D
 6376 1B30 4D           	ld c,l			;1b30	4d 	M
 6377 1B31 7E           	ld a,(hl)			;1b31	7e 	~
 6378 1B32 23           	inc hl			;1b32	23 	#
 6379 1B33 B6           	or (hl)			;1b33	b6 	.
 6380 1B34 2B           	dec hl			;1b34	2b 	+
 6381 1B35 C8           	ret z			;1b35	c8 	.
 6382 1B36 23           	inc hl			;1b36	23 	#
 6383 1B37 23           	inc hl			;1b37	23 	#
 6384 1B38 7E           	ld a,(hl)			;1b38	7e 	~
 6385 1B39 23           	inc hl			;1b39	23 	#
 6386 1B3A 66           	ld h,(hl)			;1b3a	66 	f
 6387 1B3B 6F           	ld l,a			;1b3b	6f 	o
 6388 1B3C DF           	rst #18			; Compare HL and DE ;1b3c	df 	.
 6389 1B3D 60           	ld h,b			;1b3d	60 	`
 6390 1B3E 69           	ld l,c			;1b3e	69 	i
 6391 1B3F 7E           	ld a,(hl)			;1b3f	7e 	~
 6392 1B40 23           	inc hl			;1b40	23 	#
 6393 1B41 66           	ld h,(hl)			;1b41	66 	f
 6394 1B42 6F           	ld l,a			;1b42	6f 	o
 6395 1B43 3F           	ccf			;1b43	3f 	?
 6396 1B44 C8           	ret z			;1b44	c8 	.
 6397 1B45 3F           	ccf			;1b45	3f 	?
 6398 1B46 D0           	ret nc			;1b46	d0 	.
 6399 1B47 18 E6        	jr l1b2fh		;1b47	18 e6 	. .
 6400 1B49
 6401 1B49              ; **************************************************************************************
 6402 1B49              ; BASIC NEW Entry Point
 6403 1B49              ; IN: hl - current executed command parser
 6404 1B49              ;     a - command byte
 6405 1B49              ;     Z = 1 - end of statement ('\0' or ':' found)
 6406 1B49              ;     CY = 1 - char is digit
 6407 1B49              CmdNEW
 6408 1B49 C0           	ret nz				; return if not end of statement after NEW command		;1b49	c0 	.
 6409 1B4A CD C9 01     	call CmdCLS			; clear Screen - restore MODE 0 if needed				;1b4a	cd c9 01 	. . .
 6410 1B4D
 6411 1B4D              ; **************************************************************************************
 6412 1B4D              ; Wipe out the BASIC program currently in memory by reseting pointers associated
 6413 1B4D              ; with it.
 6414 1B4D              DeleteAllBasic:
 6415 1B4D 2A A4 78     	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;1b4d	2a a4 78 	* . x
 6416 1B50 CD F8 1D     	call CmdTROFF		; disable Trace (return a = 0)							;1b50	cd f8 1d 	. . .
 6417 1B53 32 E1 78     	ld (AUTONUM_ON),a	; set AUTONUM function to OFF							;1b53	32 e1 78 	2 . x
 6418 1B56              ; -- first 2 bytes of Basic Program - $0000 means end of program reached
 6419 1B56 77           	ld (hl),a			; clear Basic Program area								;1b56	77 	w
 6420 1B57 23           	inc hl				; next address											;1b57	23 	#
 6421 1B58 77           	ld (hl),a			; clear Basic Program Area								;1b58	77 	w
 6422 1B59 23           	inc hl				; address just after 2 first empty bytes				;1b59	23 	#
 6423 1B5A 22 F9 78     	ld (PrgEndPtr),hl	; store as End of Basic Program							;1b5a	22 f9 78 	" . x
 6424 1B5D
 6425 1B5D              ; Reset Parse address, clear variables, arrays, strings, stack and error
 6426 1B5D              ; Switch to MODE 0 screen
 6427 1B5D              ; OUT: hl - Program Start-1 (parse point)
 6428 1B5D              ResetBasicPrg:
 6429 1B5D 2A A4 78     	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 			;1b5d	2a a4 78 	* . x
 6430 1B60 2B           	dec hl				; points just before Program Start					;1b60	2b 	+
 6431 1B61
 6432 1B61
 6433 1B61              ; **************************************************************************************
 6434 1B61              ; CLEAR ALL ¥AR1ABLBS
 6435 1B61              ; This routine is CALLed whenever the BASIC program is changed like adding,
 6436 1B61              ; deieting or editing lines.
 6437 1B61              ; * All variables are cleared,
 6438 1B61              ; * variables pointers are reset,
 6439 1B61              ; * various other flags and pointers are reset.
 6440 1B61              ; IN: hl - start of BASIC program minus one
 6441 1B61              BAS_ResetVars:
 6442 1B61              ; -- reset Basic Start pointer
 6443 1B61 22 DF 78     	ld (PrgStart),hl		; reset Basic Program Start							;1b61	22 df 78 	" . x
 6444 1B64              ; -- clear Variable Table
 6445 1B64 06 1A        	ld b,26					; 26 entries of VarTable (for every letter A..Z)	;1b64	06 1a 	. .
 6446 1B66 21 01 79     	ld hl,BAS_VarTypesTab	; address of Variable Declarations Table			;1b66	21 01 79 	! . y
 6447 1B69              .nextVar:
 6448 1B69 36 04        	ld (hl),4				; default 4 - single numeric type					;1b69	36 04 	6 .
 6449 1B6B 23           	inc hl					; points to next entry								;1b6b	23 	#
 6450 1B6C 10 FB        	djnz .nextVar			; fill all 26 entries								;1b6c	10 fb 	. .
 6451 1B6E              ; -- set Error status to OK
 6452 1B6E AF           	xor a			    	; 0 - no error status                               ;1b6e	af 	.
 6453 1B6F 32 F2 78     	ld (ERRORFLAG),a		; set as Error Status 	                            ;1b6f	32 f2 78 	2 . x
 6454 1B72              ; -- clear Error trap and Stopped pointers
 6455 1B72 6F           	ld l,a			                                                            ;1b72	6f 	o
 6456 1B73 67           	ld h,a			    	; hl = 0                                            ;1b73	67 	g
 6457 1B74 22 F0 78     	ld (BAS_OnErrorPtr),hl	; address of error trap routine (none)				;1b74	22 f0 78 	" . x
 6458 1B77 22 F7 78     	ld (BAS_StopedPtr),hl	; address where Program was Stopped (none)			;1b77	22 f7 78 	" . x
 6459 1B7A              ; -- reset Strings Area pointer - no Strings stored
 6460 1B7A 2A B1 78     	ld hl,(MEMORY_TOP)		; top of available memory							;1b7a	2a b1 78 	* . x
 6461 1B7D 22 D6 78     	ld (BAS_StrFreePtr),hl	; set as Strings Pointer - 0 bytes reserved 		;1b7d	22 d6 78 	" . x
 6462 1B80              ; -- Basic RESTORE command
 6463 1B80 CD 91 1D     	call CmdRESTORE			; execute RESTORE 									;1b80	cd 91 1d 	. . .
 6464 1B83              ; -- reset Array Variables Area
 6465 1B83 2A F9 78     	ld hl,(PrgEndPtr)		; first address above memory used by Program		;1b83	2a f9 78 	* . x
 6466 1B86 22 FB 78     	ld (ArrStartPtr),hl		; set as Start of Basic Arrays area					;1b86	22 fb 78 	" . x
 6467 1B89 22 FD 78     	ld (ArrEndPtr),hl		; set as End of Basic Arrays area - 0 bytes used	;1b89	22 fd 78 	" . x
 6468 1B8C CD BB 79     	call SysExtNew			; call external hook if defined (i.e. by DOS)		;1b8c	cd bb 79 	. . y
 6469 1B8F              ResetBasicStack:
 6470 1B8F C1           	pop bc					; bc - return address to calling routine (00af)			;1b8f	c1 	.
 6471 1B90              ; -- set BASIC Stack Pointer and update
 6472 1B90 2A A0 78     	ld hl,(STACKTOPPTR)		; reset BASIC Stack pointer								;1b90	2a a0 78 	* . x
 6473 1B93 2B           	dec hl					; 														;1b93	2b 	+
 6474 1B94 2B           	dec hl					; skip 2 bytes (one address pointer)					;1b94	2b 	+
 6475 1B95 22 E8 78     	ld (BAS_StackPtr),hl	; set as new BASIC Stack Pointer						;1b95	22 e8 78 	" . x
 6476 1B98 23           	inc hl					; 														;1b98	23 	#
 6477 1B99 23           	inc hl					; restore value from MaxStackPtr						;1b99	23 	#
 6478 1B9A              ResetStringVars:
 6479 1B9A              ; -- initialize CPU Stack Pointer (discard all subroutine calls)
 6480 1B9A F9           	ld sp,hl				; set as CPU stack Pointer								;1b9a	f9 	.
 6481 1B9B              ; -- reset Variables area - (discard all variables)
 6482 1B9B 21 B5 78     	ld hl,BAS_StrVars		; address of BASIC String Variables Area				;1b9b	21 b5 78 	! . x
 6483 1B9E 22 B3 78     	ld (BAS_StrNextVar),hl	; set as place for new variable	created					;1b9e	22 b3 78 	" . x
 6484 1BA1              ; -- flush any pending printing and switch Out to Screen
 6485 1BA1 CD 8B 03     	call SwitchPrnToScr	    ; Flush Printer and change current Out Device to Screeen;1ba1	cd 8b 03 	. . .
 6486 1BA4 CD 69 21     	call SysSetOutAsScreen	; set Screen as Current Out Device						;1ba4	cd 69 21 	. i !
 6487 1BA7              ; -- clear for-next Flag (discard any pending For loop)
 6488 1BA7 AF           	xor a					; a - 0 					 							;1ba7	af 	.
 6489 1BA8 67           	ld h,a					;														;1ba8	67 	g
 6490 1BA9 6F           	ld l,a					; hl - 0000 - SysReset address							;1ba9	6f 	o
 6491 1BAA 32 DC 78     	ld (ForNextFlag),a		; - clear for-next Flag									;1baa	32 dc 78 	2 . x
 6492 1BAD              ; -- reset CPU Stack content to only SysReset and calling routine return addres
 6493 1BAD E5           	push hl					; set SysReset as Top Return Address					;1bad	e5 	.
 6494 1BAE C5           	push bc					; return to calling routine address (stored before) 	;1bae	c5 	.
 6495 1BAF 2A DF 78     	ld hl,(PrgStart)		; hl - pointer to BASIC Program Start					;1baf	2a df 78 	* . x
 6496 1BB2 C9           	ret						; ----------- End of Proc ----------------------------- ;1bb2	c9 	.
 6497 1BB3
 6498 1BB3
 6499 1BB3
 6500 1BB3              ; *********************************************************************************
 6501 1BB3              ; Displays prompt character (question mark followed by space) and then jumps
 6502 1BB3              ; to routine at 0545 (see above).
 6503 1BB3              BAS_Prompt:
 6504 1BB3 3E 3F        	ld a,'?'		; a - question mark as prompt character						;1bb3	3e 3f 	> ?
 6505 1BB5 CD 2A 03     	call PrintChar	; Print '?' char on screen	    							;1bb5	cd 2a 03 	. * .
 6506 1BB8 3E 20        	ld a,' '		; space character											;1bb8	3e 20 	>
 6507 1BBA CD 2A 03     	call PrintChar	; Print ' ' char on screen	    							;1bba	cd 2a 03 	. * .
 6508 1BBD               ifdef VER_12
 6509 1BBD C3 45 05     	jp GetUserInputText		;1bbd	c3 45 05 	. E .
 6510 1BC0               else ; VER_20
 6511 1BC0 ~             	jp GetUserInputText		;1bbd	c3 3a 05 	. : .
 6512 1BC0               endif
 6513 1BC0
 6514 1BC0              ; *********************************************************************************
 6515 1BC0              ; COMPRESS BASIC LINE
 6516 1BC0              ; BASIC stores all reserved words as one-byte tokens. This routine will take a line
 6517 1BC0              ; of text and compress it so that all BASIC reserved words are tokenized.
 6518 1BC0              ; Three 0 bytes will be placed at the end of encoded statement.
 6519 1BC0              ; Register bc will contain +5 to reserve room for full BASIC line (2 bytes forvard
 6520 1BC0              ; pointer, 2 bytes line number, 1 byte zero termination).
 6521 1BC0              ; Convert all aplhabetic char to uppercase (??) unless they are inside string literal.
 6522 1BC0              ; IN: hl - text null terminated to tokenize
 6523 1BC0              ; OUT: Buffer (pointed by 78a7 minus two) contains tokenized BASIC
 6524 1BC0              ;     hl - start of tokenized content minus one (contains ':')
 6525 1BC0              ;     de - last of 0 bytes at the end
 6526 1BC0              ;     bc - length of data w/o leading ':' and 3 ending bytes + 5
 6527 1BC0              TokenizeLine:
 6528 1BC0 AF           	xor a			;1bc0	af 	.
 6529 1BC1 32 B0 78     	ld (078b0h),a		;1bc1	32 b0 78 	2 . x
 6530 1BC4 4F           	ld c,a			;1bc4	4f 	O
 6531 1BC5 EB           	ex de,hl			;1bc5	eb 	.
 6532 1BC6 2A A7 78     	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;1bc6	2a a7 78 	* . x
 6533 1BC9 2B           	dec hl			;1bc9	2b 	+
 6534 1BCA              l1bcah:
 6535 1BCA 2B           	dec hl			;1bca	2b 	+
 6536 1BCB EB           	ex de,hl			;1bcb	eb 	.
 6537 1BCC              l1bcch:
 6538 1BCC 7E           	ld a,(hl)			;1bcc	7e 	~
 6539 1BCD FE 20        	cp 020h		;1bcd	fe 20 	.
 6540 1BCF CA 5B 1C     	jp z,l1c5bh		;1bcf	ca 5b 1c 	. [ .
 6541 1BD2 47           	ld b,a			;1bd2	47 	G
 6542 1BD3 FE 22        	cp 022h		;1bd3	fe 22 	. "
 6543 1BD5 CA 77 1C     	jp z,l1c77h		;1bd5	ca 77 1c 	. w .
 6544 1BD8 B7           	or a			;1bd8	b7 	.
 6545 1BD9 CA 7D 1C     	jp z,l1c7dh		;1bd9	ca 7d 1c 	. } .
 6546 1BDC 3A B0 78     	ld a,(078b0h)		;1bdc	3a b0 78 	: . x
 6547 1BDF B7           	or a			;1bdf	b7 	.
 6548 1BE0 7E           	ld a,(hl)			;1be0	7e 	~
 6549 1BE1 C2 5B 1C     	jp nz,l1c5bh		;1be1	c2 5b 1c 	. [ .
 6550 1BE4 FE 3F        	cp 03fh		;1be4	fe 3f 	. ?
 6551 1BE6 3E B2        	ld a,0b2h		;1be6	3e b2 	> .
 6552 1BE8 CA 5B 1C     	jp z,l1c5bh		;1be8	ca 5b 1c 	. [ .
 6553 1BEB 7E           	ld a,(hl)			;1beb	7e 	~
 6554 1BEC FE 30        	cp 030h		;1bec	fe 30 	. 0
 6555 1BEE 38 05        	jr c,l1bf5h		;1bee	38 05 	8 .
 6556 1BF0 FE 3C        	cp 03ch		;1bf0	fe 3c 	. <
 6557 1BF2 DA 5B 1C     	jp c,l1c5bh		;1bf2	da 5b 1c 	. [ .
 6558 1BF5              l1bf5h:
 6559 1BF5 D5           	push de			;1bf5	d5 	.
 6560 1BF6 11 4F 16     	ld de,0164fh		;1bf6	11 4f 16 	. O .
 6561 1BF9 C5           	push bc			;1bf9	c5 	.
 6562 1BFA 01 3D 1C     	ld bc,l1c3dh		;1bfa	01 3d 1c 	. = .
 6563 1BFD C5           	push bc			;1bfd	c5 	.
 6564 1BFE 06 7F        	ld b,07fh		;1bfe	06 7f 	. 
 6565 1C00 7E           	ld a,(hl)			;1c00	7e 	~
 6566 1C01 FE 61        	cp 061h		;1c01	fe 61 	. a
 6567 1C03 38 07        	jr c,l1c0ch		;1c03	38 07 	8 .
 6568 1C05 FE 7B        	cp 07bh		;1c05	fe 7b 	. {
 6569 1C07 30 03        	jr nc,l1c0ch		;1c07	30 03 	0 .
 6570 1C09 E6 5F        	and 05fh		;1c09	e6 5f 	. _
 6571 1C0B 77           	ld (hl),a			;1c0b	77 	w
 6572 1C0C              l1c0ch:
 6573 1C0C 4E           	ld c,(hl)			;1c0c	4e 	N
 6574 1C0D EB           	ex de,hl			;1c0d	eb 	.
 6575 1C0E              l1c0eh:
 6576 1C0E 23           	inc hl			;1c0e	23 	#
 6577 1C0F B6           	or (hl)			;1c0f	b6 	.
 6578 1C10 F2 0E 1C     	jp p,l1c0eh		;1c10	f2 0e 1c 	. . .
 6579 1C13 04           	inc b			;1c13	04 	.
 6580 1C14 7E           	ld a,(hl)			;1c14	7e 	~
 6581 1C15 E6 7F        	and 07fh		;1c15	e6 7f 	. 
 6582 1C17 C8           	ret z			;1c17	c8 	.
 6583 1C18 B9           	cp c			;1c18	b9 	.
 6584 1C19 20 F3        	jr nz,l1c0eh		;1c19	20 f3 	  .
 6585 1C1B EB           	ex de,hl			;1c1b	eb 	.
 6586 1C1C E5           	push hl			;1c1c	e5 	.
 6587 1C1D              l1c1dh:
 6588 1C1D 13           	inc de			;1c1d	13 	.
 6589 1C1E 1A           	ld a,(de)			;1c1e	1a 	.
 6590 1C1F B7           	or a			;1c1f	b7 	.
 6591 1C20 FA 39 1C     	jp m,l1c39h		;1c20	fa 39 1c 	. 9 .
 6592 1C23 4F           	ld c,a			;1c23	4f 	O
 6593 1C24 78           	ld a,b			;1c24	78 	x
 6594 1C25 FE 8D        	cp 08dh		;1c25	fe 8d 	. .
 6595 1C27 20 02        	jr nz,l1c2bh		;1c27	20 02 	  .
 6596 1C29 D7           	rst $10			; move hl to next Basic token			;1c29	d7 	.
 6597 1C2A 2B           	dec hl			;1c2a	2b 	+
 6598 1C2B              l1c2bh:
 6599 1C2B 23           	inc hl			;1c2b	23 	#
 6600 1C2C 7E           	ld a,(hl)			;1c2c	7e 	~
 6601 1C2D FE 61        	cp 061h		;1c2d	fe 61 	. a
 6602 1C2F 38 02        	jr c,l1c33h		;1c2f	38 02 	8 .
 6603 1C31 E6 5F        	and 05fh		;1c31	e6 5f 	. _
 6604 1C33              l1c33h:
 6605 1C33 B9           	cp c			;1c33	b9 	.
 6606 1C34 28 E7        	jr z,l1c1dh		;1c34	28 e7 	( .
 6607 1C36 E1           	pop hl			;1c36	e1 	.
 6608 1C37 18 D3        	jr l1c0ch		;1c37	18 d3 	. .
 6609 1C39              l1c39h:
 6610 1C39 48           	ld c,b			;1c39	48 	H
 6611 1C3A F1           	pop af			;1c3a	f1 	.
 6612 1C3B EB           	ex de,hl			;1c3b	eb 	.
 6613 1C3C C9           	ret			;1c3c	c9 	.
 6614 1C3D              l1c3dh:
 6615 1C3D EB           	ex de,hl			;1c3d	eb 	.
 6616 1C3E 79           	ld a,c			;1c3e	79 	y
 6617 1C3F C1           	pop bc			;1c3f	c1 	.
 6618 1C40 D1           	pop de			;1c40	d1 	.
 6619 1C41 EB           	ex de,hl			;1c41	eb 	.
 6620 1C42 FE 95        	cp 095h		;1c42	fe 95 	. .
 6621 1C44 36 3A        	ld (hl),03ah		;1c44	36 3a 	6 :
 6622 1C46 20 02        	jr nz,l1c4ah		;1c46	20 02 	  .
 6623 1C48 0C           	inc c			;1c48	0c 	.
 6624 1C49 23           	inc hl			;1c49	23 	#
 6625 1C4A              l1c4ah:
 6626 1C4A FE FB        	cp 0fbh		;1c4a	fe fb 	. .
 6627 1C4C 20 0C        	jr nz,l1c5ah		;1c4c	20 0c 	  .
 6628 1C4E 36 3A        	ld (hl),03ah		;1c4e	36 3a 	6 :
 6629 1C50 23           	inc hl			;1c50	23 	#
 6630 1C51 06 93        	ld b,093h		;1c51	06 93 	. .
 6631 1C53 70           	ld (hl),b			;1c53	70 	p
 6632 1C54 23           	inc hl			;1c54	23 	#
 6633 1C55 EB           	ex de,hl			;1c55	eb 	.
 6634 1C56 0C           	inc c			;1c56	0c 	.
 6635 1C57 0C           	inc c			;1c57	0c 	.
 6636 1C58 18 1D        	jr l1c77h		;1c58	18 1d 	. .
 6637 1C5A              l1c5ah:
 6638 1C5A EB           	ex de,hl			;1c5a	eb 	.
 6639 1C5B              l1c5bh:
 6640 1C5B 23           	inc hl			;1c5b	23 	#
 6641 1C5C 12           	ld (de),a			;1c5c	12 	.
 6642 1C5D 13           	inc de			;1c5d	13 	.
 6643 1C5E 0C           	inc c			;1c5e	0c 	.
 6644 1C5F D6 3A        	sub 03ah		;1c5f	d6 3a 	. :
 6645 1C61 28 04        	jr z,l1c67h		;1c61	28 04 	( .
 6646 1C63 FE 4E        	cp 04eh		;1c63	fe 4e 	. N
 6647 1C65 20 03        	jr nz,l1c6ah		;1c65	20 03 	  .
 6648 1C67              l1c67h:
 6649 1C67 32 B0 78     	ld (078b0h),a		;1c67	32 b0 78 	2 . x
 6650 1C6A              l1c6ah:
 6651 1C6A D6 59        	sub 059h		;1c6a	d6 59 	. Y
 6652 1C6C C2 CC 1B     	jp nz,l1bcch		;1c6c	c2 cc 1b 	. . .
 6653 1C6F 47           	ld b,a			;1c6f	47 	G
 6654 1C70              l1c70h:
 6655 1C70 7E           	ld a,(hl)			;1c70	7e 	~
 6656 1C71 B7           	or a			;1c71	b7 	.
 6657 1C72 28 09        	jr z,l1c7dh		;1c72	28 09 	( .
 6658 1C74 B8           	cp b			;1c74	b8 	.
 6659 1C75 28 E4        	jr z,l1c5bh		;1c75	28 e4 	( .
 6660 1C77              l1c77h:
 6661 1C77 23           	inc hl			;1c77	23 	#
 6662 1C78 12           	ld (de),a			;1c78	12 	.
 6663 1C79 0C           	inc c			;1c79	0c 	.
 6664 1C7A 13           	inc de			;1c7a	13 	.
 6665 1C7B 18 F3        	jr l1c70h		;1c7b	18 f3 	. .
 6666 1C7D              l1c7dh:
 6667 1C7D 21 05 00     	ld hl,$0005		;1c7d	21 05 00 	! . .
 6668 1C80 44           	ld b,h			;1c80	44 	D
 6669 1C81 09           	add hl,bc			;1c81	09 	.
 6670 1C82 44           	ld b,h			;1c82	44 	D
 6671 1C83 4D           	ld c,l			;1c83	4d 	M
 6672 1C84 2A A7 78     	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;1c84	2a a7 78 	* . x
 6673 1C87 2B           	dec hl			;1c87	2b 	+
 6674 1C88 2B           	dec hl			;1c88	2b 	+
 6675 1C89 2B           	dec hl			;1c89	2b 	+
 6676 1C8A 12           	ld (de),a			;1c8a	12 	.
 6677 1C8B 13           	inc de			;1c8b	13 	.
 6678 1C8C 12           	ld (de),a			;1c8c	12 	.
 6679 1C8D 13           	inc de			;1c8d	13 	.
 6680 1C8E 12           	ld (de),a			;1c8e	12 	.
 6681 1C8F C9           	ret			;1c8f	c9 	.
 6682 1C90
 6683 1C90
 6684 1C90              ; ********************************************************************************
 6685 1C90              ; Math : Compare HL and DE (Unsigned Integer)
 6686 1C90              ; System routine called via JumpTable using RST 18
 6687 1C90              ; IN: hl - unsigned integer to compare
 6688 1C90              ;     de - unsigned integer to compare
 6689 1C90              ; OUT: flags - Z=1 if HL == DE, CY=1 if HL < DE
 6690 1C90              CmpHLDE:
 6691 1C90 7C           	ld a,h				; a - high byte of hl									;1c90	7c 	|
 6692 1C91 92           	sub d				; subtract high byte of de - different?					;1c91	92 	.
 6693 1C92 C0           	ret nz				; yes - CY=1 if H < D ---------------------------------	;1c92	c0 	.
 6694 1C93 7D           	ld a,l				; a - low byte of hl									;1c93	7d 	}
 6695 1C94 93           	sub e				; subtract low byte of de - different?					;1c94	93 	.
 6696 1C95 C9           	ret					; ------ End of Proc (CY=1 if HL < DE, Z=1 if equal) --	;1c95	c9 	.
 6697 1C96
 6698 1C96              // *************************************************************************
 6699 1C96              ; System routine called via JumpTable using RST 08
 6700 1C96              ; This routine is used by BASIC to check for an expected character.
 6701 1C96              ; If that character is not present, a jump is taken to the Syntax Error routine.
 6702 1C96              ; An expected character is one that must be present to preserve proper syntax.
 6703 1C96              ; IN: hl - address of char in BASIC program
 6704 1C96              ; OUT: hl - next non-space char in BASIC program
 6705 1C96              AssertToken:
 6706 1C96 7E           	ld a,(hl)			; a - next char from BASIC program 						;1c96	7e 	~
 6707 1C97 E3           	ex (sp),hl			; hl - return addres (byte just after RST 08)			;1c97	e3 	.
 6708 1C98 BE           	cp (hl)				; is char from BASIC == expected token					;1c98	be 	.
 6709 1C99 23           	inc hl				; skip byte after RST 08								;1c99	23 	#
 6710 1C9A E3           	ex (sp),hl			; (sp) - modified return addres, hl - char in BASIC		;1c9a	e3 	.
 6711 1C9B CA 78 1D     	jp z,NextToken	    ; yes - ; Move hl to next Basic token                   ;1c9b	ca 78 1d 	. x .
 6712 1C9E C3 97 19     	jp ErrRaiseSyntax	; no - Raise 'SYNTAX ERROR' 							;1c9e	c3 97 19 	. . .
 6713 1CA1
 6714 1CA1
 6715 1CA1              // *************************************************************************
 6716 1CA1              ; IN: hl - current executed command parser
 6717 1CA1              ;     a - command byte
 6718 1CA1              ;     Z = 1 - end of statement ('\0' or ':' found)
 6719 1CA1              ;     CY = 1 - char is digit
 6720 1CA1              CmdFOR
 6721 1CA1              ; -- set for-bext flag - next parsed variable is for loop index
 6722 1CA1 3E 64        	ld a,$64				; flag value 										;1ca1	3e 64 	> d
 6723 1CA3 32 DC 78     	ld (ForNextFlag),a	; set flag - next variable is for loop index		;1ca3	32 dc 78 	2 . x
 6724 1CA6 CD 21 1F     	call CmdLET		;1ca6	cd 21 1f 	. ! .
 6725 1CA9 E3           	ex (sp),hl			;1ca9	e3 	.
 6726 1CAA CD 36 19     	call sub_1936h		;1caa	cd 36 19 	. 6 .
 6727 1CAD D1           	pop de			;1cad	d1 	.
 6728 1CAE 20 05        	jr nz,l1cb5h		;1cae	20 05 	  .
 6729 1CB0 09           	add hl,bc			;1cb0	09 	.
 6730 1CB1 F9           	ld sp,hl			;1cb1	f9 	.
 6731 1CB2 22 E8 78     	ld (BAS_StackPtr),hl	; set as top of Basic Stack Pointer		;1cb2	22 e8 78 	" . x
 6732 1CB5              l1cb5h:
 6733 1CB5 EB           	ex de,hl			;1cb5	eb 	.
 6734 1CB6 0E 08        	ld c,008h		;1cb6	0e 08 	. .
 6735 1CB8 CD 63 19     	call sub_1963h		;1cb8	cd 63 19 	. c .
 6736 1CBB E5           	push hl			;1cbb	e5 	.
 6737 1CBC CD 05 1F     	call CmdDATA		;1cbc	cd 05 1f 	. . .
 6738 1CBF E3           	ex (sp),hl			;1cbf	e3 	.
 6739 1CC0 E5           	push hl			;1cc0	e5 	.
 6740 1CC1 2A A2 78     	ld hl,(BasicLineNo)	; Current Basic Line Number 		;1cc1	2a a2 78 	* . x
 6741 1CC4 E3           	ex (sp),hl			;1cc4	e3 	.
 6742 1CC5 CF           	rst $08			; Assert next token is 'TO' ;1cc5	cf 	.
 6743 1CC6 BD           	defb $BD		; Basic 'TO' token	;1cc6	bd 	.
 6744 1CC7 E7           	rst #20			; test NTF (Number Type Format);1cc7	e7 	.
 6745 1CC8 CA F6 0A     	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;1cc8	ca f6 0a 	. . .
 6746 1CCB D2 F6 0A     	jp nc,ErrRaiseTypeMismatch	; Double - Raise TYPE MISMATCH Error			;1ccb	d2 f6 0a 	. . .
 6747 1CCE F5           	push af			; save af - Number Type Format;1cce	f5 	.
 6748 1CCF CD 37 23     	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;1ccf	cd 37 23 	. 7 #
 6749 1CD2 F1           	pop af			; restore af - Number Type Format	;1cd2	f1 	.
 6750 1CD3 E5           	push hl			;1cd3	e5 	.
 6751 1CD4 F2 EC 1C     	jp p,l1cech		; Single - ;1cd4	f2 ec 1c 	. . .
 6752 1CD7 CD 7F 0A     	call FuncCINT	; convert ACC to integer		;1cd7	cd 7f 0a 	.  .
 6753 1CDA E3           	ex (sp),hl			;1cda	e3 	.
 6754 1CDB 11 01 00     	ld de,1		;1cdb	11 01 00 	. . .
 6755 1CDE 7E           	ld a,(hl)			;1cde	7e 	~
 6756 1CDF FE CC        	cp 0cch		;1cdf	fe cc 	. .
 6757 1CE1 CC 01 2B     	call z,sub_2b01h		;1ce1	cc 01 2b 	. . +
 6758 1CE4 D5           	push de			;1ce4	d5 	.
 6759 1CE5 E5           	push hl			;1ce5	e5 	.
 6760 1CE6 EB           	ex de,hl			;1ce6	eb 	.
 6761 1CE7 CD 9E 09     	call TestHLSign	; Test HL sign	;1ce7	cd 9e 09 	. . .
 6762 1CEA 18 22        	jr l1d0eh		;1cea	18 22 	. "
 6763 1CEC              l1cech:
 6764 1CEC CD B1 0A     	call FuncCSNG		; convert ACC to Single value	;1cec	cd b1 0a 	. . .
 6765 1CEF CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;1cef	cd bf 09 	. . .
 6766 1CF2 E1           	pop hl			;1cf2	e1 	.
 6767 1CF3 C5           	push bc			;1cf3	c5 	.
 6768 1CF4 D5           	push de			;1cf4	d5 	.
 6769 1CF5 01 00 81     	ld bc,08100h		;1cf5	01 00 81 	. . .
 6770 1CF8 51           	ld d,c			;1cf8	51 	Q
 6771 1CF9 5A           	ld e,d			;1cf9	5a 	Z
 6772 1CFA 7E           	ld a,(hl)			;1cfa	7e 	~
 6773 1CFB FE CC        	cp 0cch		;1cfb	fe cc 	. .
 6774 1CFD 3E 01        	ld a,001h		;1cfd	3e 01 	> .
 6775 1CFF 20 0E        	jr nz,l1d0fh		;1cff	20 0e 	  .
 6776 1D01 CD 38 23     	call sub_2338h		;1d01	cd 38 23 	. 8 #
 6777 1D04 E5           	push hl			;1d04	e5 	.
 6778 1D05 CD B1 0A     	call FuncCSNG		; convert ACC to Single value	;1d05	cd b1 0a 	. . .
 6779 1D08 CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;1d08	cd bf 09 	. . .
 6780 1D0B CD 55 09     	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;1d0b	cd 55 09 	. U .
 6781 1D0E              l1d0eh:
 6782 1D0E E1           	pop hl			;1d0e	e1 	.
 6783 1D0F              l1d0fh:
 6784 1D0F C5           	push bc			;1d0f	c5 	.
 6785 1D10 D5           	push de			;1d10	d5 	.
 6786 1D11 4F           	ld c,a			;1d11	4f 	O
 6787 1D12 E7           	rst #20			; test NTF ;1d12	e7 	.
 6788 1D13 47           	ld b,a			;1d13	47 	G
 6789 1D14 C5           	push bc			;1d14	c5 	.
 6790 1D15 E5           	push hl			;1d15	e5 	.
 6791 1D16 2A DF 78     	ld hl,(PrgStart); hl - pointer to BASIC Program Start						;1d16	2a df 78 	* . x
 6792 1D19 E3           	ex (sp),hl			;1d19	e3 	.
 6793 1D1A              l1d1ah:
 6794 1D1A 06 81        	ld b,081h		;1d1a	06 81 	. .
 6795 1D1C C5           	push bc			;1d1c	c5 	.
 6796 1D1D 33           	inc sp			;1d1d	33 	3
 6797 1D1E              l1d1eh:
 6798 1D1E CD 58 03     	call KeysReadKeySaveDE		;1d1e	cd 58 03 	. X .
 6799 1D21 B7           	or a			;1d21	b7 	.
 6800 1D22 C4 A0 1D     	call nz,sub_1da0h		;1d22	c4 a0 1d 	. . .
 6801 1D25 22 E6 78     	ld (BAS_TmpCharPtr),hl	; last byte of code executed in current line		;1d25	22 e6 78 	" . x
 6802 1D28 ED 73 E8 78  	ld (BAS_StackPtr),sp		;1d28	ed 73 e8 78 	. s . x
 6803 1D2C 7E           	ld a,(hl)			;1d2c	7e 	~
 6804 1D2D FE 3A        	cp 03ah		;1d2d	fe 3a 	. :
 6805 1D2F 28 29        	jr z,l1d5ah		;1d2f	28 29 	( )
 6806 1D31 B7           	or a			;1d31	b7 	.
 6807 1D32 C2 97 19     	jp nz,ErrRaiseSyntax	; no - Raise 'SYNTAX ERROR'	;1d32	c2 97 19 	. . .
 6808 1D35 23           	inc hl			;1d35	23 	#
 6809 1D36              l1d36h:
 6810 1D36 7E           	ld a,(hl)			;1d36	7e 	~
 6811 1D37 23           	inc hl			;1d37	23 	#
 6812 1D38 B6           	or (hl)			;1d38	b6 	.
 6813 1D39 CA 7E 19     	jp z,l197eh		;1d39	ca 7e 19 	. ~ .
 6814 1D3C 23           	inc hl			;1d3c	23 	#
 6815 1D3D 5E           	ld e,(hl)			;1d3d	5e 	^
 6816 1D3E 23           	inc hl			;1d3e	23 	#
 6817 1D3F 56           	ld d,(hl)			;1d3f	56 	V
 6818 1D40 EB           	ex de,hl			;1d40	eb 	.
 6819 1D41 22 A2 78     	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;1d41	22 a2 78 	" . x
 6820 1D44 3A 1B 79     	ld a,(TRACEFLAG)		;1d44	3a 1b 79 	: . y
 6821 1D47 B7           	or a			;1d47	b7 	.
 6822 1D48 28 0F        	jr z,l1d59h		;1d48	28 0f 	( .
 6823 1D4A D5           	push de			;1d4a	d5 	.
 6824 1D4B 3E 3C        	ld a,'<'		;1d4b	3e 3c 	> <
 6825 1D4D CD 2A 03     	call PrintChar    ; Print '<' char on screen			;1d4d	cd 2a 03 	. * .
 6826 1D50 CD AF 0F     	call PrintLineNo	; Print Line number 	;1d50	cd af 0f 	. . .
 6827 1D53 3E 3E        	ld a,'>'		;1d53	3e 3e 	> >
 6828 1D55 CD 2A 03     	call PrintChar	; Print '>' char on screen		;1d55	cd 2a 03 	. * .
 6829 1D58 D1           	pop de			;1d58	d1 	.
 6830 1D59              l1d59h:
 6831 1D59 EB           	ex de,hl			;1d59	eb 	.
 6832 1D5A              l1d5ah:
 6833 1D5A D7           	rst $10			; move hl to next Basic token			;1d5a	d7 	.
 6834 1D5B 11 1E 1D     	ld de,l1d1eh		;1d5b	11 1e 1d 	. . .
 6835 1D5E D5           	push de			;1d5e	d5 	.
 6836 1D5F              l1d5fh:
 6837 1D5F C8           	ret z			;1d5f	c8 	.
 6838 1D60              l1d60h:
 6839 1D60 D6 80        	sub $80				; is it less than ;1d60	d6 80 	. .
 6840 1D62 DA 21 1F     	jp c,CmdLET			;1d62	da 21 1f 	. ! .
 6841 1D65 FE 3C        	cp 60				; 60 Basic commands defined ;1d65	fe 3c 	. <
 6842 1D67 D2 E7 2A     	jp nc,l2ae7h		;1d67	d2 e7 2a 	. . *
 6843 1D6A 07           	rlca			;1d6a	07 	.
 6844 1D6B 4F           	ld c,a			;1d6b	4f 	O
 6845 1D6C 06 00        	ld b,0			; bc - 16bit address offset ;1d6c	06 00 	. .
 6846 1D6E EB           	ex de,hl			;1d6e	eb 	.
 6847 1D6F 21 22 18     	ld hl,BasicCmdPointers	; All Basic Commands EntryPoint Table					;1d6f	21 22 18 	! " .
 6848 1D72 09           	add hl,bc			; hl - address of entry point for Command ;1d72	09 	.
 6849 1D73 4E           	ld c,(hl)			; low byte of address	;1d73	4e 	N
 6850 1D74 23           	inc hl				; points to hight byte ;1d74	23 	#
 6851 1D75 46           	ld b,(hl)			; bc - address of entry point for this Command	;1d75	46 	F
 6852 1D76 C5           	push bc				; push on stack - set as return address ;1d76	c5 	.
 6853 1D77 EB           	ex de,hl			;1d77	eb 	.
 6854 1D78
 6855 1D78              ; **********************************************************************************
 6856 1D78              ; System routine called via JumpTable using RST 10
 6857 1D78              ; Advances HL register pair to point to the next character of a BASIC program.
 6858 1D78              ; During a run of a BASIC program, the HL register pair normally points to the next byte
 6859 1D78              ; of the BASIC program to be executed. The RST 10 instruction causes HL to be incremented,
 6860 1D78              ; skipping space (20) or linefeed (0A) characters
 6861 1D78              ; IN: hl - byte in BASIC program
 6862 1D78              ; OUT: hl - next non-space char in BASIC program
 6863 1D78              ;      a - char pointed by hl
 6864 1D78              ;      Z - ':' or \0 found (end of BASIC statement)
 6865 1D78              ;      CY - '0'..'9' found (number)
 6866 1D78              ; Move hl to next Basic token
 6867 1D78              NextToken:
 6868 1D78 23           	inc hl				; (hl) - next char in BASIC program								;1d78	23 	#
 6869 1D79 7E           	ld a,(hl)			; a - char from basic program									;1d79	7e 	~
 6870 1D7A FE 3A        	cp ':'				; is ':' (end of statement) or greater (alpha or cmd code)		;1d7a	fe 3a 	. :
 6871 1D7C D0           	ret nc				; yes - return Z=1 (for ':'), CY=0 (letter ot cmd code)			;1d7c	d0 	.
 6872 1D7D              ; -- range (00..39) number, space or one of nonprintable characters
 6873 1D7D FE 20        	cp ' '				; is this <space>												;1d7d	fe 20 	.
 6874 1D7F CA 78 1D     	jp z,NextToken	    ; yes - skip and test next char									;1d7f	ca 78 1d 	. x .
 6875 1D82              ; -- range (00..1f,21..39) chack above 0A - digit or other
 6876 1D82 FE 0B        	cp #0B				; is in range 0B..39 (can be digit or other non-alpha char)		;1d82	fe 0b 	. .
 6877 1D84 30 05        	jr nc,.digits		; yes - check if digit and return								;1d84	30 05 	0 .
 6878 1D86              ; -- range (00..0A) check below 0B
 6879 1D86 FE 09        	cp #09				; is in range 09..0A (can be TAB or CR)							;1d86	fe 09 	. .
 6880 1D88 D2 78 1D     	jp nc,NextToken	    ; yes - skip and test next char									;1d88	d2 78 1d 	. x .
 6881 1D8B              .digits:
 6882 1D8B              ; -- char is in range (0B..39)
 6883 1D8B FE 30        	cp '0'				; CY=0 if char in range 30 to 39 (digit)						;1d8b	fe 30 	. 0
 6884 1D8D 3F           	ccf					; invert Carry flag (CY=1)										;1d8d	3f 	?
 6885 1D8E              ; -- set Z flag (instruction "inc r" doesnt change CY but sets Z if r==0)
 6886 1D8E 3C           	inc a				; preincrement a for test										;1d8e	3c 	<
 6887 1D8F 3D           	dec a				; restore a and set Z flag if a == 0							;1d8f	3d 	=
 6888 1D90 C9           	ret					; ----------- End of Proc ------------------------------------ 	;1d90	c9 	.
 6889 1D91
 6890 1D91
 6891 1D91              ; *******************************************************************************
 6892 1D91              ; BASIC RESTORE Entry Point
 6893 1D91              ; Resets the DATA pointer (at DatareadPtr) to point to the start of the BASIC program,
 6894 1D91              ; so that the next time a BASIC READ statement is executed, the first DATA item
 6895 1D91              ; in the program will be read,
 6896 1D91              ; IN: hl - current executed command parser
 6897 1D91              ;     a - command byte
 6898 1D91              ;     Z = 1 - end of statement ('\0' or ':' found)
 6899 1D91              ;     CY = 1 - char is digit
 6900 1D91              CmdRESTORE:
 6901 1D91 EB           	ex de,hl				; save hl 											;1d91	eb 	.
 6902 1D92 2A A4 78     	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 			;1d92	2a a4 78 	* . x
 6903 1D95 2B           	dec hl					; minus one - interpreter pointer					;1d95	2b 	+
 6904 1D96              l1d96h:
 6905 1D96 22 FF 78     	ld (DataReadPtr),hl	; save as new READ pointer 						;1d96	22 ff 78 	" . x
 6906 1D99 EB           	ex de,hl				; restore hl									;1d99	eb 	.
 6907 1D9A C9           	ret						; ------------- End of Proc ------------------- ;1d9a	c9 	.
 6908 1D9B
 6909 1D9B
 6910 1D9B              ; *********************************************************************************
 6911 1D9B              ; ROM BASIC check for BREAK or SHIFT-@ characters.
 6912 1D9B              ; Calls routine at 0358 (note warning for this routine - see above), decrements the A
 6913 1D9B              ; register, and takes appropriate action if either key is pressed (suspends program
 6914 1D9B              ; execution on SHIFT-@ or sets certain BASIC pointers, displays BREAK message,
 6915 1D9B              ; and goes to BASIC READY _ state on BREAK) - otherwise returns with keyboard
 6916 1D9B              ; character minus one- in A.
 6917 1D9B              sub_1d9bh:
 6918 1D9B CD 58 03     	call KeysReadKeySaveDE	; read Key Pressed if any								;1d9b	cd 58 03 	. X .
 6919 1D9E B7           	or a					; is any key pressed?									;1d9e	b7 	.
 6920 1D9F C8           	ret z					; no -------------- End of Proc ----------------------- ;1d9f	c8 	.
 6921 1DA0              sub_1da0h:
 6922 1DA0              ; -- removed TRS code
 6923 1DA0 00 00 00...  	block 5					; removed TRS code 										;1da0	00 00 00 00 00 	.
 6924 1DA5              ; -- save key pressed
 6925 1DA5 32 99 78     	ld (KEYS_LASTKEY),a		; store last key pressed								;1da5	32 99 78 	2 . x
 6926 1DA8 3D           	dec a					; check if BREAK key was pressed (a=01)					;1da8	3d 	=
 6927 1DA9
 6928 1DA9              ; ************************************************************************************************************
 6929 1DA9              ; BASIC STOP Entry Point
 6930 1DA9              ; IN: hl - current executed command parser
 6931 1DA9              ;     a - command byte
 6932 1DA9              ;     Z = 1 - end of statement ('\0' or ':' found)
 6933 1DA9              ;     CY = 1 - char is digit
 6934 1DA9              CmdSTOP
 6935 1DA9 C0           	ret nz					; no - return key char minus 1							;1da9	c0 	.
 6936 1DAA              ; -- BREAK was pressed
 6937 1DAA 3C           	inc a					; restore key code as BREAK (a=01)						;1daa	3c 	<
 6938 1DAB C3 B4 1D     	jp l1db4h				; skip code (probably TRS specific)						;1dab	c3 b4 1d 	. . .
 6939 1DAE
 6940 1DAE
 6941 1DAE              ; ************************************************************************************************************
 6942 1DAE              ; BASIC END Entry Point
 6943 1DAE              ; IN: hl - current executed command parser
 6944 1DAE              ;     a - command byte
 6945 1DAE              ;     Z = 1 - end of statement ('\0' or ':' found)
 6946 1DAE              ;     CY = 1 - char is digit
 6947 1DAE              CmdEND
 6948 1DAE C0           	ret nz			;1dae	c0 	.
 6949 1DAF F5           	push af			;1daf	f5 	.
 6950 1DB0 CC BB 79     	call z,SysExtNew		;1db0	cc bb 79 	. . y
 6951 1DB3 F1           	pop af			;1db3	f1 	.
 6952 1DB4              l1db4h:
 6953 1DB4 22 E6 78     	ld (BAS_TmpCharPtr),hl	; last byte of code executed in current line		;1db4	22 e6 78 	" . x
 6954 1DB7 21 B5 78     	ld hl,BAS_StrVars		; address of BASIC String Variables Area				;1db7	21 b5 78 	! . x
 6955 1DBA 22 B3 78     	ld (BAS_StrNextVar),hl	; set as next location in literal string pool	;1dba	22 b3 78 	" . x
 6956 1DBD 21 F6 FF     	ld hl,0fff6h		;1dbd	21 f6 ff 	! . .
 6957 1DC0 C1           	pop bc			;1dc0	c1 	.
 6958 1DC1              l1dc1h:
 6959 1DC1 2A A2 78     	ld hl,(BasicLineNo)	; Current Basic Line Number 		;1dc1	2a a2 78 	* . x
 6960 1DC4 E5           	push hl			;1dc4	e5 	.
 6961 1DC5 F5           	push af			;1dc5	f5 	.
 6962 1DC6 7D           	ld a,l			    ; low byte of Current Basic Line number ;1dc6	7d 	}
 6963 1DC7 A4           	and h			    ; a = $ff (-1) only if Line number is $ffff (-1) ;1dc7	a4 	.
 6964 1DC8 3C           	inc a			    ; a = 0 if line number is $ffff (-1) ;1dc8	3c 	<
 6965 1DC9 28 09        	jr z,l1dd4h		    ; jump if interractive mode ;1dc9	28 09 	( .
 6966 1DCB 22 F5 78     	ld (BAS_LastLineNo),hl	; last line number executed before STOP or END			;1dcb	22 f5 78 	" . x
 6967 1DCE 2A E6 78     	ld hl,(BAS_TmpCharPtr)	; last byte of code executed in current line		;1dce	2a e6 78 	* . x
 6968 1DD1 22 F7 78     	ld (BAS_StopedPtr),hl	; set as address of Basic code executed before STOP 		;1dd1	22 f7 78 	" . x
 6969 1DD4              l1dd4h:
 6970 1DD4 CD 8B 03     	call SwitchPrnToScr		; Flush Printer and change current Out Device to Screeen	;1dd4	cd 8b 03 	. . .
 6971 1DD7 CD F9 20     	call SysNewLine		    ; move cursor to begin of next line                 ;1dd7	cd f9 20 	. .
 6972 1DDA F1           	pop af			        ;1dda	f1 	.
 6973 1DDB 21 30 19     	ld hl,TXT_BREAK		;1ddb	21 30 19 	! 0 .
 6974 1DDE C2 06 1A     	jp nz,l1a06h		;1dde	c2 06 1a 	. . .
 6975 1DE1 C3 18 1A     	jp BAS_ReadyPopBC		; take address from CPU stack and goto Basic READY state	;1de1	c3 18 1a 	. . .
 6976 1DE4
 6977 1DE4              ; ***********************************************************************************************
 6978 1DE4              ; BASIC CONT Entry Point
 6979 1DE4              ; IN: hl - current executed command parser
 6980 1DE4              ;     a - command byte
 6981 1DE4              ;     Z = 1 - end of statement ('\0' or ':' found)
 6982 1DE4              ;     CY = 1 - char is digit
 6983 1DE4              CmdCONT
 6984 1DE4 2A F7 78     	ld hl,(BAS_StopedPtr)	; address of Basic code executed just before STOP 		;1de4	2a f7 78 	* . x
 6985 1DE7 7C           	ld a,h			;1de7	7c 	|
 6986 1DE8 B5           	or l			;1de8	b5 	.
 6987 1DE9 1E 20        	ld e,#20				; ERROR 20 - CAN'T CONT		;1de9	1e 20 	.
 6988 1DEB CA A2 19     	jp z,ErrRaiseError		; Raise Error if hl == 0 ;1deb	ca a2 19 	. . .
 6989 1DEE EB           	ex de,hl			;1dee	eb 	.
 6990 1DEF 2A F5 78     	ld hl,(BAS_LastLineNo)	; last line number executed before STOP or END			;1def	2a f5 78 	* . x
 6991 1DF2 22 A2 78     	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;1df2	22 a2 78 	" . x
 6992 1DF5 EB           	ex de,hl			;1df5	eb 	.
 6993 1DF6 C9           	ret			;1df6	c9 	.
 6994 1DF7
 6995 1DF7              ; ***********************************************************************************************
 6996 1DF7              ; BASIC TRON Entry Point
 6997 1DF7              ; Enables the BASIC trace function by setting TraceFlag to non-zero.
 6998 1DF7              ; IN: hl - current executed command parser
 6999 1DF7              ;     a - command byte
 7000 1DF7              ;     Z = 1 - end of statement ('\0' or ':' found)
 7001 1DF7              ;     CY = 1 - char is digit
 7002 1DF7              CmdTRON
 7003 1DF7 3E           	db $3e				; trick byte - along with next makes ld a,$af	; a - non-zero - Trace ON	;1df7	3e af 	> .
 7004 1DF8              	; ld a,$af 			; skips next "xor a" instruction
 7005 1DF8
 7006 1DF8              ; ***********************************************************************************************
 7007 1DF8              ; BASIC TRON Entry Point
 7008 1DF8              ; Disables the BASIC trace function by setting TraceFlag to zero.
 7009 1DF8              ; IN: hl - current executed command parser
 7010 1DF8              ;     a - command byte
 7011 1DF8              ;     Z = 1 - end of statement ('\0' or ':' found)
 7012 1DF8              ;     CY = 1 - char is digit
 7013 1DF8              CmdTROFF
 7014 1DF8 AF           	xor a				; a - 0 - Trace Off														;1df8	af 	> .
 7015 1DF9 32 1B 79     	ld (TRACEFLAG),a	; clear TraceFlag - Trace cmdTrOff										;1df9	32 1b 79 	2 . y
 7016 1DFC C9           	ret					; --------------------- End of Proc -----------------------------------	;1dfc	c9 	.
 7017 1DFD
 7018 1DFD
 7019 1DFD F1           	pop af			;1dfd	f1 	.
 7020 1DFE E1           	pop hl			;1dfe	e1 	.
 7021 1DFF C9           	ret			;1dff	c9 	.
 7022 1E00
 7023 1E00              ; ********************************************************************************
 7024 1E00              ; [TRS] BASIC DEFSTR Entry Point
 7025 1E00              ; IN: hl - current executed command parser
 7026 1E00              ;     a - command byte
 7027 1E00              ;     Z = 1 - end of statement ('\0' or ':' found)
 7028 1E00              ;     CY = 1 - char is digit
 7029 1E00              CmdDEFSTR
 7030 1E00 1E 03        	ld e,3			; e - Number Type Format (String)								;1e00	1e 03 	. .
 7031 1E02 01           	db $01 			; trick byte - with next constructs irrevelant ld bc,$021e		;1e02	01 1e 02 	. . .
 7032 1E03
 7033 1E03              ; ********************************************************************************
 7034 1E03              ; [TRS] BASIC DEFINT Entry Point
 7035 1E03              ; IN: hl - current executed command parser
 7036 1E03              ;     a - command byte
 7037 1E03              ;     Z = 1 - end of statement ('\0' or ':' found)
 7038 1E03              ;     CY = 1 - char is digit
 7039 1E03              CmdDEFINT
 7040 1E03 1E 02        	ld e,2			; e - Number Type Format (Integer)								;1e03	1e 02 	. . . ;
 7041 1E05 01           	db $01 			; trick byte - with next constructs irrevelant ld bc,l041eh		;1e05	01 1e 04 	. . .
 7042 1E06
 7043 1E06              ; ********************************************************************************
 7044 1E06              ; [TRS] BASIC DEFSNG Entry Point
 7045 1E06              ; IN: hl - current executed command parser
 7046 1E06              ;     a - command byte
 7047 1E06              ;     Z = 1 - end of statement ('\0' or ':' found)
 7048 1E06              ;     CY = 1 - char is digit
 7049 1E06              CmdDEFSNG
 7050 1E06 1E 04        	ld e,4			; e - Number Type Format (Single)								;1e06	1e 04 	. . .
 7051 1E08 01           	db $01 			; trick byte - with next constructs irrevelant ld bc,l081eh		;1e08	01 1e 08 	. . .
 7052 1E09
 7053 1E09              ; ********************************************************************************
 7054 1E09              ; [TRS] BASIC DEFDBL Entry Point
 7055 1E09              ; IN: hl - current executed command parser
 7056 1E09              ;     a - command byte
 7057 1E09              ;     Z = 1 - end of statement ('\0' or ':' found)
 7058 1E09              ;     CY = 1 - char is digit
 7059 1E09              CmdDEFDBL
 7060 1E09 1E 08        	ld e,8			; e - Number Type Format (Double)								;1e09	1e 08 	. . .
 7061 1E0B
 7062 1E0B              l1e0bh:
 7063 1E0B CD 3D 1E     	call SysIsLetter		;1e0b	cd 3d 1e 	. = .
 7064 1E0E 01 97 19     	ld bc,ErrRaiseSyntax	; routine Raise 'SYNTAX ERROR'	;1e0e	01 97 19 	. . .
 7065 1E11 C5           	push bc			        ; put routine as return address on Stack ;1e11	c5 	.
 7066 1E12 D8           	ret c			        ; Raise 'SYNTAX ERROR';1e12	d8 	.
 7067 1E13 D6 41        	sub 041h		;1e13	d6 41 	. A
 7068 1E15 4F           	ld c,a			;1e15	4f 	O
 7069 1E16 47           	ld b,a			;1e16	47 	G
 7070 1E17 D7           	rst $10			; move hl to next Basic token			;1e17	d7 	.
 7071 1E18 FE CE        	cp $ce		    ; is it Basic '-' token ;1e18	fe ce 	. .
 7072 1E1A 20 09        	jr nz,l1e25h	; no - 	;1e1a	20 09 	  .
 7073 1E1C D7           	rst $10			; move hl to next Basic token			;1e1c	d7 	.
 7074 1E1D CD 3D 1E     	call SysIsLetter		;1e1d	cd 3d 1e 	. = .
 7075 1E20 D8           	ret c			;1e20	d8 	.
 7076 1E21 D6 41        	sub 041h		;1e21	d6 41 	. A
 7077 1E23 47           	ld b,a			;1e23	47 	G
 7078 1E24 D7           	rst $10			; move hl to next Basic token				;1e24	d7 	.
 7079 1E25              l1e25h:
 7080 1E25 78           	ld a,b			;1e25	78 	x
 7081 1E26 91           	sub c			;1e26	91 	.
 7082 1E27 D8           	ret c			;1e27	d8 	.
 7083 1E28 3C           	inc a			;1e28	3c 	<
 7084 1E29 E3           	ex (sp),hl			;1e29	e3 	.
 7085 1E2A 21 01 79     	ld hl,BAS_VarTypesTab	; address of Variable Declarations Table				;1e2a	21 01 79 	! . y
 7086 1E2D 06 00        	ld b,000h		;1e2d	06 00 	. .
 7087 1E2F 09           	add hl,bc			;1e2f	09 	.
 7088 1E30              l1e30h:
 7089 1E30 73           	ld (hl),e			;1e30	73 	s
 7090 1E31 23           	inc hl			;1e31	23 	#
 7091 1E32 3D           	dec a			;1e32	3d 	=
 7092 1E33 20 FB        	jr nz,l1e30h		;1e33	20 fb 	  .
 7093 1E35 E1           	pop hl			;1e35	e1 	.
 7094 1E36 7E           	ld a,(hl)			;1e36	7e 	~
 7095 1E37 FE 2C        	cp 02ch		;1e37	fe 2c 	. ,
 7096 1E39 C0           	ret nz			;1e39	c0 	.
 7097 1E3A D7           	rst $10			; move hl to next Basic token					;1e3a	d7 	.
 7098 1E3B 18 CE        	jr l1e0bh		;1e3b	18 ce 	. .
 7099 1E3D
 7100 1E3D              ; ********************************************************************************
 7101 1E3D              ; CHECK FOR UPPERCASE ALPHABETIC CHARACTER AT (HL)
 7102 1E3D              ; If the byte pointed to by the HL register pair contains the ASCII code
 7103 1E3D              ; for an uppercase letter of the alphabet (A-Z), the C flag will not be set,
 7104 1E3D              ; otherwise the C flag will be set on return.
 7105 1E3D              ; IN: (hl) - char to test
 7106 1E3D              ; OUT: CY - 0 - char in range 'A'..'Z', 1 - char outside of range
 7107 1E3D              SysIsLetter:
 7108 1E3D 7E           	ld a,(hl)			; a - char to test											;1e3d	7e 	~
 7109 1E3E FE 41        	cp 'A'				; is less than 'A'											;1e3e	fe 41 	. A
 7110 1E40 D8           	ret c				; yes - return with CY=1									;1e40	d8 	.
 7111 1E41 FE 5B        	cp '['				; set CY=1 if les than '[' => in range 'A'..'Z' 			;1e41	fe 5b 	. [
 7112 1E43 3F           	ccf					; invert CY													;1e43	3f 	?
 7113 1E44 C9           	ret					; return with CY ------------------------------------------	;1e44	c9 	.
 7114 1E45
 7115 1E45
 7116 1E45              sub_1e45h:
 7117 1E45 D7           	rst $10			; move hl to next Basic token					;1e45	d7 	.
 7118 1E46
 7119 1E46              ; *********************************************************************************
 7120 1E46              ; LOAD POSITIVE INTEGER EXPRESSION INTO DE
 7121 1E46              ; Same as following routine (at 1E5A) except that HL may also point to any valid
 7122 1E46              ; BASIC variable or expression, which must evaluate to a number in range to 32767
 7123 1E46              ; decimal (used to get argument of BASIC CLEAR command).
 7124 1E46              ; NOTE that this routine assumes that BASIC is operational. Results may be unpredictable
 7125 1E46              ; if this is not the case, particularly if a BASIC variable name (or something
 7126 1E46              ; that could be interpreted as such) is part of the string.
 7127 1E46              ; IN: hl - address of BASIC expression
 7128 1E46              ; OUT: de - number converted
 7129 1E46              BAS_uiConvExpToDE:
 7130 1E46 CD 02 2B     	call EvalIntExpr	; load integer expression ito de register				;1e46	cd 02 2b 	. . +
 7131 1E49 F0           	ret p					; if result positive ---- End of Proc ----------------	;1e49	f0 	.
 7132 1E4A              ErrRaiseFuncCode:
 7133 1E4A 1E 08        	ld e,#08			; ERROR 08 - FUNCTION CODE	;1e4a	1e 08 	. .
 7134 1E4C C3 A2 19     	jp ErrRaiseError	; Raise FUNCTION CODE Error	;1e4c	c3 a2 19 	. . .
 7135 1E4F
 7136 1E4F
 7137 1E4F
 7138 1E4F
 7139 1E4F              sub_1e4fh:
 7140 1E4F 7E           	ld a,(hl)			;1e4f	7e 	~
 7141 1E50 FE 2E        	cp '.'		        ;1e50	fe 2e 	. .
 7142 1E52 EB           	ex de,hl			;1e52	eb 	.
 7143 1E53 2A EC 78     	ld hl,(EditLineNo)	; Basic Line Number currently Edited	;1e53	2a ec 78 	* . x
 7144 1E56 EB           	ex de,hl			;1e56	eb 	.
 7145 1E57 CA 78 1D     	jp z,NextToken		; yes - move hl to next Basic token ;1e57	ca 78 1d 	. x .
 7146 1E5A
 7147 1E5A              ; *********************************************************************************
 7148 1E5A              ; LOAD POSITIVE INTEGER CONSTANT IN DE
 7149 1E5A              ; Evaluate the string at the address pointed to by HL register pair for a positive
 7150 1E5A              ; integer value (such as a BASIC line number), stopping at the first non-numeric character.
 7151 1E5A              ; The result is returned in DE register pair. A value of zero is returned if no numeric
 7152 1E5A              ; value is found. Maximum allowable number is 65529 dec.
 7153 1E5A              ; NOTE: If this routine is being used to obtain a BASIC line number, it may be CALLed
 7154 1E5A              ; at 1E4F. In this case, a period ($2e) character at (HL) will cause the routine
 7155 1E5A              ; to return with the "current" BASIC line number as stored at BAS_EditLineNo)
 7156 1E5A              ; IN:  hl - address of ASCII string of number to convert
 7157 1E5A              ; OUT: de - number converted
 7158 1E5A              ;      a - token byte (0 if end of Basic Statement)
 7159 1E5A              ;      flags - like from NextToken
 7160 1E5A              TextToInt:
 7161 1E5A 2B           	dec hl				; set parse address just before text to convert				;1e5a	2b 	+
 7162 1E5B              TextToInt2:
 7163 1E5B 11 00 00     	ld de,$0000		    ; reset result value to 0                                   ;1e5b	11 00 00 	. . .
 7164 1E5E              .loop:
 7165 1E5E D7           	rst $10			    ; move hl to next Basic token - is it Digit ?				;1e5e	d7 	.
 7166 1E5F D0           	ret nc			    ; not digit - return result ------------------------------- ;1e5f	d0 	.
 7167 1E60              ; -- a contains digit from (hl) address
 7168 1E60 E5           	push hl			    ; save hl - parse current address                           ;1e60	e5 	.
 7169 1E61 F5           	push af			    ; save a - digit                                            ;1e61	f5 	.
 7170 1E62              ; -- assert line number (after one more decimal digit added) won't become bigger than max
 7171 1E62 21 98 19     	ld hl,6552		    ; 65520 (max line number) divided by 10                     ;1e62	21 98 19 	! . .
 7172 1E65 DF           	rst #18			    ; is current result (de) bigger than 6552 ?                 ;1e65	df 	.
 7173 1E66 DA 97 19     	jp c,ErrRaiseSyntax	; yes - raise 'SYNTAX ERROR'	                            ;1e66	da 97 19 	. . .
 7174 1E69              ; -- converted value less than max - multiply it by 10
 7175 1E69 62           	ld h,d			                                                                ;1e69	62 	b
 7176 1E6A 6B           	ld l,e				; hl - value to multiply									;1e6a	6b 	k
 7177 1E6B 19           	add hl,de			; hl = value * 2											;1e6b	19 	.
 7178 1E6C 29           	add hl,hl			; hl = value * 4											;1e6c	29 	)
 7179 1E6D 19           	add hl,de			; hl = value * 5											;1e6d	19 	.
 7180 1E6E 29           	add hl,hl			; hl - value * 10											;1e6e	29 	)
 7181 1E6F              ; -- add digit from text
 7182 1E6F F1           	pop af				; digit char ('0'..'9')										;1e6f	f1 	.
 7183 1E70 D6 30        	sub $30				; a = value in range 0..9									;1e70	d6 30 	. 0
 7184 1E72 5F           	ld e,a				; e - value to low byte 									;1e72	5f 	_
 7185 1E73 16 00        	ld d,0				; de - value as 16bit										;1e73	16 00 	. .
 7186 1E75 19           	add hl,de			; hl - converted number										;1e75	19 	.
 7187 1E76 EB           	ex de,hl			; set as return value										;1e76	eb 	.
 7188 1E77 E1           	pop hl				; restore hl - current parser address						;1e77	e1 	.
 7189 1E78 18 E4        	jr .loop			; continue as long as digit is next char					;1e78	18 e4 	. .
 7190 1E7A
 7191 1E7A
 7192 1E7A              ; **********************************************************************************************
 7193 1E7A              ; BASIC CLEAR Entry Point
 7194 1E7A              ; CLEAR [<I>]
 7195 1E7A              ; Erases all variables currently in memory. If present, I indicates the amount of space
 7196 1E7A              ; to be allocated for the string heap; otherwise, the default is 50 or 200 bytes (depending on ROM version).
 7197 1E7A              ; IN: hl - current executed command parser
 7198 1E7A              ;     a - command byte
 7199 1E7A              ;     Z = 1 - end of statement ('\0' or ':' found)
 7200 1E7A              ;     CY = 1 - char is digit
 7201 1E7A
 7202 1E7A              CmdCLEAR
 7203 1E7A              ; -- if Z=1
 7204 1E7A CA 61 1B     	jp z,BAS_ResetVars	; no <I> argument - erase all Basic Variables 			;1e7a	ca 61 1b 	. a .
 7205 1E7D              ; -- <I> is given - read expression to de
 7206 1E7D CD 46 1E     	call BAS_uiConvExpToDE	; load positive integer expression into de register	;1e7d	cd 46 1e 	. F .
 7207 1E80 2B           	dec hl				;1e80	2b 	+
 7208 1E81 D7           	rst $10				; move hl to next Basic token							;1e81	d7 	.
 7209 1E82 C0           	ret nz				; return if not End of statement ('\0' or ':')			;1e82	c0 	.
 7210 1E83
 7211 1E83
 7212 1E83              ; **********************************************************************************************
 7213 1E83              ; CLEAR n
 7214 1E83              ; Reserves a number of bytes of memory for string storage (resets the "start of string
 7215 1E83              ; space" pointer at 78A0), then jumps to the ResetVars
 7216 1E83              ; IN: de - number of bytes to reserve
 7217 1E83 E5           	push hl			; save hl 													;1e83	e5 	.
 7218 1E84 2A B1 78     	ld hl,(MEMORY_TOP)	; address of top memory (as detected at boot)			;1e84	2a b1 78 	* . x
 7219 1E87              ; -- subtract de - number of bytes to reserve
 7220 1E87 7D           	ld a,l				; a - low byte of address								;1e87	7d 	}
 7221 1E88 93           	sub e				; subtract low byte of number							;1e88	93 	.
 7222 1E89 5F           	ld e,a				; save to e												;1e89	5f 	_
 7223 1E8A 7C           	ld a,h				; a - high byte of address								;1e8a	7c 	|
 7224 1E8B 9A           	sbc a,d				; subtract high byte of number (and CY)					;1e8b	9a 	.
 7225 1E8C 57           	ld d,a				; de - new top memory address							;1e8c	57 	W
 7226 1E8D              ; -- CY=1 if try to reserve more memory we have
 7227 1E8D DA 7A 19     	jp c,ErrRaiseOutOfMem	; if < 0 - Raise OUT OF MEMORY Error				;1e8d	da 7a 19 	. z .
 7228 1E90              ; -- check if it's above memory taken by existing Basic Program
 7229 1E90 2A F9 78     	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program					;1e90	2a f9 78 	* . x
 7230 1E93 01 28 00     	ld bc,40			; 40 bytes reserved (variables??)						;1e93	01 28 00 	. ( .
 7231 1E96 09           	add hl,bc			; hl - minimum memory already taken						;1e96	09 	.
 7232 1E97 DF           	rst #18				; is hl > de ? 											;1e97	df 	.
 7233 1E98 D2 7A 19     	jp nc,ErrRaiseOutOfMem	; yes - Raise OUT OF MEMORY Error					;1e98	d2 7a 19 	. z .
 7234 1E9B              ; -- de is valid
 7235 1E9B EB           	ex de,hl			; hl - new top memory address							;1e9b	eb 	.
 7236 1E9C 22 A0 78     	ld (STACKTOPPTR),hl	; set top of Basic Stack pointer						;1e9c	22 a0 78 	" . x
 7237 1E9F E1           	pop hl				; restore hl											;1e9f	e1 	.
 7238 1EA0 C3 61 1B     	jp BAS_ResetVars	; reset all Basic Variables	and Basic Program state 	;1ea0	c3 61 1b 	. a .
 7239 1EA3
 7240 1EA3
 7241 1EA3              ; *************************************************************************************
 7242 1EA3              ; BASIC RUN Entry Point
 7243 1EA3              ; IN: hl - current executed command parser
 7244 1EA3              ;     a - command byte
 7245 1EA3              ;     Z = 1 - end of statement ('\0' or ':' found)
 7246 1EA3              ;     CY = 1 - char is digit
 7247 1EA3              CmdRUN
 7248 1EA3 CA 5D 1B     	jp z,ResetBasicPrg	; Reset Parse point, variables, arrays, strings, stack and error state		;1ea3	ca 5d 1b 	. ] .
 7249 1EA6 CD C7 79     	call SysExtRunFile		;1ea6	cd c7 79 	. . y
 7250 1EA9 CD 61 1B     	call BAS_ResetVars	; reset all Basic Variables	and Basic Program state 	;1ea9	cd 61 1b 	. a .
 7251 1EAC 01 1E 1D     	ld bc,l1d1eh		;1eac	01 1e 1d 	. . .
 7252 1EAF 18 10        	jr l1ec1h		;1eaf	18 10 	. .
 7253 1EB1
 7254 1EB1
 7255 1EB1
 7256 1EB1              ; *************************************************************************************
 7257 1EB1              ; BASIC GOSUB Entry Point
 7258 1EB1              ; IN: hl - current executed command parser
 7259 1EB1              ;     a - command byte
 7260 1EB1              ;     Z = 1 - end of statement ('\0' or ':' found)
 7261 1EB1              ;     CY = 1 - char is digit
 7262 1EB1              CmdGOSUB
 7263 1EB1 0E 03        	ld c,003h		;1eb1	0e 03 	. .
 7264 1EB3 CD 63 19     	call sub_1963h		;1eb3	cd 63 19 	. c .
 7265 1EB6 C1           	pop bc			;1eb6	c1 	.
 7266 1EB7 E5           	push hl			;1eb7	e5 	.
 7267 1EB8 E5           	push hl			;1eb8	e5 	.
 7268 1EB9 2A A2 78     	ld hl,(BasicLineNo)	; Current Basic Line Number 		;1eb9	2a a2 78 	* . x
 7269 1EBC E3           	ex (sp),hl			;1ebc	e3 	.
 7270 1EBD 3E 91        	ld a,091h		;1ebd	3e 91 	> .
 7271 1EBF F5           	push af			;1ebf	f5 	.
 7272 1EC0 33           	inc sp			;1ec0	33 	3
 7273 1EC1              l1ec1h:
 7274 1EC1 C5           	push bc			;1ec1	c5 	.
 7275 1EC2
 7276 1EC2
 7277 1EC2
 7278 1EC2
 7279 1EC2              ; ************************************************************************************
 7280 1EC2              ; BASIC GOTO Entry Point
 7281 1EC2              ; IN: hl - current executed command parser
 7282 1EC2              ;     a - command byte
 7283 1EC2              ;     Z = 1 - end of statement ('\0' or ':' found)
 7284 1EC2              ;     CY = 1 - char is digit
 7285 1EC2              CmdGOTO:
 7286 1EC2 CD 5A 1E     	call TextToInt	; de - convert following text into Line Number 			;1ec2	cd 5a 1e 	. Z .
 7287 1EC5              l1ec5h:
 7288 1EC5 CD 07 1F     	call CmdDATA+2		;1ec5	cd 07 1f 	. . .
 7289 1EC8 E5           	push hl			;1ec8	e5 	.
 7290 1EC9 2A A2 78     	ld hl,(BasicLineNo)	; Current Basic Line Number 		;1ec9	2a a2 78 	* . x
 7291 1ECC DF           	rst #18			; Compare HL and DE ;1ecc	df 	.
 7292 1ECD E1           	pop hl			;1ecd	e1 	.
 7293 1ECE 23           	inc hl			;1ece	23 	#
 7294 1ECF DC 2F 1B     	call c,l1b2fh		;1ecf	dc 2f 1b 	. / .
 7295 1ED2 D4 2C 1B     	call nc,FindBasicLine	; find Basic line with number in de						;1ed2	d4 2c 1b 	. , .
 7296 1ED5 60           	ld h,b			;1ed5	60 	`
 7297 1ED6 69           	ld l,c			;1ed6	69 	i
 7298 1ED7 2B           	dec hl			;1ed7	2b 	+
 7299 1ED8 D8           	ret c			;1ed8	d8 	.
 7300 1ED9              ErrRaiseUndefStatement:
 7301 1ED9 1E 0E        	ld e,#0e			; ERROR 0E - UNDEF'D STATEMENT	;1ed9	1e 0e 	. .
 7302 1EDB C3 A2 19     	jp ErrRaiseError	; Raise UNDEF'D STATEMENT Error	;1edb	c3 a2 19 	. . .
 7303 1EDE
 7304 1EDE
 7305 1EDE
 7306 1EDE              ; ******************************************************************************************
 7307 1EDE              ; BASIC RETURN Entry Point
 7308 1EDE              ; IN: hl - current executed command parser
 7309 1EDE              ;     a - command byte
 7310 1EDE              ;     Z = 1 - end of statement ('\0' or ':' found)
 7311 1EDE              ;     CY = 1 - char is digit
 7312 1EDE              CmdRETURN
 7313 1EDE C0           	ret nz			;1ede	c0 	.
 7314 1EDF 16 FF        	ld d,0ffh		;1edf	16 ff 	. .
 7315 1EE1 CD 36 19     	call sub_1936h		;1ee1	cd 36 19 	. 6 .
 7316 1EE4 F9           	ld sp,hl			;1ee4	f9 	.
 7317 1EE5 22 E8 78     	ld (BAS_StackPtr),hl		;1ee5	22 e8 78 	" . x
 7318 1EE8 FE 91        	cp $91		    ; is it Basic 'GOSUB' token ;1ee8	fe 91 	. .
 7319 1EEA 1E 04        	ld e,#04			; ERROR 04 - RET'N WITHOUT GOSUB	;1eea	1e 04 	. .
 7320 1EEC C2 A2 19     	jp nz,ErrRaiseError	; Raise Error if 	;1eec	c2 a2 19 	. . .
 7321 1EEF E1           	pop hl			;1eef	e1 	.
 7322 1EF0 22 A2 78     	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;1ef0	22 a2 78 	" . x
 7323 1EF3 23           	inc hl			;1ef3	23 	#
 7324 1EF4 7C           	ld a,h			;1ef4	7c 	|
 7325 1EF5 B5           	or l			;1ef5	b5 	.
 7326 1EF6 20 07        	jr nz,l1effh		;1ef6	20 07 	  .
 7327 1EF8 3A DD 78     	ld a,(INPUTFLAG)	; Flag indicates whether inputing text.	;1ef8	3a dd 78 	: . x
 7328 1EFB B7           	or a			;1efb	b7 	.
 7329 1EFC C2 18 1A     	jp nz,BAS_ReadyPopBC	; take address from CPU stack and goto Basic READY state		;1efc	c2 18 1a 	. . .
 7330 1EFF              l1effh:
 7331 1EFF 21 1E 1D     	ld hl,l1d1eh		;1eff	21 1e 1d 	! . .
 7332 1F02 E3           	ex (sp),hl			;1f02	e3 	.
 7333 1F03 3E E1        	ld a,0e1h		;1f03	3e e1 	> .
 7334 1F05
 7335 1F05
 7336 1F05              ; ************************************************************************************************
 7337 1F05              ; BASIC DATA Entry Point
 7338 1F05              ; IN: hl - current executed command parser
 7339 1F05              ;     a - command byte
 7340 1F05              ;     Z = 1 - end of statement ('\0' or ':' found)
 7341 1F05              ;     CY = 1 - char is digit
 7342 1F05              CmdDATA:
 7343 1F05 01 3A        	db $01,$3a			; c = 3a - trick bytes - with next constructs ld bc,$0e3a : nop				;1f05	01 3a 0e 00	. : .
 7344 1F07              ; ************************************************************************************************
 7345 1F07              ; BASIC REM Entry Point
 7346 1F07              ; BASIC ELSE Entry Point
 7347 1F07              ; INCREMENT HL (IF NECESSARY) UNTIL (HL)=0
 7348 1F07              ; Used by BASIC to advance the program pointer (HL register pair) to the end
 7349 1F07              ; of the BASIC line (to skip REM statements or ELSE clauses that are not executed).
 7350 1F07              ; On entry, if HL points to a zero byte no action is taken, otherwise HL is
 7351 1F07              ; incremented until it does point to a zero byte.
 7352 1F07              ; IN: hl - current executed command parser
 7353 1F07              ;     a - command byte
 7354 1F07              ;     Z = 1 - end of statement ('\0' or ':' found)
 7355 1F07              ;     CY = 1 - char is digit
 7356 1F07              CmdREM
 7357 1F07              CmdELSE
 7358 1F07 0E 00        	ld c,0			;1f07	0e 00 	.
 7359 1F09 06 00        	ld b,0			;1f09	06 00 	. .
 7360 1F0B              l1f0bh:
 7361 1F0B 79           	ld a,c			;1f0b	79 	y
 7362 1F0C 48           	ld c,b			;1f0c	48 	H
 7363 1F0D 47           	ld b,a			;1f0d	47 	G
 7364 1F0E              l1f0eh:
 7365 1F0E 7E           	ld a,(hl)			;1f0e	7e 	~
 7366 1F0F B7           	or a			;1f0f	b7 	.
 7367 1F10 C8           	ret z			;1f10	c8 	.
 7368 1F11 B8           	cp b			;1f11	b8 	.
 7369 1F12 C8           	ret z			;1f12	c8 	.
 7370 1F13 23           	inc hl			;1f13	23 	#
 7371 1F14 FE 22        	cp 022h		;1f14	fe 22 	. "
 7372 1F16 28 F3        	jr z,l1f0bh		;1f16	28 f3 	( .
 7373 1F18 D6 8F        	sub 08fh		;1f18	d6 8f 	. .
 7374 1F1A 20 F2        	jr nz,l1f0eh		;1f1a	20 f2 	  .
 7375 1F1C B8           	cp b			;1f1c	b8 	.
 7376 1F1D 8A           	adc a,d			;1f1d	8a 	.
 7377 1F1E 57           	ld d,a			;1f1e	57 	W
 7378 1F1F 18 ED        	jr l1f0eh		;1f1f	18 ed 	. .
 7379 1F21
 7380 1F21
 7381 1F21
 7382 1F21              ; ******************************************************************************************
 7383 1F21              ; BASIC LET Entry Point
 7384 1F21              ; Evaluate and assign expression to BASIC variable
 7385 1F21              ; IN: (hl) - first char variable name followed by BASIC '=' (D5) and expression
 7386 1F21              ; IN: hl - current executed command parser
 7387 1F21              ;     a - command byte
 7388 1F21              ;     Z = 1 - end of statement ('\0' or ':' found)
 7389 1F21              ;     CY = 1 - char is digit
 7390 1F21              CmdLET:
 7391 1F21 CD 0D 26     	call GetVarAddr	; locate or create Basic Variable						;1f21	cd 0d 26 	. . &
 7392 1F24              ; -- de - address of BASIC variable
 7393 1F24 CF           	rst $08			; Assert next token is '=' ;1f24	cf 	.
 7394 1F25 D5           	db $d5			; Basic token '=' ;1f25	d5 	.
 7395 1F26 EB           	ex de,hl			;1f26	eb 	.
 7396 1F27 22 DF 78     	ld (BAS_NewVarPtr),hl	; set as current Variable address					;1f27	22 df 78 	" . x
 7397 1F2A EB           	ex de,hl			;1f2a	eb 	.
 7398 1F2B D5           	push de			; save de - variable address ;1f2b	d5 	.
 7399 1F2C E7           	rst #20			; test NTF (Number Type Format)	;1f2c	e7 	.
 7400 1F2D F5           	push af			; save af - Number Type Format ;1f2d	f5 	.
 7401 1F2E CD 37 23     	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;1f2e	cd 37 23 	. 7 #
 7402 1F31 F1           	pop af			; restore af - Number Type Format ;1f31	f1 	.
 7403 1F32 E3           	ex (sp),hl			;1f32	e3 	.
 7404 1F33              l1f33h:
 7405 1F33 C6 03        	add a,003h		;1f33	c6 03 	. .
 7406 1F35 CD 19 28     	call sub_2819h		;1f35	cd 19 28 	. . (
 7407 1F38 CD 03 0A     	call GetACCMSBPtr	; de - start of ACC bytes	;1f38	cd 03 0a 	. . .
 7408 1F3B E5           	push hl			;1f3b	e5 	.
 7409 1F3C 20 28        	jr nz,l1f66h		;1f3c	20 28 	  (
 7410 1F3E 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;1f3e	2a 21 79 	* ! y
 7411 1F41 E5           	push hl			;1f41	e5 	.
 7412 1F42 23           	inc hl			;1f42	23 	#
 7413 1F43 5E           	ld e,(hl)			;1f43	5e 	^
 7414 1F44 23           	inc hl			;1f44	23 	#
 7415 1F45 56           	ld d,(hl)			;1f45	56 	V
 7416 1F46 2A A4 78     	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;1f46	2a a4 78 	* . x
 7417 1F49              sub_1f49h:
 7418 1F49 DF           	rst #18			; Compare HL and DE ;1f49	df 	.
 7419 1F4A 30 0E        	jr nc,$+16		;1f4a	30 0e 	0 .
 7420 1F4C 2A A0 78     	ld hl,(STACKTOPPTR)	; top of Basic Stack Pointer	;1f4c	2a a0 78 	* . x
 7421 1F4F DF           	rst #18			; Compare HL and DE ;1f4f	df 	.
 7422 1F50 D1           	pop de			;1f50	d1 	.
 7423 1F51 30 0F        	jr nc,l1f62h		;1f51	30 0f 	0 .
 7424 1F53 2A F9 78     	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program						;1f53	2a f9 78 	* . x
 7425 1F56 DF           	rst #18			; Compare HL and DE ;1f56	df 	.
 7426 1F57 30 09        	jr nc,l1f62h		;1f57	30 09 	0 .
 7427 1F59 3E D1        	ld a,0d1h		;1f59	3e d1 	> .
 7428 1F5B CD F5 29     	call sub_29f5h		;1f5b	cd f5 29 	. . )
 7429 1F5E EB           	ex de,hl			;1f5e	eb 	.
 7430 1F5F CD 43 28     	call sub_2843h		;1f5f	cd 43 28 	. C (
 7431 1F62              l1f62h:
 7432 1F62 CD F5 29     	call sub_29f5h		;1f62	cd f5 29 	. . )
 7433 1F65 E3           	ex (sp),hl			;1f65	e3 	.
 7434 1F66              l1f66h:
 7435 1F66 CD D3 09     	call DEMemToHLMem	; copy math variable from (de) to (hl) mem			;1f66	cd d3 09 	. . .
 7436 1F69 D1           	pop de			;1f69	d1 	.
 7437 1F6A E1           	pop hl			;1f6a	e1 	.
 7438 1F6B C9           	ret			;1f6b	c9 	.
 7439 1F6C
 7440 1F6C
 7441 1F6C              ; ****************************************************************************************
 7442 1F6C              ; [TRS] BASIC ON EntryPoint
 7443 1F6C              ; IN: hl - current executed command parser
 7444 1F6C              ;     a - command byte
 7445 1F6C              ;     Z = 1 - end of statement ('\0' or ':' found)
 7446 1F6C              ;     CY = 1 - char is digit
 7447 1F6C              CmdON:
 7448 1F6C FE 9E        	cp 09eh		;1f6c	fe 9e 	. .
 7449 1F6E 20 25        	jr nz,l1f95h		;1f6e	20 25 	  %
 7450 1F70 D7           	rst $10			; move hl to next Basic token				;1f70	d7 	.
 7451 1F71 CF           	rst $08			; Assert next token is 'GOTO' ;1f71	cf 	.
 7452 1F72 8D           	defb $8d		; Basic 'GOTO' token	;1f72	8d 	.
 7453 1F73 CD 5A 1E     	call TextToInt	; de - convert following text into Line Number 			;1f73	cd 5a 1e 	. Z .
 7454 1F76 7A           	ld a,d			;1f76	7a 	z
 7455 1F77 B3           	or e			;1f77	b3 	.
 7456 1F78 28 09        	jr z,l1f83h		;1f78	28 09 	( .
 7457 1F7A CD 2A 1B     	call sub_1b2ah		;1f7a	cd 2a 1b 	. * .
 7458 1F7D 50           	ld d,b			;1f7d	50 	P
 7459 1F7E 59           	ld e,c			;1f7e	59 	Y
 7460 1F7F E1           	pop hl			;1f7f	e1 	.
 7461 1F80 D2 D9 1E     	jp nc,ErrRaiseUndefStatement	; Raise UNDEF'D STATEMENT Error			;1f80	d2 d9 1e 	. . .
 7462 1F83              l1f83h:
 7463 1F83 EB           	ex de,hl			;1f83	eb 	.
 7464 1F84 22 F0 78     	ld (078f0h),hl		;1f84	22 f0 78 	" . x
 7465 1F87 EB           	ex de,hl			;1f87	eb 	.
 7466 1F88 D8           	ret c			;1f88	d8 	.
 7467 1F89 3A F2 78     	ld a,(ERRORFLAG)	; Error Status										;1f89	3a f2 78 	: . x
 7468 1F8C B7           	or a			    ; has any Error occurred ? 							;1f8c	b7 	.
 7469 1F8D C8           	ret z			    ; no - return ------------------------------------- ;1f8d	c8 	.
 7470 1F8E 3A 9A 78     	ld a,(LASTERRORNO)	; Last Error Number		                            ;1f8e	3a 9a 78 	: . x
 7471 1F91 5F           	ld e,a			    ; e - Error NUmber to Raise ;1f91	5f 	_
 7472 1F92 C3 AB 19     	jp l19abh		;1f92	c3 ab 19 	. . .
 7473 1F95              l1f95h:
 7474 1F95 CD 1C 2B     	call EvalByteExpr	; expression ACC, de and a - must be 8bit value	;1f95	cd 1c 2b 	. . +
 7475 1F98 7E           	ld a,(hl)			;1f98	7e 	~
 7476 1F99 47           	ld b,a			;1f99	47 	G
 7477 1F9A FE 91        	cp 091h		;1f9a	fe 91 	. .
 7478 1F9C 28 03        	jr z,l1fa1h		;1f9c	28 03 	( .
 7479 1F9E CF           	rst $08			; Assert next token is 'GOTO' ;1f9e	cf 	.
 7480 1F9F 8D           	defb $8D		; Basic 'GOTO' token	;1f9f	8d 	.
 7481 1FA0 2B           	dec hl			;1fa0	2b 	+
 7482 1FA1              l1fa1h:
 7483 1FA1 4B           	ld c,e			;1fa1	4b 	K
 7484 1FA2              l1fa2h:
 7485 1FA2 0D           	dec c			;1fa2	0d 	.
 7486 1FA3 78           	ld a,b			;1fa3	78 	x
 7487 1FA4 CA 60 1D     	jp z,l1d60h		;1fa4	ca 60 1d 	. ` .
 7488 1FA7 CD 5B 1E     	call TextToInt2	; de - number from text at (hl) 	;1fa7	cd 5b 1e 	. [ .
 7489 1FAA FE 2C        	cp 02ch		;1faa	fe 2c 	. ,
 7490 1FAC C0           	ret nz			;1fac	c0 	.
 7491 1FAD 18 F3        	jr l1fa2h		;1fad	18 f3 	. .
 7492 1FAF
 7493 1FAF
 7494 1FAF              ; ********************************************************************************************
 7495 1FAF              ; [TRS] BASIC RESUME Entry Point
 7496 1FAF              ; IN: hl - current executed command parser
 7497 1FAF              ;     a - command byte
 7498 1FAF              ;     Z = 1 - end of statement ('\0' or ':' found)
 7499 1FAF              ;     CY = 1 - char is digit
 7500 1FAF              CmdRESUME
 7501 1FAF 11 F2 78     	ld de,ERRORFLAG		; address of Error Status Flag 					;1faf	11 f2 78 	. . x
 7502 1FB2 1A           	ld a,(de)			; Error Status									;1fb2	1a 	.
 7503 1FB3 B7           	or a			    ; has any Error occurred ? 						;1fb3	b7 	.
 7504 1FB4 CA A0 19     	jp z,ErrRaiseResumeWo	; no - Raise 'RESUME WITHOUT' Error	;1fb4	ca a0 19 	. . .
 7505 1FB7 3C           	inc a		;1fb7	3c 	<
 7506 1FB8 32 9A 78     	ld (LASTERRORNO),a	; set as Last Error Number 	;1fb8	32 9a 78 	2 . x
 7507 1FBB 12           	ld (de),a			; set Error Status flag to ERROR ;1fbb	12 	.
 7508 1FBC 7E           	ld a,(hl)			;1fbc	7e 	~
 7509 1FBD FE 87        	cp 087h		;1fbd	fe 87 	. .
 7510 1FBF 28 0C        	jr z,l1fcdh		;1fbf	28 0c 	( .
 7511 1FC1 CD 5A 1E     	call TextToInt	; de - int number from text at (hl) address 	;1fc1	cd 5a 1e 	. Z .
 7512 1FC4 C0           	ret nz			;1fc4	c0 	.
 7513 1FC5 7A           	ld a,d			;1fc5	7a 	z
 7514 1FC6 B3           	or e			;1fc6	b3 	.
 7515 1FC7 C2 C5 1E     	jp nz,l1ec5h		;1fc7	c2 c5 1e 	. . .
 7516 1FCA 3C           	inc a			;1fca	3c 	<
 7517 1FCB 18 02        	jr l1fcfh		;1fcb	18 02 	. .
 7518 1FCD              l1fcdh:
 7519 1FCD D7           	rst $10			; move hl to next Basic token					;1fcd	d7 	.
 7520 1FCE C0           	ret nz			; return if not End of Statement ('\0' or ':');1fce	c0 	.
 7521 1FCF              l1fcfh:
 7522 1FCF 2A EE 78     	ld hl,(ErrorTokenPtr)	; Pointer to Basic Token when error occurred	;1fcf	2a ee 78 	* . x
 7523 1FD2 EB           	ex de,hl			;1fd2	eb 	.
 7524 1FD3 2A EA 78     	ld hl,(ErrorLineNo)	; Basic Line Number with Error 		;1fd3	2a ea 78 	* . x
 7525 1FD6 22 A2 78     	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;1fd6	22 a2 78 	" . x
 7526 1FD9 EB           	ex de,hl			;1fd9	eb 	.
 7527 1FDA C0           	ret nz			;1fda	c0 	.
 7528 1FDB 7E           	ld a,(hl)			;1fdb	7e 	~
 7529 1FDC B7           	or a			;1fdc	b7 	.
 7530 1FDD 20 04        	jr nz,l1fe3h		;1fdd	20 04 	  .
 7531 1FDF 23           	inc hl			;1fdf	23 	#
 7532 1FE0 23           	inc hl			;1fe0	23 	#
 7533 1FE1 23           	inc hl			;1fe1	23 	#
 7534 1FE2 23           	inc hl			;1fe2	23 	#
 7535 1FE3              l1fe3h:
 7536 1FE3 23           	inc hl			;1fe3	23 	#
 7537 1FE4 7A           	ld a,d			;1fe4	7a 	z
 7538 1FE5 A3           	and e			;1fe5	a3 	.
 7539 1FE6 3C           	inc a			;1fe6	3c 	<
 7540 1FE7 C2 05 1F     	jp nz,CmdDATA		;1fe7	c2 05 1f 	. . .
 7541 1FEA 3A DD 78     	ld a,(INPUTFLAG)	; Flag indicates whether inputing text.	;1fea	3a dd 78 	: . x
 7542 1FED 3D           	dec a			;1fed	3d 	=
 7543 1FEE CA BE 1D     	jp z,01dbeh		;1fee	ca be 1d 	. . .
 7544 1FF1 C3 05 1F     	jp CmdDATA		;1ff1	c3 05 1f 	. . .
 7545 1FF4
 7546 1FF4              ; ********************************************************************************
 7547 1FF4              ; [TRS] BASIC ERROR Entry Point
 7548 1FF4              ; IN: hl - current executed command parser
 7549 1FF4              ;     a - command byte
 7550 1FF4              ;     Z = 1 - end of statement ('\0' or ':' found)
 7551 1FF4              ;     CY = 1 - char is digit
 7552 1FF4              CmdERROR
 7553 1FF4 CD 1C 2B     	call EvalByteExpr	; expression ACC, de and a - must be 8bit value	;1ff4	cd 1c 2b 	. . +
 7554 1FF7 C0           	ret nz			;1ff7	c0 	.
 7555 1FF8 B7           	or a			;1ff8	b7 	.
 7556 1FF9 CA 4A 1E     	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error		;1ff9	ca 4a 1e 	. J .
 7557 1FFC 3D           	dec a			;1ffc	3d 	=
 7558 1FFD 87           	add a,a			;1ffd	87 	.
 7559 1FFE 5F           	ld e,a			;1ffe	5f 	_
 7560 1FFF FE 2D        	cp 02dh		;1fff	fe 2d 	. -
 7561 2001 38 02        	jr c,l2005h		;2001	38 02 	8 .
 7562 2003 1E 26        	ld e,#26		; ERROR 26 - UNPRINTABLE		;2003	1e 26 	. &
 7563 2005              l2005h:
 7564 2005 C3 A2 19     	jp ErrRaiseError	; Raise Error 	;2005	c3 a2 19 	. . .
 7565 2008
 7566 2008
 7567 2008
 7568 2008              ; *************************************************************************************************
 7569 2008              ; [TRS] BASIC AUTO Entry Point
 7570 2008              ; AUTO [<StartLine> [,<Increment>]]
 7571 2008              ; IN: hl - current executed command parser
 7572 2008              ;     a - command byte
 7573 2008              ;     Z = 1 - end of statement ('\0' or ':' found)
 7574 2008              ;     CY = 1 - char is digit
 7575 2008
 7576 2008              CmdAUTO
 7577 2008 11 0A 00     	ld de,0000ah		;2008	11 0a 00 	. . .
 7578 200B D5           	push de			;200b	d5 	.
 7579 200C 28 17        	jr z,l2025h		;200c	28 17 	( .
 7580 200E CD 4F 1E     	call sub_1e4fh		;200e	cd 4f 1e 	. O .
 7581 2011 EB           	ex de,hl			;2011	eb 	.
 7582 2012 E3           	ex (sp),hl			;2012	e3 	.
 7583 2013 28 11        	jr z,l2026h		;2013	28 11 	( .
 7584 2015 EB           	ex de,hl			;2015	eb 	.
 7585 2016 CF           	rst $08			; Assert next token is ',' ;2016	cf 	.
 7586 2017 2C           	defb ','		; Basic ',' token	;2017	2c 	,
 7587 2018 EB           	ex de,hl			;2018	eb 	.
 7588 2019 2A E4 78     	ld hl,(AUTONUM_INC)	; increment value for AUTONUM line number		;2019	2a e4 78 	* . x
 7589 201C EB           	ex de,hl			;201c	eb 	.
 7590 201D 28 06        	jr z,l2025h		;201d	28 06 	( .
 7591 201F CD 5A 1E     	call TextToInt	; de - int number from text at (hl) address 	;201f	cd 5a 1e 	. Z .
 7592 2022 C2 97 19     	jp nz,ErrRaiseSyntax	; if no numeric value Raise 'SYNTAX ERROR'	;2022	c2 97 19 	. . .
 7593 2025              l2025h:
 7594 2025 EB           	ex de,hl			;2025	eb 	.
 7595 2026              l2026h:
 7596 2026 7C           	ld a,h			;2026	7c 	|
 7597 2027 B5           	or l			;2027	b5 	.
 7598 2028 CA 4A 1E     	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2028	ca 4a 1e 	. J .
 7599 202B 22 E4 78     	ld (AUTONUM_INC),hl		; set increment value for AUTONUM line number	;202b	22 e4 78 	" . x
 7600 202E 32 E1 78     	ld (AUTONUM_ON),a		; Basic AUTO input flag [TRS]. ;202e	32 e1 78 	2 . x
 7601 2031 E1           	pop hl			;2031	e1 	.
 7602 2032 22 E2 78     	ld (AUTONUM_LINE),hl	; line number generated by AUTO			;2032	22 e2 78 	" . x
 7603 2035 C1           	pop bc			;2035	c1 	.
 7604 2036 C3 33 1A     	jp l1a33h		;2036	c3 33 1a 	. 3 .
 7605 2039
 7606 2039
 7607 2039              ; *****************************************************************************************
 7608 2039              ; BASIC IF Entry Point
 7609 2039              ; IN: hl - current executed command parser
 7610 2039              ;     a - command byte
 7611 2039              ;     Z = 1 - end of statement ('\0' or ':' found)
 7612 2039              ;     CY = 1 - char is digit
 7613 2039              CmdIF
 7614 2039 CD 37 23     	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;2039	cd 37 23 	. 7 #
 7615 203C 7E           	ld a,(hl)			;203c	7e 	~
 7616 203D FE 2C        	cp ','		        ; is it ',' token  ? ;203d	fe 2c 	. ,
 7617 203F CC 78 1D     	call z,NextToken	; yes - Move hl to next Basic token	;203f	cc 78 1d 	. x .
 7618 2042 FE CA        	cp $ca		        ; is it 'THEN' token ? ;2042	fe ca 	. .
 7619 2044 CC 78 1D     	call z,NextToken	; yes - Move hl to next Basic token	;2044	cc 78 1d 	. x .
 7620 2047 2B           	dec hl			;2047	2b 	+
 7621 2048 E5           	push hl			;2048	e5 	.
 7622 2049 CD 94 09     	call TestACCSign	; Check Sign of number in ACC (Any)		;2049	cd 94 09 	. . .
 7623 204C E1           	pop hl			;204c	e1 	.
 7624 204D 28 07        	jr z,l2056h		;204d	28 07 	( .
 7625 204F              l204fh:
 7626 204F D7           	rst $10			; move hl to next Basic token					;204f	d7 	.
 7627 2050 DA C2 1E     	jp c,CmdGOTO	; jump if digit found ('0'..'9')	;2050	da c2 1e 	. . .
 7628 2053 C3 5F 1D     	jp l1d5fh		;2053	c3 5f 1d 	. _ .
 7629 2056              l2056h:
 7630 2056 16 01        	ld d,001h		;2056	16 01 	. .
 7631 2058              l2058h:
 7632 2058 CD 05 1F     	call CmdDATA		;2058	cd 05 1f 	. . .
 7633 205B B7           	or a			;205b	b7 	.
 7634 205C C8           	ret z			;205c	c8 	.
 7635 205D D7           	rst $10			; move hl to next Basic token					;205d	d7 	.
 7636 205E FE 95        	cp $95		    ; is it Basic 'ELSE' token ;205e	fe 95 	. .
 7637 2060 20 F6        	jr nz,l2058h	; no -	;2060	20 f6 	  .
 7638 2062 15           	dec d			;2062	15 	.
 7639 2063 20 F3        	jr nz,l2058h		;2063	20 f3 	  .
 7640 2065 18 E8        	jr l204fh		;2065	18 e8 	. .
 7641 2067
 7642 2067
 7643 2067              ; ************************************************************************************
 7644 2067              ; BASIC LPRINT Entry Point
 7645 2067              ; IN: hl - current executed command parser
 7646 2067              ;     a - command byte
 7647 2067              ;     Z = 1 - end of statement ('\0' or ':' found)
 7648 2067              ;     CY = 1 - char is digit
 7649 2067              CmdLPRINT
 7650 2067 3E 01        	ld a,$01				; 1 - Printer Device 											;2067	3e 01 	> .
 7651 2069 32 9C 78     	ld (SysCurOutDev),a		; set Printer as Current Out Device								;2069	32 9c 78 	2 . x
 7652 206C C3 9B 20     	jp l209bh		;206c	c3 9b 20 	. .
 7653 206F
 7654 206F
 7655 206F              ; ************************************************************************************
 7656 206F              ; BASIC PRINT Entry Point
 7657 206F              ; IN: hl - current executed command parser
 7658 206F              ;     a - command byte
 7659 206F              ;     Z = 1 - end of statement ('\0' or ':' found)
 7660 206F              ;     CY = 1 - char is digit
 7661 206F              CmdPRINT
 7662 206F CD CA 79     	call SysExtPrint	; call external hook for PRINT							;206f	cd ca 79 	. . y
 7663 2072 FE 40        	cp '@'		;2072	fe 40 	. @
 7664 2074 20 19        	jr nz,l208fh		;2074	20 19 	  .
 7665 2076 CD 01 2B     	call sub_2b01h		;2076	cd 01 2b 	. . +
 7666 2079 FE 02        	cp 002h		;2079	fe 02 	. .
 7667 207B D2 4A 1E     	jp nc,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;207b	d2 4a 1e 	. J .
 7668 207E              ; --
 7669 207E E5           	push hl				; save hl ;207e	e5 	.
 7670 207F 21 00 70     	ld hl,VRAM			; hl - address of Video RAM								;207f	21 00 70 	! . p
 7671 2082 19           	add hl,de			; add offset ;2082	19 	.
 7672 2083 22 20 78     	ld (CURSORADDR),hl	; set as new Cursor Address in VRAM 	;2083	22 20 78 	"   x
 7673 2086 7B           	ld a,e				; a - low byte of offset ;2086	7b 	{
 7674 2087 E6 1F        	and $1f		        ; trim it to range 0..31 - position in line (column)	;2087	e6 1f 	. .
 7675 2089 32 A6 78     	ld (CURSORPOS),a	; set as position of Cursor in Edited line				;2089	32 a6 78 	2 . x
 7676 208C E1           	pop hl				; restore hl ;208c	e1 	.
 7677 208D CF           	rst $08				; Assert next token is ',' ;208d	cf 	.
 7678 208E 2C           	defb ','			; Basic ',' token	;208e	2c 	,
 7679 208F              l208fh:
 7680 208F FE 23        	cp '#'		    	; is it '#' char - redirect to Tape/File device 		;208f	fe 23 	. #
 7681 2091 20 08        	jr nz,l209bh		; no - print to screen 									;2091	20 08 	  .
 7682 2093 CD 58 3B     	call sub_3b58h		;2093	cd 58 3b 	. X ;
 7683 2096 3E 80        	ld a,$80			; 80 -> Tape Device Flag 								;2096	3e 80 	> .
 7684 2098 32 9C 78     	ld (SysCurOutDev),a	; set Tape as Current Out Device						;2098	32 9c 78 	2 . x
 7685 209B              l209bh:
 7686 209B 2B           	dec hl			;209b	2b 	+
 7687 209C D7           	rst $10			; move hl to next Basic token					;209c	d7 	.
 7688 209D CC FE 20     	call z,PrintCR  ; print CR if End Of Statement found ('\0' or ':')		;209d	cc fe 20 	. .
 7689 20A0              l20a0h:
 7690 20A0 CA 69 21     	jp z,SysSetOutAsScreen		;20a0	ca 69 21 	. i !
 7691 20A3 FE BF        	cp 0bfh		;20a3	fe bf 	. .
 7692 20A5 CA BD 2C     	jp z,l2cbdh		;20a5	ca bd 2c 	. . ,
 7693 20A8 FE BC        	cp 0bch		;20a8	fe bc 	. .
 7694 20AA CA 37 21     	jp z,l2137h		;20aa	ca 37 21 	. 7 !
 7695 20AD E5           	push hl			;20ad	e5 	.
 7696 20AE FE 2C        	cp 02ch		;20ae	fe 2c 	. ,
 7697 20B0 CA 08 21     	jp z,l2108h		;20b0	ca 08 21 	. . !
 7698 20B3 FE 3B        	cp 03bh		;20b3	fe 3b 	. ;
 7699 20B5 CA 0C 3B     	jp z,l3b0ch		;20b5	ca 0c 3b 	. . ;
 7700 20B8 C1           	pop bc			;20b8	c1 	.
 7701 20B9 CD 37 23     	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;20b9	cd 37 23 	. 7 #
 7702 20BC E5           	push hl			;20bc	e5 	.
 7703 20BD E7           	rst #20			; test NTF (Number Type Format) ;20bd	e7 	.
 7704 20BE 28 32        	jr z,l20f2h		; String - just print it on screen ;20be	28 32 	( 2
 7705 20C0              ; -- numeric value
 7706 20C0 CD BD 0F     	call NumToStr	; Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)		;20c0	cd bd 0f 	. . .
 7707 20C3 CD 65 28     	call strACCfromCStr	; create Basic string in ACC from null terminated str (hl)		;20c3	cd 65 28 	. e (
 7708 20C6 CD CD 79     	call SysExtPrintNum		;20c6	cd cd 79 	. . y
 7709 20C9 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;20c9	2a 21 79 	* ! y
 7710 20CC 3A 9C 78     	ld a,(SysCurOutDev)	; current Output Device		;20cc	3a 9c 78 	: . x
 7711 20CF B7           	or a				; what is Current Output Device?	;20cf	b7 	.
 7712 20D0 FA E9 20     	jp m,l20e9h		; Tape - ;20d0	fa e9 20 	. .
 7713 20D3 28 08        	jr z,l20ddh		; Screen - ;20d3	28 08 	( .
 7714 20D5              ; -- Current Output Device is Printer
 7715 20D5 3A 9B 78     	ld a,(PRN_PosInLine)		;20d5	3a 9b 78 	: . x
 7716 20D8 86           	add a,(hl)			;20d8	86 	.
 7717 20D9 FE 84        	cp 084h		;20d9	fe 84 	. .
 7718 20DB 18 09        	jr l20e6h		;20db	18 09 	. .
 7719 20DD              l20ddh:
 7720 20DD 3A 9D 78     	ld a,(SCR_LINEMAXLEN)		;20dd	3a 9d 78 	: . x
 7721 20E0 47           	ld b,a			;20e0	47 	G
 7722 20E1 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line	;20e1	3a a6 78 	: . x
 7723 20E4 86           	add a,(hl)			;20e4	86 	.
 7724 20E5 B8           	cp b			;20e5	b8 	.
 7725 20E6              l20e6h:
 7726 20E6 D4 FE 20     	call nc,PrintCR	; Print CR char on screen ;20e6	d4 fe 20 	. .
 7727 20E9              l20e9h:
 7728 20E9 CD AA 28     	call PrintACCStr; print Basic String from ACC on screen		;20e9	cd aa 28 	. . (
 7729 20EC 3E 20        	ld a,' '		;20ec	3e 20 	>
 7730 20EE CD 2A 03     	call PrintChar	; Print ' ' char on screen		;20ee	cd 2a 03 	. * .
 7731 20F1 B7           	or a			;20f1	b7 	.
 7732 20F2              l20f2h:
 7733 20F2 CC AA 28     	call z,PrintACCStr; print Basic String from ACC on screen				;20f2	cc aa 28 	. . (
 7734 20F5 E1           	pop hl			;20f5	e1 	.
 7735 20F6 C3 9B 20     	jp l209bh		;20f6	c3 9b 20 	. .
 7736 20F9
 7737 20F9              ; ***********************************************************************************
 7738 20F9              ; Outputs a carriage return to video if cursor is not already at the beginning
 7739 20F9              ; of a line.
 7740 20F9              SysNewLine:
 7741 20F9 CD 1C 3B     	call sub_3b1ch		;20f9	cd 1c 3b 	. . ;
 7742 20FC B7           	or a			;20fc	b7 	.
 7743 20FD C8           	ret z			;20fd	c8 	.
 7744 20FE
 7745 20FE              ; **********************************************************************************
 7746 20FE              ; Output a carriage return ($Od) to a device determined by flag stored at (SysCurOutDev).
 7747 20FE              ; NOTE: This routine may be called at $20F9H, in which case it will not perform
 7748 20FE              ; the above action if the video display cursor is already positioned at the beginning
 7749 20FE              ; of a line, as determined by checking the contents of the cursor position flag at 78a6
 7750 20FE              ; (if zero, cursor is at start of line). This routine CALLs the routine at 032a
 7751 20FE              ; and also CALLs a Disk BASIC link at 79d0. See the warning for the routine at 032a
 7752 20FE              PrintCR:
 7753 20FE 3E 0D        	ld a,$d				; a - CR char												;20fe	3e 0d 	> .
 7754 2100              l2100h:
 7755 2100 CD 2A 03     	call PrintChar	; Print CR char on screen						;2100	cd 2a 03 	. * .
 7756 2103              sub_2103h:
 7757 2103 CD D0 79     	call SysExtPrintCR			;2103	cd d0 79 	. . y
 7758 2106 AF           	xor a				; clear return status (0)									;2106	af 	.
 7759 2107 C9           	ret					; ------------ End of Proc -------------------------------- ;2107	c9 	.
 7760 2108              l2108h:
 7761 2108 CD D3 79     	call SysExtPrintTab		;2108	cd d3 79 	. . y
 7762 210B 3A 9C 78     	ld a,(SysCurOutDev)		;210b	3a 9c 78 	: . x
 7763 210E B7           	or a			;210e	b7 	.
 7764 210F F2 19 21     	jp p,l2119h		;210f	f2 19 21 	. . !
 7765 2112 3E 2C        	ld a,','		;2112	3e 2c 	> ,
 7766 2114 CD 2A 03     	call PrintChar	; Print ',' char on screen		;2114	cd 2a 03 	. * .
 7767 2117 18 4B        	jr l2164h		;2117	18 4b 	. K
 7768 2119              l2119h:
 7769 2119 28 08        	jr z,l2123h		;2119	28 08 	( .
 7770 211B 3A 9B 78     	ld a,(PRN_PosInLine)		;211b	3a 9b 78 	: . x
 7771 211E FE 70        	cp 070h		;211e	fe 70 	. p
 7772 2120 C3 2B 21     	jp l212bh		;2120	c3 2b 21 	. + !
 7773 2123              l2123h:
 7774 2123 3A 9E 78     	ld a,(SCR_PRINTZONES)		;2123	3a 9e 78 	: . x
 7775 2126 47           	ld b,a			;2126	47 	G
 7776 2127 3A AE 7A     	ld a,(07aaeh)		;2127	3a ae 7a 	: . z
 7777 212A B8           	cp b			;212a	b8 	.
 7778 212B              l212bh:
 7779 212B D4 FE 20     	call nc,PrintCR	; Print CR on screen 	;212b	d4 fe 20 	. .
 7780 212E 30 34        	jr nc,l2164h		;212e	30 34 	0 4
 7781 2130              l2130h:
 7782 2130 D6 10        	sub 010h		;2130	d6 10 	. .
 7783 2132 30 FC        	jr nc,l2130h		;2132	30 fc 	0 .
 7784 2134 2F           	cpl			;2134	2f 	/
 7785 2135 18 23        	jr l215ah		;2135	18 23 	. #
 7786 2137              l2137h:
 7787 2137 CD 1B 2B     	call sub_2b1bh		;2137	cd 1b 2b 	. . +
 7788 213A E6 3F        	and 03fh		;213a	e6 3f 	. ?
 7789 213C 5F           	ld e,a			;213c	5f 	_
 7790 213D CF           	rst $08			; Assert next token is ')' ;213d	cf 	.
 7791 213E 29           	defb ')'		; Basic ')' token	;213e	29 	)
 7792 213F
 7793 213F              ; TRS ???
 7794 213F              ; TAB function for video or printer (determined by flag at SysCurOutDev).
 7795 213F              ; This routine does extensive string processing and may not be the most efficient
 7796 213F              ; method of achieving the desired result, particularly if it is desired only to tab
 7797 213F              ; over a number of spaces. Also, this routine CALLs several Disk BASIC links
 7798 213F              ; which may have to be "plugged".
 7799 213F              ; IN:  e - desired TAB position
 7800 213F              ;      (hl) - message to display (0 if no message)
 7801 213F
 7802 213F 2B           	dec hl			;213f	2b 	+
 7803 2140 E5           	push hl			;2140	e5 	.
 7804 2141 CD D3 79     	call SysExtPrintTab		;2141	cd d3 79 	. . y
 7805 2144 3A 9C 78     	ld a,(SysCurOutDev)	; a - Device Id 										;2144	3a 9c 78 	: . x
 7806 2147 B7           	or a				; where to send data									;2147	b7 	.
 7807 2148 FA 4A 1E     	jp m,ErrRaiseFuncCode	; raise FUNCTION CODE Error				; to Tape ;2148	fa 4a 1e 	. J .
 7808 214B CA 53 21     	jp z,l2153h			; to Screen ;214b	ca 53 21 	. S !
 7809 214E              ; -- to Printer
 7810 214E 3A 9B 78     	ld a,(PRN_PosInLine)		;214e	3a 9b 78 	: . x
 7811 2151 18 03        	jr l2156h		;2151	18 03 	. .
 7812 2153              l2153h:
 7813 2153 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line	;2153	3a a6 78 	: . x
 7814 2156              l2156h:
 7815 2156 2F           	cpl			;2156	2f 	/
 7816 2157 83           	add a,e			;2157	83 	.
 7817 2158 30 0A        	jr nc,l2164h		;2158	30 0a 	0 .
 7818 215A              l215ah:
 7819 215A 3C           	inc a			;215a	3c 	<
 7820 215B 47           	ld b,a			;215b	47 	G
 7821 215C 3E 20        	ld a,' '		;215c	3e 20 	>
 7822 215E              l215eh:
 7823 215E CD 2A 03     	call PrintChar	; Print ' ' char on screen		;215e	cd 2a 03 	. * .
 7824 2161 05           	dec b			;2161	05 	.
 7825 2162 20 FA        	jr nz,l215eh		;2162	20 fa 	  .
 7826 2164              l2164h:
 7827 2164 E1           	pop hl			;2164	e1 	.
 7828 2165 D7           	rst $10			; move hl to next Basic token					;2165	d7 	.
 7829 2166 C3 A0 20     	jp l20a0h		;2166	c3 a0 20 	. .
 7830 2169
 7831 2169              ; **********************************************************************************
 7832 2169              ; Reset device type flag at SysCurOutDev to zero (output to video display), also turns off
 7833 2169              ; cassette drive if necessary. CALLs Disk BASIC link at SysExtPrintEnd prior to return.
 7834 2169              ; See also routine at 038b
 7835 2169              SysSetOutAsScreen:
 7836 2169              ; -- removed TRS code  to turn off Cassette Drive if needed
 7837 2169 3A 9C 78     	ld a,(SysCurOutDev)	; Current Device Id										;2169	3a 9c 78 	: . x
 7838 216C 00 00 00 00  	block 4				; TRS removed code										;216c	00 	.
 7839 2170              ; -- set Current Out Device as Screen
 7840 2170 AF           	xor a				; Device Id 0 (Screen)									;2170	af 	.
 7841 2171 32 9C 78     	ld (SysCurOutDev),a	; set as Current Out Device								;2171	32 9c 78 	2 . x
 7842 2174 CD BE 79     	call SysExtPrintEnd	; call DOS hook									;2174	cd be 79 	. . y
 7843 2177 C9           	ret					; --------------- End of Proc ------------------------- ;2177	c9 	.
 7844 2178
 7845 2178              TXT_REDO:
 7846 2178 3F 52 45 44  	db "?REDO",$0d,0	; ?REDO text					;2178	3f 52 45 44 4f 0d 00 	.
 7846 217C 4F 0D 00
 7847 217F
 7848 217F              l217fh:
 7849 217F 3A DE 78     	ld a,(BAS_ReadInSrc)	; [TRS] READ (non-zero) or INPUT (zero) 	;217f	3a de 78 	: . x
 7850 2182 B7           	or a			;2182	b7 	.
 7851 2183 C2 91 19     	jp nz,l1991h		;2183	c2 91 19 	. . .
 7852 2186 3A A9 78     	ld a,(TapeInputFlag)	; a - input from tape Flag 							;2186	3a a9 78 	: . x
 7853 2189 B7           	or a					; is from Tape? 									;2189	b7 	.
 7854 218A 1E 2A        	ld e,#2a				; ERROR 2A - BAD FILE DATA		;218a	1e 2a 	. *
 7855 218C CA A2 19     	jp z,ErrRaiseError		; yes - Raise Error  ;218c	ca a2 19 	. . .
 7856 218F C1           	pop bc			;218f	c1 	.
 7857 2190 21 78 21     	ld hl,TXT_REDO		;2190	21 78 21 	! x !
 7858 2193 CD A7 28     	call PrintBasicStr	; print "REDO?" text on Screen	;2193	cd a7 28 	. . (
 7859 2196 2A E6 78     	ld hl,(BAS_TmpCharPtr)	; last byte of code executed in current line		;2196	2a e6 78 	* . x
 7860 2199 C9           	ret			;2199	c9 	.
 7861 219A
 7862 219A
 7863 219A              ; ************************************************************************************************
 7864 219A              ; BASIC INPUT Entry Point
 7865 219A              ; IN: hl - current executed command parser
 7866 219A              ;     a - command byte
 7867 219A              ;     Z = 1 - end of statement ('\0' or ':' found)
 7868 219A              ;     CY = 1 - char is digit
 7869 219A              CmdINPUT
 7870 219A CD 28 28     	call sub_2828h		;219a	cd 28 28 	. ( (
 7871 219D 7E           	ld a,(hl)			;219d	7e 	~
 7872 219E CD D6 79     	call SysExtInput		;219e	cd d6 79 	. . y
 7873 21A1 D6 23        	sub '#'		;21a1	d6 23 	. #
 7874 21A3 32 A9 78     	ld (TapeInputFlag),a	; set as input from tape Flag (0-true, other-false)	;21a3	32 a9 78 	2 . x
 7875 21A6 7E           	ld a,(hl)			;21a6	7e 	~
 7876 21A7 20 20        	jr nz,l21c9h		;21a7	20 20
 7877 21A9 CD 68 3B     	call sub_3b68h		;21a9	cd 68 3b 	. h ;
 7878 21AC E5           	push hl			;21ac	e5 	.
 7879 21AD 06 FA        	ld b,0fah		;21ad	06 fa 	. .
 7880 21AF 2A A7 78     	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;21af	2a a7 78 	* . x
 7881 21B2              l21b2h:
 7882 21B2 CD 88 3B     	call sub_3b88h		;21b2	cd 88 3b 	. . ;
 7883 21B5 77           	ld (hl),a			;21b5	77 	w
 7884 21B6 23           	inc hl			;21b6	23 	#
 7885 21B7 FE 0D        	cp 00dh		;21b7	fe 0d 	. .
 7886 21B9 28 02        	jr z,l21bdh		;21b9	28 02 	( .
 7887 21BB 10 F5        	djnz l21b2h		;21bb	10 f5 	. .
 7888 21BD              l21bdh:
 7889 21BD 2B           	dec hl			;21bd	2b 	+
 7890 21BE 36 00        	ld (hl),000h		;21be	36 00 	6 .
 7891 21C0 00           	nop			;21c0	00 	.
 7892 21C1 00           	nop			;21c1	00 	.
 7893 21C2 00           	nop			;21c2	00 	.
 7894 21C3 2A A7 78     	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;21c3	2a a7 78 	* . x
 7895 21C6 2B           	dec hl			;21c6	2b 	+
 7896 21C7 18 22        	jr l21ebh		;21c7	18 22 	. "
 7897 21C9
 7898 21C9
 7899 21C9
 7900 21C9
 7901 21C9              ; *********************************************************************************
 7902 21C9              ; ROM BASIC "INPUT" routine. Print prompt string (if any) and get user input to variable.
 7903 21C9              ; On entry : HL points to quotation mark (start of prompt string) or first character
 7904 21C9              ; of variable name (if no prompt string) immediately following "INPUT" command.
 7905 21C9              ; On exit: HL points to zero byte if input was valid, else prints "? REDO" (if certain
 7906 21C9              ; flags are set properly) and requests more input.
 7907 21C9              ; Syntax must be legal for BASIC "INPUT" statement, for example:
 7908 21C9              ; 	"Prompt String"; VARIABLE NAME <zero byte> or simply:
 7909 21C9              ;	VARIABLE NAME <zero byte>
 7910 21C9              ; Multiple variables may be INPUT with one statements VARIABLE NAME, VARIABLE NAME,
 7911 21C9              ; ... VARIABLE NAME <zero byte>
 7912 21C9              ; A colon may be used in place of the zero byte. See also 21E3H, including information
 7913 21C9              ; on which flags must be set to assure that the "?REDO" message is printed in the event
 7914 21C9              ; of an input error, and how to determine if an error has occured.
 7915 21C9              ; NOTE: The routine that displays the prompt string (if any) may be CALLed separately at 21CDH.
 7916 21C9              ; This routine will return immediately if the HL register pair does not point to a quotation mark
 7917 21C9              ; (22H) on entry. Otherwise, the prompt string must be terminated with a quotation mark
 7918 21C9              ; followed by a semicolon (3BH), or else a syntax error will result.
 7919 21C9              l21c9h:
 7920 21C9 01 DB 21     	ld bc,l21dbh		;21c9	01 db 21 	. . !
 7921 21CC C5           	push bc			;21cc	c5 	.
 7922 21CD FE 22        	cp '"'		;21cd	fe 22 	. "
 7923 21CF C0           	ret nz			;21cf	c0 	.
 7924 21D0 CD 66 28     	call BAS_MakeStrVecHL	; create StringVector from text enclosed with '"'	;21d0	cd 66 28 	. f (
 7925 21D3 CF           	rst $08			; Assert next token is ';' ;21d3	cf 	.
 7926 21D4 3B           	defb ';'		; Basic ';' token - end of statement	;21d4	3b 	;
 7927 21D5 E5           	push hl			;21d5	e5 	.
 7928 21D6 CD AA 28     	call PrintACCStr; print Basic String from ACC on screen				;21d6	cd aa 28 	. . (
 7929 21D9 E1           	pop hl			;21d9	e1 	.
 7930 21DA C9           	ret			;21da	c9 	.
 7931 21DB              l21dbh:
 7932 21DB E5           	push hl			;21db	e5 	.
 7933 21DC CD B3 1B     	call BAS_Prompt	; print "? " and read text line from user	;21dc	cd b3 1b 	. . .
 7934 21DF C1           	pop bc			;21df	c1 	.
 7935 21E0 DA BE 1D     	jp c,01dbeh		;21e0	da be 1d 	. . .
 7936 21E3
 7937 21E3
 7938 21E3              ; **********************************************************************************************
 7939 21E3              ; ASSIGN STRING (S) TO BASIC VARIABLE
 7940 21E3              ; This routine is part of the BACIC INPUT command routine, and can be used to process input
 7941 21E3              ; obtained from CALLing one of the keyboard input routines at 1BB3, 0361, etc.
 7942 21E3              ; On entry, BC must point to the first character of a string that contains the variable name(s).
 7943 21E3              ; If more than one variable name is used the names must be separated by commas, than a zero byte
 7944 21E3              ; or colon must be placed after the last variable name). HL must point to the byte just prior
 7945 21E3              ; to the beginning of the input string (this is where it is placed by the above-mentioned
 7946 21E3              ; input routines - note that this byte is altered by this routine), and the string may contain
 7947 21E3              ; input for more than one variable (items must be separated by commas).
 7948 21E3              ; String must be terminated with zero byte. On exit, the numbers or strings in the input
 7949 21E3              ; will be assigned to the variables listed in the string containing the variable names.
 7950 21E3              ; Numeric or string variables may be used, but only valid characters for numeric input may
 7951 21E3              ; be used with numeric variables (depending on how certain flags are set, a "?REDO" message
 7952 21E3              ; or an error will occur if this rule is violated. To force the "?REDO" message, make sure
 7953 21E3              ; that memory location BAS_ReadInSrc contains zero, and that location TapeInputFlag contains a non-zero value.
 7954 21E3              ; To determine if the "?REDO" message has occured, prior to calling the routine load memory
 7955 21E3              ; locations BAS_TmpCharPtr with zero. If the HL register pair contains zero on exit, then an error
 7956 21E3              ; has occured and the "?REDO" message has been printed).
 7957 21E3              ; NOTE.: For proper operation, the input string should be in the BASIC input buffer
 7958 21E3              ; (as it will be if one of the input routines mentioned above is used) when this routine
 7959 21E3              ; is CALLed.
 7960 21E3 23           	inc hl			;21e3	23 	#
 7961 21E4 7E           	ld a,(hl)			;21e4	7e 	~
 7962 21E5 B7           	or a			;21e5	b7 	.
 7963 21E6 2B           	dec hl			;21e6	2b 	+
 7964 21E7 C5           	push bc			;21e7	c5 	.
 7965 21E8 CA 04 1F     	jp z,01f04h		;21e8	ca 04 1f 	. . .
 7966 21EB              l21ebh:
 7967 21EB 36 2C        	ld (hl),02ch		;21eb	36 2c 	6 ,
 7968 21ED 18 05        	jr $+7		;21ed	18 05 	. .
 7969 21EF
 7970 21EF
 7971 21EF              ; *****************************************************************************
 7972 21EF              ; BASIC READ Entry Point
 7973 21EF              ; IN: hl - current executed command parser
 7974 21EF              ;     a - command byte
 7975 21EF              ;     Z = 1 - end of statement ('\0' or ':' found)
 7976 21EF              ;     CY = 1 - char is digit
 7977 21EF              CmdREAD
 7978 21EF E5           	push hl			;21ef	e5 	.
 7979 21F0 2A FF 78     	ld hl,(DataReadPtr)	; pointer where to continue READ from DATA			;21f0	2a ff 78 	* . x
 7980 21F3 F6 AF        	or 0afh		;21f3	f6 af 	. .
 7981 21F5 32 DE 78     	ld (BAS_ReadInSrc),a	; [TRS] READ (non-zero) or INPUT (zero) 		;21f5	32 de 78 	2 . x
 7982 21F8 E3           	ex (sp),hl			;21f8	e3 	.
 7983 21F9 18 02        	jr l21fdh		;21f9	18 02 	. .
 7984 21FB              l21fbh:
 7985 21FB CF           	rst $08			; Assert next token is ',' ;21fb	cf 	.
 7986 21FC 2C           	defb ','		; Basic ',' token	;21fc	2c 	,
 7987 21FD              l21fdh:
 7988 21FD CD 0D 26     	call GetVarAddr		; locate or create Basic Variable					;21fd	cd 0d 26 	. . &
 7989 2200 E3           	ex (sp),hl			;2200	e3 	.
 7990 2201 D5           	push de			;2201	d5 	.
 7991 2202 7E           	ld a,(hl)			;2202	7e 	~
 7992 2203 FE 2C        	cp 02ch		;2203	fe 2c 	. ,
 7993 2205 28 26        	jr z,l222dh		;2205	28 26 	( &
 7994 2207 3A DE 78     	ld a,(BAS_ReadInSrc)	; [TRS] READ (non-zero) or INPUT (zero) 		;2207	3a de 78 	: . x
 7995 220A B7           	or a			;220a	b7 	.
 7996 220B C2 96 22     	jp nz,l2296h		;220b	c2 96 22 	. . "
 7997 220E 3A A9 78     	ld a,(TapeInputFlag)	; a - input from tape Flag 									;220e	3a a9 78 	: . x
 7998 2211 B7           	or a					; is this from Tape? ;2211	b7 	.
 7999 2212 1E 06        	ld e,#06			; ERROR 06 - OUT OF DATA ;2212	1e 06 	. .
 8000 2214 CA A2 19     	jp z,ErrRaiseError	; yes - Raise Error 	;2214	ca a2 19 	. . .
 8001 2217 3E 3F        	ld a,'?'		;2217	3e 3f 	> ?
 8002 2219 CD 2A 03     	call PrintChar	; Print '?' char on screen		;2219	cd 2a 03 	. * .
 8003 221C CD B3 1B     	call BAS_Prompt	; print "? " and read text line from user		;221c	cd b3 1b 	. . .
 8004 221F D1           	pop de			;221f	d1 	.
 8005 2220 C1           	pop bc			;2220	c1 	.
 8006 2221 DA BE 1D     	jp c,01dbeh		;2221	da be 1d 	. . .
 8007 2224 23           	inc hl			;2224	23 	#
 8008 2225 7E           	ld a,(hl)			;2225	7e 	~
 8009 2226 B7           	or a			;2226	b7 	.
 8010 2227 2B           	dec hl			;2227	2b 	+
 8011 2228 C5           	push bc			;2228	c5 	.
 8012 2229 CA 04 1F     	jp z,01f04h		;2229	ca 04 1f 	. . .
 8013 222C D5           	push de			;222c	d5 	.
 8014 222D              l222dh:
 8015 222D CD DC 79     	call SysExtReadData		;222d	cd dc 79 	. . y
 8016 2230 E7           	rst #20			; test NTF (Number Type Format) ;2230	e7 	.
 8017 2231 F5           	push af			; save af - Number Type Format	;2231	f5 	.
 8018 2232 20 19        	jr nz,l224dh	; Number (not String)	;2232	20 19 	  .
 8019 2234              ; -- String
 8020 2234 D7           	rst $10			; move hl to next Basic token					;2234	d7 	.
 8021 2235 57           	ld d,a			;2235	57 	W
 8022 2236 47           	ld b,a			;2236	47 	G
 8023 2237 FE 22        	cp '"'		    ; is it Basic '"' token - start/end of string ;2237	fe 22 	. "
 8024 2239 28 05        	jr z,l2240h		; tak - ;2239	28 05 	( .
 8025 223B 16 3A        	ld d,':'		;223b	16 3a 	. :
 8026 223D 06 2C        	ld b,','		;223d	06 2c 	. ,
 8027 223F 2B           	dec hl			;223f	2b 	+
 8028 2240              l2240h:
 8029 2240 CD 69 28     	call BAS_MakeStrVecDelim	; create StringVector from text 		;2240	cd 69 28 	. i (
 8030 2243              l2243h:
 8031 2243 F1           	pop af			;2243	f1 	.
 8032 2244 EB           	ex de,hl			;2244	eb 	.
 8033 2245 21 5A 22     	ld hl,l225ah		;2245	21 5a 22 	! Z "
 8034 2248 E3           	ex (sp),hl			;2248	e3 	.
 8035 2249 D5           	push de			;2249	d5 	.
 8036 224A C3 33 1F     	jp l1f33h		;224a	c3 33 1f 	. 3 .
 8037 224D              l224dh:
 8038 224D D7           	rst $10			; move hl to next Basic token					;224d	d7 	.
 8039 224E F1           	pop af			;224e	f1 	.
 8040 224F F5           	push af			;224f	f5 	.
 8041 2250 01 43 22     	ld bc,l2243h		;2250	01 43 22 	. C "
 8042 2253 C5           	push bc			;2253	c5 	.
 8043 2254 DA 6C 0E     	jp c,StrToNum	;  Convert from ASCII const (HL) to Any (ACC)	;2254	da 6c 0e 	. l .
 8044 2257 D2 65 0E     	jp nc,StrToDbl	; convert string (hl) to number (double)	;2257	d2 65 0e 	. e .
 8045 225A              l225ah:
 8046 225A 2B           	dec hl			;225a	2b 	+
 8047 225B D7           	rst $10			; move hl to next Basic token					;225b	d7 	.
 8048 225C 28 05        	jr z,l2263h		; jump if End of Statement found ('\0' or ':') ;225c	28 05 	( .
 8049 225E FE 2C        	cp ','		    ; is it Basic ',' token ;225e	fe 2c 	. ,
 8050 2260 C2 7F 21     	jp nz,l217fh	; no -	;2260	c2 7f 21 	.  !
 8051 2263              l2263h:
 8052 2263 E3           	ex (sp),hl			;2263	e3 	.
 8053 2264 2B           	dec hl			;2264	2b 	+
 8054 2265 D7           	rst $10			; move hl to next Basic token					;2265	d7 	.
 8055 2266 C2 FB 21     	jp nz,l21fbh	; jump if no End of Statement found ('\0' or ':')	;2266	c2 fb 21 	. . !
 8056 2269 D1           	pop de			;2269	d1 	.
 8057 226A 00           	nop			;226a	00 	.
 8058 226B 00           	nop			;226b	00 	.
 8059 226C 00           	nop			;226c	00 	.
 8060 226D 00           	nop			;226d	00 	.
 8061 226E 00           	nop			;226e	00 	.
 8062 226F 3A DE 78     	ld a,(BAS_PrintUsingDelim)	; delimiter for PRINT USING	;226f	3a de 78 	: . x
 8063 2272 B7           	or a			;2272	b7 	.
 8064 2273 EB           	ex de,hl			;2273	eb 	.
 8065 2274 C2 96 1D     	jp nz,l1d96h		;2274	c2 96 1d 	. . .
 8066 2277 D5           	push de			;2277	d5 	.
 8067 2278 CD DF 79     	call SysExtExtraTest		;2278	cd df 79 	. . y
 8068 227B B6           	or (hl)			;227b	b6 	.
 8069 227C 21 86 22     	ld hl,TXT_EXTRAIGNORED	;227c	21 86 22 	! . "
 8070 227F C4 A7 28     	call nz,PrintBasicStr	; print "?EXTRA IGNORED" text on Screen	;227f	c4 a7 28 	. . (
 8071 2282 E1           	pop hl			;2282	e1 	.
 8072 2283 C3 69 21     	jp SysSetOutAsScreen		;2283	c3 69 21 	. i !
 8073 2286              TXT_EXTRAIGNORED:
 8074 2286 3F 45 58 54  	defb "?EXTRA IGNORED",$d,0			;2286	3f 45 58 54 52 41 20 49 47 4e 4f 52 45 44 0d 00 	.
 8074 228A 52 41 20 49
 8074 228E 47 4E 4F 52
 8074 2292 45 44 0D 00
 8075 2296
 8076 2296              l2296h:
 8077 2296 CD 05 1F     	call CmdDATA		;2296	cd 05 1f 	. . .
 8078 2299 B7           	or a			;2299	b7 	.
 8079 229A 20 12        	jr nz,l22aeh		;229a	20 12 	  .
 8080 229C 23           	inc hl			;229c	23 	#
 8081 229D 7E           	ld a,(hl)			;229d	7e 	~
 8082 229E 23           	inc hl			;229e	23 	#
 8083 229F B6           	or (hl)			;229f	b6 	.
 8084 22A0 1E 06        	ld e,#06			; ERROR 06 - OUT OF DATA ;22a0	1e 06 	. .
 8085 22A2 CA A2 19     	jp z,ErrRaiseError	; Raise Error if 	;22a2	ca a2 19 	. . .
 8086 22A5 23           	inc hl			;22a5	23 	#
 8087 22A6 5E           	ld e,(hl)			;22a6	5e 	^
 8088 22A7 23           	inc hl			;22a7	23 	#
 8089 22A8 56           	ld d,(hl)			;22a8	56 	V
 8090 22A9 EB           	ex de,hl			;22a9	eb 	.
 8091 22AA 22 DA 78     	ld (DATALineNo),hl	; Basic Line No with DATA cmd	;22aa	22 da 78 	" . x
 8092 22AD EB           	ex de,hl			;22ad	eb 	.
 8093 22AE              l22aeh:
 8094 22AE D7           	rst $10			; move hl to next Basic token				;22ae	d7 	.
 8095 22AF FE 88        	cp $88		    ; is it Basic 'DATA' token ;22af	fe 88 	. .
 8096 22B1 20 E3        	jr nz,l2296h	; no -	;22b1	20 e3 	  .
 8097 22B3 C3 2D 22     	jp l222dh		;22b3	c3 2d 22 	. - "
 8098 22B6
 8099 22B6
 8100 22B6
 8101 22B6              ; ***************************************************************************************
 8102 22B6              ; BASIC NEXT Entry Point
 8103 22B6              ; IN: hl - current executed command parser
 8104 22B6              ;     a - command byte
 8105 22B6              ;     Z = 1 - end of statement ('\0' or ':' found)
 8106 22B6              ;     CY = 1 - char is digit
 8107 22B6              CmdNEXT
 8108 22B6 11 00 00     	ld de,$0000		;22b6	11 00 00 	. . .
 8109 22B9              sub_22b9h:
 8110 22B9 C4 0D 26     	call nz,GetVarAddr	; locate or create Basic Variable						;22b9	c4 0d 26 	. . &
 8111 22BC 22 DF 78     	ld (BAS_NewVarPtr),hl	; set as current Variable								;22bc	22 df 78 	" . x
 8112 22BF CD 36 19     	call sub_1936h		;22bf	cd 36 19 	. 6 .
 8113 22C2 C2 9D 19     	jp nz,ErrRaiseNextWoFor	; Raise 'NEXT WITHOUT FOR' Error	;22c2	c2 9d 19 	. . .
 8114 22C5 F9           	ld sp,hl			;22c5	f9 	.
 8115 22C6 22 E8 78     	ld (BAS_StackPtr),hl		;22c6	22 e8 78 	" . x
 8116 22C9 D5           	push de			;22c9	d5 	.
 8117 22CA 7E           	ld a,(hl)			;22ca	7e 	~
 8118 22CB 23           	inc hl			;22cb	23 	#
 8119 22CC F5           	push af			;22cc	f5 	.
 8120 22CD D5           	push de			;22cd	d5 	.
 8121 22CE 7E           	ld a,(hl)			;22ce	7e 	~
 8122 22CF 23           	inc hl			;22cf	23 	#
 8123 22D0 B7           	or a			;22d0	b7 	.
 8124 22D1 FA EA 22     	jp m,l22eah		;22d1	fa ea 22 	. . "
 8125 22D4 CD B1 09     	call MAT_sCopyHLToACC_DBL		;22d4	cd b1 09 	. . .
 8126 22D7              l22d7h:
 8127 22D7 E3           	ex (sp),hl			;22d7	e3 	.
 8128 22D8 E5           	push hl			;22d8	e5 	.
 8129 22D9 CD 0B 07     	call sngHLaddACC_DBL	; ACC = (HL) + ACC (Single)	;22d9	cd 0b 07 	. . .
 8130 22DC E1           	pop hl			;22dc	e1 	.
 8131 22DD CD CB 09     	call MAT_sCopyACCToHL		;22dd	cd cb 09 	. . .
 8132 22E0 E1           	pop hl			;22e0	e1 	.
 8133 22E1 CD C2 09     	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;22e1	cd c2 09 	. . .
 8134 22E4 E5           	push hl			;22e4	e5 	.
 8135 22E5 CD 0C 0A     	call MAT_sCmp_ACC_BCDE		;22e5	cd 0c 0a 	. . .
 8136 22E8 18 29        	jr l2313h		;22e8	18 29 	. )
 8137 22EA              l22eah:
 8138 22EA 23           	inc hl			;22ea	23 	#
 8139 22EB 23           	inc hl			;22eb	23 	#
 8140 22EC 23           	inc hl			;22ec	23 	#
 8141 22ED 23           	inc hl			;22ed	23 	#
 8142 22EE 4E           	ld c,(hl)			;22ee	4e 	N
 8143 22EF 23           	inc hl			;22ef	23 	#
 8144 22F0 46           	ld b,(hl)			;22f0	46 	F
 8145 22F1 23           	inc hl			;22f1	23 	#
 8146 22F2 E3           	ex (sp),hl			;22f2	e3 	.
 8147 22F3 5E           	ld e,(hl)			;22f3	5e 	^
 8148 22F4 23           	inc hl			;22f4	23 	#
 8149 22F5 56           	ld d,(hl)			;22f5	56 	V
 8150 22F6 E5           	push hl			;22f6	e5 	.
 8151 22F7 69           	ld l,c			;22f7	69 	i
 8152 22F8 60           	ld h,b			;22f8	60 	`
 8153 22F9 CD D2 0B     	call MAT_iAdd_DEHL	;  ACC = DE + HL (Integer)	;22f9	cd d2 0b 	. . .
 8154 22FC 3A AF 78     	ld a,(MATH_NTF)		;22fc	3a af 78 	: . x
 8155 22FF FE 04        	cp 4			; is this variable type Single ;22ff	fe 04 	. .
 8156 2301 CA B2 07     	jp z,ErrRaiseOverflow	; Raise OVERFLOW Error		;2301	ca b2 07 	. . .
 8157 2304 EB           	ex de,hl			;2304	eb 	.
 8158 2305 E1           	pop hl			;2305	e1 	.
 8159 2306 72           	ld (hl),d			;2306	72 	r
 8160 2307 2B           	dec hl			;2307	2b 	+
 8161 2308 73           	ld (hl),e			;2308	73 	s
 8162 2309 E1           	pop hl			;2309	e1 	.
 8163 230A D5           	push de			;230a	d5 	.
 8164 230B 5E           	ld e,(hl)			;230b	5e 	^
 8165 230C 23           	inc hl			;230c	23 	#
 8166 230D 56           	ld d,(hl)			;230d	56 	V
 8167 230E 23           	inc hl			;230e	23 	#
 8168 230F E3           	ex (sp),hl			;230f	e3 	.
 8169 2310 CD 39 0A     	call MAT_iCmp_HL_DE	; Compare HL and DE (Integer)	;2310	cd 39 0a 	. 9 .
 8170 2313              l2313h:
 8171 2313 E1           	pop hl			;2313	e1 	.
 8172 2314 C1           	pop bc			;2314	c1 	.
 8173 2315 90           	sub b			;2315	90 	.
 8174 2316 CD C2 09     	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;2316	cd c2 09 	. . .
 8175 2319 28 09        	jr z,l2324h		;2319	28 09 	( .
 8176 231B EB           	ex de,hl			;231b	eb 	.
 8177 231C 22 A2 78     	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;231c	22 a2 78 	" . x
 8178 231F 69           	ld l,c			;231f	69 	i
 8179 2320 60           	ld h,b			;2320	60 	`
 8180 2321 C3 1A 1D     	jp l1d1ah		;2321	c3 1a 1d 	. . .
 8181 2324              l2324h:
 8182 2324 F9           	ld sp,hl			;2324	f9 	.
 8183 2325 22 E8 78     	ld (BAS_StackPtr),hl		;2325	22 e8 78 	" . x
 8184 2328 2A DF 78     	ld hl,(PrgStart)	; hl - pointer to BASIC Program Start							;2328	2a df 78 	* . x
 8185 232B 7E           	ld a,(hl)			;232b	7e 	~
 8186 232C FE 2C        	cp 02ch		;232c	fe 2c 	. ,
 8187 232E C2 1E 1D     	jp nz,l1d1eh		;232e	c2 1e 1d 	. . .
 8188 2331 D7           	rst $10			; move hl to next Basic token					;2331	d7 	.
 8189 2332 CD B9 22     	call sub_22b9h		;2332	cd b9 22 	. . "
 8190 2335
 8191 2335
 8192 2335
 8193 2335              ; ***********************************************************************************
 8194 2335              ; EVALUATE PARENTHESIZED EXPRESSION AT (HL)
 8195 2335              ; Evaluate BASIC string expression (may include constants, BASIC variables,
 8196 2335              ; BASIC functions, operators, etc.) and place result in ACC (also set NTF).
 8197 2335              ; On entry, HL must point to a left parenthesis (which precedes the expression
 8198 2335              ; to be evaluated) or a BASIC syntax error will result.
 8199 2335              ; On exit, HL will point to the string delimiter - a right parenthesis.
 8200 2335              ; IN: hl - expression enclosed with parenthesis
 8201 2335              EvalParam:
 8202 2335 CF           	rst $08		; Assert next token is '('	;2335	cf 	.
 8203 2336 28           	db '('		; Basic '(' token ;2336	28 (
 8204 2337
 8205 2337              ; ***********************************************************************************
 8206 2337              ; EVALUATE EXPRESSION AT (HL)
 8207 2337              ; Evaluate BASIC string expression (may include constants, BASIC variables,
 8208 2337              ; BASIC functions, operators, etc.) and place result in ACC (also set NTF).
 8209 2337              ; On entry, HL must point to first character of the string to be evaluated.
 8210 2337              ; On exit, HL will point to the string delimiter, which must be an acceptable
 8211 2337              ; BASIC expression terminator (such as a zero byte, a colon, a right parenthesis, etc.).
 8212 2337              ; NOTE: This routine may be entered at 2335, in which case the HL register pair
 8213 2337              ; MUST point to a left parenthesis (which precedes the expression to be evaluated)
 8214 2337              ; or a BASIC syntax error will result.
 8215 2337              EvalExpr:
 8216 2337 2B           	dec hl			;2337	2b
 8217 2338              sub_2338h:
 8218 2338 16 00        	ld d,000h		;2338	16 00 	. .
 8219 233A              l233ah:
 8220 233A D5           	push de			;233a	d5 	.
 8221 233B 0E 01        	ld c,001h		;233b	0e 01 	. .
 8222 233D CD 63 19     	call sub_1963h		;233d	cd 63 19 	. c .
 8223 2340 CD 9F 24     	call sub_249fh		;2340	cd 9f 24 	. . $
 8224 2343 22 F3 78     	ld (BAS_ExprTmpPtr),hl	; [TRS] expression parser current position		;2343	22 f3 78 	" . x
 8225 2346              l2346h:
 8226 2346 2A F3 78     	ld hl,(BAS_ExprTmpPtr)	; [TRS] expression parser current position		;2346	2a f3 78 	* . x
 8227 2349              l2349h:
 8228 2349 C1           	pop bc			;2349	c1 	.
 8229 234A 7E           	ld a,(hl)			;234a	7e 	~
 8230 234B 16 00        	ld d,000h		;234b	16 00 	. .
 8231 234D              l234dh:
 8232 234D D6 D4        	sub 0d4h		;234d	d6 d4 	. .
 8233 234F 38 13        	jr c,l2364h		;234f	38 13 	8 .
 8234 2351 FE 03        	cp 003h		;2351	fe 03 	. .
 8235 2353 30 0F        	jr nc,l2364h		;2353	30 0f 	0 .
 8236 2355 FE 01        	cp 001h		;2355	fe 01 	. .
 8237 2357 17           	rla			;2357	17 	.
 8238 2358 AA           	xor d			;2358	aa 	.
 8239 2359 BA           	cp d			;2359	ba 	.
 8240 235A 57           	ld d,a			;235a	57 	W
 8241 235B DA 97 19     	jp c,ErrRaiseSyntax	; Raise 'SYNTAX ERROR'	;235b	da 97 19 	. . .
 8242 235E 22 D8 78     	ld (BAS_TempPtr),hl	; temporary pointer	;235e	22 d8 78 	" . x
 8243 2361 D7           	rst $10			; move hl to next Basic token				;2361	d7 	.
 8244 2362 18 E9        	jr l234dh		;2362	18 e9 	. .
 8245 2364              l2364h:
 8246 2364 7A           	ld a,d			;2364	7a 	z
 8247 2365 B7           	or a			;2365	b7 	.
 8248 2366 C2 EC 23     	jp nz,l23ech		;2366	c2 ec 23 	. . #
 8249 2369 7E           	ld a,(hl)			;2369	7e 	~
 8250 236A 22 D8 78     	ld (BAS_TempPtr),hl	; temporary pointer	;236a	22 d8 78 	" . x
 8251 236D D6 CD        	sub 0cdh		;236d	d6 cd 	. .
 8252 236F D8           	ret c			;236f	d8 	.
 8253 2370 FE 07        	cp 007h		;2370	fe 07 	. .
 8254 2372 D0           	ret nc			;2372	d0 	.
 8255 2373 5F           	ld e,a			;2373	5f 	_
 8256 2374 3A AF 78     	ld a,(MATH_NTF)		;2374	3a af 78 	: . x
 8257 2377 D6 03        	sub 003h		;2377	d6 03 	. .
 8258 2379 B3           	or e			;2379	b3 	.
 8259 237A CA 8F 29     	jp z,l298fh		;237a	ca 8f 29 	. . )
 8260 237D 21 9A 18     	ld hl,l189ah		;237d	21 9a 18 	! . .
 8261 2380 19           	add hl,de			;2380	19 	.
 8262 2381 78           	ld a,b			;2381	78 	x
 8263 2382 56           	ld d,(hl)			;2382	56 	V
 8264 2383 BA           	cp d			;2383	ba 	.
 8265 2384 D0           	ret nc			;2384	d0 	.
 8266 2385 C5           	push bc			;2385	c5 	.
 8267 2386 01 46 23     	ld bc,l2346h		;2386	01 46 23 	. F #
 8268 2389 C5           	push bc			;2389	c5 	.
 8269 238A 7A           	ld a,d			;238a	7a 	z
 8270 238B FE 7F        	cp 07fh		;238b	fe 7f 	. 
 8271 238D CA D4 23     	jp z,l23d4h		;238d	ca d4 23 	. . #
 8272 2390 FE 51        	cp 051h		;2390	fe 51 	. Q
 8273 2392 DA E1 23     	jp c,l23e1h		;2392	da e1 23 	. . #
 8274 2395              l2395h:
 8275 2395 21 21 79     	ld hl,ACC_SNG	 ; Int,Single,String (2 or 4 bytes): 	;2395	21 21 79 	! ! y
 8276 2398 B7           	or a			;2398	b7 	.
 8277 2399 3A AF 78     	ld a,(MATH_NTF)		;2399	3a af 78 	: . x
 8278 239C 3D           	dec a			;239c	3d 	=
 8279 239D 3D           	dec a			;239d	3d 	=
 8280 239E 3D           	dec a			;239e	3d 	=
 8281 239F CA F6 0A     	jp z,ErrRaiseTypeMismatch	; Raise TYPE MISMATCH Error						;239f	ca f6 0a 	. . .
 8282 23A2 4E           	ld c,(hl)			;23a2	4e 	N
 8283 23A3 23           	inc hl			;23a3	23 	#
 8284 23A4 46           	ld b,(hl)			;23a4	46 	F
 8285 23A5 C5           	push bc			;23a5	c5 	.
 8286 23A6 FA C5 23     	jp m,l23c5h		;23a6	fa c5 23 	. . #
 8287 23A9 23           	inc hl			;23a9	23 	#
 8288 23AA 4E           	ld c,(hl)			;23aa	4e 	N
 8289 23AB 23           	inc hl			;23ab	23 	#
 8290 23AC 46           	ld b,(hl)			;23ac	46 	F
 8291 23AD C5           	push bc			;23ad	c5 	.
 8292 23AE F5           	push af			;23ae	f5 	.
 8293 23AF B7           	or a			;23af	b7 	.
 8294 23B0 E2 C4 23     	jp po,023c4h		;23b0	e2 c4 23 	. . #
 8295 23B3 F1           	pop af			;23b3	f1 	.
 8296 23B4 23           	inc hl			;23b4	23 	#
 8297 23B5 38 03        	jr c,l23bah		;23b5	38 03 	8 .
 8298 23B7 21 1D 79     	ld hl,ACC_DBL		; addres of Accumulator ;23b7	21 1d 79 	! . y
 8299 23BA              l23bah:
 8300 23BA 4E           	ld c,(hl)			;23ba	4e 	N
 8301 23BB 23           	inc hl			;23bb	23 	#
 8302 23BC 46           	ld b,(hl)			;23bc	46 	F
 8303 23BD 23           	inc hl			;23bd	23 	#
 8304 23BE C5           	push bc			;23be	c5 	.
 8305 23BF 4E           	ld c,(hl)			;23bf	4e 	N
 8306 23C0 23           	inc hl			;23c0	23 	#
 8307 23C1 46           	ld b,(hl)			;23c1	46 	F
 8308 23C2 C5           	push bc			;23c2	c5 	.
 8309 23C3 06 F1        	ld b,0f1h		;23c3	06 f1 	. .
 8310 23C5              l23c5h:
 8311 23C5 C6 03        	add a,003h		;23c5	c6 03 	. .
 8312 23C7 4B           	ld c,e			;23c7	4b 	K
 8313 23C8 47           	ld b,a			;23c8	47 	G
 8314 23C9 C5           	push bc			;23c9	c5 	.
 8315 23CA 01 06 24     	ld bc,l2406h		;23ca	01 06 24 	. . $
 8316 23CD              l23cdh:
 8317 23CD C5           	push bc			;23cd	c5 	.
 8318 23CE 2A D8 78     	ld hl,(BAS_TempPtr)	; temporary pointer	;23ce	2a d8 78 	* . x
 8319 23D1 C3 3A 23     	jp l233ah		;23d1	c3 3a 23 	. : #
 8320 23D4              l23d4h:
 8321 23D4 CD B1 0A     	call FuncCSNG		; convert ACC to Single value	;23d4	cd b1 0a 	. . .
 8322 23D7 CD A4 09     	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;23d7	cd a4 09 	. . .
 8323 23DA 01 F2 13     	ld bc,STACKPowACC_DBL		; routine -  ACC = STACK ^ ACC (Any -> Single);23da	01 f2 13 	. . .
 8324 23DD 16 7F        	ld d,07fh		;23dd	16 7f 	. 
 8325 23DF 18 EC        	jr l23cdh		;23df	18 ec 	. .
 8326 23E1              l23e1h:
 8327 23E1 D5           	push de			;23e1	d5 	.
 8328 23E2 CD 7F 0A     	call FuncCINT	; convert ACC to integer		;23e2	cd 7f 0a 	.  .
 8329 23E5 D1           	pop de			;23e5	d1 	.
 8330 23E6 E5           	push hl			;23e6	e5 	.
 8331 23E7 01 E9 25     	ld bc,l25e9h		;23e7	01 e9 25 	. . %
 8332 23EA 18 E1        	jr l23cdh		;23ea	18 e1 	. .
 8333 23EC              l23ech:
 8334 23EC 78           	ld a,b			;23ec	78 	x
 8335 23ED FE 64        	cp 064h		;23ed	fe 64 	. d
 8336 23EF D0           	ret nc			;23ef	d0 	.
 8337 23F0 C5           	push bc			;23f0	c5 	.
 8338 23F1 D5           	push de			;23f1	d5 	.
 8339 23F2 11 04 64     	ld de,06404h		;23f2	11 04 64 	. . d
 8340 23F5 21 B8 25     	ld hl,l25b8h		;23f5	21 b8 25 	! . %
 8341 23F8 E5           	push hl			;23f8	e5 	.
 8342 23F9 E7           	rst #20			; test NTF (Number Type Format) ;23f9	e7 	.
 8343 23FA C2 95 23     	jp nz,l2395h	; Number (not String) -	;23fa	c2 95 23 	. . #
 8344 23FD              ; -- String
 8345 23FD 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;23fd	2a 21 79 	* ! y
 8346 2400 E5           	push hl			;2400	e5 	.
 8347 2401 01 8C 25     	ld bc,CmpStrACC_DBL	; Compare 2 strings (ACC) == (STACK)	;2401	01 8c 25 	. . %
 8348 2404 18 C7        	jr l23cdh		;2404	18 c7 	. .
 8349 2406              l2406h:
 8350 2406 C1           	pop bc			;2406	c1 	.
 8351 2407 79           	ld a,c			;2407	79 	y
 8352 2408 32 B0 78     	ld (078b0h),a		;2408	32 b0 78 	2 . x
 8353 240B 78           	ld a,b			;240b	78 	x
 8354 240C FE 08        	cp 008h		;240c	fe 08 	. .
 8355 240E 28 28        	jr z,l2438h		;240e	28 28 	( (
 8356 2410 3A AF 78     	ld a,(MATH_NTF)		;2410	3a af 78 	: . x
 8357 2413 FE 08        	cp 8		; is this variable type Double ;2413	fe 08 	. .
 8358 2415 CA 60 24     	jp z,l2460h		;2415	ca 60 24 	. ` $
 8359 2418 57           	ld d,a			;2418	57 	W
 8360 2419 78           	ld a,b			;2419	78 	x
 8361 241A FE 04        	cp 004h		;241a	fe 04 	. .
 8362 241C CA 72 24     	jp z,l2472h		;241c	ca 72 24 	. r $
 8363 241F 7A           	ld a,d			;241f	7a 	z
 8364 2420 FE 03        	cp 003h		;2420	fe 03 	. .
 8365 2422 CA F6 0A     	jp z,ErrRaiseTypeMismatch	; Raise TYPE MISMATCH Error						;2422	ca f6 0a 	. . .
 8366 2425 D2 7C 24     	jp nc,l247ch		;2425	d2 7c 24 	. | $
 8367 2428 21 BF 18     	ld hl,l18bfh		;2428	21 bf 18 	! . .
 8368 242B 06 00        	ld b,000h		;242b	06 00 	. .
 8369 242D 09           	add hl,bc			;242d	09 	.
 8370 242E 09           	add hl,bc			;242e	09 	.
 8371 242F 4E           	ld c,(hl)			;242f	4e 	N
 8372 2430 23           	inc hl			;2430	23 	#
 8373 2431 46           	ld b,(hl)			;2431	46 	F
 8374 2432 D1           	pop de			;2432	d1 	.
 8375 2433 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2433	2a 21 79 	* ! y
 8376 2436 C5           	push bc			;2436	c5 	.
 8377 2437 C9           	ret			;2437	c9 	.
 8378 2438              l2438h:
 8379 2438 CD DB 0A     	call FuncCDBL			; convert ACC to Double value	;2438	cd db 0a 	. . .
 8380 243B CD FC 09     	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;243b	cd fc 09 	. . .
 8381 243E E1           	pop hl			;243e	e1 	.
 8382 243F 22 1F 79     	ld (ACC_DBL+2),hl		; addres of Accumulator (Double) + 2;243f	22 1f 79 	" . y
 8383 2442 E1           	pop hl			;2442	e1 	.
 8384 2443 22 1D 79     	ld (ACC_DBL),hl		; addres of Accumulator (Double) ;2443	22 1d 79 	" . y
 8385 2446              l2446h:
 8386 2446 C1           	pop bc			;2446	c1 	.
 8387 2447 D1           	pop de			;2447	d1 	.
 8388 2448 CD B4 09     	call BCDEToACC_DBL	; copy value from BCDE to ACC (Single)		;2448	cd b4 09 	. . .
 8389 244B              l244bh:
 8390 244B CD DB 0A     	call FuncCDBL		; convert ACC to Double value	;244b	cd db 0a 	. . .
 8391 244E 21 AB 18     	ld hl,l18abh		;244e	21 ab 18 	! . .
 8392 2451              l2451h:
 8393 2451 3A B0 78     	ld a,(078b0h)		;2451	3a b0 78 	: . x
 8394 2454 07           	rlca			;2454	07 	.
 8395 2455 C5           	push bc			;2455	c5 	.
 8396 2456 4F           	ld c,a			;2456	4f 	O
 8397 2457 06 00        	ld b,000h		;2457	06 00 	. .
 8398 2459 09           	add hl,bc			;2459	09 	.
 8399 245A C1           	pop bc			;245a	c1 	.
 8400 245B 7E           	ld a,(hl)			;245b	7e 	~
 8401 245C 23           	inc hl			;245c	23 	#
 8402 245D 66           	ld h,(hl)			;245d	66 	f
 8403 245E 6F           	ld l,a			;245e	6f 	o
 8404 245F E9           	jp (hl)			;245f	e9 	.
 8405 2460              l2460h:
 8406 2460 C5           	push bc			;2460	c5 	.
 8407 2461 CD FC 09     	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;2461	cd fc 09 	. . .
 8408 2464 F1           	pop af			;2464	f1 	.
 8409 2465 32 AF 78     	ld (MATH_NTF),a		;2465	32 af 78 	2 . x
 8410 2468 FE 04        	cp 4		; is this variable type Single	;2468	fe 04 	. .
 8411 246A 28 DA        	jr z,l2446h		;246a	28 da 	( .
 8412 246C E1           	pop hl			;246c	e1 	.
 8413 246D 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;246d	22 21 79 	" ! y
 8414 2470 18 D9        	jr l244bh		;2470	18 d9 	. .
 8415 2472              l2472h:
 8416 2472 CD B1 0A     	call FuncCSNG		; convert ACC to Single value	;2472	cd b1 0a 	. . .
 8417 2475 C1           	pop bc			;2475	c1 	.
 8418 2476 D1           	pop de			;2476	d1 	.
 8419 2477              l2477h:
 8420 2477 21 B5 18     	ld hl,l18b5h		;2477	21 b5 18 	! . .
 8421 247A 18 D5        	jr l2451h		;247a	18 d5 	. .
 8422 247C              l247ch:
 8423 247C E1           	pop hl			;247c	e1 	.
 8424 247D CD A4 09     	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;247d	cd a4 09 	. . .
 8425 2480 CD CF 0A     	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;2480	cd cf 0a 	. . .
 8426 2483 CD BF 09     	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;2483	cd bf 09 	. . .
 8427 2486 E1           	pop hl			;2486	e1 	.
 8428 2487 22 23 79     	ld (ACC_SNG+2),hl	 ; Int,Single,String (2 or 4 bytes): 	;2487	22 23 79 	" # y
 8429 248A E1           	pop hl			;248a	e1 	.
 8430 248B 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;248b	22 21 79 	" ! y
 8431 248E 18 E7        	jr l2477h		;248e	18 e7 	. .
 8432 2490
 8433 2490
 8434 2490              // ***********************************************************************
 8435 2490              ; Math : ACC = DE / HL (Integer)
 8436 2490              MAT_iDiv_DEHL
 8437 2490 E5           	push hl			;2490	e5 	.
 8438 2491 EB           	ex de,hl			;2491	eb 	.
 8439 2492 CD CF 0A     	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;2492	cd cf 0a 	. . .
 8440 2495 E1           	pop hl			;2495	e1 	.
 8441 2496 CD A4 09     	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;2496	cd a4 09 	. . .
 8442 2499 CD CF 0A     	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;2499	cd cf 0a 	. . .
 8443 249C C3 A0 08     	jp MAT_sDiv_STACK_ACC_DBL		;249c	c3 a0 08 	. . .
 8444 249F
 8445 249F
 8446 249F              sub_249fh:
 8447 249F D7           	rst $10			    ; move hl to next Basic token					;249f	d7 	.
 8448 24A0 1E 28        	ld e,#28			; ERROR 28 - MISSING OPERAND 		;24a0	1e 28 	. (
 8449 24A2 CA A2 19     	jp z,ErrRaiseError	; Raise Error if End of Statement found ('\0' or ':')	;24a2	ca a2 19 	. . .
 8450 24A5 DA 6C 0E     	jp c,StrToNum		; digit found -  Convert from ASCII const (HL) to Any (ACC) ;24a5	da 6c 0e 	. l .
 8451 24A8 CD 3D 1E     	call SysIsLetter	; is this letter A..Z? (variable name instead of value) 	;24a8	cd 3d 1e 	. = .
 8452 24AB D2 40 25     	jp nc,BAS_VarToAcc	; yes - locate or create variable and load into ACC	;24ab	d2 40 25 	. @ %
 8453 24AE FE CD        	cp 0cdh		;24ae	fe cd 	. .
 8454 24B0 28 ED        	jr z,sub_249fh		;24b0	28 ed 	( .
 8455 24B2 FE 2E        	cp 02eh		;24b2	fe 2e 	. .
 8456 24B4 CA 6C 0E     	jp z,StrToNum		; yes - Convert from ASCII const (HL) to Any (ACC);24b4	ca 6c 0e 	. l .
 8457 24B7 FE CE        	cp 0ceh		;24b7	fe ce 	. .
 8458 24B9 CA 32 25     	jp z,l2532h		;24b9	ca 32 25 	. 2 %
 8459 24BC              l24bch:
 8460 24BC FE 22        	cp '"'		;24bc	fe 22 	. "
 8461 24BE CA 66 28     	jp z,BAS_MakeStrVecHL	; create StringVector from text enclosed with '"'		;24be	ca 66 28 	. f (
 8462 24C1 FE CB        	cp 0cbh		;24c1	fe cb 	. .
 8463 24C3 CA C4 25     	jp z,l25c4h		;24c3	ca c4 25 	. . %
 8464 24C6 FE 26        	cp 026h		;24c6	fe 26 	. &
 8465 24C8 CA 94 79     	jp z,SysDosAND		;24c8	ca 94 79 	. . y
 8466 24CB FE C3        	cp 0c3h		;24cb	fe c3 	. .
 8467 24CD 20 0A        	jr nz,l24d9h		;24cd	20 0a 	  .
 8468 24CF D7           	rst $10			    ; move hl to next Basic token				;24cf	d7 	.
 8469 24D0 3A 9A 78     	ld a,(LASTERRORNO)	; Last Error Number occurred		;24d0	3a 9a 78 	: . x
 8470 24D3 E5           	push hl			;24d3	e5 	.
 8471 24D4 CD F8 27     	call ByteToAcc	; Copy a to ACC		;24d4	cd f8 27 	. . '
 8472 24D7 E1           	pop hl			;24d7	e1 	.
 8473 24D8 C9           	ret			;24d8	c9 	.
 8474 24D9              l24d9h:
 8475 24D9 FE C2        	cp 0c2h		;24d9	fe c2 	. .
 8476 24DB 20 0A        	jr nz,l24e7h		;24db	20 0a 	  .
 8477 24DD D7           	rst $10			; move hl to next Basic token				;24dd	d7 	.
 8478 24DE E5           	push hl			;24de	e5 	.
 8479 24DF 2A EA 78     	ld hl,(ErrorLineNo)	; Basic Line Number with Error 		;24df	2a ea 78 	* . x
 8480 24E2 CD 66 0C     	call sub_0c66h		;24e2	cd 66 0c 	. f .
 8481 24E5 E1           	pop hl			;24e5	e1 	.
 8482 24E6 C9           	ret			;24e6	c9 	.
 8483 24E7              l24e7h:
 8484 24E7 FE C0        	cp 0c0h		;24e7	fe c0 	. .
 8485 24E9 20 14        	jr nz,l24ffh		;24e9	20 14 	  .
 8486 24EB D7           	rst $10			; move hl to next Basic token				;24eb	d7 	.
 8487 24EC CF           	rst $08			; Assert next token is '(' ;24ec	cf 	.
 8488 24ED 28           	defb '('		; Basic '(' token ;24ed	28 ( .
 8489 24EE CD 0D 26     	call $260d			;24ee	cd 0d 26	.
 8490 24F1 CF           	rst $08		    ; Assert next token is ')' ;24f1	cf 	.
 8491 24F2 29           	defb ')'		; Basic ')' token 	;24f2	29 	)
 8492 24F3 E5           	push hl			;24f3	e5 	.
 8493 24F4 EB           	ex de,hl			;24f4	eb 	.
 8494 24F5 7C           	ld a,h			;24f5	7c 	|
 8495 24F6 B5           	or l			;24f6	b5 	.
 8496 24F7 CA 4A 1E     	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;24f7	ca 4a 1e 	. J .
 8497 24FA CD 9A 0A     	call ACCfromHLValue	; copy value from hl to ACC as integer number		;24fa	cd 9a 0a 	. . .
 8498 24FD E1           	pop hl			;24fd	e1 	.
 8499 24FE C9           	ret			;24fe	c9 	.
 8500 24FF              l24ffh:
 8501 24FF FE C1        	cp 0c1h		;24ff	fe c1 	. .
 8502 2501 CA FE 27     	jp z,l27feh		;2501	ca fe 27 	. . '
 8503 2504 FE C5        	cp 0c5h		;2504	fe c5 	. .
 8504 2506 CA 9D 79     	jp z,SysDosINSTR		;2506	ca 9d 79 	. . y
 8505 2509 FE C8        	cp 0c8h		;2509	fe c8 	. .
 8506 250B CA C9 27     	jp z,l27c9h		;250b	ca c9 27 	. . '
 8507 250E FE C7        	cp 0c7h		;250e	fe c7 	. .
 8508 2510 CA 76 79     	jp z,SysDosTIMES		;2510	ca 76 79 	. v y
 8509 2513 FE C6        	cp 0c6h		;2513	fe c6 	. .
 8510 2515 CA 32 01     	jp z,l0132h		;2515	ca 32 01 	. 2 .
 8511 2518 FE C9        	cp 0c9h		;2518	fe c9 	. .
 8512 251A CA 9D 01     	jp z,0019dh		;251a	ca 9d 01 	. . .
 8513 251D FE C4        	cp 0c4h		;251d	fe c4 	. .
 8514 251F CA 2F 2A     	jp z,l2a2fh		;251f	ca 2f 2a 	. / *
 8515 2522 FE BE        	cp 0beh		;2522	fe be 	. .
 8516 2524 CA 55 79     	jp z,SysDosFN		;2524	ca 55 79 	. U y
 8517 2527 D6 D7        	sub 0d7h		;2527	d6 d7 	. .
 8518 2529 D2 4E 25     	jp nc,l254eh		;2529	d2 4e 25 	. N %
 8519 252C
 8520 252C              ; *************************************************************************************
 8521 252C              ; EVALUATE PARENTHESIZED EXPRESSION
 8522 252C              ; Evaluate any valid BASIC expression enclosed in parenthesis. A BASIC syntax error will
 8523 252C              ; result if expression is not terminated with a right parenthesis
 8524 252C              EvalSubExpression:
 8525 252C CD 35 23     	call EvalParam	; assert 1st char is '(' and evaluate expression into ACC	;252c	cd 35 23 	. 5 #
 8526 252F CF           	rst $08			; Assert next token is ')' 									;252f	cf 	.
 8527 2530 29           	db ')'			; Basic ')' token 											;2530	29 	)
 8528 2531 C9           	ret				; -------------------- End of Proc ------------------------	;2531	c9 	.
 8529 2532
 8530 2532
 8531 2532              l2532h:
 8532 2532 16 7D        	ld d,07dh		;2532	16 7d 	. }
 8533 2534 CD 3A 23     	call l233ah		;2534	cd 3a 23 	. : #
 8534 2537 2A F3 78     	ld hl,(BAS_ExprTmpPtr)	; [TRS] expression parser current position		;2537	2a f3 78 	* . x
 8535 253A E5           	push hl			;253a	e5 	.
 8536 253B CD 7B 09     	call l097bh		;253b	cd 7b 09 	. { .
 8537 253E              l253eh:
 8538 253E E1           	pop hl			;253e	e1 	.
 8539 253F C9           	ret			;253f	c9 	.
 8540 2540
 8541 2540              ; ***************************************************************************************
 8542 2540              ; LOAD ACC WITH VALUE OF BASIC VARIABLE
 8543 2540              ; Get value of BASIC variable and put in ACCOM (also put precision of variable in NTF).
 8544 2540              ; IN: hl - points to first character of variable name.
 8545 2540              ; OUT: hl - point to first character following variable name.
 8546 2540              BAS_VarToAcc:
 8547 2540 CD 0D 26     	call GetVarAddr	; locate or create Basic Variable						;2540	cd 0d 26 	. . &
 8548 2543              l2543h:
 8549 2543 E5           	push hl			;2543	e5 	.
 8550 2544 EB           	ex de,hl			;2544	eb 	.
 8551 2545 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;2545	22 21 79 	" ! y
 8552 2548 E7           	rst #20			; test NTF (Number Type Format) ;2548	e7 	.
 8553 2549 C4 F7 09     	call nz,HLMemToACC_DBL	; Number (not String) - Copy value from (HL) to ACC (Any)	;2549	c4 f7 09 	. . .
 8554 254C E1           	pop hl			;254c	e1 	.
 8555 254D C9           	ret			;254d	c9 	.
 8556 254E              l254eh:
 8557 254E 06 00        	ld b,000h		;254e	06 00 	. .
 8558 2550 07           	rlca			;2550	07 	.
 8559 2551 4F           	ld c,a			;2551	4f 	O
 8560 2552 C5           	push bc			;2552	c5 	.
 8561 2553 D7           	rst $10			; move hl to next Basic token				;2553	d7 	.
 8562 2554 79           	ld a,c			;2554	79 	y
 8563 2555 FE 41        	cp 041h		;2555	fe 41 	. A
 8564 2557 38 16        	jr c,l256fh		;2557	38 16 	8 .
 8565 2559 CD 35 23     	call EvalParam	; assert 1st char is '(' and evaluate expression 		;2559	cd 35 23 	. 5 #
 8566 255C CF           	rst $08				; Assert next token is ',' 								;255c	cf 	.
 8567 255D 2C           	defb ','			; Basic ',' token 										;255d	2c 	,
 8568 255E CD F4 0A     	call AssertACCIsString	; Assert ACC contains String						;255e	cd f4 0a 	. . .
 8569 2561 EB           	ex de,hl			;2561	eb 	.
 8570 2562 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2562	2a 21 79 	* ! y
 8571 2565 E3           	ex (sp),hl			;2565	e3 	.
 8572 2566 E5           	push hl			;2566	e5 	.
 8573 2567 EB           	ex de,hl			;2567	eb 	.
 8574 2568 CD 1C 2B     	call EvalByteExpr	; expression ACC, de and a - must be 8bit value	;2568	cd 1c 2b 	. . +
 8575 256B EB           	ex de,hl			;256b	eb 	.
 8576 256C E3           	ex (sp),hl			;256c	e3 	.
 8577 256D 18 14        	jr l2583h		;256d	18 14 	. .
 8578 256F              l256fh:
 8579 256F CD 2C 25     	call EvalSubExpression	; evaluate expression (starts with '(' and ends with ')'	;256f	cd 2c 25 	. , %
 8580 2572 E3           	ex (sp),hl			;2572	e3 	.
 8581 2573 7D           	ld a,l			;2573	7d 	}
 8582 2574 FE 0C        	cp 00ch		;2574	fe 0c 	. .
 8583 2576 38 07        	jr c,l257fh		;2576	38 07 	8 .
 8584 2578 FE 1B        	cp 01bh		;2578	fe 1b 	. .
 8585 257A E5           	push hl			;257a	e5 	.
 8586 257B DC B1 0A     	call c,FuncCSNG		; convert ACC to Single value	;257b	dc b1 0a 	. . .
 8587 257E E1           	pop hl			;257e	e1 	.
 8588 257F              l257fh:
 8589 257F 11 3E 25     	ld de,l253eh		;257f	11 3e 25 	. > %
 8590 2582 D5           	push de			;2582	d5 	.
 8591 2583              l2583h:
 8592 2583 01 08 16     	ld bc,BasicFuncPointers		;2583	01 08 16 	. . .
 8593 2586
 8594 2586              ; IN: hl - base jump table
 8595 2586              ;     bc - offset for address entry
 8596 2586              SysJmpHLPlusBC:
 8597 2586 09           	add hl,bc		; add offset to base address of table				;2586	09 	.
 8598 2587 4E           	ld c,(hl)		; c - LSB of destination jump address				;2587	4e 	N
 8599 2588 23           	inc hl			; point to MSB of destination jump address			;2588	23 	#
 8600 2589 66           	ld h,(hl)		; h - MSB of destination jump address				;2589	66 	f
 8601 258A 69           	ld l,c			; hl - destination jump address						;258a	69 	i
 8602 258B E9           	jp (hl)			; jump to address taken from table					;258b	e9 	.
 8603 258C
 8604 258C
 8605 258C              ; ********************************************************************************************
 8606 258C              ; Compare 2 strings (ACC) == (STACK)
 8607 258C              ; IN: STACK: <ret addr> <varptr(String1)>
 8608 258C              ;     ACC: varptr(String2)
 8609 258C              ; OUT: a,f - compare result (-1, 0, 1)
 8610 258C              CmpStrACC_DBL:
 8611 258C CD D7 29     	call sub_29d7h		;258c	cd d7 29 	. . )
 8612 258F              ; -- hl points to StringVector structure (1 byte length + 2 bytes address of text)
 8613 258F 7E           	ld a,(hl)		; a - length of 1st string 	;258f	7e 	~
 8614 2590 23           	inc hl			; address of String text member ;2590	23 	#
 8615 2591 4E           	ld c,(hl)		; low byte of address of text		;2591	4e 	N
 8616 2592 23           	inc hl			; points to high byte of address ;2592	23 	#
 8617 2593 46           	ld b,(hl)		; bc - address of text 		;2593	46 	F
 8618 2594 D1           	pop de			;2594	d1 	.
 8619 2595 C5           	push bc			; save text address ;2595	c5 	.
 8620 2596 F5           	push af			; save text length ;2596	f5 	.
 8621 2597 CD DE 29     	call sub_29deh		;2597	cd de 29 	. . )
 8622 259A D1           	pop de			; d - length of 1st string ;259a	d1 	.
 8623 259B              ; -- hl points to StringVector structure (1 byte length + 2 bytes address of text)
 8624 259B 5E           	ld e,(hl)		; e - length of 2nd string 	;259b	5e 	^
 8625 259C 23           	inc hl			; address of String text member;259c	23 	#
 8626 259D 4E           	ld c,(hl)		; low byte of address of text	;259d	4e 	N
 8627 259E 23           	inc hl			; points to high byte of address ;259e	23 	#
 8628 259F 46           	ld b,(hl)		; bc - address of text 	;259f	46 	F
 8629 25A0 E1           	pop hl			; hl - text address for 1st string ;25a0	e1 	.
 8630 25A1
 8631 25A1
 8632 25A1
 8633 25A1              ; ********************************************************************************************
 8634 25A1              ; Compare 2 strings in memory (hl) == (bc)
 8635 25A1              ; IN: hl - String1
 8636 25A1              ;	  d - String1 length
 8637 25A1              ;     bc - String2
 8638 25A1              ;     e - String2 length
 8639 25A1              ; OUT: a,f - compare result (-1, 0, 1)
 8640 25A1              .compareNext:
 8641 25A1              ; -- check if all bytes already compared beetween both strings
 8642 25A1 7B           	ld a,e			; a - number bytes left in 2nd string           ;25a1	7b 	{
 8643 25A2 B2           	or d			; or'ed number bytes left in 1st string         ;25a2	b2 	.
 8644 25A3 C8           	ret z			; both are 0  - 1st strin == 2nd string         ;25a3	c8 	.
 8645 25A4              ; -- decrement 1st string bytes counter
 8646 25A4 7A           	ld a,d			; a - bytes left in 1st string                      ;25a4	7a 	z
 8647 25A5 D6 01        	sub 1		    ; decrement - is it less than 0 ?                   ;25a5	d6 01 	. .
 8648 25A7 D8           	ret c			; yes - 1st string < 2nd string (is shorter)        ;25a7	d8 	.
 8649 25A8              ; -- check 2nd string byte counter
 8650 25A8 AF           	xor a			; a = 0 and CY = 0                                  ;25a8	af 	.
 8651 25A9 BB           	cp e			; is bytes counter = 0 ?                            ;25a9	bb 	.
 8652 25AA 3C           	inc a			; set return value to 1 (1st nstring is greater)    ;25aa	3c 	<
 8653 25AB D0           	ret nc			; yes - 1st string > 2nd string                     ;25ab	d0 	.
 8654 25AC              ; -- both strings have bytes left to compare
 8655 25AC 15           	dec d			; decrement 1st string bytes counter                ;25ac	15 	.
 8656 25AD 1D           	dec e			; decrement 2nd string bytes counter                ;25ad	1d 	.
 8657 25AE 0A           	ld a,(bc)		; a - char from 2nd string	                        ;25ae	0a 	.
 8658 25AF BE           	cp (hl)			; compare to char from 1st stroing                  ;25af	be 	.
 8659 25B0              ; -- increment char pointers for both strings
 8660 25B0 23           	inc hl			; address of next char in 1st string                ;25b0	23 	#
 8661 25B1 03           	inc bc			; address of next char in 2nd string                ;25b1	03 	.
 8662 25B2 28 ED        	jr z,.compareNext	; if chars are equal continue comparision	        ;25b2	28 ed 	( .
 8663 25B4              ; -- chars are different - CY=1 when 1st string > 2nd string
 8664 25B4 3F           	ccf			    ; inverse CY flag  - CY=1 when 1st string < 2nd string ;25b4	3f 	?
 8665 25B5 C3 60 09     	jp CarryToRegA	; convert CY flag to -1 or 1 and return 	;25b5	c3 60 09 	. ` .
 8666 25B8              l25b8h:
 8667 25B8 3C           	inc a			;25b8	3c 	<
 8668 25B9 8F           	adc a,a			;25b9	8f 	.
 8669 25BA C1           	pop bc			;25ba	c1 	.
 8670 25BB A0           	and b			;25bb	a0 	.
 8671 25BC C6 FF        	add a,0ffh		;25bc	c6 ff 	. .
 8672 25BE 9F           	sbc a,a			;25be	9f 	.
 8673 25BF CD 8D 09     	call sub_098dh		;25bf	cd 8d 09 	. . .
 8674 25C2 18 12        	jr l25d6h		;25c2	18 12 	. .
 8675 25C4              l25c4h:
 8676 25C4 16 5A        	ld d,05ah		;25c4	16 5a 	. Z
 8677 25C6 CD 3A 23     	call l233ah		;25c6	cd 3a 23 	. : #
 8678 25C9 CD 7F 0A     	call FuncCINT	; convert ACC to integer		;25c9	cd 7f 0a 	.  .
 8679 25CC 7D           	ld a,l			;25cc	7d 	}
 8680 25CD 2F           	cpl			;25cd	2f 	/
 8681 25CE 6F           	ld l,a			;25ce	6f 	o
 8682 25CF 7C           	ld a,h			;25cf	7c 	|
 8683 25D0 2F           	cpl			;25d0	2f 	/
 8684 25D1 67           	ld h,a			;25d1	67 	g
 8685 25D2 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;25d2	22 21 79 	" ! y
 8686 25D5 C1           	pop bc			;25d5	c1 	.
 8687 25D6              l25d6h:
 8688 25D6 C3 46 23     	jp l2346h		;25d6	c3 46 23 	. F #
 8689 25D9
 8690 25D9
 8691 25D9              ; ********************************************************************************
 8692 25D9              ; Math : Test NTF (Number Type Format) of number in ACC
 8693 25D9              ; IN: ACC - numbert to test it's type
 8694 25D9              ; OUT: Flags: NC - Double, Z - String, M - Integer, P - Single (or Double), PO - Single
 8695 25D9              ;      a - -1 (integer), 0 (String), 1 (single), 5 (double)
 8696 25D9              TestNTF:
 8697 25D9 3A AF 78     	ld a,(MATH_NTF)	; a - NTF (Number Type Format)								;25d9	3a af 78 	: . x
 8698 25DC FE 08        	cp 8			; is this Double type?										;25dc	fe 08 	. .
 8699 25DE 30 05        	jr nc,.isDouble	; yes -	set reg a and flags for Double type					;25de	30 05 	0 .
 8700 25E0              ; -- ACC contains Single (4), Integer (2) or String (3)
 8701 25E0 D6 03        	sub 3			; a - 1 (Single), 0 (String), -1 (Integer)					;25e0	d6 03 	. .
 8702 25E2 B7           	or a			; set Z and M/P flags										;25e2	b7 	.
 8703 25E3 37           	scf				; set CY=1 (Single,String or Integer type)					;25e3	37 	7
 8704 25E4 C9           	ret				; ---------------- End of Proc ----------------------------	;25e4	c9 	.
 8705 25E5              .isDouble:
 8706 25E5 D6 03        	sub 3			; a - 5 for Double type										;25e5	d6 03 	. .
 8707 25E7 B7           	or a			; set P/M flags 											;25e7	b7 	.
 8708 25E8 C9           	ret				; ---------------- End of Proc ----------------------------	;25e8	c9 	.
 8709 25E9
 8710 25E9
 8711 25E9
 8712 25E9
 8713 25E9              l25e9h:
 8714 25E9 C5           	push bc			;25e9	c5 	.
 8715 25EA CD 7F 0A     	call FuncCINT	; convert ACC to integer		;25ea	cd 7f 0a 	.  .
 8716 25ED F1           	pop af			;25ed	f1 	.
 8717 25EE D1           	pop de			;25ee	d1 	.
 8718 25EF 01 FA 27     	ld bc,l27fah		;25ef	01 fa 27 	. . '
 8719 25F2 C5           	push bc			;25f2	c5 	.
 8720 25F3 FE 46        	cp 046h		;25f3	fe 46 	. F
 8721 25F5 20 06        	jr nz,MAT_iAnd_HL_DE	; A,L = HL & DE (Integer)	;25f5	20 06 	  .
 8722 25F7
 8723 25F7
 8724 25F7              ; ********************************************************************************
 8725 25F7              ; Math : A,L = HL | DE (Integer)
 8726 25F7              MAT_iOr_HL_DE
 8727 25F7 7B           	ld a,e			;25f7	7b 	{
 8728 25F8 B5           	or l			;25f8	b5 	.
 8729 25F9 6F           	ld l,a			;25f9	6f 	o
 8730 25FA 7C           	ld a,h			;25fa	7c 	|
 8731 25FB B2           	or d			;25fb	b2 	.
 8732 25FC C9           	ret			;25fc	c9 	.
 8733 25FD              ; ********************************************************************************
 8734 25FD              ; Math : A,L = HL & DE (Integer)
 8735 25FD              MAT_iAnd_HL_DE:
 8736 25FD 7B           	ld a,e			;25fd	7b 	{
 8737 25FE A5           	and l			;25fe	a5 	.
 8738 25FF 6F           	ld l,a			;25ff	6f 	o
 8739 2600 7C           	ld a,h			;2600	7c 	|
 8740 2601 A2           	and d			;2601	a2 	.
 8741 2602 C9           	ret			;2602	c9 	.
 8742 2603              l2603h:
 8743 2603 2B           	dec hl			;2603	2b 	+
 8744 2604 D7           	rst $10			; move hl to next Basic token				;2604	d7 	.
 8745 2605 C8           	ret z			; return if End of Statement found          ;2605	c8 	.
 8746 2606 CF           	rst $08			; Assert next token is ',' ;2606	cf 	.
 8747 2607 2C           	defb ','		; Basic ',' token 	;2607	2c 	,
 8748 2608
 8749 2608
 8750 2608              ; *******************************************************************************************************
 8751 2608              ; BASIC DIM Entry Point
 8752 2608              ; Dimension one or more BASIC variables.
 8753 2608              ; On entry, HL must point to the first character of a string which contains one or more
 8754 2608              ; variable names and desired dimensions (same syntax as would be required immediately
 8755 2608              ; following a BASIC DIM statement) . String must be terminated with a zero byte or colon.
 8756 2608              ; IN: hl - current executed command parser
 8757 2608              ;     a - command byte
 8758 2608              ;     Z = 1 - end of statement ('\0' or ':' found)
 8759 2608              ;     CY = 1 - char is digit
 8760 2608              CmdDIM:
 8761 2608 01 03 26     	ld bc,l2603h		;2608	01 03 26 	. . &
 8762 260B C5           	push bc			;260b	c5 	.
 8763 260C F6           	db $f6 			; trick byte - with next constructs or 0afh		;260c	f6 af 	. .
 8764 260D              	; or $af		; flag non-zero -> force Create or Error
 8765 260D
 8766 260D              ; *******************************************************************************************************
 8767 260D              ; LOCATE OR CREATE A BASIC VARIABLE
 8768 260D              ; This routine will locate the storage area in memory for an existing BASIC variable,
 8769 260D              ; or will assign a storage area for the specified variable if one does not exist.
 8770 260D              ; On exit, HL will point to the next character following the variable name, and DE will
 8771 260D              ; contain the address of the variable storage area.
 8772 260D              ; NOTE: If the variable name does not contain a type declaration character (I, %, #, or § as
 8773 260D              ; the final character of the variable name), the variable will be set to the precission as defined
 8774 260D              ; by the variable type declaration table (BAS_VarTypesTab).
 8775 260D              ; IN: hl - variable name
 8776 260D              ; OUT: de - variable storage address
 8777 260D              GetVarAddr
 8778 260D AF           	xor a					; 0 -> Locate Variable and Create if not exists		;260d	af 	. .
 8779 260E 32 AE 78     	ld (CreateVarFlag),a	; set flag to create variable if not found			;260e	32 ae 78 	2 . x
 8780 2611              ; -- variable name must be 1 letter ('A'..'Z'), 2 letters or letter+digit
 8781 2611 46           	ld b,(hl)				; first letter of variable name						;2611	46 	F
 8782 2612 CD 3D 1E     	call SysIsLetter		; check if it's letter ('A'..'Z')					;2612	cd 3d 1e 	. = .
 8783 2615 DA 97 19     	jp c,ErrRaiseSyntax		; no - Raise 'SYNTAX ERROR'							;2615	da 97 19 	. . .
 8784 2618              ; -- first char is letter
 8785 2618 AF           	xor a					; 0 for variable with 1 letter name					;2618	af 	.
 8786 2619 4F           	ld c,a					; assumed as 1 letter name							;2619	4f 	O
 8787 261A              ; -- check next char
 8788 261A D7           	rst $10					; move hl to next Basic token - is it digit?		;261a	d7 	.
 8789 261B 38 05        	jr c,.set_bc			; yes - set variable name in register bc            ;261b	38 05 	8 .
 8790 261D              ; -- it is not digit - is this letter?
 8791 261D CD 3D 1E     	call SysIsLetter		; check if it's letter ('A'..'Z')					;261d	cd 3d 1e 	. = .
 8792 2620 38 09        	jr c,.detectVarType		; no - detect variable type							;2620	38 09 	8 .
 8793 2622              .set_bc:
 8794 2622 4F           	ld c,a					; variable name stored in bc register 				;2622	4f 	O
 8795 2623              .next:
 8796 2623              ; -- ignore rest of variable name (obly 2 chars matter)
 8797 2623 D7           	rst $10					; move hl to next Basic token - is it digit?		;2623	d7 	.
 8798 2624 38 FD        	jr c,.next				; yes - skip this char and check next one			;2624	38 fd 	8 .
 8799 2626 CD 3D 1E     	call SysIsLetter		; check if it's letter ('A'..'B')					;2626	cd 3d 1e 	. = .
 8800 2629 30 F8        	jr nc,.next				; yes - skip this char and check next one			;2629	30 f8 	0 .
 8801 262B              .detectVarType:
 8802 262B              ; -- bc contains variable name
 8803 262B 11 52 26     	ld de,l2652h			; address of l2652h routine  						;262b	11 52 26 	. R &
 8804 262E D5           	push de					; push address of l2652h as return point 			;262e	d5 	.
 8805 262F              ; -- test type of variable: is it Integer Type?
 8806 262F 16 02        	ld d,2					; 2 - integer variable								;262f	16 02 	. .
 8807 2631 FE 25        	cp '%'					; is it "integer suffix"?							;2631	fe 25 	. %
 8808 2633 C8           	ret z					; yes - continue - integer type variable			;2633	c8 	.
 8809 2634              ; -- test type of variable: is it String Type?
 8810 2634 14           	inc d					; 3 - string variable								;2634	14 	.
 8811 2635 FE 24        	cp '$'					; is it "string suffix"?							;2635	fe 24 	. $
 8812 2637 C8           	ret z					; yes - continue - string type variable				;2637	c8 	.
 8813 2638              ; -- probably removed code (other variable types?)
 8814 2638 00           	nop																			;2638	00 	.
 8815 2639 00           	nop																			;2639	00 	.
 8816 263A 00           	nop																			;263a	00 	.
 8817 263B 00           	nop																			;263b	00 	.
 8818 263C 00           	nop																			;263c	00 	.
 8819 263D 00           	nop																			;263d	00 	.
 8820 263E 00           	nop																			;263e	00 	.
 8821 263F 00           	nop																			;263f	00 	.
 8822 2640 00           	nop																			;2640	00 	.
 8823 2641              ; -- numeric variable type (without suffix)
 8824 2641 78           	ld a,b				; a - first letter of variable name						;2641	78 	x
 8825 2642 D6 41        	sub 'A'				; shift range from A..Z to 0..26						;2642	d6 41 	. A
 8826 2644 E6 7F        	and $7f				; constrain range to positive number					;2644	e6 7f 	. 
 8827 2646 5F           	ld e,a				; e - variable index (0..26)							;2646	5f 	_
 8828 2647 16 00        	ld d,0				; de - variable index 									;2647	16 00 	. .
 8829 2649 E5           	push hl				; save hl - basic parse point							;2649	e5 	.
 8830 264A 21 01 79     	ld hl,BAS_VarTypesTab	; stored types of variables for 'A'..'Z'			;264a	21 01 79 	! . y
 8831 264D 19           	add hl,de			; address in Variable Types Table						;264d	19 	.
 8832 264E 56           	ld d,(hl)			; d - variable type 									;264e	56 	V
 8833 264F E1           	pop hl				; restore hl 											;264f	e1 	.
 8834 2650 2B           	dec hl				; move back basic parse point							;2650	2b 	+
 8835 2651 C9           	ret					; continue - default type variable						;2651	c9 	.
 8836 2652              l2652h:
 8837 2652              ; IN: d - variable type, bc - variable name
 8838 2652 7A           	ld a,d				; a - variable type										;2652	7a 	z
 8839 2653 32 AF 78     	ld (MATH_NTF),a		; set variable type in Accumulator						;2653	32 af 78 	2 . x
 8840 2656              ; -- test if it is for-next loop index variable
 8841 2656 D7           	rst $10				; move hl to next Basic token							;2656	d7 	.
 8842 2657 3A DC 78     	ld a,(ForNextFlag)	; flag indicating we are parsing for-next loop		;2657	3a dc 78 	: . x
 8843 265A B7           	or a				; is this for-next loop index variable?					;265a	b7 	.
 8844 265B C2 64 26     	jp nz,l2664h		; yes - skip - this variable cannot be array			;265b	c2 64 26 	. d &
 8845 265E              ; -- test if it is indexed array
 8846 265E 7E           	ld a,(hl)			; a - char next to variable name						;265e	7e 	~
 8847 265F D6 28        	sub '('				; is it open bracked? 									;265f	d6 28 	. (
 8848 2661 CA E9 26     	jp z,l26e9h			; yes - ;2661	ca e9 26 	. . &
 8849 2664              l2664h:
 8850 2664 AF           	xor a				; 0 - for-loop flag 									;2664	af 	.
 8851 2665 32 DC 78     	ld (ForNextFlag),a	; clear flag  										;2665	32 dc 78 	2 . x
 8852 2668              ; --
 8853 2668 E5           	push hl				; save hl - basic parse point							;2668	e5 	.
 8854 2669 D5           	push de				; save de - d - variable type, e - variable index (name);2669	d5 	.
 8855 266A 2A F9 78     	ld hl,(PrgEndPtr)	; address where variables are stored (above code)		;266a	2a f9 78 	* . x
 8856 266D              l266dh:
 8857 266D EB           	ex de,hl			; de - address where variables are stored				;266d	eb 	.
 8858 266E 2A FB 78     	ld hl,(ArrStartPtr)	; address where array variables are stored			;266e	2a fb 78 	* . x
 8859 2671 DF           	rst #18				; are both addresses equal? - end of VarTable			;2671	df 	.
 8860 2672 E1           	pop hl				; restore hl - type and index of variable				;2672	e1 	.
 8861 2673 28 19        	jr z,l268eh			; yes - ;2673	28 19 	( .
 8862 2675              ; -- test if variable exists already
 8863 2675 1A           	ld a,(de)			; a - existing variable type 							;2675	1a 	.
 8864 2676 6F           	ld l,a				; set as new type										;2676	6f 	o
 8865 2677 BC           	cp h				; is the same as requested?								;2677	bc 	.
 8866 2678 13           	inc de				; points to next entry in VarTable						;2678	13 	.
 8867 2679 20 0B        	jr nz,.next			;2679	20 0b 	  .
 8868 267B 1A           	ld a,(de)			;267b	1a 	.
 8869 267C B9           	cp c			;267c	b9 	.
 8870 267D 20 07        	jr nz,.next		;267d	20 07 	  .
 8871 267F 13           	inc de			;267f	13 	.
 8872 2680 1A           	ld a,(de)			;2680	1a 	.
 8873 2681 B8           	cp b			;2681	b8 	.
 8874 2682 CA CC 26     	jp z,l26cch		;2682	ca cc 26 	. . &
 8875 2685 3E           	db $3e 			; ld a,013h	used to skip 1st "inc de" 						;2685	3e 13 	> .
 8876 2686              .next
 8877 2686 13           	inc de		;2686	13 	> .
 8878 2687 13           	inc de			;2687	13 	.
 8879 2688 E5           	push hl			;2688	e5 	.
 8880 2689 26 00        	ld h,000h		;2689	26 00 	& .
 8881 268B 19           	add hl,de			;268b	19 	.
 8882 268C 18 DF        	jr l266dh		;268c	18 df 	. .
 8883 268E              l268eh:
 8884 268E 7C           	ld a,h			;268e	7c 	|
 8885 268F E1           	pop hl			;268f	e1 	.
 8886 2690 E3           	ex (sp),hl			;2690	e3 	.
 8887 2691 F5           	push af			;2691	f5 	.
 8888 2692 D5           	push de			;2692	d5 	.
 8889 2693 11 F1 24     	ld de,024f1h		;2693	11 f1 24 	. . $
 8890 2696 DF           	rst #18			; Compare HL and DE ;2696	df 	.
 8891 2697 28 36        	jr z,l26cfh		;2697	28 36 	( 6
 8892 2699 11 43 25     	ld de,l2543h		;2699	11 43 25 	. C %
 8893 269C DF           	rst #18			; Compare HL and DE ;269c	df 	.
 8894 269D D1           	pop de			;269d	d1 	.
 8895 269E 28 35        	jr z,l26d5h		;269e	28 35 	( 5
 8896 26A0 F1           	pop af			;26a0	f1 	.
 8897 26A1 E3           	ex (sp),hl			;26a1	e3 	.
 8898 26A2 E5           	push hl			;26a2	e5 	.
 8899 26A3 C5           	push bc			;26a3	c5 	.
 8900 26A4 4F           	ld c,a			;26a4	4f 	O
 8901 26A5 06 00        	ld b,000h		;26a5	06 00 	. .
 8902 26A7 C5           	push bc			;26a7	c5 	.
 8903 26A8 03           	inc bc			;26a8	03 	.
 8904 26A9 03           	inc bc			;26a9	03 	.
 8905 26AA 03           	inc bc			;26aa	03 	.
 8906 26AB 2A FD 78     	ld hl,(ArrEndPtr)	; address of End of Basic Array area		;26ab	2a fd 78 	* . x
 8907 26AE E5           	push hl			;26ae	e5 	.
 8908 26AF 09           	add hl,bc			;26af	09 	.
 8909 26B0 C1           	pop bc			;26b0	c1 	.
 8910 26B1 E5           	push hl			;26b1	e5 	.
 8911 26B2 CD 55 19     	call sub_1955h		;26b2	cd 55 19 	. U .
 8912 26B5 E1           	pop hl			;26b5	e1 	.
 8913 26B6 22 FD 78     	ld (ArrEndPtr),hl	; address of End of Basic Array area		;26b6	22 fd 78 	" . x
 8914 26B9 60           	ld h,b			;26b9	60 	`
 8915 26BA 69           	ld l,c			;26ba	69 	i
 8916 26BB 22 FB 78     	ld (ArrStartPtr),hl	; address of Start of Basic Array area			;26bb	22 fb 78 	" . x
 8917 26BE              l26beh:
 8918 26BE 2B           	dec hl			;26be	2b 	+
 8919 26BF 36 00        	ld (hl),000h		;26bf	36 00 	6 .
 8920 26C1 DF           	rst #18			; Compare HL and DE ;26c1	df 	.
 8921 26C2 20 FA        	jr nz,l26beh		;26c2	20 fa 	  .
 8922 26C4 D1           	pop de			;26c4	d1 	.
 8923 26C5 73           	ld (hl),e			;26c5	73 	s
 8924 26C6 23           	inc hl			;26c6	23 	#
 8925 26C7 D1           	pop de			;26c7	d1 	.
 8926 26C8 73           	ld (hl),e			;26c8	73 	s
 8927 26C9 23           	inc hl			;26c9	23 	#
 8928 26CA 72           	ld (hl),d			;26ca	72 	r
 8929 26CB EB           	ex de,hl			;26cb	eb 	.
 8930 26CC              l26cch:
 8931 26CC 13           	inc de			;26cc	13 	.
 8932 26CD E1           	pop hl			;26cd	e1 	.
 8933 26CE C9           	ret			;26ce	c9 	.
 8934 26CF              l26cfh:
 8935 26CF 57           	ld d,a			;26cf	57 	W
 8936 26D0 5F           	ld e,a			;26d0	5f 	_
 8937 26D1 F1           	pop af			;26d1	f1 	.
 8938 26D2 F1           	pop af			;26d2	f1 	.
 8939 26D3 E3           	ex (sp),hl			;26d3	e3 	.
 8940 26D4 C9           	ret			;26d4	c9 	.
 8941 26D5              l26d5h:
 8942 26D5 32 24 79     	ld (MATH_ACC_EXP),a		;26d5	32 24 79 	2 $ y
 8943 26D8 C1           	pop bc			;26d8	c1 	.
 8944 26D9 67           	ld h,a			;26d9	67 	g
 8945 26DA 6F           	ld l,a			;26da	6f 	o
 8946 26DB 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;26db	22 21 79 	" ! y
 8947 26DE E7           	rst #20			; test NTF (Number Type Format) ;26de	e7 	.
 8948 26DF 20 06        	jr nz,l26e7h	; Number (not String) - 	;26df	20 06 	  .
 8949 26E1              ; -- String
 8950 26E1 21 28 19     	ld hl,TXT_EMPTY	; points to char '\0' - end of string		;26e1	21 28 19 	! ( .
 8951 26E4 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;26e4	22 21 79 	" ! y
 8952 26E7              l26e7h:
 8953 26E7 E1           	pop hl			;26e7	e1 	.
 8954 26E8 C9           	ret			;26e8	c9 	.
 8955 26E9              l26e9h:
 8956 26E9              ; -- variable is array
 8957 26E9 E5           	push hl			;26e9	e5 	.
 8958 26EA 2A AE 78     	ld hl,(CreateVarFlag)		;26ea	2a ae 78 	* . x
 8959 26ED E3           	ex (sp),hl			;26ed	e3 	.
 8960 26EE 57           	ld d,a			;26ee	57 	W
 8961 26EF              l26efh:
 8962 26EF D5           	push de			;26ef	d5 	.
 8963 26F0 C5           	push bc			;26f0	c5 	.
 8964 26F1 CD 45 1E     	call sub_1e45h		;26f1	cd 45 1e 	. E .
 8965 26F4 C1           	pop bc			;26f4	c1 	.
 8966 26F5 F1           	pop af			;26f5	f1 	.
 8967 26F6 EB           	ex de,hl			;26f6	eb 	.
 8968 26F7 E3           	ex (sp),hl			;26f7	e3 	.
 8969 26F8 E5           	push hl			;26f8	e5 	.
 8970 26F9 EB           	ex de,hl			;26f9	eb 	.
 8971 26FA 3C           	inc a			;26fa	3c 	<
 8972 26FB 57           	ld d,a			;26fb	57 	W
 8973 26FC 7E           	ld a,(hl)			;26fc	7e 	~
 8974 26FD FE 2C        	cp 02ch		;26fd	fe 2c 	. ,
 8975 26FF 28 EE        	jr z,l26efh		;26ff	28 ee 	( .
 8976 2701 CF           	rst $08			; Assert next token is ')' ;2701	cf 	.
 8977 2702 29           	defb ')'		; Basic ')' token 	;2702	29 	)
 8978 2703 22 F3 78     	ld (BAS_ExprTmpPtr),hl	; [TRS] expression parser current position		;2703	22 f3 78 	" . x
 8979 2706 E1           	pop hl			;2706	e1 	.
 8980 2707 22 AE 78     	ld (CreateVarFlag),hl		;2707	22 ae 78 	" . x
 8981 270A D5           	push de			;270a	d5 	.
 8982 270B 2A FB 78     	ld hl,(ArrStartPtr)	; address of Start of Basic Array area			;270b	2a fb 78 	* . x
 8983 270E 3E 19        	ld a,019h		;270e	3e 19 	> .
 8984 2710              l2710h:
 8985 2710 EB           	ex de,hl			;2710	eb 	.
 8986 2711 2A FD 78     	ld hl,(ArrEndPtr)	; address of End of Basic Array area		;2711	2a fd 78 	* . x
 8987 2714 EB           	ex de,hl			;2714	eb 	.
 8988 2715 DF           	rst #18			; Compare HL and DE ;2715	df 	.
 8989 2716 3A AF 78     	ld a,(MATH_NTF)		;2716	3a af 78 	: . x
 8990 2719 28 27        	jr z,l2742h		;2719	28 27 	( '
 8991 271B BE           	cp (hl)			;271b	be 	.
 8992 271C 23           	inc hl			;271c	23 	#
 8993 271D 20 08        	jr nz,$+10		;271d	20 08 	  .
 8994 271F 7E           	ld a,(hl)			;271f	7e 	~
 8995 2720 B9           	cp c			;2720	b9 	.
 8996 2721 23           	inc hl			;2721	23 	#
 8997 2722 20 04        	jr nz,l2728h		;2722	20 04 	  .
 8998 2724 7E           	ld a,(hl)			;2724	7e 	~
 8999 2725 B8           	cp b			;2725	b8 	.
 9000 2726 3E 23        	ld a,023h		;2726	3e 23 	> #
 9001 2728              l2728h:
 9002 2728 23           	inc hl			;2728	23 	#
 9003 2729 5E           	ld e,(hl)			;2729	5e 	^
 9004 272A 23           	inc hl			;272a	23 	#
 9005 272B 56           	ld d,(hl)			;272b	56 	V
 9006 272C 23           	inc hl			;272c	23 	#
 9007 272D 20 E0        	jr nz,$-30		;272d	20 e0 	  .
 9008 272F 3A AE 78     	ld a,(CreateVarFlag) ; Flag is used by BASIC locate or Create Variable routine.		;272f	3a ae 78 	: . x
 9009 2732 B7           	or a			        ; raise errir if Array not exists? ;2732	b7 	.
 9010 2733 1E 12        	ld e,#12				; ERROR 12 - REDIM'D ARRAY		;2733	1e 12 	. .
 9011 2735 C2 A2 19     	jp nz,ErrRaiseError	    ; yes - Raise REDIM'D ARRAY error 	;2735	c2 a2 19 	. . .
 9012 2738 F1           	pop af			;2738	f1 	.
 9013 2739 96           	sub (hl)			;2739	96 	.
 9014 273A CA 95 27     	jp z,l2795h		;273a	ca 95 27 	. . '
 9015 273D
 9016 273D
 9017 273D
 9018 273D              ErrRaiseBadSubscript:
 9019 273D 1E 10        	ld e,#10			; ERROR number 10 - BAD SUBSCRIPT						;273d	1e 10 	. .
 9020 273F C3 A2 19     	jp ErrRaiseError	; Raise Error											;273f	c3 a2 19 	. . .
 9021 2742
 9022 2742
 9023 2742
 9024 2742              l2742h:
 9025 2742 77           	ld (hl),a			;2742	77 	w
 9026 2743 23           	inc hl			;2743	23 	#
 9027 2744 5F           	ld e,a			;2744	5f 	_
 9028 2745 16 00        	ld d,000h		;2745	16 00 	. .
 9029 2747 F1           	pop af			;2747	f1 	.
 9030 2748 71           	ld (hl),c			;2748	71 	q
 9031 2749 23           	inc hl			;2749	23 	#
 9032 274A 70           	ld (hl),b			;274a	70 	p
 9033 274B 23           	inc hl			;274b	23 	#
 9034 274C 4F           	ld c,a			;274c	4f 	O
 9035 274D CD 63 19     	call sub_1963h		;274d	cd 63 19 	. c .
 9036 2750 23           	inc hl			;2750	23 	#
 9037 2751 23           	inc hl			;2751	23 	#
 9038 2752 22 D8 78     	ld (BAS_TempPtr),hl	; temporary pointer	;2752	22 d8 78 	" . x
 9039 2755 71           	ld (hl),c			;2755	71 	q
 9040 2756 23           	inc hl			;2756	23 	#
 9041 2757 3A AE 78     	ld a,(CreateVarFlag)		;2757	3a ae 78 	: . x
 9042 275A 17           	rla			;275a	17 	.
 9043 275B 79           	ld a,c			;275b	79 	y
 9044 275C              l275ch:
 9045 275C 01 0B 00     	ld bc,11		;275c	01 0b 00 	. . .
 9046 275F 30 02        	jr nc,l2763h		;275f	30 02 	0 .
 9047 2761 C1           	pop bc			;2761	c1 	.
 9048 2762 03           	inc bc			;2762	03 	.
 9049 2763              l2763h:
 9050 2763 71           	ld (hl),c			;2763	71 	q
 9051 2764 23           	inc hl			;2764	23 	#
 9052 2765 70           	ld (hl),b			;2765	70 	p
 9053 2766 23           	inc hl			;2766	23 	#
 9054 2767 F5           	push af			;2767	f5 	.
 9055 2768 CD AA 0B     	call MAT_iMul_BC_DE	; DE = BC * DE (Unsigned Integer)	;2768	cd aa 0b 	. . .
 9056 276B F1           	pop af			;276b	f1 	.
 9057 276C 3D           	dec a			;276c	3d 	=
 9058 276D 20 ED        	jr nz,l275ch		;276d	20 ed 	  .
 9059 276F F5           	push af			;276f	f5 	.
 9060 2770 42           	ld b,d			;2770	42 	B
 9061 2771 4B           	ld c,e			;2771	4b 	K
 9062 2772 EB           	ex de,hl			;2772	eb 	.
 9063 2773 19           	add hl,de			;2773	19 	.
 9064 2774 38 C7        	jr c,ErrRaiseBadSubscript	; raise BAD SUBSCRIPT ERROR	;2774	38 c7 	8 .
 9065 2776 CD 6C 19     	call 0196ch		;2776	cd 6c 19 	. l .
 9066 2779 22 FD 78     	ld (ArrEndPtr),hl	; address of End of Basic Array area		;2779	22 fd 78 	" . x
 9067 277C              l277ch:
 9068 277C 2B           	dec hl			;277c	2b 	+
 9069 277D 36 00        	ld (hl),000h		;277d	36 00 	6 .
 9070 277F DF           	rst #18			; Compare HL and DE ;277f	df 	.
 9071 2780 20 FA        	jr nz,l277ch		;2780	20 fa 	  .
 9072 2782 03           	inc bc			;2782	03 	.
 9073 2783 57           	ld d,a			;2783	57 	W
 9074 2784 2A D8 78     	ld hl,(BAS_TempPtr)	; temporary pointer	;2784	2a d8 78 	* . x
 9075 2787 5E           	ld e,(hl)			;2787	5e 	^
 9076 2788 EB           	ex de,hl			;2788	eb 	.
 9077 2789 29           	add hl,hl			;2789	29 	)
 9078 278A 09           	add hl,bc			;278a	09 	.
 9079 278B EB           	ex de,hl			;278b	eb 	.
 9080 278C 2B           	dec hl			;278c	2b 	+
 9081 278D 2B           	dec hl			;278d	2b 	+
 9082 278E 73           	ld (hl),e			;278e	73 	s
 9083 278F 23           	inc hl			;278f	23 	#
 9084 2790 72           	ld (hl),d			;2790	72 	r
 9085 2791 23           	inc hl			;2791	23 	#
 9086 2792 F1           	pop af			;2792	f1 	.
 9087 2793 38 30        	jr c,l27c5h		;2793	38 30 	8 0
 9088 2795              l2795h:
 9089 2795 47           	ld b,a			;2795	47 	G
 9090 2796 4F           	ld c,a			;2796	4f 	O
 9091 2797 7E           	ld a,(hl)			;2797	7e 	~
 9092 2798 23           	inc hl			;2798	23 	#
 9093 2799 16 E1        	ld d,0e1h		;2799	16 e1 	. .
 9094 279B 5E           	ld e,(hl)			;279b	5e 	^
 9095 279C 23           	inc hl			;279c	23 	#
 9096 279D 56           	ld d,(hl)			;279d	56 	V
 9097 279E 23           	inc hl			;279e	23 	#
 9098 279F E3           	ex (sp),hl			;279f	e3 	.
 9099 27A0 F5           	push af			;27a0	f5 	.
 9100 27A1 DF           	rst #18			; Compare HL and DE ;27a1	df 	.
 9101 27A2 D2 3D 27     	jp nc,ErrRaiseBadSubscript	; raise BAD SUBSCRIPT ERROR		;27a2	d2 3d 27 	. = '
 9102 27A5 CD AA 0B     	call MAT_iMul_BC_DE	; DE = BC * DE (Unsigned Integer)	;27a5	cd aa 0b 	. . .
 9103 27A8 19           	add hl,de			;27a8	19 	.
 9104 27A9 F1           	pop af			;27a9	f1 	.
 9105 27AA 3D           	dec a			;27aa	3d 	=
 9106 27AB 44           	ld b,h			;27ab	44 	D
 9107 27AC 4D           	ld c,l			;27ac	4d 	M
 9108 27AD 20 EB        	jr nz,$-19		;27ad	20 eb 	  .
 9109 27AF 3A AF 78     	ld a,(MATH_NTF)		;27af	3a af 78 	: . x
 9110 27B2 44           	ld b,h			;27b2	44 	D
 9111 27B3 4D           	ld c,l			;27b3	4d 	M
 9112 27B4 29           	add hl,hl			;27b4	29 	)
 9113 27B5 D6 04        	sub 004h		;27b5	d6 04 	. .
 9114 27B7 38 04        	jr c,l27bdh		;27b7	38 04 	8 .
 9115 27B9 29           	add hl,hl			;27b9	29 	)
 9116 27BA 28 06        	jr z,l27c2h		;27ba	28 06 	( .
 9117 27BC 29           	add hl,hl			;27bc	29 	)
 9118 27BD              l27bdh:
 9119 27BD B7           	or a			;27bd	b7 	.
 9120 27BE E2 C2 27     	jp po,l27c2h		;27be	e2 c2 27 	. . '
 9121 27C1 09           	add hl,bc			;27c1	09 	.
 9122 27C2              l27c2h:
 9123 27C2 C1           	pop bc			;27c2	c1 	.
 9124 27C3 09           	add hl,bc			;27c3	09 	.
 9125 27C4 EB           	ex de,hl			;27c4	eb 	.
 9126 27C5              l27c5h:
 9127 27C5 2A F3 78     	ld hl,(BAS_ExprTmpPtr)	; [TRS] expression parser current position		;27c5	2a f3 78 	* . x
 9128 27C8 C9           	ret			;27c8	c9 	.
 9129 27C9
 9130 27C9
 9131 27C9              l27c9h:
 9132 27C9 AF           	xor a			;27c9	af 	.
 9133 27CA E5           	push hl			;27ca	e5 	.
 9134 27CB 32 AF 78     	ld (MATH_NTF),a		;27cb	32 af 78 	2 . x
 9135 27CE CD D4 27     	call FuncFRE	; get amount free memory into ACC	;27ce	cd d4 27 	. . '
 9136 27D1 E1           	pop hl			;27d1	e1 	.
 9137 27D2 D7           	rst $10			; move hl to next Basic token				;27d2	d7 	.
 9138 27D3 C9           	ret			;27d3	c9 	.
 9139 27D4
 9140 27D4              ; ********************************************************************************
 9141 27D4              ; [TRS] BASIC FRE Entry Point
 9142 27D4              ; GET AMOUNT OF FREE MEMORY TO ACCUM
 9143 27D4              ; On entry, the NTF must NOT be set to 3 (string), but it may be set
 9144 27D4              ; to any other precision or may contain zero.
 9145 27D4              ; On exit, the number of bytes of remaining free memory will be stored in ACC,
 9146 27D4              ; in single-precision format (NTF=4).
 9147 27D4              FuncFRE:
 9148 27D4 2A FD 78     	ld hl,(ArrEndPtr)	; address of End of Basic Array area		;27d4	2a fd 78 	* . x
 9149 27D7 EB           	ex de,hl			;27d7	eb 	.
 9150 27D8 21 00 00     	ld hl,$0000		;27d8	21 00 00 	! . .
 9151 27DB 39           	add hl,sp			;27db	39 	9
 9152 27DC E7           	rst #20				; test NTF (Number Type Format) ;27dc	e7 	.
 9153 27DD 20 0D        	jr nz,l27ech		; Number (not String) ;27dd	20 0d 	  .
 9154 27DF
 9155 27DF              ; ********************************************************************************
 9156 27DF              ; FRE(x$) Get number of bytes free string space to ACC.
 9157 27DF              ; OUT: ACC - number of bytes of free string space remaining in the string storage area. (Single)
 9158 27DF CD DA 29     	call sub_29dah		;27df	cd da 29 	. . )
 9159 27E2 CD E6 28     	call sub_28e6h		;27e2	cd e6 28 	. . (
 9160 27E5 2A A0 78     	ld hl,(STACKTOPPTR)	; top of Basic Stack Pointer	;27e5	2a a0 78 	* . x
 9161 27E8 EB           	ex de,hl			;27e8	eb 	.
 9162 27E9 2A D6 78     	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;27e9	2a d6 78 	* . x
 9163 27EC              l27ech:
 9164 27EC 7D           	ld a,l			;27ec	7d 	}
 9165 27ED 93           	sub e			;27ed	93 	.
 9166 27EE 6F           	ld l,a			;27ee	6f 	o
 9167 27EF 7C           	ld a,h			;27ef	7c 	|
 9168 27F0 9A           	sbc a,d			;27f0	9a 	.
 9169 27F1 67           	ld h,a			;27f1	67 	g
 9170 27F2 C3 66 0C     	jp sub_0c66h		;27f2	c3 66 0c 	. f .
 9171 27F5
 9172 27F5              ; ********************************************************************************
 9173 27F5              ; [TRS] BASIC POS Entry Point
 9174 27F5              ; Gets the position of the cursor on the current line being output to video
 9175 27F5              ; from location 78A6 (value will be in range 0 - 63), and stores in the ACC
 9176 27F5              ; in integer format (NTF=2).
 9177 27F5              FuncPOS:
 9178 27F5 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line	;27f5	3a a6 78 	: . x
 9179 27F8              ByteToAcc:
 9180 27F8 6F           	ld l,a			;27f8	6f 	o
 9181 27F9 AF           	xor a			;27f9	af 	.
 9182 27FA              l27fah:
 9183 27FA 67           	ld h,a			;27fa	67 	g
 9184 27FB C3 9A 0A     	jp ACCfromHLValue	; copy value from hl to ACC as integer number		;27fb	c3 9a 0a 	. . .
 9185 27FE
 9186 27FE              ; ********************************************************************************
 9187 27FE              ; BASIC USR
 9188 27FE              ; Argument can be numeric (any precision) or string,, and that the result
 9189 27FE              ; of the evaluated expression will be stored in the ACC, with the NTF set appropriately.
 9190 27FE              ;
 9191 27FE              l27feh:
 9192 27FE CD A9 79     	call SysExtUsr		;27fe	cd a9 79 	. . y
 9193 2801 D7           	rst $10				; move hl to next Basic token				;2801	d7 	.
 9194 2802 CD 2C 25     	call EvalSubExpression	; evaluate expression (assert it starts with '(' and ends with ')'	;2802	cd 2c 25 	. , %
 9195 2805 E5           	push hl			;2805	e5 	.
 9196 2806 21 90 08     	ld hl,l0890h		;2806	21 90 08 	! . .
 9197 2809 E5           	push hl			;2809	e5 	.
 9198 280A 3A AF 78     	ld a,(MATH_NTF)		;280a	3a af 78 	: . x
 9199 280D F5           	push af			;280d	f5 	.
 9200 280E FE 03        	cp 003h		;280e	fe 03 	. .
 9201 2810 CC DA 29     	call z,sub_29dah		;2810	cc da 29 	. . )
 9202 2813 F1           	pop af			;2813	f1 	.
 9203 2814 EB           	ex de,hl			;2814	eb 	.
 9204 2815 2A 8E 78     	ld hl,(BAS_UsrVector)	; BASIC USR routine pointer	;2815	2a 8e 78 	* . x
 9205 2818 E9           	jp (hl)			;2818	e9 	.
 9206 2819              sub_2819h:
 9207 2819 E5           	push hl			;2819	e5 	.
 9208 281A E6 07        	and $07			; a - values in range 0..7			;281a	e6 07 	. .
 9209 281C 21 A1 18     	ld hl,l18a1h	; jump table	;281c	21 a1 18 	! . .
 9210 281F 4F           	ld c,a			;    ;281f	4f 	O
 9211 2820 06 00        	ld b,0			; bc - index of entry ;2820	06 00 	. .
 9212 2822 09           	add hl,bc		; add offset once (second time will be added in JmpHLPlusBC)	;2822	09 	.
 9213 2823 CD 86 25     	call SysJmpHLPlusBC		;2823	cd 86 25 	. . %
 9214 2826 E1           	pop hl			;2826	e1 	.
 9215 2827 C9           	ret			;2827	c9 	.
 9216 2828
 9217 2828              ; *****************************************************************************************
 9218 2828              ; CHECK FOR ILLEGAL DIRECT ERROR
 9219 2828              ; Checks the current BASIC line number (stored at 78A2-78A3) for a value of FFFF,
 9220 2828              ; which indicates that commands are being executed from the direct mode (and BASIC statements
 9221 2828              ; currently being executed are stored in the BASIC input buffer, so it is not available
 9222 2828              ; to receive input). If this is the case an Illegal Direct error exists, otherwise
 9223 2828              ; returns to caller
 9224 2828              sub_2828h:
 9225 2828 E5           	push hl					; save hl													;2828	e5 	.
 9226 2829 2A A2 78     	ld hl,(BasicLineNo)	    ; hl - current BASIC line number or $ffff in direct mode		;2829	2a a2 78 	* . x
 9227 282C 23           	inc hl					; hl - 0 if current line is -1 ($ffff)						;282c	23 	#
 9228 282D 7C           	ld a,h					; a - high byte to check									;282d	7c 	|
 9229 282E B5           	or l					; is hl == 0 (line number -1)								;282e	b5 	.
 9230 282F E1           	pop hl					; restore hl before return									;282f	e1 	.
 9231 2830 C0           	ret nz					; no - return with no error 								;2830	c0 	.
 9232 2831 1E 16        	ld e,#16				; ERROR 16 - ILLEGAL DIRECT									;2831	1e 16 	. .
 9233 2833 C3 A2 19     	jp ErrRaiseError		; Raise Error												;2833	c3 a2 19 	. . .
 9234 2836
 9235 2836
 9236 2836
 9237 2836              ; ********************************************************************************
 9238 2836              ; BASIC STR$ Entry Point
 9239 2836              ; Convert number in ACC to string.
 9240 2836              ; IN: ACC - number to be converted to a string (with the NTF set appropriately).
 9241 2836              ;     STACK - <return address> <HL> <BC>
 9242 2836              ; OUT: ACC - result string
 9243 2836              FuncSTRS:
 9244 2836 CD BD 0F     	call NumToStr	; Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)		;2836	cd bd 0f 	. . .
 9245 2839 CD 65 28     	call strACCfromCStr	; create Basic string in ACC from null terminated str (hl)	;2839	cd 65 28 	. e (
 9246 283C CD DA 29     	call sub_29dah		;283c	cd da 29 	. . )
 9247 283F 01 2B 2A     	ld bc,l2a2bh		;283f	01 2b 2a 	. + *
 9248 2842 C5           	push bc			;2842	c5 	.
 9249 2843              sub_2843h:
 9250 2843 7E           	ld a,(hl)			;2843	7e 	~
 9251 2844 23           	inc hl			;2844	23 	#
 9252 2845 E5           	push hl			;2845	e5 	.
 9253 2846 CD BF 28     	call StrAlloc		;2846	cd bf 28 	. . (
 9254 2849 E1           	pop hl			;2849	e1 	.
 9255 284A 4E           	ld c,(hl)			;284a	4e 	N
 9256 284B 23           	inc hl			;284b	23 	#
 9257 284C 46           	ld b,(hl)			;284c	46 	F
 9258 284D CD 5A 28     	call StrFromADE	; store new string in StringVector variable	;284d	cd 5a 28 	. Z (
 9259 2850 E5           	push hl			;2850	e5 	.
 9260 2851 6F           	ld l,a			    ; length of string ;2851	6f 	o
 9261 2852 CD CE 29     	call StrCopy; Copy l bytes from (BC) to (DE)	;2852	cd ce 29 	. . )
 9262 2855 D1           	pop de			;2855	d1 	.
 9263 2856 C9           	ret			;2856	c9 	.
 9264 2857
 9265 2857              ; ************************************************************************************
 9266 2857              ; Allocate string and Create String Vector for new string.
 9267 2857              ; IN: a - number of bytes to reserve
 9268 2857              ; OUT: de - address of reserved space
 9269 2857              ;      BAS_StrFreePtr - equal to DE minus one (next usable string space location).
 9270 2857              ; 	   BAS_CurStrVec  - string vector
 9271 2857              ;      hl - varptr of new string (equal to BAS_StrFreePtr)
 9272 2857              StrNew:
 9273 2857 CD BF 28     	call StrAlloc		;2857	cd bf 28 	. . (
 9274 285A
 9275 285A              ;**************************************************************************
 9276 285A              ; Store String attributes in StringVector variable
 9277 285A              ; IN: a - length of Basic String
 9278 285A              ;     de - address of text
 9279 285A              StrFromADE:
 9280 285A 21 D3 78     	ld hl,StrVecBuf 	; Basic String Vector address   	            ;285a	21 d3 78 	! . x
 9281 285D E5           	push hl			    ; save hl                                       ;285d	e5 	.
 9282 285E 77           	ld (hl),a			; store String Length                           ;285e	77 	w
 9283 285F 23           	inc hl			    ; points to String Data member                  ;285f	23 	#
 9284 2860 73           	ld (hl),e			; store Low byte of String Data address         ;2860	73 	s
 9285 2861 23           	inc hl			    ; points to MSB of String Data member           ;2861	23 	#
 9286 2862 72           	ld (hl),d			; store High byte of String Data address        ;2862	72 	r
 9287 2863 E1           	pop hl			    ; restore hl - Basic String Vector              ;2863	e1 	.
 9288 2864 C9           	ret			        ; ---------- End of Proc ---------------------- ;2864	c9 	.
 9289 2865
 9290 2865
 9291 2865              ; ******************************************************************************************
 9292 2865              ; CREATE A STRING VECTOR
 9293 2865              ; This routine will create a string vector for any string stored in memory.
 9294 2865              ; IN: hl - null terminated (or quoted with char '"') string
 9295 2865              ; OUT: ACC - varptr of the string
 9296 2865              strACCfromCStr:
 9297 2865 2B           	dec hl			; points to byte before text start (loop starts with inc hl) 		;2865	2b 	+
 9298 2866              BAS_MakeStrVecHL:
 9299 2866              ; -- prepeare delimiters
 9300 2866 06 22        	ld b,'"'		; b - start delimiter '"'											;2866	06 22 	. "
 9301 2868 50           	ld d,b			; d - end delimiter '"'												;2868	50 	P
 9302 2869
 9303 2869              ; IN: hl - address 1 byte before 1st char of string
 9304 2869              ;     b - start delimiter
 9305 2869              ;     d - end delimiter
 9306 2869              BAS_MakeStrVecDelim:
 9307 2869 E5           	push hl			; save hl - (1 byte before current char)							;2869	e5 	.
 9308 286A 0E FF        	ld c,-1			; char in text index (1 position before current char)				;286a	0e ff 	. .
 9309 286C              ; -- find end of string
 9310 286C              l286ch:
 9311 286C 23           	inc hl			; point to current char												;286c	23 	#
 9312 286D 7E           	ld a,(hl)		; a - char to display												;286d	7e 	~
 9313 286E 0C           	inc c			; index of char in string											;286e	0c 	.
 9314 286F B7           	or a			; is end of string (0 terminator)									;286f	b7 	.
 9315 2870 28 06        	jr z,l2878h		; yes - ;2870	28 06 	( .
 9316 2872 BA           	cp d			; is this end delimiter ('"' or other provided)						;2872	ba 	.
 9317 2873 28 03        	jr z,l2878h		; yes - ;2873	28 03 	( .
 9318 2875 B8           	cp b			; is this start delimiter ('"' or other provided)					;2875	b8 	.
 9319 2876 20 F4        	jr nz,l286ch	; no - continue next char until any delimiter found					;2876	20 f4 	  .
 9320 2878              l2878h:
 9321 2878 FE 22        	cp '"'			; check if this char is quote '"' 									;2878	fe 22 	. "
 9322 287A CC 78 1D     	call z,NextToken; yes -	move hl to next Basic token ;287a	cc 78 1d 	. x .
 9323 287D E3           	ex (sp),hl			;287d	e3 	.
 9324 287E 23           	inc hl			; skip '"' char ;287e	23 	#
 9325 287F EB           	ex de,hl		; de - address of text 	;287f	eb 	.
 9326 2880 79           	ld a,c			; a - length of text ;2880	79 	y
 9327 2881 CD 5A 28     	call StrFromADE	; store new string in StringVector variable		;2881	cd 5a 28 	. Z (
 9328 2884              l2884h:
 9329 2884 11 D3 78     	ld de,StrVecBuf 		;2884	11 d3 78 	. . x
 9330 2887 3E D5        	ld a,0d5h		;2887	3e d5 	> .
 9331 2889 2A B3 78     	ld hl,(BAS_StrNextVar)	; next location in literal string pool	;2889	2a b3 78 	* . x
 9332 288C 22 21 79     	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;288c	22 21 79 	" ! y
 9333 288F 3E 03        	ld a,3			; variable type String ;288f	3e 03 	> .
 9334 2891 32 AF 78     	ld (MATH_NTF),a		;2891	32 af 78 	2 . x
 9335 2894 CD D3 09     	call DEMemToHLMem	; copy math variable from (de) to (hl) mem			;2894	cd d3 09 	. . .
 9336 2897 11 D6 78     	ld de,BAS_StrFreePtr	; Pointer to next free byte in string storage area	;2897	11 d6 78 	. . x
 9337 289A DF           	rst #18			; Compare HL and DE ;289a	df 	.
 9338 289B 22 B3 78     	ld (BAS_StrNextVar),hl	; set as next location in literal string pool	;289b	22 b3 78 	" . x
 9339 289E E1           	pop hl			;289e	e1 	.
 9340 289F 7E           	ld a,(hl)			;289f	7e 	~
 9341 28A0 C0           	ret nz			;28a0	c0 	.
 9342 28A1 1E 1E        	ld e,#1e			; ERROR 1E - FORMULA TOO COMPLEX		;28a1	1e 1e 	. .
 9343 28A3 C3 A2 19     	jp ErrRaiseError	; Raise Error							;28a3	c3 a2 19 	. . .
 9344 28A6              BAS_SendStringInc:
 9345 28A6 23           	inc hl			;28a6	23 	#
 9346 28A7
 9347 28A7              ; **********************************************************************************
 9348 28A7              ; Essentially the same effect as the routine at 2b75 (described below), except
 9349 28A7              ; that text may also end with a quotation mark ($22), creates string vector
 9350 28A7              ; before output (destroys current contents of ACCOM, sets NTF to 3,
 9351 28A7              ; and also uses BC & DE registers. Depends heavily on BASIC string management routines
 9352 28A7              ; (use of 2b75 or other routines may be preferable).
 9353 28A7              ; If string contains a carriage return (Od) character, a CALL will be made
 9354 28A7              ; to the Disk BASIC link at 79d0. Used by BASIC PRINT statement.
 9355 28A7              ; This routine may also be entered at 28a6, in which case the HL register pair
 9356 28A7              ; will be incremented prior to beginning to output string.
 9357 28A7              ; IN: hl - zero terminated or quoted string to send to Current Out Device
 9358 28A7              PrintBasicStr:
 9359 28A7 CD 65 28     	call strACCfromCStr	; ACC = null terminated or quoted string from (hl)		;28a7	cd 65 28 	. e (
 9360 28AA              ; IN: ACC - basic String structure (addres + length)
 9361 28AA              PrintACCStr:
 9362 28AA CD DA 29     	call sub_29dah		;28aa	cd da 29 	. . )
 9363 28AD CD C4 09     	call HLToBCD		; Copy 3 bytes from (HL) to BCD		;28ad	cd c4 09 	. . .
 9364 28B0 14           	inc d			;28b0	14 	.
 9365 28B1              l28b1h:
 9366 28B1 15           	dec d			;28b1	15 	.
 9367 28B2 C8           	ret z			;28b2	c8 	.
 9368 28B3 0A           	ld a,(bc)			;28b3	0a 	.
 9369 28B4 CD 2A 03     	call PrintChar	; Print char on screen		;28b4	cd 2a 03 	. * .
 9370 28B7 FE 0D        	cp $0d		    ; was it CR char ? ;28b7	fe 0d 	. .
 9371 28B9 CC 03 21     	call z,sub_2103h; yes - 		;28b9	cc 03 21 	. . !
 9372 28BC 03           	inc bc			;28bc	03 	.
 9373 28BD 18 F2        	jr l28b1h		;28bd	18 f2 	. .
 9374 28BF
 9375 28BF              ; ******************************************************************************************
 9376 28BF              ; MAKE ROOM FOR A STRING IN STRING STORAGE AREA.
 9377 28BF              ; This routine will make room for a string in the string storage area if possible
 9378 28BF              ; or raise Out of String space Error if not possible.
 9379 28BF              ; IN: a - number of bytes to reserve
 9380 28BF              ; OUT: de - address of reserved space
 9381 28BF              ;      BAS_StrFreePtr - equal to DE minus one (next usable string space location).
 9382 28BF              StrAlloc:
 9383 28BF B7           	or a			;28bf	b7 	.
 9384 28C0 0E F1        	ld c,0f1h		;28c0	0e f1 	. .
 9385 28C2 F5           	push af			;28c2	f5 	.
 9386 28C3 2A A0 78     	ld hl,(STACKTOPPTR)	; top of Basic Stack Pointer		;28c3	2a a0 78 	* . x
 9387 28C6 EB           	ex de,hl			;28c6	eb 	.
 9388 28C7 2A D6 78     	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;28c7	2a d6 78 	* . x
 9389 28CA 2F           	cpl			;28ca	2f 	/
 9390 28CB 4F           	ld c,a			;28cb	4f 	O
 9391 28CC 06 FF        	ld b,0ffh		;28cc	06 ff 	. .
 9392 28CE 09           	add hl,bc			;28ce	09 	.
 9393 28CF 23           	inc hl			;28cf	23 	#
 9394 28D0 DF           	rst #18			; Compare HL and DE ;28d0	df 	.
 9395 28D1 38 07        	jr c,l28dah		;28d1	38 07 	8 .
 9396 28D3 22 D6 78     	ld (BAS_StrFreePtr),hl	; set as pointer to next free byte in string storage area	;28d3	22 d6 78 	" . x
 9397 28D6 23           	inc hl			;28d6	23 	#
 9398 28D7 EB           	ex de,hl			;28d7	eb 	.
 9399 28D8              l28d8h:
 9400 28D8 F1           	pop af			;28d8	f1 	.
 9401 28D9 C9           	ret			;28d9	c9 	.
 9402 28DA              l28dah:
 9403 28DA F1           	pop af			;28da	f1 	.
 9404 28DB 1E 1A        	ld e,#1a			; ERROR 1A - OUT OF SPACE		;28db	1e 1a 	. .
 9405 28DD CA A2 19     	jp z,ErrRaiseError	; Raise Error if 	;28dd	ca a2 19 	. . .
 9406 28E0 BF           	cp a			;28e0	bf 	.
 9407 28E1 F5           	push af			;28e1	f5 	.
 9408 28E2 01 C1 28     	ld bc,028c1h		;28e2	01 c1 28 	. . (
 9409 28E5 C5           	push bc			;28e5	c5 	.
 9410 28E6              sub_28e6h:
 9411 28E6 2A B1 78     	ld hl,(MEMORY_TOP)		;28e6	2a b1 78 	* . x
 9412 28E9              l28e9h:
 9413 28E9 22 D6 78     	ld (BAS_StrFreePtr),hl	; set as pointer to next free byte in string storage area	;28e9	22 d6 78 	" . x
 9414 28EC 21 00 00     	ld hl,$0000		;28ec	21 00 00 	! . .
 9415 28EF E5           	push hl			;28ef	e5 	.
 9416 28F0 2A A0 78     	ld hl,(STACKTOPPTR)	; top of Basic Stack Pointer		;28f0	2a a0 78 	* . x
 9417 28F3 E5           	push hl			;28f3	e5 	.
 9418 28F4 21 B5 78     	ld hl,BAS_StrVars	; address of BASIC String Variables Area					;28f4	21 b5 78 	! . x
 9419 28F7              l28f7h:
 9420 28F7 EB           	ex de,hl			;28f7	eb 	.
 9421 28F8 2A B3 78     	ld hl,(BAS_StrNextVar)	; next location in literal string pool	;28f8	2a b3 78 	* . x
 9422 28FB EB           	ex de,hl			;28fb	eb 	.
 9423 28FC DF           	rst #18			; Compare HL and DE ;28fc	df 	.
 9424 28FD 01 F7 28     	ld bc,l28f7h		;28fd	01 f7 28 	. . (
 9425 2900 C2 4A 29     	jp nz,l294ah		;2900	c2 4a 29 	. J )
 9426 2903 2A F9 78     	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program						;2903	2a f9 78 	* . x
 9427 2906              l2906h:
 9428 2906 EB           	ex de,hl			;2906	eb 	.
 9429 2907 2A FB 78     	ld hl,(ArrStartPtr)	; address of Start of Basic Array area			;2907	2a fb 78 	* . x
 9430 290A EB           	ex de,hl			;290a	eb 	.
 9431 290B DF           	rst #18			; Compare HL and DE ;290b	df 	.
 9432 290C 28 13        	jr z,l2921h		;290c	28 13 	( .
 9433 290E 7E           	ld a,(hl)			;290e	7e 	~
 9434 290F 23           	inc hl			;290f	23 	#
 9435 2910 23           	inc hl			;2910	23 	#
 9436 2911 23           	inc hl			;2911	23 	#
 9437 2912 FE 03        	cp 003h		;2912	fe 03 	. .
 9438 2914 20 04        	jr nz,l291ah		;2914	20 04 	  .
 9439 2916 CD 4B 29     	call sub_294bh		;2916	cd 4b 29 	. K )
 9440 2919 AF           	xor a			;2919	af 	.
 9441 291A              l291ah:
 9442 291A 5F           	ld e,a			;291a	5f 	_
 9443 291B 16 00        	ld d,000h		;291b	16 00 	. .
 9444 291D 19           	add hl,de			;291d	19 	.
 9445 291E 18 E6        	jr l2906h		;291e	18 e6 	. .
 9446 2920              l2920h:
 9447 2920 C1           	pop bc			;2920	c1 	.
 9448 2921              l2921h:
 9449 2921 EB           	ex de,hl			;2921	eb 	.
 9450 2922 2A FD 78     	ld hl,(ArrEndPtr)	; address of End of Basic Array area		;2922	2a fd 78 	* . x
 9451 2925 EB           	ex de,hl			;2925	eb 	.
 9452 2926 DF           	rst #18			; Compare HL and DE ;2926	df 	.
 9453 2927 CA 6B 29     	jp z,l296bh		;2927	ca 6b 29 	. k )
 9454 292A 7E           	ld a,(hl)			;292a	7e 	~
 9455 292B 23           	inc hl			;292b	23 	#
 9456 292C CD C2 09     	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;292c	cd c2 09 	. . .
 9457 292F E5           	push hl			;292f	e5 	.
 9458 2930 09           	add hl,bc			;2930	09 	.
 9459 2931 FE 03        	cp 003h		;2931	fe 03 	. .
 9460 2933 20 EB        	jr nz,l2920h		;2933	20 eb 	  .
 9461 2935 22 D8 78     	ld (BAS_TempPtr),hl	; temporary pointer	;2935	22 d8 78 	" . x
 9462 2938 E1           	pop hl			;2938	e1 	.
 9463 2939 4E           	ld c,(hl)			;2939	4e 	N
 9464 293A 06 00        	ld b,000h		;293a	06 00 	. .
 9465 293C 09           	add hl,bc			;293c	09 	.
 9466 293D 09           	add hl,bc			;293d	09 	.
 9467 293E              l293eh:
 9468 293E 23           	inc hl			;293e	23 	#
 9469 293F              l293fh:
 9470 293F EB           	ex de,hl			;293f	eb 	.
 9471 2940 2A D8 78     	ld hl,(BAS_TempPtr)	; temporary pointer	;2940	2a d8 78 	* . x
 9472 2943 EB           	ex de,hl			;2943	eb 	.
 9473 2944 DF           	rst #18			; Compare HL and DE ;2944	df 	.
 9474 2945 28 DA        	jr z,l2921h		;2945	28 da 	( .
 9475 2947 01 3F 29     	ld bc,l293fh		;2947	01 3f 29 	. ? )
 9476 294A              l294ah:
 9477 294A C5           	push bc			;294a	c5 	.
 9478 294B              sub_294bh:
 9479 294B AF           	xor a			;294b	af 	.
 9480 294C B6           	or (hl)			;294c	b6 	.
 9481 294D 23           	inc hl			;294d	23 	#
 9482 294E 5E           	ld e,(hl)			;294e	5e 	^
 9483 294F 23           	inc hl			;294f	23 	#
 9484 2950 56           	ld d,(hl)			;2950	56 	V
 9485 2951 23           	inc hl			;2951	23 	#
 9486 2952 C8           	ret z			;2952	c8 	.
 9487 2953 44           	ld b,h			;2953	44 	D
 9488 2954 4D           	ld c,l			;2954	4d 	M
 9489 2955 2A D6 78     	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;2955	2a d6 78 	* . x
 9490 2958 DF           	rst #18			; Compare HL and DE ;2958	df 	.
 9491 2959 60           	ld h,b			;2959	60 	`
 9492 295A 69           	ld l,c			;295a	69 	i
 9493 295B D8           	ret c			;295b	d8 	.
 9494 295C E1           	pop hl			;295c	e1 	.
 9495 295D E3           	ex (sp),hl			;295d	e3 	.
 9496 295E DF           	rst #18			; Compare HL and DE ;295e	df 	.
 9497 295F E3           	ex (sp),hl			;295f	e3 	.
 9498 2960 E5           	push hl			;2960	e5 	.
 9499 2961 60           	ld h,b			;2961	60 	`
 9500 2962 69           	ld l,c			;2962	69 	i
 9501 2963 D0           	ret nc			;2963	d0 	.
 9502 2964 C1           	pop bc			;2964	c1 	.
 9503 2965 F1           	pop af			;2965	f1 	.
 9504 2966 F1           	pop af			;2966	f1 	.
 9505 2967 E5           	push hl			;2967	e5 	.
 9506 2968 D5           	push de			;2968	d5 	.
 9507 2969 C5           	push bc			;2969	c5 	.
 9508 296A C9           	ret			;296a	c9 	.
 9509 296B              l296bh:
 9510 296B D1           	pop de			;296b	d1 	.
 9511 296C E1           	pop hl			;296c	e1 	.
 9512 296D 7D           	ld a,l			;296d	7d 	}
 9513 296E B4           	or h			;296e	b4 	.
 9514 296F C8           	ret z			;296f	c8 	.
 9515 2970 2B           	dec hl			;2970	2b 	+
 9516 2971 46           	ld b,(hl)			;2971	46 	F
 9517 2972 2B           	dec hl			;2972	2b 	+
 9518 2973 4E           	ld c,(hl)			;2973	4e 	N
 9519 2974 E5           	push hl			;2974	e5 	.
 9520 2975 2B           	dec hl			;2975	2b 	+
 9521 2976 6E           	ld l,(hl)			;2976	6e 	n
 9522 2977 26 00        	ld h,000h		;2977	26 00 	& .
 9523 2979 09           	add hl,bc			;2979	09 	.
 9524 297A 50           	ld d,b			;297a	50 	P
 9525 297B 59           	ld e,c			;297b	59 	Y
 9526 297C 2B           	dec hl			;297c	2b 	+
 9527 297D 44           	ld b,h			;297d	44 	D
 9528 297E 4D           	ld c,l			;297e	4d 	M
 9529 297F 2A D6 78     	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;297f	2a d6 78 	* . x
 9530 2982 CD 58 19     	call sub_1958h		;2982	cd 58 19 	. X .
 9531 2985 E1           	pop hl			;2985	e1 	.
 9532 2986 71           	ld (hl),c			;2986	71 	q
 9533 2987 23           	inc hl			;2987	23 	#
 9534 2988 70           	ld (hl),b			;2988	70 	p
 9535 2989 69           	ld l,c			;2989	69 	i
 9536 298A 60           	ld h,b			;298a	60 	`
 9537 298B 2B           	dec hl			;298b	2b 	+
 9538 298C C3 E9 28     	jp l28e9h		;298c	c3 e9 28 	. . (
 9539 298F              l298fh:
 9540 298F C5           	push bc			;298f	c5 	.
 9541 2990 E5           	push hl			;2990	e5 	.
 9542 2991 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2991	2a 21 79 	* ! y
 9543 2994 E3           	ex (sp),hl			;2994	e3 	.
 9544 2995 CD 9F 24     	call sub_249fh		;2995	cd 9f 24 	. . $
 9545 2998 E3           	ex (sp),hl			;2998	e3 	.
 9546 2999 CD F4 0A     	call AssertACCIsString	; Assert ACC contains String	;2999	cd f4 0a 	. . .
 9547 299C
 9548 299C              ; **********************************************************************************
 9549 299C              ; [299c] Concatenate two strings.
 9550 299C              ; IN: STACK - <return address> <BC> <HL>
 9551 299C              ;     hl - varptr(String 1)
 9552 299C              ;     ACC - varptr(String 2) with NTF set to String (3)
 9553 299C              ; OUT: ACC - varptr(concatenated string)
 9554 299C 7E           	ld a,(hl)			;299c	7e 	~
 9555 299D E5           	push hl			;299d	e5 	.
 9556 299E 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;299e	2a 21 79 	* ! y
 9557 29A1 E5           	push hl			;29a1	e5 	.
 9558 29A2 86           	add a,(hl)			; a - string/text length in bytes ;29a2	86 	.
 9559 29A3 1E 1C        	ld e,#1c			; ERROR 1C - STRING TOO LONG	;29a3	1e 1c 	. .
 9560 29A5 DA A2 19     	jp c,ErrRaiseError	; Raise Error					;29a5	da a2 19 	. . .
 9561 29A8 CD 57 28     	call StrNew		; Allocate string and Create String Vector ;29a8	cd 57 28 	. W (
 9562 29AB D1           	pop de			;29ab	d1 	.
 9563 29AC CD DE 29     	call sub_29deh		;29ac	cd de 29 	. . )
 9564 29AF E3           	ex (sp),hl			;29af	e3 	.
 9565 29B0 CD DD 29     	call sub_29ddh		;29b0	cd dd 29 	. . )
 9566 29B3 E5           	push hl			;29b3	e5 	.
 9567 29B4 2A D4 78     	ld hl,(078d4h)		;29b4	2a d4 78 	* . x
 9568 29B7 EB           	ex de,hl			;29b7	eb 	.
 9569 29B8 CD C6 29     	call strSPOPcopyToDE    ; Copy string from (SP) to (DE) 		;29b8	cd c6 29 	. . )
 9570 29BB CD C6 29     	call strSPOPcopyToDE	; Copy string from (SP) to (DE) 	;29bb	cd c6 29 	. . )
 9571 29BE 21 49 23     	ld hl,l2349h		;29be	21 49 23 	! I #
 9572 29C1 E3           	ex (sp),hl			;29c1	e3 	.
 9573 29C2 E5           	push hl			;29c2	e5 	.
 9574 29C3 C3 84 28     	jp l2884h		;29c3	c3 84 28 	. . (
 9575 29C6
 9576 29C6              ; **********************************************************************************
 9577 29C6              ; Copy string from (SP) to (DE) - used to concatenate strings.
 9578 29C6              ; IN: de - destination memory for string
 9579 29C6              ;     STACK - address of string structure
 9580 29C6              strSPOPcopyToDE:
 9581 29C6 E1           	pop hl			;29c6	e1 	.
 9582 29C7 E3           	ex (sp),hl			;29c7	e3 	.
 9583 29C8 7E           	ld a,(hl)			;29c8	7e 	~
 9584 29C9 23           	inc hl			;29c9	23 	#
 9585 29CA 4E           	ld c,(hl)			;29ca	4e 	N
 9586 29CB 23           	inc hl			;29cb	23 	#
 9587 29CC 46           	ld b,(hl)			;29cc	46 	F
 9588 29CD 6F           	ld l,a			;29cd	6f 	o
 9589 29CE
 9590 29CE
 9591 29CE              ; **********************************************************************************
 9592 29CE              ; Copy l bytes from (BC) to (DE) - used to concatenate strings.
 9593 29CE              ; IN: de - destination memory for string
 9594 29CE              ;     bc - source memory with string
 9595 29CE              ;     l  - length of string
 9596 29CE              StrCopy:
 9597 29CE 2C           	inc l			; length of string to copy in range (1..x)					;29ce	2c 	,
 9598 29CF              .copyNext:
 9599 29CF 2D           	dec l			; decrement char counter - all copied?						;29cf	2d 	-
 9600 29D0 C8           	ret z			; yes --------------- End of Proc -------------------------	;29d0	c8 	.
 9601 29D1 0A           	ld a,(bc)		; a - char from source string								;29d1	0a 	.
 9602 29D2 12           	ld (de),a		; store into destination string 							;29d2	12 	.
 9603 29D3 03           	inc bc			; increment source pointer									;29d3	03 	.
 9604 29D4 13           	inc de			; increment destination pointer								;29d4	13 	.
 9605 29D5 18 F8        	jr .copyNext	; copy next char 											;29d5	18 f8 	. .
 9606 29D7
 9607 29D7
 9608 29D7
 9609 29D7              sub_29d7h:
 9610 29D7 CD F4 0A     	call AssertACCIsString	; Assert ACC contains String	;29d7	cd f4 0a 	. . .
 9611 29DA              sub_29dah:
 9612 29DA 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;29da	2a 21 79 	* ! y
 9613 29DD              sub_29ddh:
 9614 29DD EB           	ex de,hl			;29dd	eb 	.
 9615 29DE              sub_29deh:
 9616 29DE CD F5 29     	call sub_29f5h		;29de	cd f5 29 	. . )
 9617 29E1 EB           	ex de,hl			;29e1	eb 	.
 9618 29E2 C0           	ret nz			;29e2	c0 	.
 9619 29E3 D5           	push de			;29e3	d5 	.
 9620 29E4 50           	ld d,b			;29e4	50 	P
 9621 29E5 59           	ld e,c			;29e5	59 	Y
 9622 29E6 1B           	dec de			;29e6	1b 	.
 9623 29E7 4E           	ld c,(hl)			;29e7	4e 	N
 9624 29E8 2A D6 78     	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;29e8	2a d6 78 	* . x
 9625 29EB DF           	rst #18			; Compare HL and DE ;29eb	df 	.
 9626 29EC 20 05        	jr nz,l29f3h		;29ec	20 05 	  .
 9627 29EE 47           	ld b,a			;29ee	47 	G
 9628 29EF 09           	add hl,bc			;29ef	09 	.
 9629 29F0 22 D6 78     	ld (BAS_StrFreePtr),hl	; Pointer to next free byte in string storage area	;29f0	22 d6 78 	" . x
 9630 29F3              l29f3h:
 9631 29F3 E1           	pop hl			;29f3	e1 	.
 9632 29F4 C9           	ret			;29f4	c9 	.
 9633 29F5              sub_29f5h:
 9634 29F5 2A B3 78     	ld hl,(BAS_StrNextVar)	; next location in literal string pool	;29f5	2a b3 78 	* . x
 9635 29F8 2B           	dec hl			;29f8	2b 	+
 9636 29F9 46           	ld b,(hl)			;29f9	46 	F
 9637 29FA 2B           	dec hl			;29fa	2b 	+
 9638 29FB 4E           	ld c,(hl)			;29fb	4e 	N
 9639 29FC 2B           	dec hl			;29fc	2b 	+
 9640 29FD DF           	rst #18			; Compare HL and DE ;29fd	df 	.
 9641 29FE C0           	ret nz			;29fe	c0 	.
 9642 29FF 22 B3 78     	ld (BAS_StrNextVar),hl	; set as next location in literal string pool	;29ff	22 b3 78 	" . x
 9643 2A02 C9           	ret			;2a02	c9 	.
 9644 2A03
 9645 2A03              ; ********************************************************************************
 9646 2A03              ; BASIC LEN Entry Point
 9647 2A03              ; Get length (number of bytes) of a string to ACC
 9648 2A03              ; IN: ACC - varptr(string) with NTF set to 3.
 9649 2A03              ; OUT: ACC - length of the string (Single)
 9650 2A03              ; NOTE; When programming in Assembly Language, it is generally unnecessary to use this
 9651 2A03              ; routine (unless you intend to perform further calculations with the resulting value, etc.),
 9652 2A03              ; because the string length is contained in the byte pointed to by the VARPTR.
 9653 2A03              FuncLEN
 9654 2A03 01 F8 27     	ld bc,ByteToAcc	; routine Copy reg A to ACC									;2a03	01 f8 27 	. . '
 9655 2A06 C5           	push bc			; set as return routine to execute after					;2a06	c5 	.
 9656 2A07
 9657 2A07              ; ********************************************************************************
 9658 2A07              ; Get length (number of bytes) of a string to reg A
 9659 2A07              ; IN: ACC - varptr(string) with NTF set to 3.
 9660 2A07              ; OUT: A - length of the string
 9661 2A07              StrLen:
 9662 2A07 CD D7 29     	call sub_29d7h		;2a07	cd d7 29 	. . )
 9663 2A0A AF           	xor a			;2a0a	af 	.
 9664 2A0B 57           	ld d,a			;2a0b	57 	W
 9665 2A0C 7E           	ld a,(hl)			;2a0c	7e 	~
 9666 2A0D B7           	or a			;2a0d	b7 	.
 9667 2A0E C9           	ret			;2a0e	c9 	.
 9668 2A0F
 9669 2A0F              ; ********************************************************************************
 9670 2A0F              ; BASIC ASC Entry Point
 9671 2A0F              ; Get ASCII value of first character of string to ACC.
 9672 2A0F              ; IN: ACC - varptr of the string with the NTF set to 3.
 9673 2A0F              ; OUT: ACC - the ASCII value of the first character of the string (Integer).
 9674 2A0F              ; NOTE: Keep in mind that the two bytes following the byte pointed to by the VARPTR
 9675 2A0F              ; in turn point to the beginning of the string. Therefore, use of this routine would-be
 9676 2A0F              ; considered highly inefficient programming, except when the resulting value is to be
 9677 2A0F              ; further processed by the ROM arithmetic routines.
 9678 2A0F              FuncASC:
 9679 2A0F 01 F8 27     	ld bc,ByteToAcc	; Copy a to ACC		;2a0f	01 f8 27 	. . '
 9680 2A12 C5           	push bc			;2a12	c5 	.
 9681 2A13              sub_2a13h:
 9682 2A13 CD 07 2A     	call StrLen		;2a13	cd 07 2a 	. . *
 9683 2A16 CA 4A 1E     	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2a16	ca 4a 1e 	. J .
 9684 2A19 23           	inc hl			;2a19	23 	#
 9685 2A1A 5E           	ld e,(hl)			;2a1a	5e 	^
 9686 2A1B 23           	inc hl			;2a1b	23 	#
 9687 2A1C 56           	ld d,(hl)			;2a1c	56 	V
 9688 2A1D 1A           	ld a,(de)			;2a1d	1a 	.
 9689 2A1E C9           	ret			;2a1e	c9 	.
 9690 2A1F
 9691 2A1F
 9692 2A1F              ; ********************************************************************************
 9693 2A1F              ; BASIC CHR$ Entry Point
 9694 2A1F              ; Make a one-character string from ASCII byte
 9695 2A1F              ; IN: ACC - the ASCII value of the character (Single).
 9696 2A1F              ;     STACK - <return address> <HL> <BC>
 9697 2A1F              ; OUT: ACC - varptr of string (1 character) with the NTF set to 3.
 9698 2A1F              FuncCHRS
 9699 2A1F 3E 01        	ld a,1			; a - string/text length in bytes 							;2a1f	3e 01 	> .
 9700 2A21 CD 57 28     	call StrNew	; Allocate 1 char string and Create String Vector			;2a21	cd 57 28 	. W (
 9701 2A24 CD 1F 2B     	call ACCToByte	; convert ACC to 8bit value or throw FUNCTION CODE error	;2a24	cd 1f 2b 	. . +
 9702 2A27 2A D4 78     	ld hl,(078d4h)		;2a27	2a d4 78 	* . x
 9703 2A2A 73           	ld (hl),e			;2a2a	73 	s
 9704 2A2B              l2a2bh:
 9705 2A2B C1           	pop bc			;2a2b	c1 	.
 9706 2A2C C3 84 28     	jp l2884h		;2a2c	c3 84 28 	. . (
 9707 2A2F              l2a2fh:
 9708 2A2F D7           	rst $10			; move hl to next Basic token				;2a2f	d7 	.
 9709 2A30 CF           	rst $08			; Assert next token is '('                  ;2a30	cf 	.
 9710 2A31 28           	defb '('		; Basic '(' token                           ;2a31	28 (
 9711 2A32 CD 1C 2B     	call EvalByteExpr; expression ACC, de and a - must be 8bit value	;2a32	cd 1c 2b 	.
 9712 2A35 D5           	push de			;2a35	d5 	.
 9713 2A36 CF           	rst $08			; Assert next token is ',' ;2a36	cf 	.
 9714 2A37 2C           	defb ','		; Basic ',' token	;2a37	2c 	,
 9715 2A38 CD 37 23     	call EvalExpr	; evaluate expression pointed by hl and store in ACC	;2a38	cd 37 23 	. 7 #
 9716 2A3B CF           	rst $08			; Assert next token is ')' ;2a3b	cf 	.
 9717 2A3C 29           	defb ')'		; Basic ')' token	;2a3c	29 	)
 9718 2A3D
 9719 2A3D
 9720 2A3D              ; *****************************************************************************************
 9721 2A3D              ; STRING$ Make a string of multiple bytes of one character.
 9722 2A3D              ; IN: ACC - ASCII value of the character (Integer)
 9723 2A3D              ;     STACK - <return address> <desired Length>
 9724 2A3D              ; OUT: ACC - vartptr of created string with the NTF set to 3.
 9725 2A3D E3           	ex (sp),hl			;2a3d	e3 	.
 9726 2A3E E5           	push hl			;2a3e	e5 	.
 9727 2A3F E7           	rst #20			; test NTF (Number Type Format) ;2a3f	e7 	.
 9728 2A40 28 05        	jr z,l2a47h		; String - ;2a40	28 05 	( .
 9729 2A42 CD 1F 2B     	call ACCToByte	; convert ACC to 8bit value or throw FUNCTION CODE error		;2a42	cd 1f 2b 	. . +
 9730 2A45 18 03        	jr l2a4ah		;2a45	18 03 	. .
 9731 2A47              l2a47h:
 9732 2A47 CD 13 2A     	call sub_2a13h		;2a47	cd 13 2a 	. . *
 9733 2A4A              l2a4ah:
 9734 2A4A D1           	pop de			; e - text length, d - ???  ;2a4a	d1 	.
 9735 2A4B F5           	push af			;2a4b	f5 	.
 9736 2A4C F5           	push af			;2a4c	f5 	.
 9737 2A4D 7B           	ld a,e			; a - string/text length in bytes ;2a4d	7b 	{
 9738 2A4E CD 57 28     	call StrNew	; Allocate string and Create String Vector	;2a4e	cd 57 28 	. W (
 9739 2A51 5F           	ld e,a			;2a51	5f 	_
 9740 2A52 F1           	pop af			;2a52	f1 	.
 9741 2A53 1C           	inc e			;2a53	1c 	.
 9742 2A54 1D           	dec e			;2a54	1d 	.
 9743 2A55 28 D4        	jr z,l2a2bh		;2a55	28 d4 	( .
 9744 2A57 2A D4 78     	ld hl,(078d4h)		;2a57	2a d4 78 	* . x
 9745 2A5A              l2a5ah:
 9746 2A5A 77           	ld (hl),a			;2a5a	77 	w
 9747 2A5B 23           	inc hl			;2a5b	23 	#
 9748 2A5C 1D           	dec e			;2a5c	1d 	.
 9749 2A5D 20 FB        	jr nz,l2a5ah		;2a5d	20 fb 	  .
 9750 2A5F 18 CA        	jr l2a2bh		;2a5f	18 ca 	. .
 9751 2A61
 9752 2A61
 9753 2A61              ; ********************************************************************************
 9754 2A61              ; [TRS] BASIC LEFT$ Entry Point
 9755 2A61              ; IN: STACK <return address> <varptr of string> <number of characters>
 9756 2A61              ;     de - must point to '('
 9757 2A61              ; OUT: ACC - varptr of new string with the NTF set to 3
 9758 2A61              FuncLEFTS:
 9759 2A61 CD DF 2A     	call sub_2adfh		;2a61	cd df 2a 	. . *
 9760 2A64
 9761 2A64
 9762 2A64              ; ********************************************************************************
 9763 2A64              ; Make a string of the leftmost n characters of string
 9764 2A64              ; IN: STACK <return address> <varptr of string>
 9765 2A64              ;     b - number of characters to be retained at the left side of the string
 9766 2A64              ; OUT: ACC - varptr of new string with the NTF set to 3
 9767 2A64 AF           	xor a			;2a64	af 	.
 9768 2A65              l2a65h:
 9769 2A65 E3           	ex (sp),hl			;2a65	e3 	.
 9770 2A66 4F           	ld c,a			;2a66	4f 	O
 9771 2A67 3E           	db $3e 			; trick byte - with next constructs irrevelant ld a,0e5h		;2a67	3e e5 	> .
 9772 2A68
 9773 2A68              ; ********************************************************************************
 9774 2A68              ; CREATE OR DUPLICATE STRING OR SUBSTRING.
 9775 2A68              ; This routine is used by LEFT$ , MID$, and RIGHT$ to create new substrings.
 9776 2A68              ; It can also be used to duplicate existing strings in memory or to create
 9777 2A68              ; a permanent storage area for a temporary string.
 9778 2A68              ; IN: hl - varptr of string
 9779 2A68              ;     b - maximum length of generated string (255 to duplicate string)
 9780 2A68              ;     c - number of characters to ignore at the start (0 to duplicate string)
 9781 2A68              ;  Note that the new string will not exceed the current string length
 9782 2A68              ; or the length placed in the B register, whichever is less.
 9783 2A68              ; However, if the C register contains a value other than zero, it is possible
 9784 2A68              ; that "garbage" characters may be included in the new string unless precautions
 9785 2A68              ; are taken to avoid this.
 9786 2A68              ; For example, if the B register contains a value of 25 decimal but the current string
 9787 2A68              ; is only 10 characters long, the maximum string length will be 10 characters.
 9788 2A68              ; If a value of 5 is placed In the C register, the resulting string will contain
 9789 2A68              ; the last five characters of the original string plus the five bytes following
 9790 2A68              ; the original string in memory (which probably contain "garbage" or parts
 9791 2A68              ; of other strings).
 9792 2A68              ; OUT: ACC - varptr of created string with the NTF set to 3.
 9793 2A68 E5           	push hl			;2a68	e5 	> .
 9794 2A69              l2a69h:
 9795 2A69 E5           	push hl			;2a69	e5 	.
 9796 2A6A 7E           	ld a,(hl)			;2a6a	7e 	~
 9797 2A6B B8           	cp b			;2a6b	b8 	.
 9798 2A6C 38 02        	jr c,$+4		;2a6c	38 02 	8 .
 9799 2A6E 78           	ld a,b			;2a6e	78 	x
 9800 2A6F 11 0E 00     	ld de,$000e		;2a6f	11 0e 00 	. . .
 9801 2A72 C5           	push bc			;2a72	c5 	.
 9802 2A73 CD BF 28     	call StrAlloc		;2a73	cd bf 28 	. . (
 9803 2A76 C1           	pop bc			;2a76	c1 	.
 9804 2A77 E1           	pop hl			;2a77	e1 	.
 9805 2A78 E5           	push hl			;2a78	e5 	.
 9806 2A79 23           	inc hl			;2a79	23 	#
 9807 2A7A 46           	ld b,(hl)			;2a7a	46 	F
 9808 2A7B 23           	inc hl			;2a7b	23 	#
 9809 2A7C 66           	ld h,(hl)			;2a7c	66 	f
 9810 2A7D 68           	ld l,b			;2a7d	68 	h
 9811 2A7E 06 00        	ld b,000h		;2a7e	06 00 	. .
 9812 2A80 09           	add hl,bc			;2a80	09 	.
 9813 2A81 44           	ld b,h				;2a81	44 	D
 9814 2A82 4D           	ld c,l			; bc - address of source string to copy	;2a82	4d 	M
 9815 2A83 CD 5A 28     	call StrFromADE	; store new string in StringVector variable (de - new string chars)		;2a83	cd 5a 28 	. Z (
 9816 2A86 6F           	ld l,a			; length of string ;2a86	6f 	o
 9817 2A87 CD CE 29     	call StrCopy	; Copy l bytes from (BC) to (DE) 	;2a87	cd ce 29 	. . )
 9818 2A8A D1           	pop de			;2a8a	d1 	.
 9819 2A8B CD DE 29     	call sub_29deh		;2a8b	cd de 29 	. . )
 9820 2A8E C3 84 28     	jp l2884h		;2a8e	c3 84 28 	. . (
 9821 2A91
 9822 2A91
 9823 2A91              ; ********************************************************************************
 9824 2A91              ; BASIC RIGHT$ Entry Point
 9825 2A91              ; IN: STACK <return address> <varptr of string> <number of characters>
 9826 2A91              ;     de - must point to '('
 9827 2A91              ; OUT: ACC - varptr of new string with the NTF set to 3
 9828 2A91              FuncRIGHTS
 9829 2A91 CD DF 2A     	call sub_2adfh		;2a91	cd df 2a 	. . *
 9830 2A94
 9831 2A94              ; ********************************************************************************
 9832 2A94              ; Make a string of the rightmost n characters of string
 9833 2A94              ; IN: STACK <return address> <varptr of string>
 9834 2A94              ;     b - number of characters to be retained at the right side of the string.
 9835 2A94              ; OUT: ACC - varptr of new string with the NTF set to 3
 9836 2A94 D1           	pop de			;2a94	d1 	.
 9837 2A95 D5           	push de			;2a95	d5 	.
 9838 2A96 1A           	ld a,(de)			;2a96	1a 	.
 9839 2A97 90           	sub b			;2a97	90 	.
 9840 2A98 18 CB        	jr l2a65h		;2a98	18 cb 	. .
 9841 2A9A
 9842 2A9A
 9843 2A9A              ; ********************************************************************************
 9844 2A9A              ; BASIC MID$ Entry Point
 9845 2A9A              FuncMIDS:
 9846 2A9A EB           	ex de,hl			;2a9a	eb 	.
 9847 2A9B 7E           	ld a,(hl)			;2a9b	7e 	~
 9848 2A9C CD E2 2A     	call sub_2ae2h		;2a9c	cd e2 2a 	. . *
 9849 2A9F 04           	inc b			;2a9f	04 	.
 9850 2AA0 05           	dec b			;2aa0	05 	.
 9851 2AA1 CA 4A 1E     	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2aa1	ca 4a 1e 	. J .
 9852 2AA4 C5           	push bc			;2aa4	c5 	.
 9853 2AA5 1E FF        	ld e,0ffh		;2aa5	1e ff 	. .
 9854 2AA7 FE 29        	cp 029h		;2aa7	fe 29 	. )
 9855 2AA9 28 05        	jr z,l2ab0h		;2aa9	28 05 	( .
 9856 2AAB CF           	rst $08			; Assert next token is ',' ;2aab	cf 	.
 9857 2AAC 2C           	defb ','		; Basic ',' token	;2aac	2c 	,
 9858 2AAD CD 1C 2B     	call EvalByteExpr; expression ACC, de and a - must be 8bit value	;2aad	cd 1c 2b 	. . +
 9859 2AB0              l2ab0h:
 9860 2AB0 CF           	rst $08			; Assert next token is ')' ;2ab0	cf 	.
 9861 2AB1 29           	defb ')'		; Basic ')' token 	;2ab1	29 	)
 9862 2AB2 F1           	pop af			;2ab2	f1 	.
 9863 2AB3
 9864 2AB3              ; ********************************************************************************
 9865 2AB3              ; Make a string from a portion of another string.
 9866 2AB3              ; IN: a - position of the first character to be retained
 9867 2AB3              ;     e - maximum length of the new string - ff if no limit
 9868 2AB3              ;     STACK - <return address> <varptr of string>
 9869 2AB3              ; OUT: ACC - string created with the NTF set to 3.
 9870 2AB3              ; NOTE: The "standard" entry point to MID$ is 2A9AH, however that entry point
 9871 2AB3              ; requires extra setup procedures.
 9872 2AB3 E3           	ex (sp),hl			;2ab3	e3 	.
 9873 2AB4 01 69 2A     	ld bc,l2a69h		;2ab4	01 69 2a 	. i *
 9874 2AB7 C5           	push bc			;2ab7	c5 	.
 9875 2AB8 3D           	dec a			;2ab8	3d 	=
 9876 2AB9 BE           	cp (hl)			;2ab9	be 	.
 9877 2ABA 06 00        	ld b,000h		;2aba	06 00 	. .
 9878 2ABC D0           	ret nc			;2abc	d0 	.
 9879 2ABD 4F           	ld c,a			;2abd	4f 	O
 9880 2ABE 7E           	ld a,(hl)			;2abe	7e 	~
 9881 2ABF 91           	sub c			;2abf	91 	.
 9882 2AC0 BB           	cp e			;2ac0	bb 	.
 9883 2AC1 47           	ld b,a			;2ac1	47 	G
 9884 2AC2 D8           	ret c			;2ac2	d8 	.
 9885 2AC3 43           	ld b,e			;2ac3	43 	C
 9886 2AC4 C9           	ret			;2ac4	c9 	.
 9887 2AC5
 9888 2AC5
 9889 2AC5
 9890 2AC5
 9891 2AC5              ; ********************************************************************************
 9892 2AC5              ; BASIC VAL Entry Point
 9893 2AC5              ; Get value of numeric string to ACC
 9894 2AC5              ; IN: ACC - varptr of string  with the NTF set to 3.
 9895 2AC5              ; OUT: ACC - value of the number represented in the string (Double) with the NTF set to 8.
 9896 2AC5              FuncVAL
 9897 2AC5 CD 07 2A     	call StrLen		;2ac5	cd 07 2a 	. . *
 9898 2AC8 CA F8 27     	jp z,ByteToAcc	; Copy a to ACC		;2ac8	ca f8 27 	. . '
 9899 2ACB 5F           	ld e,a			;2acb	5f 	_
 9900 2ACC 23           	inc hl			;2acc	23 	#
 9901 2ACD 7E           	ld a,(hl)			;2acd	7e 	~
 9902 2ACE 23           	inc hl			;2ace	23 	#
 9903 2ACF 66           	ld h,(hl)			;2acf	66 	f
 9904 2AD0 6F           	ld l,a			;2ad0	6f 	o
 9905 2AD1 E5           	push hl			;2ad1	e5 	.
 9906 2AD2 19           	add hl,de			;2ad2	19 	.
 9907 2AD3 46           	ld b,(hl)			;2ad3	46 	F
 9908 2AD4 72           	ld (hl),d			;2ad4	72 	r
 9909 2AD5 E3           	ex (sp),hl			;2ad5	e3 	.
 9910 2AD6 C5           	push bc			;2ad6	c5 	.
 9911 2AD7 7E           	ld a,(hl)			;2ad7	7e 	~
 9912 2AD8 CD 65 0E     	call StrToDbl	; convert string (hl) to number (double)		;2ad8	cd 65 0e 	. e .
 9913 2ADB C1           	pop bc			;2adb	c1 	.
 9914 2ADC E1           	pop hl			;2adc	e1 	.
 9915 2ADD 70           	ld (hl),b			;2add	70 	p
 9916 2ADE C9           	ret			;2ade	c9 	.
 9917 2ADF              sub_2adfh:
 9918 2ADF EB           	ex de,hl			;2adf	eb 	.
 9919 2AE0 CF           	rst $08			; Assert next token is ')' ;2ae0	cf 	.
 9920 2AE1 29           	defb ')'		; Basic ')' token 	;2ae1	29 	)
 9921 2AE2              sub_2ae2h:
 9922 2AE2 C1           	pop bc			;2ae2	c1 	.
 9923 2AE3 D1           	pop de			;2ae3	d1 	.
 9924 2AE4 C5           	push bc			;2ae4	c5 	.
 9925 2AE5 43           	ld b,e			;2ae5	43 	C
 9926 2AE6 C9           	ret			;2ae6	c9 	.
 9927 2AE7              l2ae7h:
 9928 2AE7 FE 7A        	cp 07ah		;2ae7	fe 7a 	. z
 9929 2AE9 C2 97 19     	jp nz,ErrRaiseSyntax	; no - Raise 'SYNTAX ERROR'	;2ae9	c2 97 19 	. . .
 9930 2AEC C3 D9 79     	jp SysExtAssign		;2aec	c3 d9 79 	. . y
 9931 2AEF
 9932 2AEF              ; ********************************************************************************
 9933 2AEF              ; [TRS] BASIC INP Entry Point
 9934 2AEF              FuncINP
 9935 2AEF CD 1F 2B     	call ACCToByte		; convert ACC to 8bit value or throw FUNCTION CODE error	;2aef	cd 1f 2b 	. . +
 9936 2AF2 32 94 78     	ld (smcPortInAddr),a	; set port number inside routine code					;2af2	32 94 78 	2 . x
 9937 2AF5 CD 93 78     	call smcPortIn		; execute routine (in a,(<port>))							;2af5	cd 93 78 	. . x
 9938 2AF8 C3 F8 27     	jp ByteToAcc		; Copy a to ACC - result ----------------------------------	;2af8	c3 f8 27 	. . '
 9939 2AFB
 9940 2AFB
 9941 2AFB              ; ***************************************************************************************************
 9942 2AFB              ; BASIC OUT Entry Point
 9943 2AFB              ; IN: hl - current executed command parser
 9944 2AFB              ;     a - command byte
 9945 2AFB              ;     Z = 1 - end of statement ('\0' or ':' found)
 9946 2AFB              ;     CY = 1 - char is digit
 9947 2AFB              CmdOUT
 9948 2AFB CD 0E 2B     	call sub_2b0eh		;2afb	cd 0e 2b 	. . +
 9949 2AFE C3 96 78     	jp smcPortOut		;2afe	c3 96 78 	. . x
 9950 2B01              sub_2b01h:
 9951 2B01 D7           	rst $10			; move hl to next Basic token				;2b01	d7 	.
 9952 2B02
 9953 2B02              ; *********************************************************************************
 9954 2B02              ; LOAD INTEGER EXPRESSION INTO DE
 9955 2B02              ; Evaluate the string at the address pointed to by HL register pair for an integer
 9956 2B02              ; value, stopping at the first non-numeric character. The result is returned
 9957 2B02              ; in DE register pair. A value of zero is returned if no numeric value is found.
 9958 2B02              ; Maximum allowable number is in range -32768 to 32767.
 9959 2B02              ; IN:  hl - address of ASCII string of number to convert
 9960 2B02              ; OUT: de - number converted
 9961 2B02              EvalIntExpr:
 9962 2B02 CD 37 23     	call EvalExpr	; evaluate expression pointed by hl and store in ACC	;2b02	cd 37 23 	. 7 #
 9963 2B05
 9964 2B05
 9965 2B05              ; ********************************************************************************
 9966 2B05              ; Math : Convert from Any (ACC) to Integer (ACC)
 9967 2B05              ; Result also in DE, Z flag set if number in range 0..ff (8bit).
 9968 2B05              ACCToInt:
 9969 2B05 E5           	push hl			;2b05	e5 	.
 9970 2B06 CD 7F 0A     	call FuncCINT	; convert ACC to integer		;2b06	cd 7f 0a 	.  .
 9971 2B09 EB           	ex de,hl			;2b09	eb 	.
 9972 2B0A E1           	pop hl			;2b0a	e1 	.
 9973 2B0B 7A           	ld a,d			;2b0b	7a 	z
 9974 2B0C B7           	or a			;2b0c	b7 	.
 9975 2B0D C9           	ret			;2b0d	c9 	.
 9976 2B0E              sub_2b0eh:
 9977 2B0E CD 1C 2B     	call EvalByteExpr; expression ACC, de and a - must be 8bit value	;2b0e	cd 1c 2b 	. . +
 9978 2B11 32 94 78     	ld (smcPortInAddr),a		;2b11	32 94 78 	2 . x
 9979 2B14 32 97 78     	ld (smcPortOutAddr),a		;2b14	32 97 78 	2 . x
 9980 2B17 CF           	rst $08			; Assert next token is ',' ;2b17	cf 	.
 9981 2B18 2C           	defb ','		; Basic ',' token 	;2b18	2c 	,
 9982 2B19 18 01        	jr EvalByteExpr	; expression ACC, de and a - must be 8bit value	;2b19	18 01 	. .
 9983 2B1B              sub_2b1bh:
 9984 2B1B D7           	rst $10			; move hl to next Basic token				;2b1b	d7 	.
 9985 2B1C
 9986 2B1C              ; **************************************************************************************
 9987 2B1C              ; Evaluate Integer expression and places it in ACC and register de
 9988 2B1C              ; If expression is not Integer, raise FUNCTION CODE error
 9989 2B1C              EvalByteExpr:
 9990 2B1C CD 37 23     	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;2b1c	cd 37 23 	. 7 #
 9991 2B1F              ACCToByte:
 9992 2B1F CD 05 2B     	call ACCToInt	; Convert ACC to Integer - set Z if it is 8bit value	;2b1f	cd 05 2b 	. . +
 9993 2B22 C2 4A 1E     	jp nz,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2b22	c2 4a 1e 	. J .
 9994 2B25 2B           	dec hl			;2b25	2b 	+
 9995 2B26 D7           	rst $10			; move hl to next Basic token				;2b26	d7 	.
 9996 2B27 7B           	ld a,e			;2b27	7b 	{
 9997 2B28 C9           	ret			;2b28	c9 	.
 9998 2B29
 9999 2B29              ; *************************************************************************************
10000 2B29              ; BASIC LIST Entry Point
10001 2B29              ; IN: hl - current executed command parser
10002 2B29              ;     a - command byte
10003 2B29              ;     Z = 1 - end of statement ('\0' or ':' found)
10004 2B29              ;     CY = 1 - char is digit
10005 2B29              CmdLLIST
10006 2B29 3E 01        	ld a,$01			; 1 - Printer Device 											;2b29	3e 01 	> .
10007 2B2B 32 9C 78     	ld (SysCurOutDev),a	; set Printer as Current Out Device								;2b2b	32 9c 78 	2 . x
10008 2B2E
10009 2B2E              ; *************************************************************************************
10010 2B2E              ; BASIC LIST Entry Point
10011 2B2E              ; IN: hl - current executed command parser
10012 2B2E              ;     a - command byte
10013 2B2E              ;     Z = 1 - end of statement ('\0' or ':' found)
10014 2B2E              ;     CY = 1 - char is digit
10015 2B2E              CmdLIST
10016 2B2E C1           	pop bc			;2b2e	c1 	.
10017 2B2F CD 10 1B     	call sub_1b10h		;2b2f	cd 10 1b 	. . .
10018 2B32 C5           	push bc			;2b32	c5 	.
10019 2B33              l2b33h:
10020 2B33 CD 25 3B     	call sub_3b25h		;2b33	cd 25 3b 	. % ;
10021 2B36 22 A2 78     	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;2b36	22 a2 78 	" . x
10022 2B39 E1           	pop hl			;2b39	e1 	.
10023 2B3A D1           	pop de			;2b3a	d1 	.
10024 2B3B 4E           	ld c,(hl)			;2b3b	4e 	N
10025 2B3C 23           	inc hl			;2b3c	23 	#
10026 2B3D 46           	ld b,(hl)			;2b3d	46 	F
10027 2B3E 23           	inc hl			;2b3e	23 	#
10028 2B3F 78           	ld a,b			;2b3f	78 	x
10029 2B40 B1           	or c			;2b40	b1 	.
10030 2B41 CA 19 1A     	jp z,BasicREADY	; jump to Basic Ready and display prompt to user           	;2b41	ca 19 1a 	. . .
10031 2B44 CD DF 79     	call SysExtExtraTest		;2b44	cd df 79 	. . y
10032 2B47 CD 9B 1D     	call sub_1d9bh		;2b47	cd 9b 1d 	. . .
10033 2B4A C5           	push bc			;2b4a	c5 	.
10034 2B4B 4E           	ld c,(hl)			;2b4b	4e 	N
10035 2B4C 23           	inc hl			;2b4c	23 	#
10036 2B4D 46           	ld b,(hl)			;2b4d	46 	F
10037 2B4E 23           	inc hl			;2b4e	23 	#
10038 2B4F C5           	push bc			;2b4f	c5 	.
10039 2B50 E3           	ex (sp),hl			;2b50	e3 	.
10040 2B51 EB           	ex de,hl			;2b51	eb 	.
10041 2B52 DF           	rst #18			; Compare HL and DE ;2b52	df 	.
10042 2B53 C1           	pop bc			;2b53	c1 	.
10043 2B54 DA 18 1A     	jp c,BAS_ReadyPopBC	; take address from CPU stack and goto Basic READY state		;2b54	da 18 1a 	. . .
10044 2B57 E3           	ex (sp),hl			;2b57	e3 	.
10045 2B58 E5           	push hl			;2b58	e5 	.
10046 2B59 C5           	push bc			;2b59	c5 	.
10047 2B5A EB           	ex de,hl			;2b5a	eb 	.
10048 2B5B 22 EC 78     	ld (EditLineNo),hl	; set as current Edited Basic Line Number		;2b5b	22 ec 78 	" . x
10049 2B5E CD AF 0F     	call PrintLineNo	; Print Line number 	;2b5e	cd af 0f 	. . .
10050 2B61 3E 20        	ld a,' '		;2b61	3e 20 	>
10051 2B63 E1           	pop hl			;2b63	e1 	.
10052 2B64 CD 2A 03     	call PrintChar	; Print ' ' char on screen		;2b64	cd 2a 03 	. * .
10053 2B67 CD 7E 2B     	call DetokenizeLine	; detokenize Basic Line into LineBuffer	;2b67	cd 7e 2b 	. ~ +
10054 2B6A 2A A7 78     	ld hl,(LINEBUFPTR)	; address of Line Buffer with text of Basic Line	;2b6a	2a a7 78 	* . x
10055 2B6D CD 75 2B     	call PrintCStr	    ; Print Line Buffer to screen 	;2b6d	cd 75 2b 	. u +
10056 2B70 CD FE 20     	call PrintCR	    ; Print CR on screen 	;2b70	cd fe 20 	. .
10057 2B73 18 BE        	jr l2b33h		;2b73	18 be 	. .
10058 2B75
10059 2B75              ; **********************************************************************************
10060 2B75              ; Output a string to device indicated by device type flag stored at SysCurOutDev.
10061 2B75              ; Calls routine at 032a (note warning for that routine - see above)
10062 2B75              ; IN:  (hl) - string to send to device (terminated with 0)
10063 2B75              PrintCStr:
10064 2B75 7E           	ld a,(hl)			; a - char to send to DCB Device				;2b75	7e 	~
10065 2B76 B7           	or a				; is this \0 (end of string)					;2b76	b7 	.
10066 2B77 C8           	ret z				; yes ----------- End of Proc ----------------- ;2b77	c8 	.
10067 2B78 CD 2A 03     	call PrintChar	    ; Print ' ' char on screen						;2b78	cd 2a 03 	. * .
10068 2B7B 23           	inc hl				; address of next char to send					;2b7b	23 	#
10069 2B7C 18 F7        	jr PrintCStr	    ; continue with next chars --------------------	;2b7c	18 f7 	. .
10070 2B7E
10071 2B7E              ; **********************************************************************************
10072 2B7E              ; EXPAND COMPRESSED BASIC LINE
10073 2B7E              ; After a BASIC line has been compressed, this routine may be used to expand it back
10074 2B7E              ; into a line of text, so that it can be LISTed, EDITed, etc.
10075 2B7E              ; On entry, HL must point to the first byte of compressed text in the line
10076 2B7E              ; (that is, the first byte following the forward pointer and line number).
10077 2B7E              ; The line will be decoded and the result placed in the BASIC text buffer
10078 2B7E              ; until a zero byte is encountered in the line (address of the buffer at 78A7).
10079 2B7E              ; The expanded line will be terminated with a zero byte.
10080 2B7E              ; IN: hl - tokenized BASIC line (null terminated)
10081 2B7E              ; OUT: Buffer ([78A7]) detokenized BASIC line
10082 2B7E              DetokenizeLine:
10083 2B7E E5           	push hl			    ; save hl - address of Basic Line 						;2b7e	e5 	.
10084 2B7F 2A A7 78     	ld hl,(LINEBUFPTR)	; address of Line Buffer 								;2b7f	2a a7 78 	* . x
10085 2B82 44           	ld b,h				; high byte of Line Buffer address						;2b82	44 	D
10086 2B83 4D           	ld c,l			    ; bc - address of Line Buffer 							;2b83	4d 	M
10087 2B84 E1           	pop hl				; hl - address of tokenized Basic line					;2b84	e1 	.
10088 2B85 16 FF        	ld d,255			; max 225 chars 										;2b85	16 ff 	. .
10089 2B87 18 03        	jr l2b8ch			; skip first decrement and check						;2b87	18 03 	. .
10090 2B89              l2b89h:
10091 2B89 03           	inc bc				; points to next address in Buffer (dst) 				;2b89	03 	.
10092 2B8A 15           	dec d				; decrement number of chars left in destination Buffer 	;2b8a	15 	.
10093 2B8B C8           	ret z				; none left ----------- End of Proc -------------------	;2b8b	c8 	.
10094 2B8C              l2b8ch:
10095 2B8C 7E           	ld a,(hl)			; a - token byte from Baci line							;2b8c	7e 	~
10096 2B8D B7           	or a				; is it '\0' (end of line)?								;2b8d	b7 	.
10097 2B8E 23           	inc hl				; points to next char or token							;2b8e	23 	#
10098 2B8F 02           	ld (bc),a			; store char in BUffer									;2b8f	02 	.
10099 2B90 C8           	ret z				; yes (end of line) -------- End of Proc --------------	;2b90	c8 	.
10100 2B91              ; -- stored char/token
10101 2B91 C3 9D 2E     	jp l2e9dh		;2b91	c3 9d 2e 	. . .
10102 2B94
10103 2B94
10104 2B94              ; (cont) Detokenize line
10105 2B94              ; IN: a - token from basic line (also stored in Edit Buffer)
10106 2B94              ;     hl - (src) address of next char
10107 2B94              ;     bc - (dst) address of current char in Buffer
10108 2B94              l2b94h:
10109 2B94 FE FB        	cp $fb			; is this "'" Basic Token (REM alias)						;2b94	fe fb 	. .
10110 2B96 20 08        	jr nz,l2ba0h	; no -	;2b96	20 08 	  .
10111 2B98              ; -- "'" token (REM alias) - comment
10112 2B98 0B           	dec bc			;2b98	0b 	.
10113 2B99 0B           	dec bc			;2b99	0b 	.
10114 2B9A 0B           	dec bc			;2b9a	0b 	.
10115 2B9B 0B           	dec bc			;2b9b	0b 	.
10116 2B9C 14           	inc d			;2b9c	14 	.
10117 2B9D 14           	inc d			;2b9d	14 	.
10118 2B9E 14           	inc d			;2b9e	14 	.
10119 2B9F 14           	inc d			;2b9f	14 	.
10120 2BA0              l2ba0h:
10121 2BA0 FE 95        	cp $95			; is it 'ELSE' Token?										;2ba0	fe 95 	. .
10122 2BA2 CC 24 0B     	call z,sub_0b24h; yes -		;2ba2	cc 24 0b 	. $ .
10123 2BA5              ; -- other token - find text of this command
10124 2BA5 D6 7F        	sub $7f			; token index in range 1..127								;2ba5	d6 7f 	. 
10125 2BA7 E5           	push hl			; save hl - address of current token in source Basic Line	;2ba7	e5 	.
10126 2BA8 5F           	ld e,a			; e - token index											;2ba8	5f 	_
10127 2BA9 21 50 16     	ld hl,BasicCmdNames	; All Basic Commands Names table 						;2ba9	21 50 16 	! P .
10128 2BAC              .next:
10129 2BAC              ;-- find start of Command name in table
10130 2BAC 7E           	ld a,(hl)		; a - char from table										;2bac	7e 	~
10131 2BAD B7           	or a			; is bit 7 set (start of name)?								;2bad	b7 	.
10132 2BAE 23           	inc hl			; points to next char										;2bae	23 	#
10133 2BAF F2 AC 2B     	jp p,.next		; no - check next char										;2baf	f2 ac 2b 	. . +
10134 2BB2              ; -- start of name found - is it for this token?
10135 2BB2 1D           	dec e			; decrement index - is it for this token?					;2bb2	1d 	.
10136 2BB3 20 F7        	jr nz,.next		; no - check next char										;2bb3	20 f7 	  .
10137 2BB5              ; -- name found - copy to buffer
10138 2BB5 E6 7F        	and $7f			; clear bit 7 for the first char (start marker)				;2bb5	e6 7f 	. 
10139 2BB7              .copynext:
10140 2BB7 02           	ld (bc),a		; store char in buffer										;2bb7	02 	.
10141 2BB8 03           	inc bc			; increment destination pointer								;2bb8	03 	.
10142 2BB9 15           	dec d			; decrement number of chars left in buffer 					;2bb9	15 	.
10143 2BBA CA D8 28     	jp z,l28d8h		; no more space in buffer ----- Exit with "pop af"			;2bba	ca d8 28 	. . (
10144 2BBD 7E           	ld a,(hl)		; a - char from name 										;2bbd	7e 	~
10145 2BBE 23           	inc hl			; points to next char										;2bbe	23 	#
10146 2BBF B7           	or a			; is bit 7 set (start of next name)?						;2bbf	b7 	.
10147 2BC0 F2 B7 2B     	jp p,.copynext	; no - copy next char										;2bc0	f2 b7 2b 	. . +
10148 2BC3 E1           	pop hl			; restore hl - address of current token in source Line		;2bc3	e1 	.
10149 2BC4 18 C6        	jr l2b8ch		;2bc4	18 c6 	. .
10150 2BC6
10151 2BC6
10152 2BC6
10153 2BC6              ; ************************************************************************************************
10154 2BC6              ; [TRS] BASIC DELETE Entry Point
10155 2BC6              ; IN: hl - current executed command parser
10156 2BC6              ;     a - command byte
10157 2BC6              ;     Z = 1 - end of statement ('\0' or ':' found)
10158 2BC6              ;     CY = 1 - char is digit
10159 2BC6              CmdDELETE
10160 2BC6 CD 10 1B     	call sub_1b10h		;2bc6	cd 10 1b 	. . .
10161 2BC9 D1           	pop de			; de - Basic Line number ;2bc9	d1 	.
10162 2BCA C5           	push bc			;2bca	c5 	.
10163 2BCB C5           	push bc			;2bcb	c5 	.
10164 2BCC CD 2C 1B     	call FindBasicLine	; find Basic line with number in de						;2bcc	cd 2c 1b 	. , .
10165 2BCF 30 05        	jr nc,l2bd6h		;2bcf	30 05 	0 .
10166 2BD1 54           	ld d,h			;2bd1	54 	T
10167 2BD2 5D           	ld e,l			;2bd2	5d 	]
10168 2BD3 E3           	ex (sp),hl			;2bd3	e3 	.
10169 2BD4 E5           	push hl			;2bd4	e5 	.
10170 2BD5 DF           	rst #18			; Compare HL and DE ;2bd5	df 	.
10171 2BD6              l2bd6h:
10172 2BD6 D2 4A 1E     	jp nc,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2bd6	d2 4a 1e 	. J .
10173 2BD9 21 29 19     	ld hl,TXT_READY		;2bd9	21 29 19 	! ) .
10174 2BDC CD A7 28     	call PrintBasicStr	; print "READY" text on Screen	;2bdc	cd a7 28 	. . (
10175 2BDF C1           	pop bc			;2bdf	c1 	.
10176 2BE0 21 E8 1A     	ld hl,l1ae8h		;2be0	21 e8 1a 	! . .
10177 2BE3 E3           	ex (sp),hl			;2be3	e3 	.
10178 2BE4
10179 2BE4
10180 2BE4              ; ********************************************************************************
10181 2BE4              ; DELETE BASIC LINE(s)
10182 2BE4              ; On entry, the BC register must point to the start of the first BASIC line to delete,
10183 2BE4              ; and the HL register must point to the start of the following line to be retained
10184 2BE4              ; On exit, the lines are deleted, but the forward line pointers are not corrected
10185 2BE4              ; by this routine. Therefore, suggested entry to this routine is to PUSH BC prior
10186 2BE4              ; to the CALL. Then, after the return from this routine, you can POP DE and CALL
10187 2BE4              ; BAS_AdjustLines to adjust the forward pointers.
10188 2BE4              ; IN: bc - first BASIC line to delete
10189 2BE4              ;     hl - first BASIC line to retain
10190 2BE4              DelBasicLines:
10191 2BE4 EB           	ex de,hl			; de - first basic line to retain						;2be4	eb 	.
10192 2BE5 2A F9 78     	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program					;2be5	2a f9 78 	* . x
10193 2BE8              .next:
10194 2BE8 1A           	ld a,(de)			; get byte from source 									;2be8	1a 	.
10195 2BE9 02           	ld (bc),a			; store in destination									;2be9	02 	.
10196 2BEA 03           	inc bc				; increment destination pointer							;2bea	03 	.
10197 2BEB 13           	inc de				; increment source pointer								;2beb	13 	.
10198 2BEC DF           	rst #18				; is src pointer = end of Basic program?				;2bec	df 	.
10199 2BED 20 F9        	jr nz,.next			; no - continue copy bytes								;2bed	20 f9 	  .
10200 2BEF 60           	ld h,b																		;2bef	60 	`
10201 2BF0 69           	ld l,c				; hl - destination address after copy					;2bf0	69 	i
10202 2BF1 22 F9 78     	ld (PrgEndPtr),hl	; set as address of End of Basic Program				;2bf1	22 f9 78 	" . x
10203 2BF4 C9           	ret					; ----------------- End of Proc -----------------------	;2bf4	c9 	.
10204 2BF5
10205 2BF5
10206 2BF5
10207 2BF5              ; *************************************************************************************
10208 2BF5              ; TRS BASIC CSA¥E routine.
10209 2BF5              ; Saves a BASIC program to tape. On entry, HL register pair must point to the start
10210 2BF5              ; of a valid filename sequence (a quotation mark followed by a single character
10211 2BF5              ; filename, which in turn may be optionally followed by a second quotation mark.
10212 2BF5              ; The entire filename sequence must be terminated by a zero byte or colon).
10213 2BF5              ; IN: hl - valid filename sequence
10214 2BF5
10215 2BF5
10216 2BF5              ; *************************************************************************************
10217 2BF5              ; BASIC SOUND Entry Point
10218 2BF5              ; SOUND <freq>,<duration> [;<freq>,<duration>] ...
10219 2BF5              ; Where: freq = 0..31 (0 - silent/pause), duration = 1..9
10220 2BF5              ; IN: hl - current executed command parser
10221 2BF5              ;     a - command byte
10222 2BF5              ;     Z = 1 - end of statement ('\0' or ':' found)
10223 2BF5              ;     CY = 1 - char is digit
10224 2BF5              CmdSOUND:
10225 2BF5              ; -- parse syntax - read Frequency
10226 2BF5 CD 1C 2B     	call EvalByteExpr	; expression to ACC, de and a - must be 8bit value			;2bf5	cd 1c 2b 	. . +
10227 2BF8 FE 20        	cp 32				; is Freq >= 32 ?										;2bf8	fe 20 	.
10228 2BFA D2 4A 1E     	jp nc,ErrRaiseFuncCode	; yes Invalid - raise FUNCTION CODE Error			;2bfa	d2 4a 1e 	. J .
10229 2BFD              ; -- Freq valid - save it
10230 2BFD 32 D2 7A     	ld (TAPEFILETYPE),a	; save Frequency parameter 								;2bfd	32 d2 7a 	2 . z
10231 2C00              ; -- next char must be ',' - args separator
10232 2C00 CF           	rst $08				; Assert next token is ',' - args separator				;2c00	cf 	.
10233 2C01 2C           	defb ','			; Basic ',' token 										;2c01	2c 	,
10234 2C02              ; -- parse syntax - read Duration
10235 2C02 CD 1C 2B     	call EvalByteExpr	; expression to ACC, de and a - must be 8bit value		;2c02	cd 1c 2b 	. . +
10236 2C05 B7           	or a				; is it 0 (invalid value)?								;2c05	b7 	.
10237 2C06 CA 4A 1E     	jp z,ErrRaiseFuncCode	; yes Invalid - raise FUNCTION CODE Error			;2c06	ca 4a 1e 	. J .
10238 2C09 FE 0A        	cp 10				; is Duration >= 10 ? 									;2c09	fe 0a 	. .
10239 2C0B D2 4A 1E     	jp nc,ErrRaiseFuncCode	; yes Invalid - raise FUNCTION CODE Error			;2c0b	d2 4a 1e 	. J .
10240 2C0E              ; -- Validated params: (TAPEFILETYPE) = Freq, reg A = Duration - generate Sound
10241 2C0E F3           	di					; disable interrupts									;2c0e	f3 	.
10242 2C0F E5           	push hl				; save hl - interpreter current pointer					;2c0f	e5 	.
10243 2C10 3D           	dec a				; decrement Duration counter 							;2c10	3d 	=
10244 2C11 F5           	push af				; save af - duration counter w/ flags after decrement	;2c11	f5 	.
10245 2C12              ; -- find counters' values for given Freq
10246 2C12 3A D2 7A     	ld a,(TAPEFILETYPE)	; a - Frequency index									;2c12	3a d2 7a 	: . z
10247 2C15 B7           	or a				; is it 0 (silent/pause note)?							;2c15	b7 	.
10248 2C16 28 40        	jr z,.playrest		; yes - play silent (rest) note							;2c16	28 40 	( @
10249 2C18              ; -- Freq index in range 1..30 - calculate offset in SNDFREQTAB
10250 2C18 3D           	dec a				; a - Freq index in range 0..29							;2c18	3d 	=
10251 2C19 CB 27        	sla a				; a * 2 - every entry in table is 16bit value			;2c19	cb 27 	. '
10252 2C1B 4F           	ld c,a				; c - low byte of offset								;2c1b	4f 	O
10253 2C1C AF           	xor a				; 0 value for high byte of offset						;2c1c	af 	.
10254 2C1D 47           	ld b,a				; bc - offset in SNDFREQTAB								;2c1d	47 	G
10255 2C1E F1           	pop af				; restore af - duration counter w/ flags after decrement;2c1e	f1 	.
10256 2C1F              ; -- calculate address in Sound Frequency Table - get Period counter
10257 2C1F 21 CF 02     	ld hl,SNDFREQTAB	; base addres of Table									;2c1f	21 cf 02 	! . .
10258 2C22 09           	add hl,bc			; add offset 											;2c22	09 	.
10259 2C23 5E           	ld e,(hl)			; e - low byte of Freq Counter							;2c23	5e 	^
10260 2C24 23           	inc hl				; points to High byte of entry							;2c24	23 	#
10261 2C25 56           	ld d,(hl)			; de - Freq Counter										;2c25	56 	V
10262 2C26 D5           	push de				; save de - Freq Counter								;2c26	d5 	.
10263 2C27              ; -- get how many periods of given freq must be played for 1/8 note (??)
10264 2C27 21 61 03     	ld hl,SNDFCNTTAB	; base address of Table									;2c27	21 61 03 	! a .
10265 2C2A CB 39        	srl c				; bc / 2 - back as index 0..29							;2c2a	cb 39 	. 9
10266 2C2C 09           	add hl,bc			; add offset - address in SNDFCNTTAB					;2c2c	09 	.
10267 2C2D 5E           	ld e,(hl)			; e - period counter									;2c2d	5e 	^
10268 2C2E 16 00        	ld d,0				; de - 16bit period counter								;2c2e	16 00 	. .
10269 2C30              ; -- calculate duration for given index (0..8)
10270 2C30 21 21 03     	ld hl,SNDDURTAB		; base address of Table 								;2c30	21 21 03 	! ! .
10271 2C33 4F           	ld c,a				; bc - duration param (0..8) of sound					;2c33	4f 	O
10272 2C34 09           	add hl,bc			; add offet												;2c34	09 	.
10273 2C35 46           	ld b,(hl)			; b - multiplier of 1/8 note length to play				;2c35	46 	F
10274 2C36              ; -- calculate total number of periods to play for whole note = b x number of periodd
10275 2C36 D5           	push de				; copy de to hl											;2c36	d5 	.
10276 2C37 E1           	pop hl				; hl - periods per 1/8 note 							;2c37	e1 	.
10277 2C38              .addmore:
10278 2C38 19           	add hl,de			; add de to sum											;2c38	19 	.
10279 2C39 10 FD        	djnz .addmore		; decrement b counter and add more if not zero			;2c39	10 fd 	. .
10280 2C3B E5           	push hl				; move hl to bc											;2c3b	e5 	.
10281 2C3C C1           	pop bc				; bc - total number of periods to play for this note	;2c3c	c1 	.
10282 2C3D E1           	pop hl				; hl - Freq counter (Period length)						;2c3d	e1 	.
10283 2C3E              .next:
10284 2C3E              ; -- test Ctrl+Break and execute Basic STOP command
10285 2C3E CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;2c3e	cd f8 3a 	. . :
10286 2C41 3A 3B 78     	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  					;2c41	3a 3b 78 	: ; x
10287 2C44 57           	ld d,a				; save IO_LATCH value to reg d							;2c44	57 	W
10288 2C45 CD 69 34     	call PlayOneTone		;2c45	cd 69 34 	. i 4
10289 2C48              ; -- check if we've played bc times already
10290 2C48 0B           	dec bc				; decrement periods to play counter						;2c48	0b 	.
10291 2C49 79           	ld a,c				; a - low byte of counter								;2c49	79 	y
10292 2C4A B0           	or b				; are both 0 (end of sound)?							;2c4a	b0 	.
10293 2C4B 20 F1        	jr nz,.next			; no - check Break and play again						;2c4b	20 f1 	  .
10294 2C4D              .exit:
10295 2C4D E1           	pop hl				; restore hl - interpreter current pointer				;2c4d	e1 	.
10296 2C4E FB           	ei					; enable interrupts										;2c4e	fb 	.
10297 2C4F              ; -- check optional follow up sound definitions
10298 2C4F 7E           	ld a,(hl)			; a - next char from Basic code 						;2c4f	7e 	~
10299 2C50 23           	inc hl				; increment interpreter pointer							;2c50	23 	#
10300 2C51 FE 3B        	cp ';'				; is it ';' (list separator)							;2c51	fe 3b 	. ;
10301 2C53 CA F5 2B     	jp z,CmdSOUND		; yes - parse and play next sound						;2c53	ca f5 2b 	. . +
10302 2C56 2B           	dec hl				; decrement back interpreter pointer					;2c56	2b 	+
10303 2C57 C9           	ret					; --------------- End of Proc -------------------------	;2c57	c9 	.
10304 2C58
10305 2C58
10306 2C58              .playrest:
10307 2C58              ; -- calculate duration for given index (0..8)
10308 2C58 F1           	pop af				; restore af - duration param (0..8) 					;2c58	f1 	.
10309 2C59 4F           	ld c,a				; c - low byte of offset 								;2c59	4f 	O
10310 2C5A AF           	xor a				; 0 value for high byte of offset						;2c5a	af 	.
10311 2C5B 47           	ld b,a				; bc - offset to note duration in Table					;2c5b	47 	G
10312 2C5C 21 21 03     	ld hl,SNDDURTAB		; base address of Table									;2c5c	21 21 03 	! ! .
10313 2C5F 09           	add hl,bc			; add offset											;2c5f	09 	.
10314 2C60 46           	ld b,(hl)			; b - multiplier of 1/8 note length to play				;2c60	46 	F
10315 2C61              ; -- calculate total number of periods to play for whole note = b x number of period
10316 2C61              ; -- NOTE: there is no Frequency for rest note so we have simply loop count
10317 2C61 21 36 19     	ld hl,$1936			; "number of periods" for 1/8 note						;2c61	21 36 19 	! 6 .
10318 2C64 E5           	push hl				; copy hl to de											;2c64	e5 	.
10319 2C65 D1           	pop de				; de - periods per 1/8 note 							;2c65	d1 	.
10320 2C66              .addmore2:
10321 2C66 19           	add hl,de			; add to sum											;2c66	19 	.
10322 2C67 10 FD        	djnz .addmore2		; decrement b counter and add more if not zero			;2c67	10 fd 	. .
10323 2C69              .next2:
10324 2C69              ; -- test Ctrl+Break and execute Basic STOP command
10325 2C69 CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;2c69	cd f8 3a 	. . :
10326 2C6C 2B           	dec hl				; decrement loop counter								;2c6c	2b 	+
10327 2C6D 7D           	ld a,l				; a - low byte of counter								;2c6d	7d 	}
10328 2C6E B4           	or h				;is hl = 0 (end of rest note)?							;2c6e	b4 	.
10329 2C6F 20 F8        	jr nz,.next2		; no - continue ;2c6f	20 f8 	  .
10330 2C71 18 DA        	jr .exit			; continue from exit proc -----------------------------	;2c71	18 da 	. .
10331 2C73
10332 2C73
10333 2C73              sub_2c73h:
10334 2C73 C5           	push bc			;2c73	c5 	.
10335 2C74 47           	ld b,a			;2c74	47 	G
10336 2C75 3E 08        	ld a,008h		;2c75	3e 08 	> .
10337 2C77 CD BA 3A     	call sub_3abah		;2c77	cd ba 3a 	. . :
10338 2C7A 78           	ld a,b			;2c7a	78 	x
10339 2C7B E6 0F        	and 00fh		;2c7b	e6 0f 	. .
10340 2C7D E5           	push hl			;2c7d	e5 	.
10341 2C7E CB 27        	sla a		;2c7e	cb 27 	. '
10342 2C80 4F           	ld c,a			;2c80	4f 	O
10343 2C81 AF           	xor a			;2c81	af 	.
10344 2C82 47           	ld b,a			;2c82	47 	G
10345 2C83 21 AF 02     	ld hl,l02afh		;2c83	21 af 02 	! . .
10346 2C86 09           	add hl,bc			;2c86	09 	.
10347 2C87 7E           	ld a,(hl)			;2c87	7e 	~
10348 2C88 47           	ld b,a			;2c88	47 	G
10349 2C89 23           	inc hl			;2c89	23 	#
10350 2C8A 7E           	ld a,(hl)			;2c8a	7e 	~
10351 2C8B 4F           	ld c,a			;2c8b	4f 	O
10352 2C8C 78           	ld a,b			;2c8c	78 	x
10353 2C8D CD BA 3A     	call sub_3abah		;2c8d	cd ba 3a 	. . :
10354 2C90 CD BA 3A     	call sub_3abah		;2c90	cd ba 3a 	. . :
10355 2C93 CD BA 3A     	call sub_3abah		;2c93	cd ba 3a 	. . :
10356 2C96 79           	ld a,c			;2c96	79 	y
10357 2C97 CD BA 3A     	call sub_3abah		;2c97	cd ba 3a 	. . :
10358 2C9A CD BA 3A     	call sub_3abah		;2c9a	cd ba 3a 	. . :
10359 2C9D CD BA 3A     	call sub_3abah		;2c9d	cd ba 3a 	. . :
10360 2CA0 E1           	pop hl			;2ca0	e1 	.
10361 2CA1 C1           	pop bc			;2ca1	c1 	.
10362 2CA2 3E 0F        	ld a,00fh		;2ca2	3e 0f 	> .
10363 2CA4 CD BA 3A     	call sub_3abah		;2ca4	cd ba 3a 	. . :
10364 2CA7 C9           	ret			;2ca7	c9 	.
10365 2CA8
10366 2CA8               ifdef VER_12
10367 2CA8 88           	adc a,b			;2ca8	88 	.
10368 2CA9 9A           	sbc a,d			;2ca9	9a 	.
10369 2CAA               else ; VER_20
10370 2CAA ~            	jr nc,$-97		;2ca8	30 9d 	0 .
10371 2CAA               endif
10372 2CAA
10373 2CAA
10374 2CAA              ; ********************************************************************************
10375 2CAA              ; [TRS] BASIC PEEK Entry Point
10376 2CAA              FuncPEEK
10377 2CAA CD 7F 0A     	call FuncCINT		; convert ACC to integer	;2caa	cd 7f 0a 	.  .
10378 2CAD 7E           	ld a,(hl)			;2cad	7e 	~
10379 2CAE C3 F8 27     	jp ByteToAcc	; Copy a to ACC		;2cae	c3 f8 27 	. . '
10380 2CB1
10381 2CB1
10382 2CB1              ; **********************************************************************************
10383 2CB1              ; BASIC POKE Entry Point
10384 2CB1              ; IN: hl - current executed command parser
10385 2CB1              ;     a - command byte
10386 2CB1              ;     Z = 1 - end of statement ('\0' or ':' found)
10387 2CB1              ;     CY = 1 - char is digit
10388 2CB1              CmdPOKE
10389 2CB1 CD 02 2B     	call EvalIntExpr	; load integer expression ito de register			;2cb1	cd 02 2b 	. . +
10390 2CB4 D5           	push de			;2cb4	d5 	.
10391 2CB5 CF           	rst $08			; Assert next token is ',' ;2cb5	cf 	.
10392 2CB6 2C           	defb ','		; Basic ',' token 	;2cb6	2c 	,
10393 2CB7 CD 1C 2B     	call EvalByteExpr	; expression ACC, de and a - must be 8bit value	;2cb7	cd 1c 2b 	. . +
10394 2CBA D1           	pop de			;2cba	d1 	.
10395 2CBB 12           	ld (de),a			;2cbb	12 	.
10396 2CBC C9           	ret			;2cbc	c9 	.
10397 2CBD              l2cbdh:
10398 2CBD CD 38 23     	call sub_2338h		;2cbd	cd 38 23 	. 8 #
10399 2CC0 CD F4 0A     	call AssertACCIsString	; Assert ACC contains String	;2cc0	cd f4 0a 	. . .
10400 2CC3 CF           	rst $08			; Assert next token is ';' ;2cc3	cf 	.
10401 2CC4 3B           	defb ';'		; Basic ';' token - End of statement	;2cc4	3b 	;
10402 2CC5 EB           	ex de,hl			;2cc5	eb 	.
10403 2CC6 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2cc6	2a 21 79 	* ! y
10404 2CC9 18 08        	jr l2cd3h		;2cc9	18 08 	. .
10405 2CCB              l2ccbh:
10406 2CCB 3A DE 78     	ld a,(BAS_PrintUsingDelim)	; delimiter for PRINT USING		;2ccb	3a de 78 	: . x
10407 2CCE B7           	or a			;2cce	b7 	.
10408 2CCF              l2ccfh:
10409 2CCF 28 0C        	jr z,l2cddh		;2ccf	28 0c 	( .
10410 2CD1 D1           	pop de			;2cd1	d1 	.
10411 2CD2 EB           	ex de,hl			;2cd2	eb 	.
10412 2CD3              l2cd3h:
10413 2CD3 E5           	push hl			;2cd3	e5 	.
10414 2CD4 AF           	xor a			;2cd4	af 	.
10415 2CD5 32 DE 78     	ld (BAS_PrintUsingDelim),a	; delimiter for PRINT USING		;2cd5	32 de 78 	2 . x
10416 2CD8 BA           	cp d			;2cd8	ba 	.
10417 2CD9 F5           	push af			;2cd9	f5 	.
10418 2CDA D5           	push de			;2cda	d5 	.
10419 2CDB 46           	ld b,(hl)			;2cdb	46 	F
10420 2CDC B0           	or b			;2cdc	b0 	.
10421 2CDD              l2cddh:
10422 2CDD CA 4A 1E     	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2cdd	ca 4a 1e 	. J .
10423 2CE0 23           	inc hl			;2ce0	23 	#
10424 2CE1 4E           	ld c,(hl)			;2ce1	4e 	N
10425 2CE2 23           	inc hl			;2ce2	23 	#
10426 2CE3 66           	ld h,(hl)			;2ce3	66 	f
10427 2CE4 69           	ld l,c			;2ce4	69 	i
10428 2CE5 18 1C        	jr l2d03h		;2ce5	18 1c 	. .
10429 2CE7              l2ce7h:
10430 2CE7 58           	ld e,b			;2ce7	58 	X
10431 2CE8 E5           	push hl			;2ce8	e5 	.
10432 2CE9 0E 02        	ld c,002h		;2ce9	0e 02 	. .
10433 2CEB              l2cebh:
10434 2CEB 7E           	ld a,(hl)			;2ceb	7e 	~
10435 2CEC 23           	inc hl			;2cec	23 	#
10436 2CED FE 25        	cp 025h		;2ced	fe 25 	. %
10437 2CEF CA 17 2E     	jp z,02e17h		;2cef	ca 17 2e 	. . .
10438 2CF2 FE 20        	cp 020h		;2cf2	fe 20 	.
10439 2CF4 20 03        	jr nz,l2cf9h		;2cf4	20 03 	  .
10440 2CF6 0C           	inc c			;2cf6	0c 	.
10441 2CF7 10 F2        	djnz l2cebh		;2cf7	10 f2 	. .
10442 2CF9              l2cf9h:
10443 2CF9 E1           	pop hl			;2cf9	e1 	.
10444 2CFA 43           	ld b,e			;2cfa	43 	C
10445 2CFB 3E 25        	ld a,025h		;2cfb	3e 25 	> %
10446 2CFD              l2cfdh:
10447 2CFD CD 49 2E     	call sub_2e49h		;2cfd	cd 49 2e 	. I .
10448 2D00 CD 2A 03     	call PrintChar	; Print  char on screen		;2d00	cd 2a 03 	. * .
10449 2D03              l2d03h:
10450 2D03 AF           	xor a			;2d03	af 	.
10451 2D04 5F           	ld e,a			;2d04	5f 	_
10452 2D05 57           	ld d,a			;2d05	57 	W
10453 2D06              l2d06h:
10454 2D06 CD 49 2E     	call sub_2e49h		;2d06	cd 49 2e 	. I .
10455 2D09 57           	ld d,a			;2d09	57 	W
10456 2D0A 7E           	ld a,(hl)			;2d0a	7e 	~
10457 2D0B 23           	inc hl			;2d0b	23 	#
10458 2D0C FE 21        	cp 021h		;2d0c	fe 21 	. !
10459 2D0E CA 14 2E     	jp z,l2e14h		;2d0e	ca 14 2e 	. . .
10460 2D11 FE 23        	cp 023h		;2d11	fe 23 	. #
10461 2D13 28 37        	jr z,l2d4ch		;2d13	28 37 	( 7
10462 2D15 05           	dec b			;2d15	05 	.
10463 2D16 CA FE 2D     	jp z,l2dfeh		;2d16	ca fe 2d 	. . -
10464 2D19 FE 2B        	cp 02bh		;2d19	fe 2b 	. +
10465 2D1B 3E 08        	ld a,008h		;2d1b	3e 08 	> .
10466 2D1D 28 E7        	jr z,l2d06h		;2d1d	28 e7 	( .
10467 2D1F 2B           	dec hl			;2d1f	2b 	+
10468 2D20 7E           	ld a,(hl)			;2d20	7e 	~
10469 2D21 23           	inc hl			;2d21	23 	#
10470 2D22 FE 2E        	cp 02eh		;2d22	fe 2e 	. .
10471 2D24 28 40        	jr z,l2d66h		;2d24	28 40 	( @
10472 2D26 FE 25        	cp 025h		;2d26	fe 25 	. %
10473 2D28 28 BD        	jr z,l2ce7h		;2d28	28 bd 	( .
10474 2D2A BE           	cp (hl)			;2d2a	be 	.
10475 2D2B 20 D0        	jr nz,l2cfdh		;2d2b	20 d0 	  .
10476 2D2D FE 24        	cp 024h		;2d2d	fe 24 	. $
10477 2D2F 28 14        	jr z,$+22		;2d2f	28 14 	( .
10478 2D31 FE 2A        	cp 02ah		;2d31	fe 2a 	. *
10479 2D33 20 C8        	jr nz,l2cfdh		;2d33	20 c8 	  .
10480 2D35 78           	ld a,b			;2d35	78 	x
10481 2D36 FE 02        	cp 002h		;2d36	fe 02 	. .
10482 2D38 23           	inc hl			;2d38	23 	#
10483 2D39 38 03        	jr c,l2d3eh		;2d39	38 03 	8 .
10484 2D3B 7E           	ld a,(hl)			;2d3b	7e 	~
10485 2D3C FE 24        	cp 024h		;2d3c	fe 24 	. $
10486 2D3E              l2d3eh:
10487 2D3E 3E 20        	ld a,020h		;2d3e	3e 20 	>
10488 2D40 20 07        	jr nz,l2d49h		;2d40	20 07 	  .
10489 2D42 05           	dec b			;2d42	05 	.
10490 2D43 1C           	inc e			;2d43	1c 	.
10491 2D44 FE AF        	cp 0afh		;2d44	fe af 	. .
10492 2D46 C6 10        	add a,010h		;2d46	c6 10 	. .
10493 2D48 23           	inc hl			;2d48	23 	#
10494 2D49              l2d49h:
10495 2D49 1C           	inc e			;2d49	1c 	.
10496 2D4A 82           	add a,d			;2d4a	82 	.
10497 2D4B 57           	ld d,a			;2d4b	57 	W
10498 2D4C              l2d4ch:
10499 2D4C 1C           	inc e			;2d4c	1c 	.
10500 2D4D 0E 00        	ld c,000h		;2d4d	0e 00 	. .
10501 2D4F 05           	dec b			;2d4f	05 	.
10502 2D50 28 47        	jr z,l2d99h		;2d50	28 47 	( G
10503 2D52 7E           	ld a,(hl)			;2d52	7e 	~
10504 2D53 23           	inc hl			;2d53	23 	#
10505 2D54 FE 2E        	cp 02eh		;2d54	fe 2e 	. .
10506 2D56 28 18        	jr z,l2d70h		;2d56	28 18 	( .
10507 2D58 FE 23        	cp 023h		;2d58	fe 23 	. #
10508 2D5A 28 F0        	jr z,l2d4ch		;2d5a	28 f0 	( .
10509 2D5C FE 2C        	cp 02ch		;2d5c	fe 2c 	. ,
10510 2D5E 20 1A        	jr nz,l2d7ah		;2d5e	20 1a 	  .
10511 2D60 7A           	ld a,d			;2d60	7a 	z
10512 2D61 F6 40        	or 040h		;2d61	f6 40 	. @
10513 2D63 57           	ld d,a			;2d63	57 	W
10514 2D64 18 E6        	jr l2d4ch		;2d64	18 e6 	. .
10515 2D66              l2d66h:
10516 2D66 7E           	ld a,(hl)			;2d66	7e 	~
10517 2D67 FE 23        	cp 023h		;2d67	fe 23 	. #
10518 2D69 3E 2E        	ld a,02eh		;2d69	3e 2e 	> .
10519 2D6B 20 90        	jr nz,l2cfdh		;2d6b	20 90 	  .
10520 2D6D 0E 01        	ld c,001h		;2d6d	0e 01 	. .
10521 2D6F 23           	inc hl			;2d6f	23 	#
10522 2D70              l2d70h:
10523 2D70 0C           	inc c			;2d70	0c 	.
10524 2D71 05           	dec b			;2d71	05 	.
10525 2D72 28 25        	jr z,l2d99h		;2d72	28 25 	( %
10526 2D74 7E           	ld a,(hl)			;2d74	7e 	~
10527 2D75 23           	inc hl			;2d75	23 	#
10528 2D76 FE 23        	cp 023h		;2d76	fe 23 	. #
10529 2D78 28 F6        	jr z,l2d70h		;2d78	28 f6 	( .
10530 2D7A              l2d7ah:
10531 2D7A D5           	push de			;2d7a	d5 	.
10532 2D7B 11 97 2D     	ld de,02d97h		;2d7b	11 97 2d 	. . -
10533 2D7E D5           	push de			;2d7e	d5 	.
10534 2D7F 54           	ld d,h			;2d7f	54 	T
10535 2D80 5D           	ld e,l			;2d80	5d 	]
10536 2D81 FE 5B        	cp 05bh		;2d81	fe 5b 	. [
10537 2D83 C0           	ret nz			;2d83	c0 	.
10538 2D84 BE           	cp (hl)			;2d84	be 	.
10539 2D85 C0           	ret nz			;2d85	c0 	.
10540 2D86 23           	inc hl			;2d86	23 	#
10541 2D87 BE           	cp (hl)			;2d87	be 	.
10542 2D88 C0           	ret nz			;2d88	c0 	.
10543 2D89 23           	inc hl			;2d89	23 	#
10544 2D8A BE           	cp (hl)			;2d8a	be 	.
10545 2D8B C0           	ret nz			;2d8b	c0 	.
10546 2D8C 23           	inc hl			;2d8c	23 	#
10547 2D8D 78           	ld a,b			;2d8d	78 	x
10548 2D8E D6 04        	sub 004h		;2d8e	d6 04 	. .
10549 2D90 D8           	ret c			;2d90	d8 	.
10550 2D91 D1           	pop de			;2d91	d1 	.
10551 2D92 D1           	pop de			;2d92	d1 	.
10552 2D93 47           	ld b,a			;2d93	47 	G
10553 2D94 14           	inc d			;2d94	14 	.
10554 2D95 23           	inc hl			;2d95	23 	#
10555 2D96 CA EB D1     	jp z,0d1ebh		;2d96	ca eb d1 	. . .
10556 2D99              l2d99h:
10557 2D99 7A           	ld a,d			;2d99	7a 	z
10558 2D9A 2B           	dec hl			;2d9a	2b 	+
10559 2D9B 1C           	inc e			;2d9b	1c 	.
10560 2D9C E6 08        	and 008h		;2d9c	e6 08 	. .
10561 2D9E 20 15        	jr nz,l2db5h		;2d9e	20 15 	  .
10562 2DA0 1D           	dec e			;2da0	1d 	.
10563 2DA1 78           	ld a,b			;2da1	78 	x
10564 2DA2 B7           	or a			;2da2	b7 	.
10565 2DA3 28 10        	jr z,l2db5h		;2da3	28 10 	( .
10566 2DA5 7E           	ld a,(hl)			;2da5	7e 	~
10567 2DA6 D6 2D        	sub 02dh		;2da6	d6 2d 	. -
10568 2DA8 28 06        	jr z,l2db0h		;2da8	28 06 	( .
10569 2DAA FE FE        	cp 0feh		;2daa	fe fe 	. .
10570 2DAC 20 07        	jr nz,l2db5h		;2dac	20 07 	  .
10571 2DAE 3E 08        	ld a,008h		;2dae	3e 08 	> .
10572 2DB0              l2db0h:
10573 2DB0 C6 04        	add a,004h		;2db0	c6 04 	. .
10574 2DB2 82           	add a,d			;2db2	82 	.
10575 2DB3 57           	ld d,a			;2db3	57 	W
10576 2DB4 05           	dec b			;2db4	05 	.
10577 2DB5              l2db5h:
10578 2DB5 E1           	pop hl			;2db5	e1 	.
10579 2DB6 F1           	pop af			;2db6	f1 	.
10580 2DB7 28 50        	jr z,l2e09h		;2db7	28 50 	( P
10581 2DB9 C5           	push bc			;2db9	c5 	.
10582 2DBA D5           	push de			;2dba	d5 	.
10583 2DBB CD 37 23     	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;2dbb	cd 37 23 	. 7 #
10584 2DBE D1           	pop de			;2dbe	d1 	.
10585 2DBF C1           	pop bc			;2dbf	c1 	.
10586 2DC0 C5           	push bc			;2dc0	c5 	.
10587 2DC1 E5           	push hl			;2dc1	e5 	.
10588 2DC2 43           	ld b,e			;2dc2	43 	C
10589 2DC3 78           	ld a,b			;2dc3	78 	x
10590 2DC4 81           	add a,c			;2dc4	81 	.
10591 2DC5 FE 19        	cp 019h		;2dc5	fe 19 	. .
10592 2DC7 D2 4A 1E     	jp nc,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2dc7	d2 4a 1e 	. J .
10593 2DCA 7A           	ld a,d			;2dca	7a 	z
10594 2DCB F6 80        	or 080h			; format flag (bit3) - force sign (+/-) in front ;2dcb	f6 80 	. .
10595 2DCD CD BE 0F     	call NumToStrFmt	; ; Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)		;2dcd	cd be 0f 	. . .
10596 2DD0 CD A7 28     	call PrintBasicStr	; print null termianted or quoted string from (hl) on Screen		;2dd0	cd a7 28 	. . (
10597 2DD3              l2dd3h:
10598 2DD3 E1           	pop hl			;2dd3	e1 	.
10599 2DD4 2B           	dec hl			;2dd4	2b 	+
10600 2DD5 D7           	rst $10			; move hl to next Basic token				;2dd5	d7 	.
10601 2DD6 37           	scf			;2dd6	37 	7
10602 2DD7 28 0D        	jr z,l2de6h		; jump if End of Statement found ;2dd7	28 0d 	( .
10603 2DD9 32 DE 78     	ld (BAS_PrintUsingDelim),a	; delimiter for PRINT USING		;2dd9	32 de 78 	2 . x
10604 2DDC FE 3B        	cp ';'		;2ddc	fe 3b 	. ;
10605 2DDE 28 05        	jr z,l2de5h		;2dde	28 05 	( .
10606 2DE0 FE 2C        	cp ','		            ; is it ',' char ? ;2de0	fe 2c 	. ,
10607 2DE2 C2 97 19     	jp nz,ErrRaiseSyntax	; no - Raise 'SYNTAX ERROR'	;2de2	c2 97 19 	. . .
10608 2DE5              l2de5h:
10609 2DE5 D7           	rst $10			; move hl to next Basic token				;2de5	d7 	.
10610 2DE6              l2de6h:
10611 2DE6 C1           	pop bc			;2de6	c1 	.
10612 2DE7 EB           	ex de,hl			;2de7	eb 	.
10613 2DE8 E1           	pop hl			;2de8	e1 	.
10614 2DE9 E5           	push hl			;2de9	e5 	.
10615 2DEA F5           	push af			;2dea	f5 	.
10616 2DEB D5           	push de			;2deb	d5 	.
10617 2DEC 7E           	ld a,(hl)			;2dec	7e 	~
10618 2DED 90           	sub b			;2ded	90 	.
10619 2DEE 23           	inc hl			;2dee	23 	#
10620 2DEF 4E           	ld c,(hl)			;2def	4e 	N
10621 2DF0 23           	inc hl			;2df0	23 	#
10622 2DF1 66           	ld h,(hl)			;2df1	66 	f
10623 2DF2 69           	ld l,c			;2df2	69 	i
10624 2DF3 16 00        	ld d,000h		;2df3	16 00 	. .
10625 2DF5 5F           	ld e,a			;2df5	5f 	_
10626 2DF6 19           	add hl,de			;2df6	19 	.
10627 2DF7 78           	ld a,b			;2df7	78 	x
10628 2DF8 B7           	or a			;2df8	b7 	.
10629 2DF9 C2 03 2D     	jp nz,l2d03h		;2df9	c2 03 2d 	. . -
10630 2DFC 18 06        	jr l2e04h		;2dfc	18 06 	. .
10631 2DFE              l2dfeh:
10632 2DFE CD 49 2E     	call sub_2e49h		;2dfe	cd 49 2e 	. I .
10633 2E01 CD 2A 03     	call PrintChar	; Print char on screen		;2e01	cd 2a 03 	. * .
10634 2E04              l2e04h:
10635 2E04 E1           	pop hl			;2e04	e1 	.
10636 2E05 F1           	pop af			;2e05	f1 	.
10637 2E06 C2 CB 2C     	jp nz,l2ccbh		;2e06	c2 cb 2c 	. . ,
10638 2E09              l2e09h:
10639 2E09 DC FE 20     	call c,PrintCR	; Print CR on screen 	;2e09	dc fe 20 	. .
10640 2E0C E3           	ex (sp),hl			;2e0c	e3 	.
10641 2E0D CD DD 29     	call sub_29ddh		;2e0d	cd dd 29 	. . )
10642 2E10 E1           	pop hl			;2e10	e1 	.
10643 2E11 C3 69 21     	jp SysSetOutAsScreen		;2e11	c3 69 21 	. i !
10644 2E14              l2e14h:
10645 2E14 0E 01        	ld c,001h		;2e14	0e 01 	. .
10646 2E16 3E F1        	ld a,0f1h		;2e16	3e f1 	> .
10647 2E18 05           	dec b			;2e18	05 	.
10648 2E19 CD 49 2E     	call sub_2e49h		;2e19	cd 49 2e 	. I .
10649 2E1C E1           	pop hl			;2e1c	e1 	.
10650 2E1D F1           	pop af			;2e1d	f1 	.
10651 2E1E 28 E9        	jr z,l2e09h		;2e1e	28 e9 	( .
10652 2E20 C5           	push bc			;2e20	c5 	.
10653 2E21 CD 37 23     	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;2e21	cd 37 23 	. 7 #
10654 2E24 CD F4 0A     	call AssertACCIsString	; Assert ACC contains String	;2e24	cd f4 0a 	. . .
10655 2E27 C1           	pop bc			;2e27	c1 	.
10656 2E28 C5           	push bc			;2e28	c5 	.
10657 2E29 E5           	push hl			;2e29	e5 	.
10658 2E2A 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2e2a	2a 21 79 	* ! y
10659 2E2D 41           	ld b,c			;2e2d	41 	A
10660 2E2E 0E 00        	ld c,000h		;2e2e	0e 00 	. .
10661 2E30 C5           	push bc			;2e30	c5 	.
10662 2E31 CD 68 2A     	call 02a68h		;2e31	cd 68 2a 	. h *
10663 2E34 CD AA 28     	call PrintACCStr; print Basic String from ACC on screen			;2e34	cd aa 28 	. . (
10664 2E37 2A 21 79     	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2e37	2a 21 79 	* ! y
10665 2E3A F1           	pop af			;2e3a	f1 	.
10666 2E3B 96           	sub (hl)			;2e3b	96 	.
10667 2E3C 47           	ld b,a			;2e3c	47 	G
10668 2E3D 3E 20        	ld a,020h		;2e3d	3e 20 	>
10669 2E3F 04           	inc b			;2e3f	04 	.
10670 2E40              l2e40h:
10671 2E40 05           	dec b			;2e40	05 	.
10672 2E41 CA D3 2D     	jp z,l2dd3h		;2e41	ca d3 2d 	. . -
10673 2E44 CD 2A 03     	call PrintChar	; Print  char on screen		;2e44	cd 2a 03 	. * .
10674 2E47 18 F7        	jr l2e40h		;2e47	18 f7 	. .
10675 2E49              sub_2e49h:
10676 2E49 F5           	push af			;2e49	f5 	.
10677 2E4A 7A           	ld a,d			;2e4a	7a 	z
10678 2E4B B7           	or a			;2e4b	b7 	.
10679 2E4C 3E 2B        	ld a,'+'		;2e4c	3e 2b 	> +
10680 2E4E C4 2A 03     	call nz,PrintChar	; Print '+' char on screen		;2e4e	c4 2a 03 	. * .
10681 2E51 F1           	pop af			;2e51	f1 	.
10682 2E52 C9           	ret			;2e52	c9 	.
10683 2E53              ; IN: bc - start of Basic Line record
10684 2E53              PrintBasicLine:
10685 2E53              ; -- copy Basic Line Record address from bc to hl
10686 2E53 60           	ld h,b			    ; High Byte of Basic Line address                       ;2e53	60 	`
10687 2E54 69           	ld l,c			    ; Low Byte of Basic Line address                        ;2e54	69 	i
10688 2E55              ; -- skip header data: Next Line Address and Line Number
10689 2E55 23           	inc hl			    ; skip Low Byte of Next Line Address                    ;2e55	23 	#
10690 2E56 23           	inc hl			    ; skip High Byte of Next Line Address                   ;2e56	23 	#
10691 2E57 23           	inc hl			    ; skip Low Byte of Line Number                          ;2e57	23 	#
10692 2E58 23           	inc hl			    ; skip High Byte of Line Number                         ;2e58	23 	#
10693 2E59 CD 7E 2B     	call DetokenizeLine	; detokenize Basic Line into LineBuffer	                ;2e59	cd 7e 2b 	. ~ +
10694 2E5C 2A A7 78     	ld hl,(LINEBUFPTR)	; address of Line Buffer with text of Basic Line	    ;2e5c	2a a7 78 	* . x
10695 2E5F CD 75 2B     	call PrintCStr	    ; Print Line Buffer to screen or printer	            ;2e5f	cd 75 2b 	. u +
10696 2E62 C9           	ret			        ; ----------------- End of Proc ----------------------- ;2e62	c9 	.
10697 2E63
10698 2E63
10699 2E63              ; ****************************************************************************************
10700 2E63              ; BASIC MODE Entry Point
10701 2E63              ; IN: hl - current executed command parser
10702 2E63              ;     a - command byte
10703 2E63              ;     Z = 1 - end of statement ('\0' or ':' found)
10704 2E63              ;     CY = 1 - char is digit
10705 2E63              CmdMODE
10706 2E63              ; -- assert next char is '('
10707 2E63 CF           	rst $08				; Assert next token is '(' 								;2e63	cf 	.
10708 2E64 28           	defb '('			; Basic '(' token 										;2e64	28 cd 	( .
10709 2E65              ; -- parse argument
10710 2E65 CD 1C 2B     	call EvalByteExpr	; expression ACC, de and a - must be 8bit value			;2e65	cd 1c 2b	.
10711 2E68 B7           	or a				; test if argument is '0'?								;2e68	b7 	.
10712 2E69 28 12        	jr z,.mode0			; yes - MODE(0)											;2e69	28 12 	( .
10713 2E6B 3D           	dec a				; test if argument is '1'?								;2e6b	3d 	=
10714 2E6C 28 03        	jr z,.mode1			; yes - MODE (1)										;2e6c	28 03 	( .
10715 2E6E              ; -- invalid argument value
10716 2E6E C3 4A 1E     	jp ErrRaiseFuncCode	; raise FUNCTION CODE Error	---------------------------	;2e6e	c3 4a 1e 	. J .
10717 2E71              .mode1:
10718 2E71 16 00        	ld d,$00			; byte to fill VRAM - all pixels off					;2e71	16 00 	. .
10719 2E73 3A 3B 78     	ld a,(IOLATCH_COPY)	; get last value written to IO_LATCH  					;2e73	3a 3b 78 	: ; x
10720 2E76 F6 08        	or %00001000		; set bit 3 - Gfx Mode 1 								;2e76	f6 08 	. .
10721 2E78 32 3B 78     	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH				;2e78	32 3b 78 	2 ; x
10722 2E7B 18 0A        	jr .commit			; commit change to hardware register					;2e7b	18 0a 	. .
10723 2E7D              .mode0:
10724 2E7D 16 20        	ld d,020h			; char to fill VRAM - Space char						;2e7d	16 20 	.
10725 2E7F 3A 3B 78     	ld a,(IOLATCH_COPY)	; get last value written to IO_LATCH  					;2e7f	3a 3b 78 	: ; x
10726 2E82 E6 F7        	and %11110111		; clear bit 3 - Gfx Mode 0 								;2e82	e6 f7 	. .
10727 2E84 32 3B 78     	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH				;2e84	32 3b 78 	2 ; x
10728 2E87              .commit:
10729 2E87 32 00 68     	ld (IO_LATCH),a		; store in hardware register							;2e87	32 00 68 	2 . h
10730 2E8A              ; -- mode changed - clear screen (fiil VRAM with predefined char/byte)
10731 2E8A E5           	push hl				; save hl												;2e8a	e5 	.
10732 2E8B 21 00 70     	ld hl,VRAM			; hl - start of screen memory							;2e8b	21 00 70 	! . p
10733 2E8E 01 00 08     	ld bc,$800			; 2k bytes of whole VRAM								;2e8e	01 00 08 	. . .
10734 2E91              .next:
10735 2E91 7A           	ld a,d				; a - char/byte to fill VRAM							;2e91	7a 	z
10736 2E92 77           	ld (hl),a			; set byte in VRAM										;2e92	77 	w
10737 2E93 23           	inc hl				; points to next byte									;2e93	23 	#
10738 2E94 0B           	dec bc				; decrement byte counter 								;2e94	0b 	.
10739 2E95 78           	ld a,b				; high byte of counter									;2e95	78 	x
10740 2E96 B1           	or c				; is it 0 ?												;2e96	b1 	.
10741 2E97 20 F8        	jr nz,.next			; no - fill all 2048 bytes								;2e97	20 f8 	  .
10742 2E99 E1           	pop hl				; restore hl 											;2e99	e1 	.
10743 2E9A              ; -- assert next token is ')'
10744 2E9A CF           	rst $08				; Assert next token is ')' 								;2e9a	cf 	.
10745 2E9B 29           	defb ')'			; Basic ')' token 										;2e9b	29 	)
10746 2E9C C9           	ret					; ----------------- End of Proc -----------------------	;2e9c	c9 	.
10747 2E9D
10748 2E9D
10749 2E9D              ; (cont) Detokenize line
10750 2E9D              ; IN: a - char or token from basic line (also stored in Edit Buffer)
10751 2E9D              ;     hl - (src) address of next char
10752 2E9D              ;     bc - (dst) address of current char in Buffer
10753 2E9D              l2e9dh:
10754 2E9D              ; -- check if it is string literal
10755 2E9D FE 22        	cp '"'				; is it '"' (start of string literal)?					;2e9d	fe 22 	. "
10756 2E9F CA B3 2E     	jp z,l2eb3h			; yes - copy chars until '\0' or '"' found				;2e9f	ca b3 2e 	. . .
10757 2EA2              ; -- can be token when (a < 0) or char (literal data)
10758 2EA2 B7           	or a				; is it Basic Token (a < 0 or bit7 is set)?				;2ea2	b7 	.
10759 2EA3 F2 89 2B     	jp p,l2b89h			; no - process as char data 							;2ea3	f2 89 2b 	. . +
10760 2EA6 C3 94 2B     	jp l2b94h			; yes - process as Basic Token							;2ea6	c3 94 2b 	. . +
10761 2EA9              l2ea9h:
10762 2EA9 7E           	ld a,(hl)			; a - char from Bacic line								;2ea9	7e 	~
10763 2EAA B7           	or a				; is it '\0' (end of line)?								;2eaa	b7 	.
10764 2EAB 23           	inc hl				; points to next char of string							;2eab	23 	#
10765 2EAC 02           	ld (bc),a			; store char in destination Buffer						;2eac	02 	.
10766 2EAD C8           	ret z				; yes (end of line) -------- End of Proc --------------	;2ead	c8 	.
10767 2EAE FE 22        	cp '"'				; is it '"' (end of string literal)?					;2eae	fe 22 	. "
10768 2EB0 CA 89 2B     	jp z,l2b89h			; yes - ;2eb0	ca 89 2b 	. . +
10769 2EB3
10770 2EB3              l2eb3h:
10771 2EB3 03           	inc bc				; points to next address in Buffer (dst) 				;2eb3	03 	.
10772 2EB4 15           	dec d				; decrement number of chars left in destination Buffer 	;2eb4	15 	.
10773 2EB5 C8           	ret z				; none left ----------- End of Proc -------------------	;2eb5	c8 	.
10774 2EB6 18 F1        	jr l2ea9h			; ;2eb6	18 f1 	. .
10775 2EB8
10776 2EB8
10777 2EB8
10778 2EB8              ; ****************************************************************************
10779 2EB8              ; Main Interrupt Handler
10780 2EB8              CpuINTHandler:
10781 2EB8              ; Save Cpu Registers
10782 2EB8 F5           	push af				; save AF on stack 									;2eb8	f5 	.
10783 2EB9 C5           	push bc				; save BC on stack 									;2eb9	c5 	.
10784 2EBA D5           	push de				; save DE on stack									;2eba	d5 	.
10785 2EBB E5           	push hl				; save HL on stack									;2ebb	e5 	.
10786 2EBC              ; -- call System Update routines
10787 2EBC CD 7D 78     	call OnCpuINT		; call extension hook								;2ebc	cd 7d 78 	. } x
10788 2EBF               ifdef VER_12
10789 2EBF CD E8 30     	call sub_30e8h		;2ebf	cd e8 30 	. . 0
10790 2EC2               else
10791 2EC2 ~             	call sub_3f7bh		;2ebf	cd 7b 3f 	. { ?
10792 2EC2               endif
10793 2EC2
10794 2EC2
10795 2EC2 CD DC 2E     	call sub_2edch		;2ec2	cd dc 2e 	. . .
10796 2EC5 CD FD 2E     	call l2efdh		;2ec5	cd fd 2e 	. . .
10797 2EC8
10798 2EC8
10799 2EC8
10800 2EC8              ; --
10801 2EC8 F5           	push af				; save af											;2ec8	f5 	.
10802 2EC9 21 39 78     	ld hl,SYSFLAGS	; System flags	;2ec9	21 39 78 	! 9 x
10803 2ECC CB 46        	bit 0,(hl)		;2ecc	cb 46 	. F
10804 2ECE CC 1B 30     	call z,sub_301bh		;2ece	cc 1b 30 	. . 0
10805 2ED1 F1           	pop af				; restore af										;2ed1	f1 	.
10806 2ED2 CD 30 34     	call sub_3430h		;2ed2	cd 30 34 	. 0 4
10807 2ED5 E1           	pop hl			;2ed5	e1 	.
10808 2ED6 D1           	pop de			;2ed6	d1 	.
10809 2ED7 C1           	pop bc			;2ed7	c1 	.
10810 2ED8 F1           	pop af			;2ed8	f1 	.
10811 2ED9 FB           	ei			;2ed9	fb 	.
10812 2EDA ED 4D        	reti		;2eda	ed 4d 	. M
10813 2EDC              sub_2edch:
10814 2EDC 3A 39 78     	ld a,(SYSFLAGS)		;2edc	3a 39 78 	: 9 x
10815 2EDF CB 47        	bit 0,a		;2edf	cb 47 	. G
10816 2EE1 C0           	ret nz			;2ee1	c0 	.
10817 2EE2              ; -- decrement Cursor Inverse Timer
10818 2EE2 21 41 78     	ld hl,CURSORTIMER	; timer for inverse char under cursor					;2ee2	21 41 78 	! A x
10819 2EE5 35           	dec (hl)			; decrement timer - time for inverse?					;2ee5	35 	5
10820 2EE6 C0           	ret nz				; no -------------------- End of Proc -----------------	;2ee6	c0 	.
10821 2EE7              ; -- reset timer
10822 2EE7 3E 10        	ld a,16				; initial timer value									;2ee7	3e 10 	> .
10823 2EE9 32 41 78     	ld (CURSORTIMER),a	; reset timer											;2ee9	32 41 78 	2 A x
10824 2EEC              ; -- inverse char under cursor
10825 2EEC 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 								;2eec	2a 20 78 	*   x
10826 2EEF 3E 40        	ld a,%01000000		; bit 6 of char (char inverse color) 					;2eef	3e 40 	> @
10827 2EF1 AE           	xor (hl)			; a - inverted char										;2ef1	ae 	.
10828 2EF2 77           	ld (hl),a			; store directly in VRAM								;2ef2	77 	w
10829 2EF3 C9           	ret					; ----------------------- End of Proc -----------------	;2ef3	c9 	.
10830 2EF4
10831 2EF4
10832 2EF4
10833 2EF4              ; *****************************************************************************
10834 2EF4              					ASSERT($==$2ef4)
10835 2EF4              // Keyboard Device Handler
10836 2EF4              ; IN: ix - Keyboard Device Control Block address
10837 2EF4              ;     FLAGS -
10838 2EF4              KBD_DevHandler:
10839 2EF4 CD FD 2E     	call l2efdh		;2ef4	cd fd 2e 	. . .
10840 2EF7 F5           	push af			;2ef7	f5 	.
10841 2EF8 CD 0E 2F     	call sub_2f0eh		;2ef8	cd 0e 2f 	. . /
10842 2EFB F1           	pop af			;2efb	f1 	.
10843 2EFC C9           	ret			;2efc	c9 	.
10844 2EFD
10845 2EFD
10846 2EFD              l2efdh:
10847 2EFD 3A 00 68     	ld a,(KEYS_MATRIX)		; read all keys at once								;2efd	3a 00 68 	: . h
10848 2F00 F6 C0        	or %11000000			; set bits 7,6 (not used by keyboards)				;2f00	f6 c0 	. .
10849 2F02 2F           	cpl						; invert bits (pressed key makes bit set now)		;2f02	2f 	/
10850 2F03 FE 00        	cp %00000000			; check if any key is pressed (0 means none)		;2f03	fe 00 	. .
10851 2F05 28 07        	jr z,sub_2f0eh			; no - ;2f05	28 07 	( .
10852 2F07              ; -- some key(s) pressed
10853 2F07 CD 28 2F     	call ScanKeyMatrix		; scan Keyboard Matrix								;2f07	cd 28 2f 	. ( /
10854 2F0A B7           	or a					; is Key detected (except Shift, Ctrl, Function)	;2f0a	b7 	.
10855 2F0B C2 D7 05     	jp nz,l05d7h			; yes - ;2f0b	c2 d7 05 	. . .
10856 2F0E
10857 2F0E              sub_2f0eh:
10858 2F0E 21 38 78     	ld hl,KEYSFLAGS	    ; Keyboard's current State						;2f0e	21 38 78 	! 8 x
10859 2F11 CB 56        	bit 2,(hl)				; is FUNCTION mode active							;2f11	cb 56 	. V
10860 2F13 28 08        	jr z,l2f1dh				; no - ;2f13	28 08 	( .
10861 2F15 3A 3A 78     	ld a,(KEYS_DEBOUNCER)	; read Key Debounce Counter							;2f15	3a 3a 78 	: : x
10862 2F18 B7           	or a					; is any Key pressed but not reported yet (a > 0)	;2f18	b7 	.
10863 2F19 28 02        	jr z,l2f1dh				; no - ;2f19	28 02 	( .
10864 2F1B              ; -- yes - we have incomming Key
10865 2F1B CB 96        	res 2,(hl)				; clear Key Modifier bit 2 - FUNCTION not active	;2f1b	cb 96 	. .
10866 2F1D              l2f1dh:
10867 2F1D 7E           	ld a,(hl)				; read Key Modifier									;2f1d	7e 	~
10868 2F1E E6 06        	and %00000110			; clear except Function and ??? 					;2f1e	e6 06 	. .
10869 2F20 32 38 78     	ld (KEYSFLAGS),a	; save changed modifiers							;2f20	32 38 78 	2 8 x
10870 2F23 AF           	xor a				;2f23	af 	.
10871 2F24 32 36 78     	ld (KEYCODE1),a		;2f24	32 36 78 	2 6 x
10872 2F27 C9           	ret			;2f27	c9 	.
10873 2F28
10874 2F28              // ************************************************************************
10875 2F28              ; Scan Keyboard Matrix
10876 2F28              ScanKeyMatrix:
10877 2F28 21 FE 68     	ld hl,KEYS_ROW_0	; start with selecting Keyboard Row 0							;2f28	21 fe 68 	! . h
10878 2F2B 0E 08        	ld c,8				; number of Keyboard Rows to scan 								;2f2b	0e 08 	. .
10879 2F2D              l2f2dh:
10880 2F2D 06 06        	ld b,6				; number of Keyboard Columns (bits) to scan						;2f2d	06 06 	. .
10881 2F2F 7E           	ld a,(hl)			; read Keyboard Row (pressed key makes bit 0)					;2f2f	7e 	~
10882 2F30 F6 04        	or %00000100		; ignore bit 3 (keys CTRL, SHIFT, RETURN, :)					;2f30	f6 04 	. .
10883 2F32              l2f32h:
10884 2F32 1F           	rra					; rotate byte - bit 0 into CY									;2f32	1f 	.
10885 2F33 30 2D        	jr nc,l2f62h		; jump if bit 0 - key pressed 									;2f33	30 2d 	0 -
10886 2F35              ; IN: c - Keyboard Row (8..1)
10887 2F35              ;     b - bit number (6..1)
10888 2F35              ;     hl - Keyborad Matrix Row address
10889 2F35              sub_2f35h:
10890 2F35 10 FB        	djnz l2f32h			; check next bit in current row									;2f35	10 fb 	. .
10891 2F37              ; -- all bits checked in this row - calculate next row address
10892 2F37 CB 05        	rlc l				; shift bits in address LSB (ie: FE => FD, BF => 7F, etc) 		;2f37	cb 05 	. .
10893 2F39 0D           	dec c				; decrement current Keyboard Row and check if 0 (all scanned)	;2f39	0d 	.
10894 2F3A 20 F1        	jr nz,l2f2dh		; repeat scan for all 8 rows									;2f3a	20 f1 	  .
10895 2F3C              ; -- all Keyboard Rows scanned - check extra keys: ':','-' and RETURN
10896 2F3C 06 04        	ld b,4				; set bit number to 4 											;2f3c	06 04 	. .
10897 2F3E 21 DF 68     	ld hl,KEYS_ROW_5	; select Keyboard row with '-'									;2f3e	21 df 68 	! . h
10898 2F41 7E           	ld a,(hl)			; read Keyboard Row												;2f41	7e 	~
10899 2F42 CB 57        	bit 2,a				; is '-' key pressed											;2f42	cb 57 	. W
10900 2F44 28 10        	jr z,l2f56h			; yes - set row and bits, convert to Ascii and Exit 			;2f44	28 10 	( .
10901 2F46 CB 05        	rlc l				; shift bits in address => select Keyboard Row with RETURN		;2f46	cb 05 	. .
10902 2F48 7E           	ld a,(hl)			; read Keyboard row												;2f48	7e 	~
10903 2F49 CB 57        	bit 2,a				; is RETURN pressed												;2f49	cb 57 	. W
10904 2F4B 28 0D        	jr z,l2f5ah			; yes - set row and bits, convert to Ascii and Exit				;2f4b	28 0d 	( .
10905 2F4D CB 05        	rlc l				; shift bits in address => select Keyboard Row with ':'			;2f4d	cb 05 	. .
10906 2F4F 7E           	ld a,(hl)			; read Keyboard row												;2f4f	7e 	~
10907 2F50 CB 57        	bit 2,a				; is ':' key pressed											;2f50	cb 57 	. W
10908 2F52 28 0A        	jr z,l2f5eh			; yes - set row and bits, convert to Ascii and Exit				;2f52	28 0a 	( .
10909 2F54 AF           	xor a				; set return value 0 - no key pressed							;2f54	af 	.
10910 2F55 C9           	ret					; ------------------ End of Proc ------------------------------	;2f55	c9 	.
10911 2F56              l2f56h:
10912 2F56 0E 03        	ld c,3				; set keyboard row 3 (with '-' char)							;2f56	0e 03 	. .
10913 2F58 18 06        	jr l2f60h			; set bit 2 - detected key '-'									;2f58	18 06 	. .
10914 2F5A              l2f5ah:
10915 2F5A 0E 02        	ld c,2				; set keyboard row 2 (with RETURN key)							;2f5a	0e 02 	. .
10916 2F5C 18 02        	jr l2f60h			; set bit 2 - detected Key RETURN								;2f5c	18 02 	. .
10917 2F5E              l2f5eh:
10918 2F5E 0E 01        	ld c,1			; set keyboard row 1 (with ':' key)							;2f5e	0e 01 	. .
10919 2F60              l2f60h:
10920 2F60 F6 04        	or %00000100	; set bit 2 - detected key (':','-' or RETURN)				;2f60	f6 04 	. .
10921 2F62
10922 2F62
10923 2F62              ; ************************************************************************************
10924 2F62              ; Key Pressed
10925 2F62              ; IN: b - bit number (6..1)
10926 2F62              ;	  c - row number (8..1)
10927 2F62              ;	  hl - address of Keyboard row scanned
10928 2F62              ;     a - bits read from Keyboard row
10929 2F62              ;     CY - 0 (key pressed)
10930 2F62              l2f62h:
10931 2F62 5F           	ld e,a			; save a - bits read from Keyboard Row					;2f62	5f 	_
10932 2F63              ; calculate scan code byte: bits 7-3 - bit number, bits 2-0 - matrix row
10933 2F63
10934 2F63              ; -- normalize bit number
10935 2F63 3E 06        	ld a,6			; normalize bit number from (6..1) to (0..5)				;2f63	3e 06 	> .
10936 2F65 90           	sub b			; a - bit number for pressed key (0..5)						;2f65	90 	.
10937 2F66 CB 27        	sla a			; shift left bit number 										;2f66	cb 27 	. '
10938 2F68 CB 27        	sla a			; shift left bit number 										;2f68	cb 27 	. '
10939 2F6A CB 27        	sla a			; shift left bit number => bit number on bits 7-3				;2f6a	cb 27 	. '
10940 2F6C              ; -- normalize row number and add to scan code
10941 2F6C C6 08        	add a,8			; normalize row number from (8..1) to (0..7)					;2f6c	c6 08 	. .
10942 2F6E 91           	sub c			; a - scan code with row and bit number							;2f6e	91 	.
10943 2F6F
10944 2F6F              ; -- save data about detected key
10945 2F6F ED 43 42 78  	ld (KEYS_SCAN_COORDS),bc		; b - bit number (6..1), c - row number (8..1)					;2f6f	ed 43 42 78 	. C B x
10946 2F73 22 44 78     	ld (KEYS_SCAN_ROWADR),hl		; save address of Keyboard row with scanned key	;2f73	22 44 78 	" D x
10947 2F76
10948 2F76              ; -- determine proper Key to Ascii/Command Table
10949 2F76 21 D9 01     	ld hl,TabKey2Char		; normal ScanCode to ASCII Table (default)				;2f76	21 d9 01 	! . .
10950 2F79 4F           	ld c,a					; copy ScanCode to C											;2f79	4f 	O
10951 2F7A 06 00        	ld b,0					; bc - key index in ScanCode to Ascii Table						;2f7a	06 00 	. .
10952 2F7C              ; -- check if Shift Key is pressed
10953 2F7C 3A FB 68     	ld a,(KEYS_ROW_SHIFT)	; read keyboard row with Shift Key						;2f7c	3a fb 68 	: . h
10954 2F7F CB 57        	bit 2,a					; is Shift pressed										;2f7f	cb 57 	. W
10955 2F81 20 0A        	jr nz,.CheckCTRLKey		; no - check Ctrl Key									;2f81	20 0a 	  .
10956 2F83              ; -- mark Shift Modifier Active
10957 2F83 21 38 78     	ld hl,KEYSFLAGS	    ; Keyboard current State											;2f83	21 38 78 	! 8 x
10958 2F86 CB C6        	set 0,(hl)				; set bit 0 (Shift is pressed)									;2f86	cb c6 	. .
10959 2F88 21 09 02     	ld hl,TabShiftKey2Char	; Shift ScanCode to ASCII Table							;2f88	21 09 02 	! . .
10960 2F8B 18 3D        	jr l2fcah_ExitWithKey	; convert Key to Char and return to caller 	            ;2f8b	18 3d 	. =
10961 2F8D              .CheckCTRLKey:
10962 2F8D 3A FD 68     	ld a,(KROW_CTRL)	; read keyboard row with Ctrl Key						;2f8d	3a fd 68 	: . h
10963 2F90 CB 57        	bit 2,a					; is Ctrl pressed										;2f90	cb 57 	. W
10964 2F92 20 39        	jr nz,l2fcdh			; no - ;2f92	20 39 	  9
10965 2F94              ; -- Ctrl Key is pressed
10966 2F94 3A 7F 68     	ld a,(KEYS_ROW_INVERSE)	; read keyboard row with Inverse Key					;2f94	3a 7f 68 	:  h
10967 2F97 CB 57        	bit 2,a					; is Inverse also pressed								;2f97	cb 57 	. W
10968 2F99 20 0E        	jr nz,l2fa9h			; no - ;2f99	20 0e 	  .
10969 2F9B              ; -- Ctrl + Inverse is pressed
10970 2F9B 21 38 78     	ld hl,KEYSFLAGS	    ; Keyboard current State								;2f9b	21 38 78 	! 8 x
10971 2F9E CB 6E        	bit 5,(hl)				; is bit 5 (???) set? ;2f9e	cb 6e 	. n
10972 2FA0 20 04        	jr nz,l2fa6h_Exit_noKey	; no - exit with no key pressed	                        ;2fa0	20 04 	  .
10973 2FA2              ; flip bit 1 and 5
10974 2FA2 7E           	ld a,(hl)				; a - Keyboard current State										;2fa2	7e 	~
10975 2FA3 EE 22        	xor %00100010			; flip (clear) bits 1 and 5										;2fa3	ee 22 	. "
10976 2FA5 77           	ld (hl),a				; store new value										;2fa5	77 	w
10977 2FA6              l2fa6h_Exit_noKey:
10978 2FA6 AF           	xor a					; set return value 0 (no key pressed)					;2fa6	af 	.
10979 2FA7 C1           	pop bc					; restore BC											;2fa7	c1 	.
10980 2FA8 C9           	ret						; ---------- End of Proc ------------------------------ ;2fa8	c9 	.
10981 2FA9
10982 2FA9              ; -- Ctrl key is pressed
10983 2FA9              l2fa9h:
10984 2FA9 21 38 78     	ld hl,KEYSFLAGS	    ; Keyboard current State								;2fa9	21 38 78 	! 8 x
10985 2FAC CB FE        	set 7,(hl)				; set bit 7 (CTRL is pressed)						    ;2fac	cb fe 	. .
10986 2FAE CB 56        	bit 2,(hl)				; check if bit 2 (Function) is active					;2fae	cb 56 	. V
10987 2FB0 28 05        	jr z,.CheckCtrlFunc		; no - check if now Function (RETURN) is pressed        ;2fb0	28 05 	( .
10988 2FB2
10989 2FB2              ; -- Function Mode is Active - convert Key to BASIC Funcion byte and Exit
10990 2FB2 21 69 02     	ld hl,TabCtrlKey2Func	; Control Key to BASIC Function Table					;2fb2	21 69 02 	! i .
10991 2FB5 18 13        	jr l2fcah_ExitWithKey	; convert Key to Function and return to caller			;2fb5	18 13 	. .
10992 2FB7
10993 2FB7              ; -- Ctrl key is pressed (Function Inactive)
10994 2FB7              .CheckCtrlFunc:
10995 2FB7 3A BF 68     	ld a,(KEYS_ROW_RETURN)	; read keyboard row with RETURN/FUNCTION Key			;2fb7	3a bf 68 	: . h
10996 2FBA CB 57        	bit 2,a					; is RETURN + Ctrl pressed (FUNCTION)					;2fba	cb 57 	. W
10997 2FBC 20 07        	jr nz,.ExitWithCtrlAndKey; no - set FUNCTION Inactive and get just Ctrl+Key		;2fbc	20 07 	  .
10998 2FBE              ; -- mark FUNCTION pressed
10999 2FBE CB D6        	set 2,(hl)				; set bit 2 (FUNCTION is Active)			            ;2fbe	cb d6 	. .
11000 2FC0 AF           	xor a					; set return value 0 - no key pressed					;2fc0	af 	.
11001 2FC1 32 3A 78     	ld (KEYS_DEBOUNCER),a	; reset Key Debounce Counter							;2fc1	32 3a 78 	2 : x
11002 2FC4 C9           	ret						; return to caller - no key pressed						;2fc4	c9 	.
11003 2FC5              .ExitWithCtrlAndKey:
11004 2FC5 CB 96        	res 2,(hl)				; clear Key Modifier bit 2 - FUNCTION is not active 	;2fc5	cb 96 	. .
11005 2FC7 21 39 02     	ld hl,TabCtrlKey2Cmd	; convert Key to BASIC Command and return to caller	;2fc7	21 39 02 	! 9 .
11006 2FCA              l2fcah_ExitWithKey:
11007 2FCA              ; IN: hl - address of Key to Char Conversion Table
11008 2FCA              ;     bc - index of key (scancode)
11009 2FCA 09           	add hl,bc			; calculate address of Char for Key pressed					;2fca	09 	.
11010 2FCB 7E           	ld a,(hl)			; a - Char from Keyboard									;2fcb	7e 	~
11011 2FCC C9           	ret					; ----------- End of Proc --------------------------------- ;2fcc	c9 	.
11012 2FCD
11013 2FCD              ; both Shift and Ctrl aren't pressed at this time
11014 2FCD              l2fcdh:
11015 2FCD 3A 38 78     	ld a,(KEYSFLAGS)	    ; get Keyboard current State							;2fcd	3a 38 78 	: 8 x
11016 2FD0 E6 81        	and %10000001			; check bit 7 (CTRL) and bit 0 (Shift)					;2fd0	e6 81 	. .
11017 2FD2 28 F6        	jr z,l2fcah_ExitWithKey	; none - get Char from table and Exit					;2fd2	28 f6 	( .
11018 2FD4 AF           	xor a					; set no key pressed									;2fd4	af 	.
11019 2FD5 E1           	pop hl			;2fd5	e1 	.
11020 2FD6 C9           	ret			;2fd6	c9 	.
11021 2FD7              l2fd7h:
11022 2FD7 21 38 78     	ld hl,KEYSFLAGS		; Keyboard current State                                ;2fd7	21 38 78 	! 8 x
11023 2FDA CB 6E        	bit 5,(hl)		        ; check if bit 5 (???) is set ;2fda	cb 6e 	. n
11024 2FDC 28 25        	jr z,l3003h		        ; no - ;2fdc	28 25 	( %
11025 2FDE              ; -- bit 5 (???) is set
11026 2FDE 3A 3A 78     	ld a,(KEYS_DEBOUNCER)		;2fde	3a 3a 78 	: : x
11027 2FE1 3C           	inc a			;2fe1	3c 	<
11028 2FE2 32 3A 78     	ld (KEYS_DEBOUNCER),a		;2fe2	32 3a 78 	2 : x
11029 2FE5 FE 2A        	cp 42		;2fe5	fe 2a 	. *
11030 2FE7 28 02        	jr z,l2febh		;2fe7	28 02 	( .
11031 2FE9 AF           	xor a			;2fe9	af 	.
11032 2FEA C9           	ret			;2fea	c9 	.
11033 2FEB              l2febh:
11034 2FEB 7E           	ld a,(hl)			    ; get Keyboard current State ;2feb	7e 	~
11035 2FEC E6 DF        	and %11011111		    ; clear bit 5 (???) ;2fec	e6 df 	. .
11036 2FEE F6 40        	or  %01000000		    ; set bit 6 (???) ;2fee	f6 40 	. @
11037 2FF0 32 38 78     	ld (KEYSFLAGS),a		; sore modified Keyboard State ;2ff0	32 38 78 	2 8 x
11038 2FF3              l2ff3h:
11039 2FF3 AF           	xor a			;2ff3	af 	.
11040 2FF4 32 3A 78     	ld (KEYS_DEBOUNCER),a		;2ff4	32 3a 78 	2 : x
11041 2FF7 CB 66        	bit 4,(hl)		;2ff7	cb 66 	. f
11042 2FF9 20 04        	jr nz,l2fffh		;2ff9	20 04 	  .
11043 2FFB 3A 36 78     	ld a,(KEYCODE1)		;2ffb	3a 36 78 	: 6 x
11044 2FFE C9           	ret			;2ffe	c9 	.
11045 2FFF              l2fffh:
11046 2FFF 3A 37 78     	ld a,(KEYCODE2)		;2fff	3a 37 78 	: 7 x
11047 3002 C9           	ret			;3002	c9 	.
11048 3003              l3003h:
11049 3003 CB 76        	bit 6,(hl)		;3003	cb 76 	. v
11050 3005 20 07        	jr nz,l300eh		;3005	20 07 	  .
11051 3007 CB EE        	set 5,(hl)		;3007	cb ee 	. .
11052 3009 AF           	xor a			;3009	af 	.
11053 300A 32 3A 78     	ld (KEYS_DEBOUNCER),a		;300a	32 3a 78 	2 : x
11054 300D C9           	ret			;300d	c9 	.
11055 300E              l300eh:
11056 300E 3A 3A 78     	ld a,(KEYS_DEBOUNCER)		;300e	3a 3a 78 	: : x
11057 3011 3C           	inc a			;3011	3c 	<
11058 3012 32 3A 78     	ld (KEYS_DEBOUNCER),a		;3012	32 3a 78 	2 : x
11059 3015 FE 06        	cp 006h		;3015	fe 06 	. .
11060 3017 28 DA        	jr z,l2ff3h		;3017	28 da 	( .
11061 3019 AF           	xor a			;3019	af 	.
11062 301A C9           	ret			;301a	c9 	.
11063 301B
11064 301B              ;***************************************************************************
11065 301B              ; CPU Interrupt subroutine
11066 301B              sub_301bh:
11067 301B B7           	or a			;301b	b7 	.
11068 301C C8           	ret z			;301c	c8 	.
11069 301D F5           	push af			;301d	f5 	.
11070 301E CD 39 30     	call sub_3039h		;301e	cd 39 30 	. 9 0
11071 3021 F1           	pop af			;3021	f1 	.
11072 3022 FE 0D        	cp 00dh		;3022	fe 0d 	. .
11073 3024 C8           	ret z			;3024	c8 	.
11074 3025 FE 01        	cp 001h		;3025	fe 01 	. .
11075 3027 C8           	ret z			;3027	c8 	.
11076 3028 3A 39 78     	ld a,(SYSFLAGS)	; System flags	;3028	3a 39 78 	: 9 x
11077 302B CB 47        	bit 0,a		;302b	cb 47 	. G
11078 302D C0           	ret nz			;302d	c0 	.
11079 302E              ; -- set initial value for Cursor Timer
11080 302E 3E 20        	ld a,32				; initial timer value (twice as normal)					;302e	3e 20 	>
11081 3030 32 41 78     	ld (CURSORTIMER),a	; reset timer for inverse char under cursor				;3030	32 41 78 	2 A x
11082 3033 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 								;3033	2a 20 78 	*   x
11083 3036               ifdef VER_12
11084 3036 CB F6        	set 6,(hl)			; set Inverse bit of char under Cursor					;3036	cb f6 	. .
11085 3038 C9           	ret					; ---------------- End of Proc ------------------------	;3038	c9 	.
11086 3039               else ; VER_20
11087 3039 ~             	jp l3eb2h		;3036	c3 b2 3e 	. . >
11088 3039               endif
11089 3039              ; -- IN: a = ???
11090 3039              sub_3039h:
11091 3039 21 38 78     	ld hl,KEYSFLAGS	; Keyboard current State	;3039	21 38 78 	! 8 x
11092 303C CB 7E        	bit 7,(hl)		    ; check bit 7 (CTRL is pressed) ;303c	cb 7e 	. ~
11093 303E CA 57 31     	jp z,sub_3157h		; no - ;303e	ca 57 31 	. W 1
11094 3041
11095 3041 B7           	or a			;3041	b7 	.
11096 3042 F2 57 31     	jp p,sub_3157h		;3042	f2 57 31 	. W 1
11097 3045 F5           	push af			;3045	f5 	.
11098 3046 D6 80        	sub 080h		;3046	d6 80 	. .
11099 3048 3C           	inc a			;3048	3c 	<
11100 3049 47           	ld b,a			;3049	47 	G
11101 304A 21 4F 16     	ld hl,0164fh		;304a	21 4f 16 	! O .
11102 304D              l304dh:
11103 304D 23           	inc hl			;304d	23 	#
11104 304E CB 7E        	bit 7,(hl)		;304e	cb 7e 	. ~
11105 3050 28 FB        	jr z,l304dh		;3050	28 fb 	( .
11106 3052 10 F9        	djnz l304dh		;3052	10 f9 	. .
11107 3054 7E           	ld a,(hl)			;3054	7e 	~
11108 3055              l3055h:
11109 3055 CD 82 30     	call sub_3082h		;3055	cd 82 30 	. . 0
11110 3058 7E           	ld a,(hl)			;3058	7e 	~
11111 3059 CB 7F        	bit 7,a		;3059	cb 7f 	.
11112 305B 28 F8        	jr z,l3055h		;305b	28 f8 	( .
11113 305D F1           	pop af			;305d	f1 	.
11114 305E 06 16        	ld b,22		;305e	06 16 	. .
11115 3060 21 99 02     	ld hl,l0299h		;3060	21 99 02 	! . .
11116 3063              l3063h:
11117 3063 BE           	cp (hl)			;3063	be 	.
11118 3064 28 16        	jr z,l307ch		;3064	28 16 	( .
11119 3066 23           	inc hl			;3066	23 	#
11120 3067 10 FA        	djnz l3063h		;3067	10 fa 	. .
11121 3069 FE B0        	cp #b0		;3069	fe b0 	. .
11122 306B C0           	ret nz			;306b	c0 	.
11123 306C 3E 20        	ld a,020h		;306c	3e 20 	>
11124 306E CD 82 30     	call sub_3082h		;306e	cd 82 30 	. . 0
11125 3071 3E 46        	ld a,046h		;3071	3e 46 	> F
11126 3073 CD 82 30     	call sub_3082h		;3073	cd 82 30 	. . 0
11127 3076 3E 4E        	ld a,04eh		;3076	3e 4e 	> N
11128 3078 CD 82 30     	call sub_3082h		;3078	cd 82 30 	. . 0
11129 307B C9           	ret			;307b	c9 	.
11130 307C              l307ch:
11131 307C 3E 28        	ld a,028h		;307c	3e 28 	> (
11132 307E CD 82 30     	call sub_3082h		;307e	cd 82 30 	. . 0
11133 3081 C9           	ret			;3081	c9 	.
11134 3082              sub_3082h:
11135 3082 E6 7F        	and 07fh		;3082	e6 7f 	.
11136 3084 E5           	push hl			;3084	e5 	.
11137 3085 CD 57 31     	call sub_3157h		;3085	cd 57 31 	. W 1
11138 3088 E1           	pop hl			;3088	e1 	.
11139 3089 23           	inc hl			;3089	23 	#
11140 308A C9           	ret			;308a	c9 	.
11141 308B
11142 308B              ; **************************************************************************************
11143 308B              ; Print Char to Screen at current Cursor Position (and advance Cursor)
11144 308B              ; Ensures MODE 0 for screen, ...
11145 308B              ; IN: a - char to print
11146 308B              ScrPrintChar:
11147 308B F5           	push af				; save af														;308b	f5 	.
11148 308C
11149 308C              ; check if MODE 0 - if not also clear screen
11150 308C 3A 3B 78     	ld a,(IOLATCH_COPY); a - last value written to Hardware Register 					;308c	3a 3b 78 	: ; x
11151 308F CB 5F        	bit 3,a				; check if bit 3 (MC6847 AG pin) equals 0 (MODE 0)				;308f	cb 5f 	. _
11152 3091 28 17        	jr z,.modeIs0		; yes - skip change MODE and Clear Screen						;3091	28 17 	( .
11153 3093
11154 3093              ; -- change MC6847 graphics mode to 0
11155 3093 E6 F7        	and %11110111		; clear bit 3 - set MODE 0										;3093	e6 f7 	. .
11156 3095 32 3B 78     	ld (IOLATCH_COPY),a	; save to Shadow Register for future read						;3095	32 3b 78 	2 ; x
11157 3098 32 00 68     	ld (IO_LATCH),a		; store value to Hardware Register - force MODE 0				;3098	32 00 68 	2 . h
11158 309B
11159 309B              ; -- clear Screen Memory - set 512 bytes to ' ' ($20)
11160 309B 01 00 02     	ld bc,$200			; set counter to 512 bytes to fill								;309b	01 00 02 	. . .
11161 309E 21 00 70     	ld hl,VRAM			; Video RAM start												;309e	21 00 70 	! . p
11162 30A1              .loop:
11163 30A1               ifdef VER_12
11164 30A1 3E 20        	ld a,' '			; a - space char												;30a1	3e 20 	>
11165 30A3 77           	ld (hl),a			; store to Video Memory											;30a3	77 	w
11166 30A4               else ; VER_20
11167 30A4 ~             	call sub_3ebeh		;30a1	cd be 3e 	. . >
11168 30A4               endif
11169 30A4 23           	inc hl				; next address													;30a4	23 	#
11170 30A5 0B           	dec bc				; decrement bytes counter										;30a5	0b 	.
11171 30A6 79           	ld a,c				; test if counter (bc) is 0										;30a6	79 	y
11172 30A7 B0           	or b																				;30a7	b0 	.
11173 30A8 20 F7        	jr nz,.loop			; no - fill all 512 bytes										;30a8	20 f7 	  .
11174 30AA
11175 30AA
11176 30AA              ; --
11177 30AA              .modeIs0:
11178 30AA F1           	pop af				; restore af - char to display on screen						;30aa	f1 	.
11179 30AB 21 39 78     	ld hl,SYSFLAGS		; System flags ;30ab	21 39 78 	! 9 x
11180 30AE CB 6E        	bit 5,(hl)			; buffered output? ;30ae	cb 6e 	. n
11181 30B0 CA 06 31     	jp z,l3106h		;30b0	ca 06 31 	. . 1
11182 30B3 FE 20        	cp ' '				; is this printable char (greater than or equal to ' ')			;30b3	fe 20 	.
11183 30B5 D2 C0 30     	jp nc,l30c0h		; yes - skip ??? ;30b5	d2 c0 30 	. . 0
11184 30B8              ; -- ???
11185 30B8 F5           	push af			;30b8	f5 	.
11186 30B9              l30b9h:
11187 30B9 3A AF 7A     	ld a,(07aafh)		;30b9	3a af 7a 	: . z
11188 30BC B7           	or a			;30bc	b7 	.
11189 30BD 20 FA        	jr nz,l30b9h		;30bd	20 fa 	  .
11190 30BF F1           	pop af			;30bf	f1 	.
11191 30C0              l30c0h:
11192 30C0 F3           	di					; disable interrupts											;30c0	f3 	.
11193 30C1 2A B0 7A     	ld hl,(07ab0h)		;30c1	2a b0 7a 	* . z
11194 30C4 77           	ld (hl),a			;30c4	77 	w
11195 30C5 23           	inc hl			;30c5	23 	#
11196 30C6 22 B0 7A     	ld (07ab0h),hl		;30c6	22 b0 7a 	" . z
11197 30C9 21 AF 7A     	ld hl,07aafh		;30c9	21 af 7a 	! . z
11198 30CC 34           	inc (hl)			;30cc	34 	4
11199 30CD F5           	push af			;30cd	f5 	.
11200 30CE 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line	;30ce	3a a6 78 	: . x
11201 30D1 86           	add a,(hl)			;30d1	86 	.
11202 30D2 32 AE 7A     	ld (07aaeh),a		;30d2	32 ae 7a 	2 . z
11203 30D5 F1           	pop af			;30d5	f1 	.
11204 30D6 FB           	ei			;30d6	fb 	.
11205 30D7 FE 20        	cp 020h		;30d7	fe 20 	.
11206 30D9 DA E3 30     	jp c,l30e3h		;30d9	da e3 30 	. . 0
11207 30DC 3E 14        	ld a,014h		;30dc	3e 14 	> .
11208 30DE              l30deh:
11209 30DE BE           	cp (hl)			;30de	be 	.
11210 30DF DA DE 30     	jp c,l30deh		;30df	da de 30 	. . 0
11211 30E2 C9           	ret			;30e2	c9 	.
11212 30E3              l30e3h:
11213 30E3 AF           	xor a			;30e3	af 	.
11214 30E4              l30e4h:
11215 30E4 BE           	cp (hl)			;30e4	be 	.
11216 30E5 20 FD        	jr nz,l30e4h		;30e5	20 fd 	  .
11217 30E7 C9           	ret			;30e7	c9 	.
11218 30E8              sub_30e8h:
11219 30E8 3A AF 7A     	ld a,(07aafh)		;30e8	3a af 7a 	: . z
11220 30EB B7           	or a			;30eb	b7 	.
11221 30EC C8           	ret z			;30ec	c8 	.
11222 30ED 47           	ld b,a			;30ed	47 	G
11223 30EE 21 B2 7A     	ld hl,TAPEFILENAME	; tape buffer for filename (18) bytes	;30ee	21 b2 7a 	! . z
11224 30F1 E5           	push hl			;30f1	e5 	.
11225 30F2              l30f2h:
11226 30F2 7E           	ld a,(hl)			;30f2	7e 	~
11227 30F3 23           	inc hl			;30f3	23 	#
11228 30F4 E5           	push hl			;30f4	e5 	.
11229 30F5 C5           	push bc			;30f5	c5 	.
11230 30F6 CD 06 31     	call l3106h		;30f6	cd 06 31 	. . 1
11231 30F9 C1           	pop bc			;30f9	c1 	.
11232 30FA E1           	pop hl			;30fa	e1 	.
11233 30FB 10 F5        	djnz l30f2h		;30fb	10 f5 	. .
11234 30FD E1           	pop hl			;30fd	e1 	.
11235 30FE 22 B0 7A     	ld (07ab0h),hl		;30fe	22 b0 7a 	" . z
11236 3101 AF           	xor a			;3101	af 	.
11237 3102 32 AF 7A     	ld (07aafh),a		;3102	32 af 7a 	2 . z
11238 3105 C9           	ret			;3105	c9 	.
11239 3106              l3106h:
11240 3106 CD 0D 03     	call ScrRefreshCursor	; refresh char at Cursor Position					;3106	cd 0d 03 	. . .
11241 3109 B7           	or a					; is 0 (null) to print   ;3109	b7 	.
11242 310A 28 04        	jr z,l3110h				; yes - ;310a	28 04 	( .
11243 310C FE 0D        	cp #0d					; is CR to print 	;310c	fe 0d 	. .
11244 310E 20 4A        	jr nz,l315ah			; no - ;310e	20 4a 	  J
11245 3110
11246 3110              ; -- char to rint is 0 or CR
11247 3110              l3110h:
11248 3110 F5           	push af					; save a 											;3110	f5 	.
11249 3111              ; -- get Cursor current address and position in line
11250 3111 2A 20 78     	ld hl,(CURSORADDR)	    ; hl - addres of Cursor in VRAM						;3111	2a 20 78 	*   x
11251 3114 3A A6 78     	ld a,(CURSORPOS)	    ; position of Cursor in Edited line					;3114	3a a6 78 	: . x
11252 3117 4F           	ld c,a					; c - Cursor Position								;3117	4f 	O
11253 3118 AF           	xor a					; 													;3118	af 	.
11254 3119 47           	ld b,a					; bc - Cursor Position in line						;3119	47 	G
11255 311A              ; -- move Cursor to start of next line
11256 311A 32 A6 78     	ld (CURSORPOS),a	    ; reset Cursor In Line to 0 (begin of line)			;311a	32 a6 78 	2 . x
11257 311D ED 42        	sbc hl,bc				; hl - address of begin of line with cursor			;311d	ed 42 	. B
11258 311F 01 20 00     	ld bc,32				; line contains 32 bytes 							;311f	01 20 00 	.   .
11259 3122 09           	add hl,bc				; hl - address of begin of next line				;3122	09 	.
11260 3123              ; -- test if Cursor is out of Screen and Screen Scroll is needed
11261 3123              ; -- in MODE 0 (text) Screen addresses are in range 7000..71ff
11262 3123 7C           	ld a,h					; a - MSB of Cursor address							;3123	7c 	|
11263 3124 FE 72        	cp $72					; is address out of Screen							;3124	fe 72 	. r
11264 3126 F4 F3 33     	call p,ScrScrollUp		; yes - scroll screen 1 line up						;3126	f4 f3 33 	. . 3
11265 3129 22 20 78     	ld (CURSORADDR),hl		; set as new Cursor Address in VRAM                 ;3129	22 20 78 	"   x
11266 312C CD 53 00     	call SetCursorFromHL	; update Cursor char	;312c	cd 53 00 	. S .
11267 312F F1           	pop af			;312f	f1 	.
11268 3130 B7           	or a			;3130	b7 	.
11269 3131 C8           	ret z			;3131	c8 	.
11270 3132 CD A8 33     	call GetEditorLineFlag		;3132	cd a8 33 	. . 3
11271 3135 FE 80        	cp 080h		;3135	fe 80 	. .
11272 3137 C8           	ret z			;3137	c8 	.
11273 3138 FE 81        	cp 081h		;3138	fe 81 	. .
11274 313A 20 05        	jr nz,l3141h		;313a	20 05 	  .
11275 313C 3D           	dec a			;313c	3d 	=
11276 313D 77           	ld (hl),a			;313d	77 	w
11277 313E 23           	inc hl			;313e	23 	#
11278 313F 77           	ld (hl),a			;313f	77 	w
11279 3140 C9           	ret			;3140	c9 	.
11280 3141              l3141h:
11281 3141 3E 80        	ld a,080h		;3141	3e 80 	> .
11282 3143 77           	ld (hl),a			;3143	77 	w
11283 3144 C9           	ret			;3144	c9 	.
11284 3145              l3145h:
11285 3145 CB 77        	bit 6,a		;3145	cb 77 	. w
11286 3147 28 04        	jr z,l314dh		;3147	28 04 	( .
11287 3149               ifdef VER_12
11288 3149 E6 7F        	and 07fh		;3149	e6 7f 	.
11289 314B 18 07        	jr l3154h		;314b	18 07 	. .
11290 314D               else ; VER_20
11291 314D ~            	jp l3f60h		;3149	c3 60 3f 	. ` ?
11292 314D ~            	nop			;314c	00 	.
11293 314D               endif
11294 314D              l314dh:
11295 314D E6 8F        	and 08fh		;314d	e6 8f 	. .
11296 314F 47           	ld b,a			;314f	47 	G
11297 3150 3A 46 78     	ld a,(FCOLOR)	; Foreground Color	;3150	3a 46 78 	: F x
11298 3153 B0           	or b			;3153	b0 	.
11299 3154              l3154h:
11300 3154 47           	ld b,a			;3154	47 	G
11301 3155 18 5F        	jr l31b6h		;3155	18 5f 	. _
11302 3157              sub_3157h:
11303 3157 CD 0D 03     	call ScrRefreshCursor		;3157	cd 0d 03 	. . .
11304 315A              l315ah:
11305 315A B7           	or a			;315a	b7 	.
11306 315B FA 45 31     	jp m,l3145h		;315b	fa 45 31 	. E 1
11307 315E FE 0D        	cp 00dh		;315e	fe 0d 	. .
11308 3160 C8           	ret z			;3160	c8 	.
11309 3161 FE 08        	cp 008h		;3161	fe 08 	. .
11310 3163 CA 27 32     	jp z,l3227h		;3163	ca 27 32 	. ' 2
11311 3166 FE 1B        	cp 01bh		;3166	fe 1b 	. .
11312 3168 CA 53 32     	jp z,l3253h		;3168	ca 53 32 	. S 2
11313 316B FE 0A        	cp 00ah		;316b	fe 0a 	. .
11314 316D CA 6D 32     	jp z,l326dh		;316d	ca 6d 32 	. m 2
11315 3170 FE 08        	cp 008h		;3170	fe 08 	. .
11316 3172 CA 27 32     	jp z,l3227h		;3172	ca 27 32 	. ' 2
11317 3175 FE 09        	cp 009h		;3175	fe 09 	. .
11318 3177 CA B8 31     	jp z,l31b8h		;3177	ca b8 31 	. . 1
11319 317A FE 01        	cp 001h		;317a	fe 01 	. .
11320 317C C8           	ret z			;317c	c8 	.
11321 317D FE 7F        	cp 07fh		;317d	fe 7f 	.
11322 317F CA CB 33     	jp z,l33cbh		;317f	ca cb 33 	. . 3
11323 3182 FE 15        	cp 015h		;3182	fe 15 	. .
11324 3184 CA C6 32     	jp z,l32c6h		;3184	ca c6 32 	. . 2
11325 3187 FE 18        	cp 018h		;3187	fe 18 	. .
11326 3189 CA 27 32     	jp z,l3227h		;3189	ca 27 32 	. ' 2
11327 318C FE 19        	cp 019h		;318c	fe 19 	. .
11328 318E CA B8 31     	jp z,l31b8h		;318e	ca b8 31 	. . 1
11329 3191 FE 1B        	cp 01bh		;3191	fe 1b 	. .
11330 3193 CA 53 32     	jp z,l3253h		;3193	ca 53 32 	. S 2
11331 3196 FE 1C        	cp $1c		;3196	fe 1c 	. .
11332 3198 CA 87 32     	jp z,CursorHome		; moves Cursor to top-left corner of Screen	;3198	ca 87 32 	. . 2
11333 319B FE 1D        	cp 01dh		;319b	fe 1d 	. .
11334 319D CA B4 32     	jp z,CursorLineStart	; set Cursor at start of line						;319d	ca b4 32 	. . 2
11335 31A0 FE 1F        	cp 01fh		;31a0	fe 1f 	. .
11336 31A2 CA 92 32     	jp z,ResetEditor		; clear Screen and Editor Flags						;31a2	ca 92 32 	. . 2
11337 31A5 FE 20        	cp 020h		;31a5	fe 20 	.
11338 31A7 F8           	ret m			;31a7	f8 	.
11339 31A8               ifdef VER_12
11340 31A8 E6 3F        	and 03fh		;31a8	e6 3f 	. ?
11341 31AA E5           	push hl			    ; save hl ;31aa	e5 	.
11342 31AB               else ; VER_20
11343 31AB ~            	jp l3ecah		;31a8	c3 ca 3e 	. . >
11344 31AB               endif
11345 31AB
11346 31AB
11347 31AB              l31abh:
11348 31AB 21 38 78     	ld hl,KEYSFLAGS	; Keyboard current State	;31ab	21 38 78 	! 8 x
11349 31AE CB 4E        	bit 1,(hl)		    ; check bit 1 (???) ;31ae	cb 4e 	. N
11350 31B0 E1           	pop hl			    ; restore hl ;31b0	e1 	.
11351 31B1 28 02        	jr z,l31b5h		    ; not set - ;31b1	28 02 	( .
11352 31B3 F6 40        	or 040h		;31b3	f6 40 	. @
11353 31B5              l31b5h:
11354 31B5 47           	ld b,a			;31b5	47 	G
11355 31B6              l31b6h:
11356 31B6 78           	ld a,b			;31b6	78 	x
11357 31B7 77           	ld (hl),a			;31b7	77 	w
11358 31B8              l31b8h:
11359 31B8 CD BF 31     	call sub_31bfh		;31b8	cd bf 31 	. . 1
11360 31BB CD 50 00     	call UpdateCursorChar	; update Cursor Char	;31bb	cd 50 00 	. P .
11361 31BE C9           	ret			;31be	c9 	.
11362 31BF              sub_31bfh:
11363 31BF 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line	;31bf	3a a6 78 	: . x
11364 31C2 3C           	inc a			    ; increment Cursor position ;31c2	3c 	<
11365 31C3 FE 20        	cp 32		        ; is it next screen line ? ;31c3	fe 20 	.
11366 31C5 20 2B        	jr nz,l31f2h		; no - ;31c5	20 2b 	  +
11367 31C7 CD A8 33     	call GetEditorLineFlag		;31c7	cd a8 33 	. . 3
11368 31CA FE 81        	cp 081h		;31ca	fe 81 	. .
11369 31CC 28 23        	jr z,l31f1h		;31cc	28 23 	( #
11370 31CE B7           	or a			;31ce	b7 	.
11371 31CF 20 35        	jr nz,l3206h		;31cf	20 35 	  5
11372 31D1 47           	ld b,a			;31d1	47 	G
11373 31D2 3A 39 78     	ld a,(SYSFLAGS)	; System flags	;31d2	3a 39 78 	: 9 x
11374 31D5 CB 47        	bit 0,a		;31d5	cb 47 	. G
11375 31D7 78           	ld a,b			;31d7	78 	x
11376 31D8 C8           	ret z			;31d8	c8 	.
11377 31D9              l31d9h:
11378 31D9 AF           	xor a			;31d9	af 	.
11379 31DA 23           	inc hl			;31da	23 	#
11380 31DB 77           	ld (hl),a			;31db	77 	w
11381 31DC 23           	inc hl			;31dc	23 	#
11382 31DD E5           	push hl			;31dd	e5 	.
11383 31DE ED 4B A4 78  	ld bc,(PrgStartPtr)	; bc - address of start of BASIC program 				;31de	ed 4b a4 78 	. K . x
11384 31E2 0B           	dec bc			;31e2	0b 	.
11385 31E3 0B           	dec bc			;31e3	0b 	.
11386 31E4 B7           	or a			;31e4	b7 	.
11387 31E5 ED 42        	sbc hl,bc		;31e5	ed 42 	. B
11388 31E7 E1           	pop hl			;31e7	e1 	.
11389 31E8 30 07        	jr nc,l31f1h		;31e8	30 07 	0 .
11390 31EA 7E           	ld a,(hl)			;31ea	7e 	~
11391 31EB B7           	or a			;31eb	b7 	.
11392 31EC 20 03        	jr nz,l31f1h		;31ec	20 03 	  .
11393 31EE 3E 80        	ld a,080h		;31ee	3e 80 	> .
11394 31F0 77           	ld (hl),a			;31f0	77 	w
11395 31F1              l31f1h:
11396 31F1 AF           	xor a			;31f1	af 	.
11397 31F2              l31f2h:
11398 31F2 32 A6 78     	ld (CURSORPOS),a	; set new position of Cursor in Edited line	;31f2	32 a6 78 	2 . x
11399 31F5 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 	;31f5	2a 20 78 	*   x
11400 31F8 01 01 00     	ld bc,1		        ; 1 position to move cursor right   ;31f8	01 01 00 	. . .
11401 31FB 09           	add hl,bc			;31fb	09 	.
11402 31FC 7C           	ld a,h			    ;31fc	7c 	|
11403 31FD FE 72        	cp $72		;31fd	fe 72 	. r
11404 31FF F4 F3 33     	call p,ScrScrollUp	; yes - scroll screen and Editor 1 line Up		;31ff	f4 f3 33 	. . 3
11405 3202 22 20 78     	ld (CURSORADDR),hl	; Cursor Address in VRAM (last line) 	;3202	22 20 78 	"   x
11406 3205 C9           	ret			;3205	c9 	.
11407 3206              l3206h:
11408 3206 F5           	push af			;3206	f5 	.
11409 3207 ED 5B 20 78  	ld de,(CURSORADDR)	; Cursor Address in VRAM 		;3207	ed 5b 20 78 	. [   x
11410 320B 13           	inc de			;320b	13 	.
11411 320C 7A           	ld a,d			;320c	7a 	z
11412 320D FE 72        	cp 072h		;320d	fe 72 	. r
11413 320F 28 10        	jr z,l3221h		;320f	28 10 	( .
11414 3211 E5           	push hl			;3211	e5 	.
11415 3212 21 39 78     	ld hl,SYSFLAGS	; System flags	;3212	21 39 78 	! 9 x
11416 3215 CB 46        	bit 0,(hl)		;3215	cb 46 	. F
11417 3217 20 07        	jr nz,l3220h		;3217	20 07 	  .
11418 3219 CB 66        	bit 4,(hl)		;3219	cb 66 	. f
11419 321B 20 03        	jr nz,l3220h		;321b	20 03 	  .
11420 321D CD 2C 33     	call sub_332ch		;321d	cd 2c 33 	. , 3
11421 3220              l3220h:
11422 3220 E1           	pop hl			;3220	e1 	.
11423 3221              l3221h:
11424 3221 F1           	pop af			;3221	f1 	.
11425 3222 3C           	inc a			;3222	3c 	<
11426 3223 77           	ld (hl),a			;3223	77 	w
11427 3224 C3 D9 31     	jp l31d9h		;3224	c3 d9 31 	. . 1
11428 3227              l3227h:
11429 3227 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line	;3227	3a a6 78 	: . x
11430 322A 3D           	dec a			    ; decrement position of Cursor ;322a	3d 	=
11431 322B F2 35 32     	jp p,l3235h		    ; jump if less than 0 ;322b	f2 35 32 	. 5 2
11432 322E              l322eh:
11433 322E CD A8 33     	call GetEditorLineFlag		;322e	cd a8 33 	. . 3
11434 3231 B7           	or a			;3231	b7 	.
11435 3232 C0           	ret nz			;3232	c0 	.
11436 3233 3E 1F        	ld a,31		;3233	3e 1f 	> .
11437 3235              l3235h:
11438 3235 32 A6 78     	ld (CURSORPOS),a    ; set new position of Cursor in Edited line		;3235	32 a6 78 	2 . x
11439 3238 01 01 00     	ld bc,$0001		;3238	01 01 00 	. . .
11440 323B 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 		;323b	2a 20 78 	*   x
11441 323E AF           	xor a			;323e	af 	.
11442 323F ED 42        	sbc hl,bc		;323f	ed 42 	. B
11443 3241 7C           	ld a,h			;3241	7c 	|
11444 3242 FE 70        	cp 070h		;3242	fe 70 	. p
11445 3244 DA 4E 32     	jp c,l324eh		;3244	da 4e 32 	. N 2
11446 3247 22 20 78     	ld (CURSORADDR),hl	; save new address of Cursor  		;3247	22 20 78 	"   x
11447 324A CD 53 00     	call SetCursorFromHL; update Cursor char 		;324a	cd 53 00 	. S .
11448 324D C9           	ret			;324d	c9 	.
11449 324E              l324eh:
11450 324E AF           	xor a			    ; new Cursor position - begin of line                   ;324e	af 	.
11451 324F 32 A6 78     	ld (CURSORPOS),a	; reset position of Cursor to 0 (begin of Edited line)	;324f	32 a6 78 	2 . x
11452 3252 C9           	ret			        ; ------------ End of Proc ---------------------------- ;3252	c9 	.
11453 3253              l3253h:
11454 3253 21 39 78     	ld hl,SYSFLAGS		; System flags ;3253	21 39 78 	! 9 x
11455 3256 CB 66        	bit 4,(hl)		;3256	cb 66 	. f
11456 3258 C0           	ret nz			;3258	c0 	.
11457 3259 01 20 00     	ld bc,32		    ; 32 bytes per line ;3259	01 20 00 	.   .
11458 325C 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 		;325c	2a 20 78 	*   x
11459 325F AF           	xor a			    ;325f	af 	.
11460 3260 ED 42        	sbc hl,bc		;3260	ed 42 	. B
11461 3262 7C           	ld a,h			;3262	7c 	|
11462 3263 FE 70        	cp 070h		;3263	fe 70 	. p
11463 3265 F8           	ret m			;3265	f8 	.
11464 3266 22 20 78     	ld (CURSORADDR),hl	; Cursor Address in VRAM 			;3266	22 20 78 	"   x
11465 3269 CD 53 00     	call SetCursorFromHL; update Cursor char		;3269	cd 53 00 	. S .
11466 326C C9           	ret			;326c	c9 	.
11467 326D              l326dh:
11468 326D 21 39 78     	ld hl,SYSFLAGS		; System flags ;326d	21 39 78 	! 9 x
11469 3270 CB 66        	bit 4,(hl)		;3270	cb 66 	. f
11470 3272 C0           	ret nz			;3272	c0 	.
11471 3273 01 20 00     	ld bc,32		    ; 32 bytes per line ;3273	01 20 00 	.   .
11472 3276 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 			;3276	2a 20 78 	*   x
11473 3279 09           	add hl,bc			;3279	09 	.
11474 327A 7C           	ld a,h				; high byte of new Cursor address			;327a	7c 	|
11475 327B FE 72        	cp $72				; is id outside of screen? 					;327b	fe 72 	. r
11476 327D F4 24 34     	call p,ScrollEditorUp	; yes - scroll screen up 1 line 		;327d	f4 24 34 	. $ 4
11477 3280 22 20 78     	ld (CURSORADDR),hl	; store new Cursor Address in VRAM 			;3280	22 20 78 	"   x
11478 3283 CD 53 00     	call SetCursorFromHL; update Cursor char		;3283	cd 53 00 	. S .
11479 3286 C9           	ret			;3286	c9 	.
11480 3287
11481 3287
11482 3287
11483 3287              ;************************************************************************************
11484 3287              ; Moves Cursor to top-left corner of Screen
11485 3287              CursorHome:
11486 3287 21 00 70     	ld hl,VRAM		    ; address of top-left corner in VRAM                    ;3287	21 00 70 	! . p
11487 328A 22 20 78     	ld (CURSORADDR),hl	; set as new Cursor Address in VRAM 			        ;328a	22 20 78 	"   x
11488 328D AF           	xor a			    ; new Cursor position - begin of line                   ;328d	af 	.
11489 328E 32 A6 78     	ld (CURSORPOS),a    ; reset position of Cursor to 0 (begin of Edited line)	;328e	32 a6 78 	2 . x
11490 3291 C9           	ret			        ; ------------ End of Proc ---------------------------- ;3291	c9 	.
11491 3292
11492 3292
11493 3292
11494 3292              ;************************************************************************************
11495 3292              ; Clear Screen and Editor Flags
11496 3292              ResetEditor:
11497 3292              ; -- reset Cursor Screen Address
11498 3292 21 00 70     	ld hl,VRAM		    ; address of top-left corner in VRAM                    ;3292	21 00 70 	! . p
11499 3295 22 20 78     	ld (CURSORADDR),hl	; set as current Cursor Address in VRAM 			    ;3295	22 20 78 	"   x
11500 3298              ; -- clear Screen
11501 3298 01 00 02     	ld bc,512		    ; 512 bytes of Screen in Text Mode (0)                  ;3298	01 00 02 	. . .
11502 329B              .next:
11503 329B               ifdef VER_12
11504 329B 3E 20        	ld a,' '		    ; space char to fill Screen                             ;329b	3e 20 	>
11505 329D 77           	ld (hl),a			; store int VRAM                                        ;329d	77 	w
11506 329E               else ; VER_20
11507 329E ~            	call sub_3ebeh		;329b	cd be 3e 	. . >
11508 329E               endif
11509 329E 23           	inc hl			    ; next address                                          ;329e	23 	#
11510 329F 0B           	dec bc			    ; decrement char's counter                              ;329f	0b 	.
11511 32A0 79           	ld a,c			                                                            ;32a0	79 	y
11512 32A1 B0           	or b			    ; is counter = 0 ?                                      ;32a1	b0 	.
11513 32A2 20 F7        	jr nz,.next			; no - continue with all 512 bytes                      ;32a2	20 f7 	  .
11514 32A4              ; -- reset Cursor in line position
11515 32A4 AF           	xor a			    ; new Cursor position - begin of line                   ;32a4	af 	.
11516 32A5 32 A6 78     	ld (CURSORPOS),a    ; reset position of Cursor to 0 (begin of Edited line)	;32a5	32 a6 78 	2 . x
11517 32A8              ; -- clear Editor flags
11518 32A8 06 10        	ld b,16		        ; 16 lines of Screen/Editor                             ;32a8	06 10 	. .
11519 32AA 3E 80        	ld a,$80			; default Editor Line status - single or empty line 	;32aa	3e 80 	> .
11520 32AC 21 D7 7A     	ld hl,EDITORLINES	; Editor Flags for every Screen line	                ;32ac	21 d7 7a 	! . z
11521 32AF              .nextline:
11522 32AF 77           	ld (hl),a			; set $80 as flag for line (single line)                ;32af	77 	w
11523 32B0 23           	inc hl			    ; next line                                             ;32b0	23 	#
11524 32B1 10 FC        	djnz .nextline		; fill all 16 flags lines                               ;32b1	10 fc 	. .
11525 32B3 C9           	ret			        ; ----------------- End Of Proc ----------------------- ;32b3	c9 	.
11526 32B4
11527 32B4
11528 32B4
11529 32B4
11530 32B4              ;************************************************************************************
11531 32B4              ; Set Cursor at start of line
11532 32B4              CursorLineStart:
11533 32B4 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 			                 	;32b4	2a 20 78 	*   x
11534 32B7 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line						;32b7	3a a6 78 	: . x
11535 32BA 4F           	ld c,a				; c - Cursor Position									;32ba	4f 	O
11536 32BB AF           	xor a				; 0 as High Byte 										;32bb	af 	.
11537 32BC 47           	ld b,a				; bc - posion of Cursor in Edited line					;32bc	47 	G
11538 32BD 32 A6 78     	ld (CURSORPOS),a	; reset position of Cursor to 0 (begin of Edited line)	;32bd	32 a6 78 	2 . x
11539 32C0 ED 42        	sbc hl,bc			; VRAM address of start of line							;32c0	ed 42 	. B
11540 32C2 22 20 78     	ld (CURSORADDR),hl	; set Cursor Address at start of edited line			;32c2	22 20 78 	"   x
11541 32C5 C9           	ret					; ----------------- End Of Proc ----------------------- ;32c5	c9 	.
11542 32C6
11543 32C6              l32c6h:
11544 32C6 CD A8 33     	call GetEditorLineFlag		;32c6	cd a8 33 	. . 3
11545 32C9 FE 81        	cp 081h		;32c9	fe 81 	. .
11546 32CB 28 31        	jr z,l32feh		;32cb	28 31 	( 1
11547 32CD 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line			;32cd	3a a6 78 	: . x
11548 32D0 FE 1F        	cp 31		;32d0	fe 1f 	. .
11549 32D2 28 25        	jr z,l32f9h		;32d2	28 25 	( %
11550 32D4 4F           	ld c,a			;32d4	4f 	O
11551 32D5 AF           	xor a			;32d5	af 	.
11552 32D6 47           	ld b,a			;32d6	47 	G
11553 32D7 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 				;32d7	2a 20 78 	*   x
11554 32DA ED 42        	sbc hl,bc		;32da	ed 42 	. B
11555 32DC 01 1F 00     	ld bc,$001f		;32dc	01 1f 00 	. . .
11556 32DF 09           	add hl,bc			;32df	09 	.
11557 32E0               ifdef VER_12
11558 32E0 7E           	ld a,(hl)			;32e0	7e 	~
11559 32E1 FE 20        	cp 020h		;32e1	fe 20 	.
11560 32E3               else ; VER_20
11561 32E3 ~            	call sub_3ee9h		;32e0	cd e9 3e 	. . >
11562 32E3               endif
11563 32E3 20 14        	jr nz,l32f9h		;32e3	20 14 	  .
11564 32E5 E5           	push hl			;32e5	e5 	.
11565 32E6 D1           	pop de			;32e6	d1 	.
11566 32E7 2B           	dec hl			;32e7	2b 	+
11567 32E8 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line			;32e8	3a a6 78 	: . x
11568 32EB 4F           	ld c,a			;32eb	4f 	O
11569 32EC 3E 1F        	ld a,01fh		;32ec	3e 1f 	> .
11570 32EE              l32eeh:
11571 32EE 91           	sub c			;32ee	91 	.
11572 32EF 4F           	ld c,a			;32ef	4f 	O
11573 32F0 ED B8        	lddr		;32f0	ed b8 	. .
11574 32F2               ifdef VER_12
11575 32F2 3E 20        	ld a,' '		    ; space character ;32f2	3e 20 	>
11576 32F4 32 3C 78     	ld (CURSORCHAR),a	; set as current character at cursor position	;32f4	32 3c 78 	2 < x
11577 32F7 12           	ld (de),a			;32f7	12 	.
11578 32F8               else ; VER_20
11579 32F8 ~            	call sub_3ef6h		;32f2	cd f6 3e 	. . >
11580 32F8 ~            	ld (0783ch),a		;32f5	32 3c 78 	2 < x
11581 32F8               endif
11582 32F8 C9           	ret			;32f8	c9 	.
11583 32F9
11584 32F9
11585 32F9              l32f9h:
11586 32F9 CD A8 33     	call GetEditorLineFlag		;32f9	cd a8 33 	. . 3
11587 32FC B7           	or a			;32fc	b7 	.
11588 32FD C8           	ret z			;32fd	c8 	.
11589 32FE              l32feh:
11590 32FE FE 80        	cp 080h		;32fe	fe 80 	. .
11591 3300 28 1E        	jr z,l3320h		;3300	28 1e 	( .
11592 3302 3A A6 78     	ld a,(CURSORPOS)    ; position of Cursor in Edited line				;3302	3a a6 78 	: . x
11593 3305 4F           	ld c,a			;3305	4f 	O
11594 3306 AF           	xor a			;3306	af 	.
11595 3307 47           	ld b,a			;3307	47 	G
11596 3308 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 				;3308	2a 20 78 	*   x
11597 330B ED 42        	sbc hl,bc		;330b	ed 42 	. B
11598 330D 01 3F 00     	ld bc,0003fh		;330d	01 3f 00 	. ? .
11599 3310 09           	add hl,bc			;3310	09 	.
11600 3311               ifdef VER_12
11601 3311 7E           	ld a,(hl)			;3311	7e 	~
11602 3312 FE 20        	cp 020h		;3312	fe 20 	.
11603 3314               else ; VER_20
11604 3314 ~            	call sub_3ee9h		;3311	cd e9 3e 	. . >
11605 3314               endif
11606 3314 C0           	ret nz			;3314	c0 	.
11607 3315 E5           	push hl			;3315	e5 	.
11608 3316 D1           	pop de			;3316	d1 	.
11609 3317 2B           	dec hl			;3317	2b 	+
11610 3318 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line			;3318	3a a6 78 	: . x
11611 331B 4F           	ld c,a			;331b	4f 	O
11612 331C 3E 3F        	ld a,03fh		;331c	3e 3f 	> ?
11613 331E 18 CE        	jr l32eeh		;331e	18 ce 	. .
11614 3320              l3320h:
11615 3320 E5           	push hl			;3320	e5 	.
11616 3321 CD 2C 33     	call sub_332ch		;3321	cd 2c 33 	. , 3
11617 3324 E1           	pop hl			;3324	e1 	.
11618 3325 3E 81        	ld a,081h		;3325	3e 81 	> .
11619 3327 77           	ld (hl),a			;3327	77 	w
11620 3328 23           	inc hl			;3328	23 	#
11621 3329 AF           	xor a			;3329	af 	.
11622 332A 77           	ld (hl),a			;332a	77 	w
11623 332B C9           	ret			;332b	c9 	.
11624 332C
11625 332C
11626 332C              sub_332ch:
11627 332C 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 				;332c	2a 20 78 	*   x
11628 332F 7C           	ld a,h			    ; upper byte of VRAM address            ;332f	7c 	|
11629 3330 FE 71        	cp $71		        ; is it bottom half of Screen?          ;3330	fe 71 	. q
11630 3332 20 2B        	jr nz,l335fh		; no -;3332	20 2b 	  +
11631 3334 7D           	ld a,l			    ; lower byte of VRAM address            ;3334	7d 	}
11632 3335 FE E0        	cp $e0				; is it last line of Screen?  			;3335	fe e0 	. .
11633 3337 DA 5F 33     	jp c,l335fh		;3337	da 5f 33 	. _ 3
11634 333A 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line			;333a	3a a6 78 	: . x
11635 333D F5           	push af			;333d	f5 	.
11636 333E 3A D7 7A     	ld a,(EDITORLINES)	; Editor first Line info				;333e	3a d7 7a 	: . z
11637 3341 FE 81        	cp $81				; is it first of two-line statement/program ;3341	fe 81 	. .
11638 3343 20 08        	jr nz,l334dh		; no - ;3343	20 08 	  .
11639 3345 E5           	push hl				; save hl ;3345	e5 	.
11640 3346 CD F3 33     	call ScrScrollUp	; Scroll Screen and Editor 1 line Up	;3346	cd f3 33 	. . 3
11641 3349 E1           	pop hl				; restore hl ;3349	e1 	.
11642 334A CD 17 03     	call sub_0317h		;334a	cd 17 03 	. . .
11643 334D              l334dh:
11644 334D E5           	push hl				; save hl - ;334d	e5 	.
11645 334E CD F3 33     	call ScrScrollUp	; Scroll Screen and Editor 1 line Up 		;334e	cd f3 33 	. . 3
11646 3351 E1           	pop hl				; restore hl - ;3351	e1 	.
11647 3352 CD 17 03     	call sub_0317h		;3352	cd 17 03 	. . .
11648 3355 F1           	pop af			;3355	f1 	.
11649 3356 32 A6 78     	ld (CURSORPOS),a	; set new position of Cursor in Edited line			;3356	32 a6 78 	2 . x
11650 3359 D1           	pop de			;3359	d1 	.
11651 335A E1           	pop hl			;335a	e1 	.
11652 335B 2B           	dec hl			;335b	2b 	+
11653 335C E5           	push hl			;335c	e5 	.
11654 335D D5           	push de			;335d	d5 	.
11655 335E C9           	ret			;335e	c9 	.
11656 335F
11657 335F
11658 335F              ; IN - hl - curent address of cursor on screen
11659 335F              l335fh:
11660 335F 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line		;335f	3a a6 78 	: . x
11661 3362 4F           	ld c,a			    ; store position as lsb in register bc  ;3362	4f 	O
11662 3363 AF           	xor a			    ; msb of BC is 0                        ;3363	af 	.
11663 3364 47           	ld b,a			    ; bc - cursor in line position          ;3364	47 	G
11664 3365 ED 42        	sbc hl,bc		    ; hl - first char in current line       ;3365	ed 42 	. B
11665 3367 01 40 00     	ld bc,64		    ; 64 bytes per line                     ;3367	01 40 00 	. @ .
11666 336A 09           	add hl,bc			; hl - first char in next line          ;336a	09 	.
11667 336B E5           	push hl			    ; save hl                               ;336b	e5 	.
11668 336C EB           	ex de,hl			;336c	eb 	.
11669 336D 21 00 72     	ld hl,07200h		;336d	21 00 72 	! . r
11670 3370 ED 52        	sbc hl,de		;3370	ed 52 	. R
11671 3372 E5           	push hl			;3372	e5 	.
11672 3373 C1           	pop bc			;3373	c1 	.
11673 3374 21 DF 71     	ld hl,071dfh		;3374	21 df 71 	! . q
11674 3377 11 FF 71     	ld de,071ffh		;3377	11 ff 71 	. . q
11675 337A 79           	ld a,c			;337a	79 	y
11676 337B B0           	or b			;337b	b0 	.
11677 337C 28 02        	jr z,l3380h		;337c	28 02 	( .
11678 337E ED B8        	lddr		;337e	ed b8 	. .
11679 3380              l3380h:
11680 3380 E1           	pop hl			;3380	e1 	.
11681 3381               ifdef VER_12
11682 3381 06 20        	ld b,020h		;3381	06 20 	.
11683 3383 3E 20        	ld a,020h		;3383	3e 20 	>
11684 3385               else ; VER_20
11685 3385 ~            	call sub_3f02h		;3381	cd 02 3f 	. . ?
11686 3385 ~            	nop 			;3384	00
11687 3385               endif
11688 3385
11689 3385
11690 3385              l3385h:
11691 3385 12           	ld (de),a			;3385	12 	.
11692 3386 1B           	dec de			;3386	1b 	.
11693 3387 10 FC        	djnz l3385h		;3387	10 fc 	. .
11694 3389 CD A8 33     	call GetEditorLineFlag		;3389	cd a8 33 	. . 3
11695 338C E5           	push hl			;338c	e5 	.
11696 338D C1           	pop bc			;338d	c1 	.
11697 338E 21 E6 7A     	ld hl,07ae6h		;338e	21 e6 7a 	! . z
11698 3391 E5           	push hl			;3391	e5 	.
11699 3392 B7           	or a			;3392	b7 	.
11700 3393 ED 42        	sbc hl,bc		;3393	ed 42 	. B
11701 3395 E5           	push hl			;3395	e5 	.
11702 3396 C1           	pop bc			;3396	c1 	.
11703 3397 E1           	pop hl			;3397	e1 	.
11704 3398 E5           	push hl			;3398	e5 	.
11705 3399 D1           	pop de			;3399	d1 	.
11706 339A 2B           	dec hl			;339a	2b 	+
11707 339B ED B8        	lddr		;339b	ed b8 	. .
11708 339D 3A E6 7A     	ld a,(07ae6h)		;339d	3a e6 7a 	: . z
11709 33A0 FE 81        	cp 081h		;33a0	fe 81 	. .
11710 33A2 C0           	ret nz			;33a2	c0 	.
11711 33A3 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 				;33a3	2a 20 78 	*   x
11712 33A6 18 B7        	jr l335fh		;33a6	18 b7 	. .
11713 33A8              GetEditorLineFlag:
11714 33A8              ; -- get Cursor in-line position (column) into BC register
11715 33A8 3A A6 78     	ld a,(CURSORPOS); position of Cursor in Edited line							;33a8	3a a6 78 	: . x
11716 33AB 4F           	ld c,a			; c - LSB of Cursor position (column)						;33ab	4f 	O
11717 33AC AF           	xor a																		;33ac	af 	.
11718 33AD 47           	ld b,a			; bc - Cursor position (column)								;33ad	47 	G
11719 33AE              ; -- calculate VRAM address of Start of current line on screeen
11720 33AE 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 								;33ae	2a 20 78 	*   x
11721 33B1 ED 42        	sbc hl,bc		; hl - address of Start current line						;33b1	ed 42 	. B
11722 33B3 E5           	push hl			; copy address to bc 										;33b3	e5 	.
11723 33B4 C1           	pop bc			; bc - address of Start current line						;33b4	c1 	.
11724 33B5              ; -- calculate screen line number
11725 33B5 78           	ld a,b			; a - high byte of address									;33b5	78 	x
11726 33B6 E6 0F        	and $0f			; constrain range to (0..4095) 								;33b6	e6 0f 	. .
11727 33B8              ; -- divide offset by 32 chars per line
11728 33B8 CB 3F        	srl a			; divide by 2 (now range 0..2047)								;33b8	cb 3f 	. ?
11729 33BA 47           	ld b,a			; store high byte of address								;33ba	47 	G
11730 33BB CB 19        	rr c			; divide by 2 (with bit0 from high byte) (0..1023)			;33bb	cb 19 	. .
11731 33BD CB 39        	srl c			; divide by 2 (0..511)										;33bd	cb 39 	. 9
11732 33BF CB 39        	srl c			; divide by 2 (0..256)										;33bf	cb 39 	. 9
11733 33C1 CB 39        	srl c			; divide by 2 (0..127)										;33c1	cb 39 	. 9
11734 33C3 CB 39        	srl c			; divide by 2 (0..63)										;33c3	cb 39 	. 9
11735 33C5              ; -- get Editor Line Info for current line
11736 33C5 21 D7 7A     	ld hl,EDITORLINES	; hl - Editor Info for every Screen line	            ;33c5	21 d7 7a 	! . z
11737 33C8 09           	add hl,bc		; hl - pointer to Info entry for current line 				;33c8	09 	.
11738 33C9 7E           	ld a,(hl)		; a - Editor Line Info for current line						;33c9	7e 	~
11739 33CA C9           	ret				; ------------------- End of Proc -------------------------	;33ca	c9 	.
11740 33CB
11741 33CB
11742 33CB
11743 33CB
11744 33CB              l33cbh:
11745 33CB CD A8 33     	call GetEditorLineFlag		;33cb	cd a8 33 	. . 3
11746 33CE FE 81        	cp 081h		;33ce	fe 81 	. .
11747 33D0 2A 20 78     	ld hl,(CURSORADDR)	; Cursor Address in VRAM 					;33d0	2a 20 78 	*   x
11748 33D3 E5           	push hl			;33d3	e5 	.
11749 33D4 D1           	pop de			;33d4	d1 	.
11750 33D5 23           	inc hl			;33d5	23 	#
11751 33D6 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line			;33d6	3a a6 78 	: . x
11752 33D9 4F           	ld c,a			;33d9	4f 	O
11753 33DA 28 13        	jr z,l33efh		;33da	28 13 	( .
11754 33DC FE 1F        	cp 01fh		;33dc	fe 1f 	. .
11755 33DE 28 08        	jr z,l33e8h		;33de	28 08 	( .
11756 33E0 3E 1F        	ld a,01fh		;33e0	3e 1f 	> .
11757 33E2              l33e2h:
11758 33E2 91           	sub c			;33e2	91 	.
11759 33E3 4F           	ld c,a			;33e3	4f 	O
11760 33E4 AF           	xor a			;33e4	af 	.
11761 33E5 47           	ld b,a			;33e5	47 	G
11762 33E6 ED B0        	ldir		;33e6	ed b0 	. .
11763 33E8              l33e8h:
11764 33E8               ifdef VER_12
11765 33E8 3E 20        	ld a,020h		;33e8	3e 20 	>
11766 33EA 12           	ld (de),a			;33ea	12 	.
11767 33EB               else ; VER_20
11768 33EB ~            	call sub_3ef6h		;33e8	cd f6 3e 	. . >
11769 33EB               endif
11770 33EB
11771 33EB CD 50 00     	call UpdateCursorChar	; update Cursor Char	;33eb	cd 50 00 	. P .
11772 33EE C9           	ret			;33ee	c9 	.
11773 33EF              l33efh:
11774 33EF 3E 3F        	ld a,03fh		;33ef	3e 3f 	> ?
11775 33F1 18 EF        	jr l33e2h		;33f1	18 ef 	. .
11776 33F3
11777 33F3              ;**************************************************************************************
11778 33F3              ; Scroll Screen and Editor 1 line Up
11779 33F3              ; OUT: hl - VRAM address of Start of Last line on screen
11780 33F3              ScrScrollUp:
11781 33F3              ; -- move content of Screen 1 line up
11782 33F3 11 00 70     	ld de,VRAM			; de - dest address - start of 1st line on Screen			;33f3	11 00 70 	. . p
11783 33F6 21 20 70     	ld hl,VRAM+32		; hl - src address - start of 2nd line on Screen			;33f6	21 20 70 	!   p
11784 33F9 01 E0 01     	ld bc,32*(16-1)		; bc - 15 lines x 32 bytes per line to move 				;33f9	01 e0 01 	. . .
11785 33FC ED B0        	ldir				; copy Screen bytes 1 line up 								;33fc	ed b0 	. .
11786 33FE              ; -- clear last line of screen (fill with ' ')
11787 33FE               ifdef VER_12
11788 33FE 06 20        	ld b,32				; 32 bytes in line to fill									;33fe	06 20 	.
11789 3400 3E 20        	ld a,' '			; char to fill on Screen									;3400	3e 20 	>
11790 3402               else ; VER_20
11791 3402 ~            	call sub_3f02h		;33fe	cd 02 3f 	. . ?
11792 3402 ~            	nop					;3401	00
11793 3402               endif
11794 3402
11795 3402              ; -- after above copy de already points to start of last line
11796 3402              .nextbyte:
11797 3402 12           	ld (de),a			; store ' ' on screen 									;3402	12 	.
11798 3403 13           	inc de				; nex byte												;3403	13 	.
11799 3404 10 FC        	djnz .nextbyte		; fill all 32 bytes										;3404	10 fc 	. .
11800 3406              ; -- move Editor Lines Infos 1 line up
11801 3406 21 D7 7A     	ld hl,EDITORLINES	; hl - Editor Lines Info Table 							;3406	21 d7 7a 	! . z
11802 3409 E5           	push hl				; copy hl to de											;3409	e5 	.
11803 340A D1           	pop de				; de - destination pionter (1st line entry)					;340a	d1 	.
11804 340B 23           	inc hl				; hl - source pointer (2nd line entry)						;340b	23 	#
11805 340C 01 0F 00     	ld bc,15			; 15 lines/entries to move 								;340c	01 0f 00 	. . .
11806 340F ED B0        	ldir				; copy Editor Line Infos one line up					;340f	ed b0 	. .
11807 3411              ; -- correct last line Info
11808 3411 1A           	ld a,(de)			; a - last line Info									;3411	1a 	.
11809 3412 FE 81        	cp $81				; was it first of two-line statement?					;3412	fe 81 	. .
11810 3414 20 03        	jr nz,l3419h		; no - ;3414	20 03 	  .
11811 3416 AF           	xor a			;3416	af 	.
11812 3417 18 02        	jr l341bh		;3417	18 02 	. .
11813 3419              l3419h:
11814 3419 3E 80        	ld a,$80		;3419	3e 80 	> .
11815 341B              l341bh:
11816 341B 12           	ld (de),a			;341b	12 	.
11817 341C              ; -- set Cursor at Start of line
11818 341C AF           	xor a			    ; new Cursor position - begin of line                   ;341c	af 	.
11819 341D 32 A6 78     	ld (CURSORPOS),a	; reset position of Cursor to 0 (begin of Edited line)	;341d	32 a6 78 	2 . x
11820 3420              ; -- return hl pointing to Start of last line of screen
11821 3420 21 E0 71     	ld hl,$71e0			; start of last line on screen							;3420	21 e0 71 	! . q
11822 3423 C9           	ret					; ----------- End of Proc ----------------------------	;3423	c9 	.
11823 3424
11824 3424
11825 3424
11826 3424              ScrollEditorUp:
11827 3424 3A D7 7A     	ld a,(EDITORLINES)	; a - Editor first Line info  								;3424	3a d7 7a 	: . z
11828 3427 FE 81        	cp $81				; is it first of two line statement						;3427	fe 81 	. .
11829 3429 CC F3 33     	call z,ScrScrollUp	; yes - scroll screen one time more					;3429	cc f3 33 	. . 3
11830 342C CD F3 33     	call ScrScrollUp	; Scroll Screen and Editor 1 line Up				;342c	cd f3 33 	. . 3
11831 342F C9           	ret					; ------------- End of Proc -----------------------	;342f	c9 	.
11832 3430              sub_3430h:
11833 3430 21 39 78     	ld hl,SYSFLAGS		; System flags ;3430	21 39 78 	! 9 x
11834 3433 B7           	or a			;3433	b7 	.
11835 3434 20 0B        	jr nz,l3441h		;3434	20 0b 	  .
11836 3436 CB CE        	set 1,(hl)		;3436	cb ce 	. .
11837 3438 01 FF 03     	ld bc,003ffh		;3438	01 ff 03 	. . .
11838 343B              l343bh:
11839 343B 0B           	dec bc			;343b	0b 	.
11840 343C 79           	ld a,c			;343c	79 	y
11841 343D B0           	or b			;343d	b0 	.
11842 343E 20 FB        	jr nz,l343bh		;343e	20 fb 	  .
11843 3440 C9           	ret			;3440	c9 	.
11844 3441              l3441h:
11845 3441 CB 46        	bit 0,(hl)		;3441	cb 46 	. F
11846 3443 C0           	ret nz			;3443	c0 	.
11847 3444 FE 0D        	cp 00dh		;3444	fe 0d 	. .
11848 3446 28 06        	jr z,l344eh		;3446	28 06 	( .
11849 3448 FE 01        	cp 001h		;3448	fe 01 	. .
11850 344A 20 04        	jr nz,l3450h		;344a	20 04 	  .
11851 344C CB D6        	set 2,(hl)		;344c	cb d6 	. .
11852 344E              l344eh:
11853 344E CB C6        	set 0,(hl)		;344e	cb c6 	. .
11854 3450              l3450h:
11855 3450 E5           	push hl			;3450	e5 	.
11856 3451 21 A0 00     	ld hl,000a0h		;3451	21 a0 00 	! . .
11857 3454 01 06 00     	ld bc,$0006		;3454	01 06 00 	. . .
11858 3457 CD 5C 34     	call sub_345ch		;3457	cd 5c 34 	. \ 4
11859 345A E1           	pop hl			;345a	e1 	.
11860 345B C9           	ret			;345b	c9 	.
11861 345C              sub_345ch:
11862 345C 3A 3B 78     	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  						;345c	3a 3b 78 	: ; x
11863 345F 57           	ld d,a			;345f	57 	W
11864 3460              l3460h:
11865 3460 CD 69 34     	call PlayOneTone		;3460	cd 69 34 	. i 4
11866 3463 0B           	dec bc			;3463	0b 	.
11867 3464 79           	ld a,c			;3464	79 	y
11868 3465 B0           	or b			;3465	b0 	.
11869 3466 20 F8        	jr nz,l3460h		;3466	20 f8 	  .
11870 3468 C9           	ret			;3468	c9 	.
11871 3469
11872 3469
11873 3469              ;************************************************************************************
11874 3469              ; Play one sound
11875 3469              ; IN: d - value currently written into IO_LATCH
11876 3469              ;     hl - frequency counter (period length)
11877 3469              ;     bc - total number of periods to play
11878 3469              PlayOneTone:
11879 3469 C5           	push bc			; save bc - number of freq periods to play 					;3469	c5 	.
11880 346A              ; -- set Speaker Pins to opposite values
11881 346A 7A           	ld a,d			; a - value from IO_LATCH									;346a	7a 	z
11882 346B EE 21        	xor %00100001	; inverse Speaker Pins (bits 5 and 0)						;346b	ee 21 	. !
11883 346D 32 00 68     	ld (IO_LATCH),a	; store in hardware register								;346d	32 00 68 	2 . h
11884 3470              ; -- wait delay defined as period length
11885 3470 E5           	push hl			; copy hl to bc												;3470	e5 	.
11886 3471 C1           	pop bc			; bc - period length (delay counter)						;3471	c1 	.
11887 3472              .wait1:
11888 3472 0B           	dec bc			; decrement delay counter									;3472	0b 	.
11889 3473 79           	ld a,c			; a - low byte of counter									;3473	79 	y
11890 3474 B0           	or b			; are both 0 (time elapsed)?								;3474	b0 	.
11891 3475 20 FB        	jr nz,.wait1	; no - wait more											;3475	20 fb 	  .
11892 3477              ; -- revert Speaker Pins to previous values
11893 3477 7A           	ld a,d			; a - previous value from IO_LATCH							;3477	7a 	z
11894 3478 32 00 68     	ld (IO_LATCH),a	; store in hardware register								;3478	32 00 68 	2 . h
11895 347B              ; -- wait delay defined as period length
11896 347B E5           	push hl			; copy hl to bc 											;347b	e5 	.
11897 347C C1           	pop bc			; bc - period length (delay counter)						;347c	c1 	.
11898 347D              .wait2:
11899 347D 0B           	dec bc			; decrement delay counter									;347d	0b 	.
11900 347E 79           	ld a,c			; a - low byte of counter									;347e	79 	y
11901 347F B0           	or b			; are both 0 (time elapsed)?								;347f	b0 	.
11902 3480 20 FB        	jr nz,.wait2	; no - wait more											;3480	20 fb 	  .
11903 3482              ; -- restore bc and return back
11904 3482 C1           	pop bc			; restore bc - number of freq periods to play 				;3482	c1 	.
11905 3483 C9           	ret				; -------------------- End of Proc ------------------------	;3483	c9 	.
11906 3484
11907 3484
11908 3484
11909 3484
11910 3484              sub_3484h:
11911 3484              ; -- set Space as current Cursor char
11912 3484               ifdef VER_12
11913 3484 3E 20        	ld a,' '		    ; space character and also Gfx Mode 0 byte  			;3484	3e 20 	>
11914 3486 32 3C 78     	ld (CURSORCHAR),a	; set as current character at cursor position			;3486	32 3c 78 	2 < x
11915 3489               else ; VER_20
11916 3489 ~            	call sub_3fa0h		;3484	cd a0 3f 	. . ?
11917 3489 ~            	ld a,%00100000		;3487	3e 20
11918 3489               endif
11919 3489              ; -- reset video Mode to Text (0)
11920 3489 32 3B 78     	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH  				;3489	32 3b 78 	2 ; x
11921 348C 32 00 68     	ld (IO_LATCH),a		; store in hardware register	;348c	32 00 68 	2 . h
11922 348F              ; --
11923 348F 3E 3C        	ld a,60		;348f	3e 3c 	> <
11924 3491 32 3A 78     	ld (KEYS_DEBOUNCER),a		;3491	32 3a 78 	2 : x
11925 3494              ; -- set initial value for Cursor Timer
11926 3494 3E 10        	ld a,16				; initial timer value 									;3494	3e 10 	> .
11927 3496 32 41 78     	ld (CURSORTIMER),a	; reset timer for inverse char under cursor				;3496	32 41 78 	2 A x
11928 3499              ; --
11929 3499 AF           	xor a				;3499	af 	.
11930 349A 32 AF 7A     	ld (07aafh),a		;349a	32 af 7a 	2 . z
11931 349D 21 B2 7A     	ld hl,TAPEFILENAME	; tape buffer for filename (18) bytes	;349d	21 b2 7a 	! . z
11932 34A0 22 B0 7A     	ld (07ab0h),hl		;34a0	22 b0 7a 	" . z
11933 34A3 3E C9        	ld a,0c9h		;34a3	3e c9 	> .
11934 34A5 C3 37 3E     	jp l3e37h		;34a5	c3 37 3e 	. 7 >
11935 34A8 C9           	ret			;34a8	c9 	.
11936 34A9
11937 34A9
11938 34A9
11939 34A9              ; **********************************************************************************************
11940 34A9              ; BASIC CSAVE Entry Point
11941 34A9              ; Saves a BASIC program to tape.
11942 34A9              ; On entry, the HL register pair must point to the start of a valid filename sequence (a quotation
11943 34A9              ; mark followed by a single character filename, which in turn may be optionally followed by a second
11944 34A9              ; quotation mark, The entire filename sequence must be terminated by a zero byte or colon).
11945 34A9              ; IN: hl - current executed command parser
11946 34A9              ;     a - command byte
11947 34A9              ;     Z = 1 - end of statement ('\0' or ':' found)
11948 34A9              ;     CY = 1 - char is digit
11949 34A9              CmdCSAVE
11950 34A9              ; -- disable interrupt to avoid timing issues
11951 34A9 F3           	di					; disable interrupts 									;34a9	f3 	.
11952 34AA              ; -- send to Tape header - sync blocks, file type (Basic) and file name
11953 34AA 0E F0        	ld c,$f0			; file type - Basic 									;34aa	0e f0 	. .
11954 34AC CD 58 35     	call TapeWriteHeader; Send sync and file header to Tape						;34ac	cd 58 35 	. X 5
11955 34AF DA FE 3A     	jp c,TapeAbort		; Break - Cancel loading Tape and pass control to Basic ;34af	da fe 3a 	. . :
11956 34B2 E5           	push hl				; save hl 												;34b2	e5 	.
11957 34B3              ; -- wait delay (10+(6+4+4+13)*410+8)x0.279us = 11088x0.297us = 3293.136us ~3.3ms
11958 34B3 01 9A 01     	ld bc,410			; delay counter											;34b3	01 9a 01 	. . .
11959 34B6              .wait:
11960 34B6 0B           	dec bc				; decrement delay counter								;34b6	0b 	.
11961 34B7 79           	ld a,c				; low byte of counter									;34b7	79 	y
11962 34B8 B0           	or b				; is counter 0?											;34b8	b0 	.
11963 34B9 20 FB        	jr nz,.wait			; no - wait delay 3.3ms									;34b9	20 fb 	  .
11964 34BB              ; -- test Ctrl+Break and execute Basic STOP command
11965 34BB CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;34bb	cd f8 3a 	. . :
11966 34BE DD 21 23 78  	ld ix,TAPE_CRC		; ix - pointer to CRC 16bit value						;34be	dd 21 23 78 	. ! # x
11967 34C2
11968 34C2              ; -- send program start address (destination for CLOAD later)
11969 34C2 2A A4 78     	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;34c2	2a a4 78 	* . x
11970 34C5 7D           	ld a,l				; low byte of address									;34c5	7d 	}
11971 34C6 CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34c6	cd 11 35 	. . 5
11972 34C9 DD 77 00     	ld (ix+0),a			; store into CRC 										;34c9	dd 77 00 	. w .
11973 34CC AF           	xor a				; high byte of init CRC (0)								;34cc	af 	.
11974 34CD DD 77 01     	ld (ix+1),a			; CRC = 0 + LSB of program address						;34cd	dd 77 01 	. w .
11975 34D0 7C           	ld a,h				; high byte of address									;34d0	7c 	|
11976 34D1 CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34d1	cd 11 35 	. . 5
11977 34D4 CD 8E 38     	call AddToCRC		; Add high byte of addres to Tape CRC 					;34d4	cd 8e 38 	. . 8
11978 34D7              ; -- save program addres in de for later use
11979 34D7 EB           	ex de,hl			; de - program start address							;34d7	eb 	.
11980 34D8              ; -- send program end address
11981 34D8 2A F9 78     	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program					;34d8	2a f9 78 	* . x
11982 34DB 7D           	ld a,l				; low byte of address									;34db	7d 	}
11983 34DC CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34dc	cd 11 35 	. . 5
11984 34DF CD 8E 38     	call AddToCRC		; Add low byte of addres to Tape CRC 					;34df	cd 8e 38 	. . 8
11985 34E2 7C           	ld a,h				; high byte of address									;34e2	7c 	|
11986 34E3 CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34e3	cd 11 35 	. . 5
11987 34E6 CD 8E 38     	call AddToCRC		; Add high byte of addres to Tape CRC 					;34e6	cd 8e 38 	. . 8
11988 34E9              ; -- test Ctrl+Break and execute Basic STOP command
11989 34E9 CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;34e9	cd f8 3a 	. . :
11990 34EC              ; -- send Basic Program content
11991 34EC              .next:
11992 34EC 1A           	ld a,(de)			; a - byte of Basic Program code 						;34ec	1a 	.
11993 34ED 13           	inc de				; points to next byte									;34ed	13 	.
11994 34EE CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34ee	cd 11 35 	. . 5
11995 34F1 CD 8E 38     	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;34f1	cd 8e 38 	. . 8
11996 34F4              ; -- test Ctrl+Break and execute Basic STOP command
11997 34F4 CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;34f4	cd f8 3a 	. . :
11998 34F7              ; -- test if all Program bytes are sent
11999 34F7 DF           	rst #18				; compare if HL equals DE - all bytes sent				;34f7	df 	.
12000 34F8 20 F2        	jr nz,.next			; no - send all bytes of Basic Program 					;34f8	20 f2 	  .
12001 34FA              ; -- all bytes sent - now send calculated CRC
12002 34FA DD 7E 00     	ld a,(ix+0)			; low byte of CRC										;34fa	dd 7e 00 	. ~ .
12003 34FD CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34fd	cd 11 35 	. . 5
12004 3500 DD 7E 01     	ld a,(ix+1)			; high byte of CRC										;3500	dd 7e 01 	. ~ .
12005 3503 CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;3503	cd 11 35 	. . 5
12006 3506              ; -- send trailing sequence block - 20 x $00
12007 3506 06 14        	ld b,20				; counter - 20 bytes to send							;3506	06 14 	. .
12008 3508 AF           	xor a				; byte value to send									;3508	af 	.
12009 3509              .next0:
12010 3509 CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;3509	cd 11 35 	. . 5
12011 350C 10 FB        	djnz .next0			; decrement counter - send 20 times						;350c	10 fb 	. .
12012 350E              ; -- restore hl, enable interrupts and exit
12013 350E E1           	pop hl				; restore hl											;350e	e1 	.
12014 350F FB           	ei					; enable interrupts										;350f	fb 	.
12015 3510 C9           	ret					; --------------------- End of Proc -------------------	;3510	c9 	.
12016 3511
12017 3511
12018 3511
12019 3511              ;*********************************************************************************************
12020 3511              ; Send 1 byte to Tape via hardware register (IO_LATCH)
12021 3511              ; IN: a - byte to send
12022 3511              TapeWriteByte:
12023 3511              ; -- preserve used registers
12024 3511 F5           	push af				; save af 												;3511	f5 	.
12025 3512 C5           	push bc				; save bc 												;3512	c5 	.
12026 3513 E5           	push hl				; save hl												;3513	e5 	.
12027 3514              ; -- initialize bit counter
12028 3514 2E 08        	ld l,8				; 8 bits to send 										;3514	2e 08 	. .
12029 3516 67           	ld h,a				; h - data byte to send 								;3516	67 	g
12030 3517              ; -- send data byte (MSB first) as sequence of pulse packs (1680us long):
12031 3517              ;    0 - Short Long 		(560us + 1120us)
12032 3517              ;    1 - Short Short Short	(560us + 560us + 560us)
12033 3517              .nextbit:
12034 3517 CD 42 35     	call TapeShortPulse	; Send one pulse 1/0 (280us each) to Tape via IO_LATCH	;3517	cd 42 35 	. B 5
12035 351A CB 04        	rlc h				; CY - next bit to send									;351a	cb 04 	. .
12036 351C 30 0D        	jr nc,TapeLongPulse	; Send one pulse 1/0 (560us each) to Tape via IO_LATCH	;351c	30 0d 	0 .
12037 351E CD 42 35     	call TapeShortPulse	; Send one pulse 1/0 (280us each) to Tape via IO_LATCH	;351e	cd 42 35 	. B 5
12038 3521 CD 42 35     	call TapeShortPulse	; Send one pulse 1/0 (280us each) to Tape via IO_LATCH	;3521	cd 42 35 	. B 5
12039 3524              .cont:
12040 3524 2D           	dec l				; decrement bit counter - all bits sent?				;3524	2d 	-
12041 3525 20 F0        	jr nz,.nextbit		; no - send next bit									;3525	20 f0 	  .
12042 3527              ; -- restore registers
12043 3527 E1           	pop hl				; restore hl											;3527	e1 	.
12044 3528 C1           	pop bc				; restore bc											;3528	c1 	.
12045 3529 F1           	pop af				; restore af											;3529	f1 	.
12046 352A C9           	ret					; ------------------- End of Proc ---------------------	;352a	c9 	.
12047 352B
12048 352B
12049 352B
12050 352B              ;**************************************************************************************
12051 352B              ; Send one pulse 1/0 (560us each) to Tape via IO_LATCH
12052 352B              TapeLongPulse:
12053 352B              ; -- set bit 2 and bit 1 (Cassette Out) to 1
12054 352B 3A 3B 78     	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  							;352b	3a 3b 78 	: ; x
12055 352E F6 06        	or %00000110		; set bit 2 (Cassette Out(-)) and bit 1 (Cassette Out(+))		;352e	f6 06 	. .
12056 3530 32 00 68     	ld (IO_LATCH),a		; store in hardware register									;3530	32 00 68 	2 . h
12057 3533              ; -- wait long delay (7+153*13+8)*0.279us = 2004*0.279us = 559.116us ~ 560us
12058 3533 06 99        	ld b,153			; delay counter 												;3533	06 99 	. .
12059 3535              .wait1:
12060 3535 10 FE        	djnz .wait1			; wait 560us													;3535	10 fe 	. .
12061 3537              ; -- clear bit 2 and bit 1 (Cassette Out) to 0
12062 3537 E6 F9        	and %11111001		; clear bit 2 (Cassette Out(-)) and bit 1 (Cassette Out(+))		;3537	e6 f9 	. .
12063 3539 32 00 68     	ld (IO_LATCH),a		; store in hardware register									;3539	32 00 68 	2 . h
12064 353C              ; -- wait long delay (7+153*13+8)*0.279us = 2004*0.279us = 559.116us ~ 560us
12065 353C 06 99        	ld b,153			; delay counter													;353c	06 99 	. .
12066 353E              .wait2:
12067 353E 10 FE        	djnz .wait2			; wait 560us													;353e	10 fe 	. .
12068 3540 18 E2        	jr TapeWriteByte.cont; continue sending bits											;3540	18 e2 	. .
12069 3542
12070 3542
12071 3542
12072 3542
12073 3542              ;****************************************************************************************
12074 3542              ; Send one pulse 1/0 (280us each) to Tape via IO_LATCH
12075 3542              TapeShortPulse:
12076 3542              ; -- set bit 2 and bit 1 (Cassette Out) to 1
12077 3542 3A 3B 78     	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  							;3542	3a 3b 78 	: ; x
12078 3545 F6 06        	or %00000110		; set bit 2 (Cassette Out(-)) and bit 1 (Cassette Out(+))		;3545	f6 06 	. .
12079 3547 32 00 68     	ld (IO_LATCH),a		; store in hardware register									;3547	32 00 68 	2 . h
12080 354A              ; -- wait short delay (7+76*13+8)*0.279us = 1003*0.279us = 279.837us ~ 280us
12081 354A 06 4C        	ld b,76				; delay counter													;354a	06 4c 	. L
12082 354C              .wait1:
12083 354C 10 FE        	djnz .wait1			; wait 280us													;354c	10 fe 	. .
12084 354E              ; -- clear bit 2 and bit 1 (Cassette Out) to 0
12085 354E E6 F9        	and %11111001		; clear bit 2 (Cassette Out(-)) and bit 1 (Cassette Out(+))		;354e	e6 f9 	. .
12086 3550 32 00 68     	ld (IO_LATCH),a		; store in hardware register									;3550	32 00 68 	2 . h
12087 3553              ; -- wait short delay (7+76*13+8)*0.279us = 1003*0.279us = 279.837us ~ 280us
12088 3553 06 4C        	ld b,76				; delay counter													;3553	06 4c 	. L
12089 3555              .wait2:
12090 3555 10 FE        	djnz .wait2			; wait 280us													;3555	10 fe 	. .
12091 3557 C9           	ret					; ----------------- End of Proc -------------------------------	;3557	c9 	.
12092 3558
12093 3558
12094 3558
12095 3558
12096 3558              ;****************************************************************************************
12097 3558              ; Send sync and file header to Tape
12098 3558              ; IN: c - file type (F0 or F2)
12099 3558              TapeWriteHeader:
12100 3558              ; -- get filename from command parameter and store in Tape Filename Buffer
12101 3558 CD 8C 35     	call TapeParseFilename	; parse filename into FileNameBuf					;3558	cd 8c 35 	. . 5
12102 355B
12103 355B              ; -- send sync (1) block to Tape - 255 x $80
12104 355B 06 FF        	ld b,255			; counter - 255 bytes to send							;355b	06 ff 	. .
12105 355D              .next1:
12106 355D 3E 80        	ld a,$80			; byte to send											;355d	3e 80 	> .
12107 355F CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;355f	cd 11 35 	. . 5
12108 3562 CD E8 3A     	call TestCtrlBreak	; Test if Ctrl+Break keys pressed						;3562	cd e8 3a 	. . :
12109 3565 D8           	ret c			    ; yes ---------- End of Proc -------------------------- ;3565	d8 	.
12110 3566 10 F5        	djnz .next1			; decrement byte counter - jump if not all sent yet		;3566	10 f5 	. .
12111 3568
12112 3568              ; -- send sync (2) block to Tape - 5 x $fe
12113 3568 06 05        	ld b,5				; counter - 5 bytes to send								;3568	06 05 	. .
12114 356A              .next2:
12115 356A 3E FE        	ld a,$fe			; byte to send											;356a	3e fe 	> .
12116 356C CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;356c	cd 11 35 	. . 5
12117 356F CD E8 3A     	call TestCtrlBreak	; Test if Ctrl+Break keys pressed						;356f	cd e8 3a 	. . :
12118 3572 D8           	ret c			    ; yes ---------- End of Proc -------------------------- ;3572	d8 	.
12119 3573 10 F5        	djnz .next2			; decrement byte counter - jump if not all sent yet		;3573	10 f5 	. .
12120 3575              ; -- send file type byte
12121 3575 79           	ld a,c				; file type byte										;3575	79 	y
12122 3576 CD 11 35     	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;3576	cd 11 35 	. . 5
12123 3579 CD E8 3A     	call TestCtrlBreak	; Test if Ctrl+Break keys pressed						;3579	cd e8 3a 	. . :
12124 357C D8           	ret c			    ; yes ---------- End of Proc -------------------------- ;357c	d8 	.
12125 357D              ; -- send file name
12126 357D 3A D6 7A     	ld a,(FILENAMELEN)	; length of file name for tape (including 0 terminator)	;357d	3a d6 7a 	: . z
12127 3580 47           	ld b,a				; char counter											;3580	47 	G
12128 3581 11 9D 7A     	ld de,FileNameBuf	; addres of tape file name buffer (17 bytes)			;3581	11 9d 7a 	. . z
12129 3584              .nextchar:
12130 3584 1A           	ld a,(de)			; char of file name										;3584	1a 	.
12131 3585 13           	inc de				; points to next char									;3585	13 	.
12132 3586 CD 11 35     	call TapeWriteByte	; Send char to Tape via hardware register (IO_LATCH)	;3586	cd 11 35 	. . 5
12133 3589 10 F9        	djnz .nextchar		; decrement counter - jump if not all sent yet			;3589	10 f9 	. .
12134 358B C9           	ret					; ------------------- End of Proc ---------------------	;358b	c9 	.
12135 358C
12136 358C
12137 358C              ;***************************************************************************************
12138 358C              ; Parse filename (quoted with '"') and copy into File Name Buffer
12139 358C              ; IN: hl - address of filename text
12140 358C              ; OUT: a - filename length
12141 358C              TapeParseFilename:
12142 358C              ; -- filename can have max 16 chars
12143 358C 06 10        	ld b,16				; 16 chars maximum										;358c	06 10 	. .
12144 358E 11 9D 7A     	ld de,FileNameBuf	; addres of tape file name buffer (16 bytes)			;358e	11 9d 7a 	. . z
12145 3591              ; -- test if there is no filename given - end of statement or line
12146 3591 7E           	ld a,(hl)			; a - byte from program									;3591	7e 	~
12147 3592 FE 3A        	cp ':'				; is it End of Basic Statement (no filename given)		;3592	fe 3a 	. :
12148 3594 28 12        	jr z,.exit			; yes - add '\0' terminator (empty filename)			;3594	28 12 	( .
12149 3596 B7           	or a				; is it End of Basic Line or Command (no filename) 		;3596	b7 	.
12150 3597 28 0F        	jr z,.exit			; yes - add '\0' terminator (empty filename)			;3597	28 0f 	( .
12151 3599              ; -- filename text must be enclosed with '"' char
12152 3599 CF           	rst $08				; Assert next token is '"' 								;3599	cf 	.
12153 359A 22           	defb '"'			; Basic '"' token - start of string 					;359a	22
12154 359B              .next
12155 359B              ; -- copy filename into FileNameBuf (max 16 chars)
12156 359B 7E           	ld a,(hl)			; char of filename										;359b	7e 	" .
12157 359C B7           	or a				; is it End of Basic Line or Command?					;359b	b7
12158 359D 28 09        	jr z,.exit			; yes - add '\0' terminator (filename ready)			;359d	28 09 	( .
12159 359F 23           	inc hl				; advance source char pointer							;359f	23 	#
12160 35A0 FE 22        	cp '"'				; is it end of string delimiter							;35a0	fe 22 	. "
12161 35A2 28 04        	jr z,.exit			; yes - add '\0' terminator (filename ready)			;35a2	28 04 	( .
12162 35A4 12           	ld (de),a			; copy char into buffer									;35a4	12 	.
12163 35A5 13           	inc de				; advance destination char pointer						;35a5	13 	.
12164 35A6 10 F3        	djnz .next 			; decrement counter - copy max 16 chars					;35a6	10 f3 	. .
12165 35A8              .exit:
12166 35A8              ; -- filename text must always be terminated with '\0'
12167 35A8 AF           	xor a				; 0 - string terminator									;35a8	af 	.
12168 35A9 12           	ld (de),a			; store at last position in buffer						;35a9	12 	.
12169 35AA              ; -- calculate text length (including 0 terminator)
12170 35AA 3E 11        	ld a,17				; 17 chars (max 16 + 1 termiantor)						;35aa	3e 11 	> .
12171 35AC 90           	sub b				; substract downcounter value							;35ac	90 	.
12172 35AD 32 D6 7A     	ld (FILENAMELEN),a	; store length of file name for tape					;35ad	32 d6 7a 	2 . z
12173 35B0 C9           	ret					; ----------------- End of Proc -----------------------	;35b0	c9 	.
12174 35B1
12175 35B1
12176 35B1
12177 35B1              ;*********************************************************************************
12178 35B1              ; Prepeare Screen for TAPE info texts
12179 35B1              ; Set cursor at the end of screen
12180 35B1              TapePrepScreen:
12181 35B1              ; -- if Hide Info Flag is set then skip Screen preparation
12182 35B1 3A 4C 78     	ld a,(TAPEHIDEINFO)		; Tape Hide Info flag								;35b1	3a 4c 78 	: L x
12183 35B4 B7           	or a					; hide info about Tape operation?					;35b4	b7 	.
12184 35B5 C0           	ret nz					; yes - ---------- End of Proc --------------------	;35b5	c0 	.
12185 35B6              ; -- check if Gfx MODE 0 (TXT) and Reset Screen/Editor if not
12186 35B6 3A 3B 78     	ld a,(IOLATCH_COPY)		; a - last value written to IO_LATCH  				;35b6	3a 3b 78 	: ; x
12187 35B9 CB 5F        	bit 3,a					; is Gfx MOde 0 already?							;35b9	cb 5f 	. _
12188 35BB 28 0B        	jr z,.setCursor			; yes - skip Editor Reset							;35bb	28 0b 	( .
12189 35BD              ; -- set Text Mode, clear Screen and reset Editor
12190 35BD E6 F7        	and %11110111			; clear bit 3 - set Mode 0 (text)					;35bd	e6 f7 	. .
12191 35BF 32 3B 78     	ld (IOLATCH_COPY),a		; save as last value written to IO_LATCH  			;35bf	32 3b 78 	2 ; x
12192 35C2 32 00 68     	ld (IO_LATCH),a			; set Gfx Mode 0 									;35c2	32 00 68 	2 . h
12193 35C5 CD 92 32     	call ResetEditor		; clear Screen and Editor Flags						;35c5	cd 92 32 	. . 2
12194 35C8              .setCursor:
12195 35C8              ; -- set Cursor at bottom-right of Screen (last char)
12196 35C8 21 FF 71     	ld hl,VRAM+511			; hl - last char of screen (bottom-right)			;35c8	21 ff 71 	! . q
12197 35CB 22 20 78     	ld (CURSORADDR),hl		; set Cursor Address in VRAM 						;35cb	22 20 78 	"   x
12198 35CE 3E 1F        	ld a,31		        	; new Cursor position - end of line                 ;35ce	3e 1f 	> .
12199 35D0 32 A6 78     	ld (CURSORPOS),a		; set new position of Cursor in Edited line			;35d0	32 a6 78 	2 . x
12200 35D3              ; -- correct Editor flags for last 2 lines
12201 35D3 3A E5 7A     	ld a,(EDITORLINES+14)	; Editor 15th Line Info 							;35d3	3a e5 7a 	: . z
12202 35D6 FE 81        	cp $81					; is it first of two-line-statement					;35d6	fe 81 	. .
12203 35D8 C0           	ret nz					; no - no correction needed -----------------------	;35d8	c0 	.
12204 35D9              ; -- lines 15 and 16 was taken as one 2 line edit - convert into two single lines
12205 35D9 3D           	dec a					; a = $80 - single line								;35d9	3d 	=
12206 35DA 32 E5 7A     	ld (EDITORLINES+14),a	; set Editor line 15 as single line					;35da	32 e5 7a 	2 . z
12207 35DD 32 E6 7A     	ld (EDITORLINES+15),a	; set Editor line 16 as single line					;35dd	32 e6 7a 	2 . z
12208 35E0 C9           	ret						; ----------------- End of Proc -------------------	;35e0	c9 	.
12209 35E1
12210 35E1
12211 35E1
12212 35E1
12213 35E1 21 42 38     	ld hl,TXT_WAITING	; text 'WAITING'										;35e1	21 42 38 	! B 8
12214 35E4 CD F4 37     	call TapeDispOper	; Display Tape Operation Info 'WAITING' 				;35e4	cd f4 37 	. . 7
12215 35E7
12216 35E7
12217 35E7              ;********************************************************************************
12218 35E7              ; Read sync, file type and name from Tape
12219 35E7              TapeReadHeader:
12220 35E7              .start
12221 35E7              ; -- test Ctrl+Break and execute Basic STOP command
12222 35E7 CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;35e7	cd f8 3a 	. . :
12223 35EA              ; -- wait for transmission start
12224 35EA 3A 00 68     	ld a,(CassIn)		; read Tape input bit									;35ea	3a 00 68 	: . h
12225 35ED CB 77        	bit 6,a				; is bit reset (Tape input Active)?						;35ed	cb 77 	. w
12226 35EF 20 F6        	jr nz,.start		; no - wait for bit active								;35ef	20 f6 	  .
12227 35F1              .waitforStart:
12228 35F1 CD 8F 37     	call TapeReadBit	; Read 1 bit from Tape and insert into d MSB first		;35f1	cd 8f 37 	. . 7
12229 35F4 38 F1        	jr c,.start			; error ----------- start over with BREAK check ------- ;35f4	38 f1 	8 .
12230 35F6              ; -- a contains bit 0 already read
12231 35F6 CB 47        	bit 0,a				; is data bit = 1										;35f6	cb 47 	. G
12232 35F8 28 F7        	jr z,.waitforStart			; no - read next bit - we want 1 						;35f8	28 f7 	( .
12233 35FA              ; -- first bit was 1 - read remaining 7 bits
12234 35FA 06 07        	ld b,7				; bit counter											;35fa	06 07 	. .
12235 35FC              .nextBit:
12236 35FC CD 8F 37     	call TapeReadBit	; Read 1 bit from Tape and insert into d MSB first		;35fc	cd 8f 37 	. . 7
12237 35FF 38 E6        	jr c,.start			; error ----------- start over with BREAK check ------- ;35ff	38 e6 	8 .
12238 3601 10 F9        	djnz .nextBit		; success - read all 7 bits								;3601	10 f9 	. .
12239 3603              ; -- all 8 bits from Tape stored in a
12240 3603 FE 80        	cp $80				; is it SYNC80 byte	?									;3603	fe 80 	. .
12241 3605 20 E0        	jr nz,.start		; no ------------- start over with BREAK check -------- ;3605	20 e0 	  .
12242 3607
12243 3607              .next80:
12244 3607 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 								;3607	cd 75 37 	. u 7
12245 360A DA E7 35     	jp c,.start			; error ----------- start over with BREAK check ------- ;360a	da e7 35 	. . 5
12246 360D FE 80        	cp $80				; is it SYNC80 byte	?									;360d	fe 80 	. .
12247 360F 28 F6        	jr z,.next80		; yes - read next sync byte								;360f	28 f6 	( .
12248 3611              ; -- sync (80) ended - 1 byte already read - 4 more to go
12249 3611 06 04        	ld b,4				; 4 bytes (SYNCFE) to read								;3611	06 04 	. .
12250 3613              .nextFE:
12251 3613 FE FE        	cp $fe				; is it SYNCFE byte	?									;3613	fe fe 	. .
12252 3615 C2 E7 35     	jp nz,.start		; no ------------- start over with BREAK check -------- ;3615	c2 e7 35 	. . 5
12253 3618 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 								;3618	cd 75 37 	. u 7
12254 361B DA E7 35     	jp c,.start			; error ----------- start over with BREAK check ------- ;361b	da e7 35 	. . 5
12255 361E 10 F3        	djnz .nextFE		; read all 4 bytes 										;361e	10 f3 	. .
12256 3620              ; -- sunc (FE) ended - read file type (F0 or F2)
12257 3620 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 								;3620	cd 75 37 	. u 7
12258 3623 32 D2 7A     	ld (TAPEFILETYPE),a	; save as File Type byte								;3623	32 d2 7a 	2 . z
12259 3626              ; -- read File Name
12260 3626 21 B2 7A     	ld hl,TAPEFILENAME	; address of buffer for filename (18) bytes				;3626	21 b2 7a 	! . z
12261 3629 06 12        	ld b,18				; maximum 18 bytes to read								;3629	06 12 	. .
12262 362B              .nextChar:
12263 362B CD 75 37     	call TapeReadByte	; Read 1 char from Tape 								;362b	cd 75 37 	. u 7
12264 362E 77           	ld (hl),a			; store char in buffer									;362e	77 	w
12265 362F B7           	or a				; is it '\0' (end of text)?								;362f	b7 	.
12266 3630 28 06        	jr z,.fileFound			; yes - display filename and copy to system buffer		;3630	28 06 	( .
12267 3632 23           	inc hl				; points to next location in buffer						;3632	23 	#
12268 3633 10 F6        	djnz .nextChar		; read from Tape 18 bytes or until terminated with 0	;3633	10 f6 	. .
12269 3635              ; -- FAIL: filename must be terminated with '\0'
12270 3635 C3 E7 35     	jp .start			; error ----------- start over with BREAK check ------- ;3635	c3 e7 35 	. . 5
12271 3638
12272 3638              .fileFound:
12273 3638              ; -- display text 'FOUND' on Screen
12274 3638 21 5A 38     	ld hl,TXT_FOUND		; text 'FOUND'											;3638	21 5a 38 	! Z 8
12275 363B CD F4 37     	call TapeDispOper	; Display Tape Operation Info 'FOUND'					;363b	cd f4 37 	. . 7
12276 363E              ; -- display file name and type on Screen
12277 363E 21 B2 7A     	ld hl,TAPEFILENAME	; address of tape buffer with filename 					;363e	21 b2 7a 	! . z
12278 3641 CD 14 38     	call TapeDispFileInfo	; display file type and file name					;3641	cd 14 38 	. . 8
12279 3644              ; -- compare filename requested by user with filename found
12280 3644 21 B2 7A     	ld hl,TAPEFILENAME	; address of buffer with filename found 				;3644	21 b2 7a 	! . z
12281 3647 11 9D 7A     	ld de,FileNameBuf	; address of buffer with filename requested by user		;3647	11 9d 7a 	. . z
12282 364A              .cmpNext:
12283 364A 1A           	ld a,(de)			; char of requested filename							;364a	1a 	.
12284 364B B7           	or a				; is it '\0' (end of string)?							;364b	b7 	.
12285 364C C8           	ret z				; yes - filenames match --------- End of Proc ---------	;364c	c8 	.
12286 364D BE           	cp (hl)				; is the same as char of found filename?				;364d	be 	.
12287 364E C2 E7 35     	jp nz,.start		; no -------------- start over with BREAK check ------- ;364e	c2 e7 35 	. . 5
12288 3651 23           	inc hl				; points to next char of found filename					;3651	23 	#
12289 3652 13           	inc de				; points to next char of requested filename				;3652	13 	.
12290 3653 18 F5        	jr .cmpNext			; compare all chars of filenames						;3653	18 f5 	. .
12291 3655              ; -- dead code
12292 3655 C9           	ret					; --------------- End of Proc ------------------------- ;3655	c9 	.
12293 3656
12294 3656
12295 3656              ; *******************************************************************************************
12296 3656              ; BASIC CLOAD Entry Point
12297 3656              ; Loads a BASIC program from tape.
12298 3656              ; On entry, the HL register pair must point to a valid argument for the CLOAD command,
12299 3656              ; or to a zero byte or colon terminator. A valid argument could consist of a filename
12300 3656              ; sequence (as explained for above CSA¥E routine), a question mark (to verify
12301 3656              ; the program on tape against the program in memory), etc.
12302 3656              ; Arguments must be properly terminated with a colon or zero byte,
12303 3656              ; NOTE: This routine 'does NOT return to the calling program, but instead exits
12304 3656              ; to the BASIC command level ("READY" prompt)
12305 3656              ; IN: hl - current executed command parser
12306 3656              ;     a - command byte
12307 3656              ;     Z = 1 - end of statement ('\0' or ':' found)
12308 3656              ;     CY = 1 - char is digit
12309 3656              CmdCLOAD
12310 3656              ; -- setup state
12311 3656 E5           	push hl				; save hl 												;3656	e5 	.
12312 3657 21 39 78     	ld hl,SYSFLAGS		; address of System flags 								;3657	21 39 78 	! 9 x
12313 365A CB B6        	res 6,(hl)			; clear load for VERIFY flag							;365a	cb b6 	. .
12314 365C CB 9E        	res 3,(hl)			; clear load for CRUN flag								;365c	cb 9e 	. .
12315 365E E1           	pop hl				; rstore hl												;365e	e1 	.
12316 365F
12317 365F
12318 365F              TapeReadFile:
12319 365F F3           	di					; disable interrupt 									;365f	f3 	.
12320 3660              ; -- get filename from command parameter and store in Tape Filename Buffer
12321 3660 CD 8C 35     	call TapeParseFilename	; parse filename into FileNameBuf					;3660	cd 8c 35 	. . 5
12322 3663 E5           	push hl				; save hl - current parse point 						;3663	e5 	.
12323 3664              ;-- prepare Screen - move Cursor to end of last line
12324 3664 CD B1 35     	call TapePrepScreen	; Prepeare Screen for TAPE info texts					;3664	cd b1 35 	. . 5
12325 3667              TapeReadStart:
12326 3667              ; -- clean last line of Screen and copy there text 'WAITING'
12327 3667 21 42 38     	ld hl,TXT_WAITING	; hl - text 'WAITING'									;3667	21 42 38 	! B 8
12328 366A CD F4 37     	call TapeDispOper	; Display Tape Operation Info 'WAITING'					;366a	cd f4 37 	. . 7
12329 366D              .start:
12330 366D              ; -- read file header - found filename must match requested filename (unless it's empty)
12331 366D CD E7 35     	call TapeReadHeader	; Read sync, file type and name from Tape				;366d	cd e7 35 	. . 5
12332 3670              ; -- we want Program (text or bin) file - check if it is Data file type
12333 3670 3A D2 7A     	ld a,(TAPEFILETYPE)	; file type read from Tape								;3670	3a d2 7a 	: . z
12334 3673 FE F2        	cp $f2				; is it Data File (type F2)?							;3673	fe f2 	. .
12335 3675 28 F6        	jr z,.start			; yes ----------------- load again another file -------	;3675	28 f6 	( .
12336 3677              ; -- found requested file - chabge displayed operation to 'LOADING'
12337 3677 21 60 38     	ld hl,TXT_LOADING	; text 'LOADING'										;3677	21 60 38 	! ` 8
12338 367A CD 04 38     	call TapeDispOper2	; Display Tape Operation Info 'LOADING'					;367a	cd 04 38 	. . 8
12339 367D              ; -- rest of file data must conform CRC
12340 367D DD 21 23 78  	ld ix,TAPE_CRC		; ix - address of 16bit variable for CRC				;367d	dd 21 23 78 	. ! # x
12341 3681              ; -- load Program Start and Program End from file
12342 3681 CD 68 38     	call TapeReadPrgStartEnd	; load Start and End addresses 					;3681	cd 68 38 	. h 8
12343 3684               ifdef VER_12
12344 3684 DA 6D 36     	jp c,.start			; error ---------------- try load again ---------------	;3684	da 6d 36 	. m 6
12345 3687               else ; VER_20
12346 3687 ~            	jp c,TapeLoadError		;3684	da 11 37 	. . 7
12347 3687               endif
12348 3687              ; -- verify Start (de) and End (hl) address of Program
12349 3687 E5           	push hl				; save hl - Program End address							;3687	e5 	.
12350 3688 ED 52        	sbc hl,de			; subtract Program Start = length - is End < Start?		;3688	ed 52 	. R
12351 368A               ifdef VER_12
12352 368A DA 6D 36     	jp c,.start			; yes - invalid -------- try load again ---------------	;368a	da 6d 36 	. m 6
12353 368D               else ; VER_20
12354 368D ~            	jp c,TapeLoadError		;368a	da 11 37 	. . 7
12355 368D               endif
12356 368D              ; -- store program addresses and length
12357 368D ED 53 1E 78  	ld (TAPESTARTPRG),de; set as Autostart address (in case it's binary file)	;368d	ed 53 1e 78 	. S . x
12358 3691 E5           	push hl				; copy hl to bc											;3691	e5 	.
12359 3692 C1           	pop bc				; bc - program length (bytes to read counter)			;3692	c1 	.
12360 3693 E1           	pop hl				; restore hl - Program End address						;3693	e1 	.
12361 3694              ; -- check if we're loading for VERIFY (just compare) or CLOAD/CRUN (store)
12362 3694 3A 39 78     	ld a,(SYSFLAGS)		; System flags 											;3694	3a 39 78 	: 9 x
12363 3697 CB 5F        	bit 3,a				; is tape loading for VERIFY?							;3697	cb 5f 	. _
12364 3699 C2 42 37     	jp nz,TapeReadVerify; yes - just compare data from Tape to Memory			;3699	c2 42 37 	. B 7
12365 369C
12366 369C              .next:
12367 369C              ; -- store data loaded from Tape
12368 369C               ifdef VER_12
12369 369C CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 								;369c	cd 75 37 	. u 7
12370 369F               else ; VER_20
12371 369F ~            	call sub_3f73h		;369c	cd 73 3f 	. s ?
12372 369F               endif
12373 369F 12           	ld (de),a			; store byte into Program memory						;369f	12 	.
12374 36A0 CD 8E 38     	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;36a0	cd 8e 38 	. . 8
12375 36A3 13           	inc de				; points to next location in Program memory				;36a3	13 	.
12376 36A4 0B           	dec bc				; decrement bytes counter 								;36a4	0b 	.
12377 36A5 79           	ld a,c				; low byte of counter									;36a5	79 	y
12378 36A6 B0           	or b				; is 0 bytes to read left?								;36a6	b0 	.
12379 36A7 20 F3        	jr nz,.next		; no - read all Program bytes 							;36a7	20 f3 	  .
12380 36A9              ; -- all Program data read - check CRC match
12381 36A9 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape - low byte of stored CRC 		;36a9	cd 75 37 	. u 7
12382 36AC DD BE 00     	cp (ix+0)			; is the same as just calculated?						;36ac	dd be 00 	. . .
12383 36AF C2 11 37     	jp nz,TapeLoadError	; no ------------------- display 'LOADING ERROR' ------	;36af	c2 11 37 	. . 7
12384 36B2 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape - high byte of stored CRC 		;36b2	cd 75 37 	. u 7
12385 36B5 DD BE 01     	cp (ix+1)			; is the same as just calculated?						;36b5	dd be 01 	. . .
12386 36B8 C2 11 37     	jp nz,TapeLoadError	; no ------------------- display 'LOADING ERROR' ------	;36b8	c2 11 37 	. . 7
12387 36BB              ; -- CRC OK - store Program End address and
12388 36BB 22 F9 78     	ld (PrgEndPtr),hl	; store Program End address 							;36bb	22 f9 78 	" . x
12389 36BE FB           	ei					; enable interrupts										;36be	fb 	.
12390 36BF              ; -- Print CR on Screen
12391 36BF 3E 0D        	ld a,#0D			; CR special char										;36bf	3e 0d 	> .
12392 36C1 CD 8B 30     	call ScrPrintChar	; print char at Cursor position							;36c1	cd 8b 30 	. . 0
12393 36C4              ; -- file type determine autostart code or return to READY prompt
12394 36C4 3A D2 7A     	ld a,(TAPEFILETYPE)	; file type read from Tape								;36c4	3a d2 7a 	: . z
12395 36C7 FE F1        	cp $f1				; is it Binary file? 									;36c7	fe f1 	. .
12396 36C9 20 04        	jr nz,TapeReadExit	; no - skip autorun binary code							;36c9	20 04 	  .
12397 36CB              ; -- it's Binary file - run from start
12398 36CB 2A 1E 78     	ld hl,(TAPESTARTPRG); saved Program Start address							;36cb	2a 1e 78 	* . x
12399 36CE E9           	jp (hl)				; execute code ----------------------------------------	;36ce	e9 	.
12400 36CF
12401 36CF              ; -- Basic/Text file loaded
12402 36CF              TapeReadExit:
12403 36CF              ; -- print 'READY' prompt
12404 36CF 21 29 19     	ld hl,TXT_READY		; text 'READY'											;36cf	21 29 19 	! ) .
12405 36D2 CD A7 28     	call PrintBasicStr	; print "READY" text on Screen							;36d2	cd a7 28 	. . (
12406 36D5              ; -- set current Program Start as return addres on CPU Stack
12407 36D5 2A A4 78     	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;36d5	2a a4 78 	* . x
12408 36D8 E5           	push hl				; push on Stack as return address						;36d8	e5 	.
12409 36D9              ; -- check Tape load for CRUN flag
12410 36D9 21 39 78     	ld hl,SYSFLAGS		; System flags 											;36d9	21 39 78 	! 9 x
12411 36DC CB 76        	bit 6,(hl)			; is tape loading for CRUN?								;36dc	cb 76 	. v
12412 36DE 20 03        	jr nz,TapeRunPrg	; yes - run loaded Basic Program						;36de	20 03 	  .
12413 36E0
12414 36E0              ; -- for CLOAD - adjust Basic lines, clear variables and exit to BASIC prompt
12415 36E0 C3 E8 1A     	jp l1ae8h			;36e0	c3 e8 1a 	. . .
12416 36E3
12417 36E3              TapeRunPrg:
12418 36E3              ; -- clear CRUN flag
12419 36E3 21 39 78     	ld hl,SYSFLAGS		; System flags 											;36e3	21 39 78 	! 9 x
12420 36E6 CB B6        	res 6,(hl)			; clear tape loading for CRUN flag						;36e6	cb b6 	. .
12421 36E8              ; -- adjust Basic lines and clear variables
12422 36E8 D1           	pop de				; de - Basic line address to start from 				;36e8	d1 	.
12423 36E9 CD FC 1A     	call AdjustBasLines	; Adjust BASIC line pointers 							;36e9	cd fc 1a 	. . .
12424 36EC CD B5 79     	call OnLineChanged	; call external OnLineChanged hook						;36ec	cd b5 79 	. . y
12425 36EF CD 5D 1B     	call ResetBasicPrg	; Reset Parse point, variables, arrays, strings, stack and error state	;36ef	cd 5d 1b 	. ] .
12426 36F2 CD B8 79     	call OnResetBasPrg	; call external OnResetBasPrg hook						;36f2	cd b8 79 	. . y
12427 36F5              ; -- set current Basic Line Number to -1 - means Interractive Commands Mode
12428 36F5 21 FF FF     	ld hl,-1		    ; hl = -1 - interractive mode 							;36f5	21 ff ff 	! . .
12429 36F8 22 A2 78     	ld (BasicLineNo),hl	; set as Current Basic Line Number 						;36f8	22 a2 78 	" . x
12430 36FB              ; -- copy to Edit Buffer command 'RUN'
12431 36FB 21 E8 79     	ld hl,EditLineBuf	; address of Editor Line Buffer							;36fb	21 e8 79 	! . y
12432 36FE               ifdef VER_12
12433 36FE 11 7B 05     	ld de,TXT_RUN		; text 'RUN'											;36fe	11 7b 05 	. { .
12434 3701               else ; VER_20
12435 3701 ~            	ld de,TXT_RUN		;36fe	11 70 05 	. p .
12436 3701               endif
12437 3701              .next:
12438 3701 1A           	ld a,(de)			; char from source text									;3701	1a 	.
12439 3702 77           	ld (hl),a			; store char in Editor Buffer							;3702	77 	w
12440 3703 B7           	or a				; is it '\0' (end of string)?							;3703	b7 	.
12441 3704 28 04        	jr z,.parseBuf		; yes - Parse text in Buffer - RUN Program				;3704	28 04 	( .
12442 3706 23           	inc hl				; points to next location in Editor Buffer				;3706	23 	#
12443 3707 13           	inc de				; points to next char of text							;3707	13 	.
12444 3708 18 F7        	jr .next			; copy all chars of text including '\0' terminator		;3708	18 f7 	. .
12445 370A              .parseBuf:
12446 370A 21 E7 79     	ld hl,EditLineBuf-1	; hl - address just before buffer - parse point			;370a	21 e7 79 	! . y
12447 370D AF           	xor a				; a=0 - simulate previous token was End Of Basic Line	;370d	af 	.
12448 370E C3 81 1A     	jp ParseEditBuf		; Parse text in Editor Line Buffer - RUN Program		;370e	c3 81 1a 	. . .
12449 3711
12450 3711
12451 3711              TapeLoadError:
12452 3711              ; -- display LOADING ERROR message
12453 3711 21 4A 38     	ld hl,TXT_LOADINGERROR	; text 'LOADING ERROR'								;3711	21 4a 38 	! J 8
12454 3714 FB           	ei					; enable interrupts										;3714	fb 	.
12455 3715 CD A7 28     	call PrintBasicStr	; print "LOADING ERROR" text on Screen					;3715	cd a7 28 	. . (
12456 3718 F3           	di					; disable interrupts again								;3718	f3 	.
12457 3719              ; -- if Hide Info Flag is set then skip Screen operation
12458 3719 3A 4C 78     	ld a,(TAPEHIDEINFO)	; Tape Hide Info flag									;3719	3a 4c 78 	: L x
12459 371C B7           	or a				; hide info about Tape operation?						;371c	b7 	.
12460 371D C2 67 36     	jp nz,TapeReadStart	; yes - ;371d	c2 67 36 	. g 6
12461 3720              ; -- set Cursor at bootom-right edge of Screen
12462 3720 21 FF 71     	ld hl,VRAM+511		; last char in last line of Screen						;3720	21 ff 71 	! . q
12463 3723 22 20 78     	ld (CURSORADDR),hl	; set Cursor Address in VRAM 							;3723	22 20 78 	"   x
12464 3726 3E 1F        	ld a,31		        ; new Cursor position - end of line                   	;3726	3e 1f 	> .
12465 3728 32 A6 78     	ld (CURSORPOS),a	; set new position of Cursor in Edited line				;3728	32 a6 78 	2 . x
12466 372B C3 67 36     	jp TapeReadStart			;372b	c3 67 36 	. g 6
12467 372E
12468 372E
12469 372E              ; *****************************************************************************************************
12470 372E              ; BASIC CRUN Entry Point
12471 372E              ; IN: hl - current executed command parser
12472 372E              ;     a - command byte
12473 372E              ;     Z = 1 - end of statement ('\0' or ':' found)
12474 372E              ;     CY = 1 - char is digit
12475 372E              CmdCRUN
12476 372E E5           	push hl			; save hl 													;372e	e5 	.
12477 372F 21 39 78     	ld hl,SYSFLAGS	; System flags												;372f	21 39 78 	! 9 x
12478 3732 CB F6        	set 6,(hl)		; set tape load for CRUN flag								;3732	cb f6 	. .
12479 3734 E1           	pop hl			; restore hl												;3734	e1 	.
12480 3735 C3 5F 36     	jp TapeReadFile	; read file from Tape										;3735	c3 5f 36 	. _ 6
12481 3738
12482 3738
12483 3738              ; *****************************************************************************************************
12484 3738              ; BASIC VERIFY Entry Point
12485 3738              ; IN: hl - current executed command parser
12486 3738              ;     a - command byte
12487 3738              ;     Z = 1 - end of statement ('\0' or ':' found)
12488 3738              ;     CY = 1 - char is digit
12489 3738              CmdVERIFY
12490 3738 E5           	push hl				; save hl 												;3738	e5 	.
12491 3739 21 39 78     	ld hl,SYSFLAGS		; System flags											;3739	21 39 78 	! 9 x
12492 373C CB DE        	set 3,(hl)			; set tape load for VERIFY flag							;373c	cb de 	. .
12493 373E E1           	pop hl				; restore hl											;373e	e1 	.
12494 373F C3 5F 36     	jp TapeReadFile		; read file from Tape									;373f	c3 5f 36 	. _ 6
12495 3742
12496 3742
12497 3742              ;******************************************************************************************************
12498 3742              ; Read Program data from Tape and compare to program existing in memory
12499 3742              ; IN: de - Program Start address as loaded from file
12500 3742              TapeReadVerify:
12501 3742 EB           	ex de,hl			; hl - Program Start address							;3742	eb 	.
12502 3743              .next:
12503 3743 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 								;3743	cd 75 37 	. u 7
12504 3746 BE           	cp (hl)				; is the same as currrent in memory? 					;3746	be 	.
12505 3747 28 09        	jr z,.nextaaddr		; yes - update address and counter and continue 		;3747	28 09 	( .
12506 3749              ; -- bytes mismatch - display VERIFY ERROR
12507 3749 21 6C 37     	ld hl,TXT_VERIFY	; text 'VERIFY'											;3749	21 6c 37 	! l 7
12508 374C CD A7 28     	call PrintBasicStr	; print "VERIFY " text on Screen						;374c	cd a7 28 	. . (
12509 374F C3 83 01     	jp l0183h			;374f	c3 83 01 	. . .
12510 3752              .nextaaddr:
12511 3752 23           	inc hl				; points to next location in memory						;3752	23 	#
12512 3753 0B           	dec bc				; decrement bytes counter								;3753	0b 	.
12513 3754 79           	ld a,c				; low byte of number bytes to read						;3754	79 	y
12514 3755 B0           	or b				; is 0 bytes to read left?								;3755	b0 	.
12515 3756 20 EB        	jr nz,.next			; no - read and compare all program data				;3756	20 eb 	  .
12516 3758              ; -- all bytes read an verified - clear VERIFY flag
12517 3758 21 39 78     	ld hl,SYSFLAGS		; System flags											;3758	21 39 78 	! 9 x
12518 375B CB 9E        	res 3,(hl)			; clear tape load for VERIFY flag						;375b	cb 9e 	. .
12519 375D              ; -- display VERIFY OK
12520 375D 21 6C 37     	ld hl,TXT_VERIFY	; text 'VERIFY'											;375d	21 6c 37 	! l 7
12521 3760 CD A7 28     	call PrintBasicStr	; print "VERIFY " text on Screen						;3760	cd a7 28 	. . (
12522 3763 21 80 03     	ld hl,TXT_OK		; text 'OK'												;3763	21 80 03 	! . .
12523 3766 CD A7 28     	call PrintBasicStr	; print "OK" text on Screen								;3766	cd a7 28 	. . (
12524 3769 C3 CF 36     	jp TapeReadExit		; finalize Tape Read and exit to READY prompt			;3769	c3 cf 36 	. . 6
12525 376C
12526 376C 0D 56 45 52  TXT_VERIFY:             db $d,"VERIFY ",0       ;376c	0d 56 45 52 49 46 59 20 00 	  .
12526 3770 49 46 59 20
12526 3774 00
12527 3775
12528 3775
12529 3775
12530 3775              ;*********************************************************************************
12531 3775              ; Read 1 byte from Tape
12532 3775              ; OUT: a - data byte
12533 3775              ;      CY=1 - error - no data detected, CY=0 - success
12534 3775              TapeReadByte:
12535 3775 C5           	push bc				; save bc 												;3775	c5 	.
12536 3776 D5           	push de				; save de												;3776	d5 	.
12537 3777 06 08        	ld b,8				; 8 bits to read from Tape								;3777	06 08 	. .
12538 3779              .next:
12539 3779 CD 8F 37     	call TapeReadBit	; Read 1 bit from Tape and insert into a MSB first		;3779	cd 8f 37 	. . 7
12540 377C 38 0E        	jr c,.exitError		; error --------- exit with CY=1 ---------------------- ;377c	38 0e 	8 .
12541 377E 10 F9        	djnz .next			; read all 8 bits										;377e	10 f9 	. .
12542 3780              ; -- a contains data byte from Tape
12543 3780 D1           	pop de				; restore de											;3780	d1 	.
12544 3781 C1           	pop bc				; restore bc											;3781	c1 	.
12545 3782 32 D3 7A     	ld (TAPEBYTEBUF),a	; save byte read from Tape								;3782	32 d3 7a 	2 . z
12546 3785              ; -- test Ctrl+Break and execute Basic STOP command
12547 3785 CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;3785	cd f8 3a 	. . :
12548 3788 3A D3 7A     	ld a,(TAPEBYTEBUF)	; restore byte read from Tape							;3788	3a d3 7a 	: . z
12549 378B C9           	ret					; ---------------- End of Proc ------------------------	;378b	c9 	.
12550 378C              .exitError:
12551 378C D1           	pop de				; restore de											;378c	d1 	.
12552 378D C1           	pop bc				; restore bc											;378d	c1 	.
12553 378E C9           	ret					; ---------------- End of Proc ------------------------	;378e	c9 	.
12554 378F
12555 378F              ;*********************************************************************************
12556 378F              ; Read 1 bit from Tape and insert it data byte (d) MSB first
12557 378F              ; IN: d - current data byte (partially read)
12558 378F              ; OUT: d - updated data byte
12559 378F              ;      a - updated data byte
12560 378F              ;      CY=1 - error - no data detected, CY=0 - success
12561 378F              TapeReadBit:
12562 378F C5           	push bc			; save bc 													;378f	c5 	.
12563 3790              .startRead:
12564 3790              ; -- set timeout 32767*(13+8+7+6+4+4+13) = 32767*55 = 1802185*0.279 = 500ms
12565 3790               ifdef VER_12
12566 3790 01 FF 7F     	ld bc,32767		; timeout counter for 500ms									;3790	01 ff 7f 	. .
12567 3793               else ; VER_20
12568 3793 ~            	ld bc,2047		;3790	01 ff 07 	. . .
12569 3793               endif
12570 3793              .waitforStart:
12571 3793              ; -- wait for Tape signal (0)
12572 3793 3A 00 68     	ld a,(CassIn)	; read Tape input bit										;3793	3a 00 68 	: . h
12573 3796 CB 77        	bit 6,a			; is bit reset - Tape signal (0)							;3796	cb 77 	. w
12574 3798 28 08        	jr z,.confirmStart	; yes - confirm two times more that it wasn't glitch 	;3798	28 08 	( .
12575 379A 0B           	dec bc			; decrement timeout counter									;379a	0b 	.
12576 379B 79           	ld a,c			; low byte of counter										;379b	79 	y
12577 379C B0           	or b			; is it 0 - timeout?										;379c	b0 	.
12578 379D 20 F4        	jr nz,.waitforStart	; no - wait 500ms										;379d	20 f4 	  .
12579 379F              ; -- FAIL: no Tape signal (0) from Tape for last 500ms - return with CY=1
12580 379F C1           	pop bc			; restore bc												;379f	c1 	.
12581 37A0 37           	scf				; set CY - timeout elapsed									;37a0	37 	7
12582 37A1 C9           	ret				; ---------------- End of Proc ----------------------------	;37a1	c9 	.
12583 37A2              .confirmStart:
12584 37A2              ; -- PASS: Tape singal (0) detected - confirm it
12585 37A2 3A 00 68     	ld a,(CassIn)	; read Tape input bit										;37a2	3a 00 68 	: . h
12586 37A5 CB 77        	bit 6,a			; is bit reset - Tape signal (0)?							;37a5	cb 77 	. w
12587 37A7 20 EA        	jr nz,.waitforStart	; no ------------- start over from 1st probe ----------	;37a7	20 ea 	  .
12588 37A9              ; -- PASS: Tape signal (0) confirmed once - confirm again
12589 37A9 3A 00 68     	ld a,(CassIn)	; read Tape input bit										;37a9	3a 00 68 	: . h
12590 37AC CB 77        	bit 6,a			; is bit reset - Tape signal (0)?							;37ac	cb 77 	. w
12591 37AE 20 E3        	jr nz,.waitforStart	; no ------------- start over from 1st probe ----------	;37ae	20 e3 	  .
12592 37B0
12593 37B0              ; -- PASS: Tape signal (0) confirmed twice - expected Tape signal (1) after 280us
12594 37B0 06 52        	ld b,82			; delay counter	for 279us									;37b0	06 52 	. R
12595 37B2              .delay280us:
12596 37B2 10 FE        	djnz .delay280us; wait 82*13*0.279us = 1066*0.279us = 297.414us ~ 279us		;37b2	10 fe 	. .
12597 37B4              ; -- expected Tape signal (1) after ~280us
12598 37B4 3A 00 68     	ld a,(CassIn)	; read Tape input bit										;37b4	3a 00 68 	: . h
12599 37B7 CB 77        	bit 6,a			; is bit set - Tape signal (1)?								;37b7	cb 77 	. w
12600 37B9 20 09        	jr nz,.readBit	; yes - determine BIT value									;37b9	20 09 	  .
12601 37BB              ; -- FAIL: wait for bit set (idle state) and start over with new timeout 500ms
12602 37BB              .waitforIdle:
12603 37BB 3A 00 68     	ld a,(CassIn)	; read Tape input bit										;37bb	3a 00 68 	: . h
12604 37BE CB 77        	bit 6,a			; is bit set - Tape signal (1)?								;37be	cb 77 	. w
12605 37C0 28 F9        	jr z,.waitforIdle	; no - wait for bit set									;37c0	28 f9 	( .
12606 37C2 18 CC        	jr .startRead	; ------------ start over with new 500ms timeout ----------	;37c2	18 cc 	. .
12607 37C4
12608 37C4              .readBit:
12609 37C4              ; -- PASS: we have 1st Short pulse 0-1 - read bit value: 0101 or 0011
12610 37C4 06 5A        	ld b,90			; delay counter	for 1.03ms									;37c4	06 5a 	. Z
12611 37C6 0E 00        	ld c,0			; conter for detected Tape signal (0) (pulses within 1ms)	;37c6	0e 00 	. .
12612 37C8              .waitFor0:
12613 37C8              ; -- wait for Tape signal (0)
12614 37C8 3A 00 68     	ld a,(CassIn)	; read Tape input bit										;37c8	3a 00 68 	: . h
12615 37CB CB 77        	bit 6,a			; is bit reset - Tape signal (0)?							;37cb	cb 77 	. w
12616 37CD 28 0B        	jr z,.confirm0	; yes - confirm Tape signal (0)								;37cd	28 0b 	( .
12617 37CF              .wait0again:
12618 37CF 10 F7        	djnz .waitFor0	; wait 90*(13+8+7+13)*0.279us = 3690*0.279us = 1029.510us ~ 1.03ms	;37cf	10 f7 	. .
12619 37D1
12620 37D1              .exit:
12621 37D1              ; -- 1ms window elapsed - c contains number of 0 pulsed detected in this time
12622 37D1 79           	ld a,c			; a - number of pulses (1 for databit=0, 2 for databit=1)	;37d1	79 	y
12623 37D2 3D           	dec a			; decrement counter - bit 0 will be databit equivalent 		;37d2	3d 	=
12624 37D3 1F           	rra				; roll register right - CY = databit						;37d3	1f 	.
12625 37D4 CB 12        	rl d			; roll data byte left - insert CY as bit 0					;37d4	cb 12 	. .
12626 37D6              ; -- restore bc and exit with CY = 0 (no error)
12627 37D6 C1           	pop bc			; restore bc												;37d6	c1 	.
12628 37D7 7A           	ld a,d			; a - updated data byte										;37d7	7a 	z
12629 37D8 B7           	or a			; clear CY flag												;37d8	b7 	.
12630 37D9 C9           	ret				; ------------- End of Proc -------------------------------	;37d9	c9 	.
12631 37DA              .confirm0:
12632 37DA              ; -- found Tape signal (0) - confirm
12633 37DA 3A 00 68     	ld a,(CassIn)	; read Tape input bit										;37da	3a 00 68 	: . h
12634 37DD CB 77        	bit 6,a			; is bit reset - Tape signal (0)?							;37dd	cb 77 	. w
12635 37DF 20 EE        	jr nz,.wait0again	; no - it was glitch - continue waiting for 0				;37df	20 ee 	  .
12636 37E1              ; -- found Tape signal (0) - confirmed once
12637 37E1 3A 00 68     	ld a,(CassIn)	; read Tape input bit										;37e1	3a 00 68 	: . h
12638 37E4 CB 77        	bit 6,a			; is bit reset - Tape signal (0)?							;37e4	cb 77 	. w
12639 37E6 20 E7        	jr nz,.wait0again	; no - it was glitch - continue waiting for 0				;37e6	20 e7 	  .
12640 37E8              ; -- found Tape signal (0) - confirmed twice
12641 37E8 0C           	inc c			; increment pulses counter									;37e8	0c 	.
12642 37E9              .waitfor1:
12643 37E9              ; -- wait for Tape signal (1)
12644 37E9 3A 00 68     	ld a,(CassIn)	; read Tape input bit										;37e9	3a 00 68 	: . h
12645 37EC CB 77        	bit 6,a			; is bit set - Tape signal (1)?								;37ec	cb 77 	. w
12646 37EE 20 DF        	jr nz,.wait0again	; yes ---------------- go back and wait for Tape Signal (0)	;37ee	20 df 	  .
12647 37F0 10 F7        	djnz .waitfor1	; wait for Tape signal (1) for the rest of 1ms window 		;37f0	10 f7 	. .
12648 37F2              ; -- 1ms time elapsed - calculate read data bit
12649 37F2 18 DD        	jr .exit		; calculate data bit and exit proc ------------------------ ;37f2	18 dd 	. .
12650 37F4
12651 37F4              ;*********************************************************************************************
12652 37F4              ; Clear last line of Screen and Display Tape Operation Info
12653 37F4              ; IN: hl - text to display at last screen line
12654 37F4              TapeDispOper:
12655 37F4              ; -- if Hide Info Flag is set then skip Screen operation
12656 37F4 3A 4C 78     	ld a,(TAPEHIDEINFO)	; Tape Hide Info flag									;37f4	3a 4c 78 	: L x
12657 37F7 B7           	or a				; hide info about Tape operation?						;37f7	b7 	.
12658 37F8 C0           	ret nz				; yes - ---------- End of Proc ------------------------	;37f8	c0 	.
12659 37F9              ; -- clear last line of Screen
12660 37F9 11 E0 71     	ld de,VRAM+480		; de - address of last line on screen					;37f9	11 e0 71 	. . q
12661 37FC 06 20        	ld b,32				; 32 chars per line										;37fc	06 20 	.
12662 37FE              .next:
12663 37FE               ifdef VER_12
12664 37FE 3E 20        	ld a,' '			; Space - char to fill line								;37fe	3e 20 	>
12665 3800 12           	ld (de),a			; store in VRAM											;3800	12 	.
12666 3801               else ; VER_20
12667 3801 ~            	call sub_3ef6h		;37fe	cd f6 3e 	. . >
12668 3801               endif
12669 3801 13           	inc de				; points to next char									;3801	13 	.
12670 3802 10 FA        	djnz .next			; fill all 32 chars in line								;3802	10 fa 	. .
12671 3804
12672 3804              ;*********************************************************************************************
12673 3804              ; Display Tape Operation Info
12674 3804              ; IN: hl - text to display at last screen line
12675 3804              TapeDispOper2:
12676 3804              ; -- if Hide Info Flag is set then skip Screen operation
12677 3804 3A 4C 78     	ld a,(TAPEHIDEINFO)	; Tape Hide Info flag									;3804	3a 4c 78 	: L x
12678 3807 B7           	or a				; hide info about Tape operation?						;3807	b7 	.
12679 3808 C0           	ret nz				; yes - ---------- End of Proc ------------------------	;3808	c0 	.
12680 3809              ; -- copy chars from text to last line of Screen
12681 3809               ifdef VER_12
12682 3809 11 E0 71     	ld de,VRAM+480		; de - address of last line on screen					;3809	11 e0 71 	. . q
12683 380C               else ; VER_20
12684 380C ~            	call sub_3f0eh		;3809	cd 0e 3f 	. . ?
12685 380C               endif
12686 380C              .next:
12687 380C 7E           	ld a,(hl)			; char from given text									;380c	7e 	~
12688 380D B7           	or a				; is it '\0' (end of string)?							;380d	b7 	.
12689 380E C8           	ret z				; yes ---------- End of Proc --------------------------	;380e	c8 	.
12690 380F 12           	ld (de),a			; store char in VRAM - display char						;380f	12 	.
12691 3810 13           	inc de				; points to next location on screen						;3810	13 	.
12692 3811 23           	inc hl				; points to next char in given text						;3811	23 	#
12693 3812 18 F8        	jr .next			; copy all chars from text to screen last line			;3812	18 f8 	. .
12694 3814
12695 3814
12696 3814              ;**********************************************************************************************
12697 3814              ; Display File Type and Name
12698 3814              ; IN: hl - address of filename text (terminated with '\0')
12699 3814              ;     TAPEFILETYPE - file type
12700 3814              TapeDispFileInfo:
12701 3814              ; -- if Hide Info Flag is set then skip Screen operation
12702 3814 3A 4C 78     	ld a,(TAPEHIDEINFO)	; Tape Hide Info flag									;3814	3a 4c 78 	: L x
12703 3817 B7           	or a				; hide info about Tape operation?						;3817	b7 	.
12704 3818 C0           	ret nz				; yes - ---------- End of Proc ------------------------	;3818	c0 	.
12705 3819              ; -- display file type in last line of Screen
12706 3819 11 E9 71     	ld de,VRAM+480+9	; destination address - offset 9 chars to skip 'FOUND'	;3819	11 e9 71 	. . q
12707 381C E5           	push hl				; save hl - address of buffer with filename				;381c	e5 	.
12708 381D              ; -- decode FileType Byte to char
12709 381D 3A D2 7A     	ld a,(TAPEFILETYPE)	; a - file type read from Tape ($f0,$f1 or $f2)			;381d	3a d2 7a 	: . z
12710 3820 E6 0F        	and $0f				; constrain range to (0..15) - index for FileTypeChars	;3820	e6 0f 	. .
12711 3822 21 3F 38     	ld hl,FILETYPECHARS	; address of table with chars (screen encoded)			;3822	21 3f 38 	! ? 8
12712 3825 85           	add a,l				; add low byte of address								;3825	85 	.
12713 3826 6F           	ld l,a				; store back low byte									;3826	6f 	o
12714 3827 3E 00        	ld a,0				; zero value to add only CY flag						;3827	3e 00 	> .
12715 3829 8C           	adc a,h				; add CY 												;3829	8c 	.
12716 382A 67           	ld h,a				; hl - address in FileTypeChars table					;382a	67 	g
12717 382B               ifdef VER_12
12718 382B 7E           	ld a,(hl)			; a - char (screen encoded) for given File Type			;382b	7e 	~
12719 382C 12           	ld (de),a			; store in VRAM - display char							;382c	12 	.
12720 382D 13           	inc de				; points to next location on screen						;382d	13 	.
12721 382E              ; -- display separator ':'
12722 382E 3E 3A        	ld a,':'			; visual separator										;382e	3e 3a 	> :
12723 3830               else ; VER_20
12724 3830 ~            	call sub_3f21h		;382b	cd 21 3f 	. ! ?
12725 3830 ~            	nop			;382e	00 	.
12726 3830 ~            	nop			;382f	00 	.
12727 3830               endif
12728 3830 12           	ld (de),a			; store in VRAM - display char							;3830	12 	.
12729 3831 13           	inc de				; points to next location on screen						;3831	13 	.
12730 3832              ; -- skip 1 char (leave space)
12731 3832 13           	inc de				; points to next location on screen						;3832	13 	.
12732 3833              ; -- display filename
12733 3833 E1           	pop hl				; restore hl - address of buffer with filename			;3833	e1 	.
12734 3834              .next:
12735 3834 7E           	ld a,(hl)			; a - filename char from buffer							;3834	7e 	~
12736 3835 B7           	or a				; is it '\0' (end of string)?							;3835	b7 	.
12737 3836 C8           	ret z				; yes ------------ End of Proc ------------------------	;3836	c8 	.
12738 3837               ifdef VER_12
12739 3837 E6 3F        	and $3f				; convert ascii char to Screen char						;3837	e6 3f 	. ?
12740 3839 12           	ld (de),a			; store in VRAM - display char							;3839	12 	.
12741 383A               else ; VER_20
12742 383A ~            	call sub_3f33h		;3837	cd 33 3f 	. 3 ?
12743 383A               endif
12744 383A 13           	inc de				; points to next location on string						;383a	13 	.
12745 383B 23           	inc hl				; points to next char in source buffer					;383b	23 	#
12746 383C 18 F6        	jr .next			; copy all chars of filename							;383c	18 f6 	. .
12747 383E              ; -- dead code
12748 383E C9           	ret					; ---------------- End of Proc ------------------------	;383e	c9 	.
12749 383F
12750 383F
12751 383F
12752 383F              ;***************************************************************
12753 383F              ; Table with chars (screen codes) for 3 file Types
12754 383F              FILETYPECHARS:
12755 383F 14           	db	$14			; 'T' - F0 - Text (Basic) File 	;383f	14 	.
12756 3840 02           	db	$02			; 'B' - F1 - Binary (Code) File	;3840	02 	.
12757 3841 04           	db	$04			; 'D' - F2 - Data File			;3841	04 	.
12758 3842
12759 3842
12760 3842 57 41 49 54  TXT_WAITING:        db "WAITING",0                  ;3842	57 41 49 54 49 4e 47 00 	.
12760 3846 49 4E 47 00
12761 384A 0D 4C 4F 41  TXT_LOADINGERROR:   db $d,"LOADING ERROR",$d,0		;384a	0d 4c 4f 41 44 49 4e 47 20 45 52 52 4f 52 0d 00 	.
12761 384E 44 49 4E 47
12761 3852 20 45 52 52
12761 3856 4F 52 0D 00
12762 385A 46 4F 55 4E  TXT_FOUND:          db "FOUND",0		            ;385a	46 4f 55 4e 44 00 	.
12762 385E 44 00
12763 3860 4C 4F 41 44  TXT_LOADING:        db "LOADING",0                  ;3860	4c 4f 41 44 49 4e 47 00 	.
12763 3864 49 4E 47 00
12764 3868
12765 3868
12766 3868              ;*********************************************************************************
12767 3868              ; Load from Tape Program Start and Program End
12768 3868              ; IN: ix - address of 16bit variable to calculate CRC
12769 3868              ; OUT: de - program Start address (destination)
12770 3868              ;      hl - program End address
12771 3868              ;      CY=1 - error, Cy=0 - success
12772 3868              TapeReadPrgStartEnd:
12773 3868              ; -- read Program Start (also destination) address
12774 3868 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 								;3868	cd 75 37 	. u 7
12775 386B D8           	ret c				; error -------------- End of Proc --------------------	;386b	d8 	.
12776 386C 5F           	ld e,a				; e - low byte of Program Start address					;386c	5f 	_
12777 386D DD 77 00     	ld (ix+0),a			; store as low byte of CRC 								;386d	dd 77 00 	. w .
12778 3870 AF           	xor a				; a = 0 												;3870	af 	.
12779 3871 DD 77 01     	ld (ix+1),a			; store as high byte of CRC								;3871	dd 77 01 	. w .
12780 3874 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 								;3874	cd 75 37 	. u 7
12781 3877 D8           	ret c				; error -------------- End of Proc --------------------	;3877	d8 	.
12782 3878 57           	ld d,a				; de - Program Start address							;3878	57 	W
12783 3879 CD 8E 38     	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;3879	cd 8e 38 	. . 8
12784 387C              ; -- read Program End address
12785 387C CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 								;387c	cd 75 37 	. u 7
12786 387F D8           	ret c				; error -------------- End of Proc --------------------	;387f	d8 	.
12787 3880 6F           	ld l,a				; l - low byte of Program End address					;3880	6f 	o
12788 3881 CD 8E 38     	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;3881	cd 8e 38 	. . 8
12789 3884 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 								;3884	cd 75 37 	. u 7
12790 3887 D8           	ret c				; error -------------- End of Proc --------------------	;3887	d8 	.
12791 3888 67           	ld h,a				; hl - Program End address								;3888	67 	g
12792 3889 CD 8E 38     	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;3889	cd 8e 38 	. . 8
12793 388C B7           	or a				; clear CY flag											;388c	b7 	.
12794 388D C9           	ret					; ------------------- End of Proc ---------------------	;388d	c9 	.
12795 388E
12796 388E              ;********************************************************************
12797 388E              ; Add byte value to Tape CRC (16bit Control Sum)
12798 388E              ; IN: a - value to add
12799 388E              ;     ix - address of CRC
12800 388E              AddToCRC:
12801 388E DD 86 00     	add a,(ix+0)	; add low byte of CRC to given value						;388e	dd 86 00 	. . .
12802 3891 DD 77 00     	ld (ix+0),a		; store new low byte of CRC									;3891	dd 77 00 	. w .
12803 3894 3E 00        	ld a,0			; high byte of given value (always 0)						;3894	3e 00 	> .
12804 3896 DD 8E 01     	adc a,(ix+1)	; add high byte of CRC to 0 and CY 							;3896	dd 8e 01 	. . .
12805 3899 DD 77 01     	ld (ix+1),a		; store new high byte of CRC								;3899	dd 77 01 	. w .
12806 389C C9           	ret				; ------------------------ End of Proc --------------------	;389c	c9 	.
12807 389D
12808 389D
12809 389D              ; **********************************************************************************
12810 389D              ; BASIC COLOR Entry Point
12811 389D              ; COLOR [<F>|,<B>]
12812 389D              ; Changes colors for Text Mode where: <F> foreground (1..8) and <B> background (0..1)
12813 389D              ; IN: hl - current executed command parser
12814 389D              ;     a - command byte
12815 389D              ;     Z = 1 - end of statement ('\0' or ':' found)
12816 389D              ;     CY = 1 - char is digit
12817 389D              CmdCOLOR
12818 389D 7E           	ld a,(hl)			; a = char of first argument or ','						;389d	7e 	~
12819 389E FE 2C        	cp ','				; is it ',' (foreground arg skipped)?					;389e	fe 2c 	. ,
12820 38A0 28 20        	jr z,.bgcolor		; yes - change only background color					;38a0	28 20 	(
12821 38A2              ; -- parse <F> foreground color argument
12822 38A2 CD 1C 2B     	call EvalByteExpr	; a - given <F> color as Integer (8bit) value			;38a2	cd 1c 2b 	. . +
12823 38A5              ; -- valid range is 1..8
12824 38A5 B7           	or a				; is it 0? 												;38a5	b7 	.
12825 38A6 CA 4A 1E     	jp z,ErrRaiseFuncCode	; yes - raise FUNCTION CODE Error					;38a6	ca 4a 1e 	. J .
12826 38A9 FE 09        	cp 9				; is it >= 9?											;38a9	fe 09 	. .
12827 38AB D2 4A 1E     	jp nc,ErrRaiseFuncCode	; yes - raise FUNCTION CODE Error					;38ab	d2 4a 1e 	. J .
12828 38AE              ; -- <F> color in valid range
12829 38AE 3D           	dec a				; a - color in range 0..7								;38ae	3d 	=
12830 38AF              ; -- shift <F>oreground color value to high nibble of ForeColor variable
12831 38AF E6 07        	and $07				; clear bits 7..3										;38af	e6 07 	. .
12832 38B1 CB 27        	sla a				; shift left 1 bit 										;38b1	cb 27 	. '
12833 38B3 CB 27        	sla a				; shift left 1 bit										;38b3	cb 27 	. '
12834 38B5 CB 27        	sla a				; shift left 1 bit										;38b5	cb 27 	. '
12835 38B7 CB 27        	sla a				; shift left 1 bit										;38b7	cb 27 	. '
12836 38B9 32 46 78     	ld (FCOLOR),a		; store as Foreground Color								;38b9	32 46 78 	2 F x
12837 38BC              ; -- check if <B>ackground argument was given
12838 38BC 7E           	ld a,(hl)			; next char in Program									;38bc	7e 	~
12839 38BD B7           	or a				; is it '\0' (end of Basic Line)?						;38bd	b7 	.
12840 38BE C8           	ret z				; yes --------------- End of Proc ---------------------	;38be	c8 	.
12841 38BF FE 3A        	cp ':'				; is it ':' (end of statement)?							;38bf	fe 3a 	. :
12842 38C1 C8           	ret z				; yes --------------- End of Proc ---------------------	;38c1	c8 	.
12843 38C2              .bgcolor:
12844 38C2              ; -- try to set <B>ackground color
12845 38C2 CF           	rst $08				; Assert next token is ',' 								;38c2	cf 	.
12846 38C3 2C           	defb ','			; Basic ',' token 										;38c3	2c 	,
12847 38C4 CD 1C 2B     	call EvalByteExpr	; a - given <B> color as Integer (8bit) value			;38c4	cd 1c 2b 	. . +
12848 38C7 B7           	or a				; is it 0 (green)?										;38c7	b7 	.
12849 38C8 20 0C        	jr nz,.orange		; no - check if it is 1 (orange)						;38c8	20 0c 	  .
12850 38CA              ; -- set color 0 (green)
12851 38CA 3A 3B 78     	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH 					;38ca	3a 3b 78 	: ; x
12852 38CD CB A7        	res 4,a				; set COLOR 0 (Green)									;38cd	cb a7 	. .
12853 38CF 32 3B 78     	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH  				;38cf	32 3b 78 	2 ; x
12854 38D2 32 00 68     	ld (IO_LATCH),a		; store in hardware (VDG CSS pin)						;38d2	32 00 68 	2 . h
12855 38D5 C9           	ret					; ------------------ End of Proc ----------------------	;38d5	c9 	.
12856 38D6              .orange:
12857 38D6 FE 01        	cp 1				; is it 1 (orange)?										;38d6	fe 01 	. .
12858 38D8 C2 4A 1E     	jp nz,ErrRaiseFuncCode	; no - raise FUNCTION CODE Error					;38d8	c2 4a 1e 	. J .
12859 38DB 3A 3B 78     	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH 					;38db	3a 3b 78 	: ; x
12860 38DE CB E7        	set 4,a				; set COLOR 1 (Orange)									;38de	cb e7 	. .
12861 38E0 32 3B 78     	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH  				;38e0	32 3b 78 	2 ; x
12862 38E3 32 00 68     	ld (IO_LATCH),a		; store in hardware (VDG CSS pin)						;38e3	32 00 68 	2 . h
12863 38E6 C9           	ret					; ------------------ End of Proc ----------------------	;38e6	c9 	.
12864 38E7
12865 38E7
12866 38E7              l38e7h:
12867 38E7 0E C0        	ld c,0c0h		;38e7	0e c0 	. .
12868 38E9              l38e9h:
12869 38E9 CB 09        	rrc c		;38e9	cb 09 	. .
12870 38EB 10 FC        	djnz l38e9h		;38eb	10 fc 	. .
12871 38ED 1A           	ld a,(de)			;38ed	1a 	.
12872 38EE A1           	and c			;38ee	a1 	.
12873 38EF 47           	ld b,a			;38ef	47 	G
12874 38F0 79           	ld a,c			;38f0	79 	y
12875 38F1              l38f1h:
12876 38F1 CB 08        	rrc b		;38f1	cb 08 	. .
12877 38F3 CB 0F        	rrc a		;38f3	cb 0f 	. .
12878 38F5 FE 03        	cp 003h		;38f5	fe 03 	. .
12879 38F7 20 F8        	jr nz,l38f1h		;38f7	20 f8 	  .
12880 38F9 78           	ld a,b			;38f9	78 	x
12881 38FA 3C           	inc a			;38fa	3c 	<
12882 38FB E5           	push hl			;38fb	e5 	.
12883 38FC CD 8D 09     	call sub_098dh		;38fc	cd 8d 09 	. . .
12884 38FF E1           	pop hl			;38ff	e1 	.
12885 3900 C3 0F 39     	jp l390fh		;3900	c3 0f 39 	. . 9
12886 3903              l3903h:
12887 3903 47           	ld b,a			;3903	47 	G
12888 3904 1A           	ld a,(de)			;3904	1a 	.
12889 3905 A1           	and c			;3905	a1 	.
12890 3906 12           	ld (de),a			;3906	12 	.
12891 3907 F1           	pop af			;3907	f1 	.
12892 3908 B7           	or a			;3908	b7 	.
12893 3909 F2 0F 39     	jp p,l390fh		;3909	f2 0f 39 	. . 9
12894 390C 1A           	ld a,(de)			;390c	1a 	.
12895 390D B0           	or b			;390d	b0 	.
12896 390E 12           	ld (de),a			;390e	12 	.
12897 390F              l390fh:
12898 390F CF           	rst $08			; Assert next token is ')' ;390f	cf 	.
12899 3910 29           	defb ')'		; Basic ')' token 	;3910	29 	)
12900 3911 C9           	ret			;3911	c9 	.
12901 3912
12902 3912
12903 3912              ; ***********************************************************************************************
12904 3912              ; BASIC COPY Entry Point
12905 3912              ; IN: hl - current executed command parser
12906 3912              ;     a - command byte
12907 3912              ;     Z = 1 - end of statement ('\0' or ':' found)
12908 3912              ;     CY = 1 - char is digit
12909 3912              CmdCOPY
12910 3912 F3           	di			;3912	f3 	.
12911 3913 E5           	push hl			;3913	e5 	.
12912 3914 3A 3B 78     	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  							;3914	3a 3b 78 	: ; x
12913 3917 CB 5F        	bit 3,a		;3917	cb 5f 	. _
12914 3919 C2 8E 39     	jp nz,l398eh		;3919	c2 8e 39 	. . 9
12915 391C 21 00 70     	ld hl,VRAM		;391c	21 00 70 	! . p
12916 391F 0E 10        	ld c,010h		;391f	0e 10 	. .
12917 3921              l3921h:
12918 3921 06 20        	ld b,020h		;3921	06 20 	.
12919 3923              l3923h:
12920 3923 7E           	ld a,(hl)			;3923	7e 	~
12921 3924 B7           	or a			;3924	b7 	.
12922 3925 F2 2D 39     	jp p,l392dh		;3925	f2 2d 39 	. - 9
12923 3928 CD 73 2C     	call sub_2c73h		;3928	cd 73 2c 	. s ,
12924 392B 18 16        	jr l3943h		;392b	18 16 	. .
12925 392D              l392dh:
12926 392D               ifdef VER_12
12927 392D CB 77        	bit 6,a		;392d	cb 77 	. w
12928 392F 28 07        	jr z,l3938h		;392f	28 07 	( .
12929 3931               else ; VER_20
12930 3931 ~            	jp l3f44h		;392d	c3 44 3f 	. D ?
12931 3931 ~            	nop			;3930	00 	.
12932 3931               endif
12933 3931
12934 3931              l3931h:
12935 3931 E6 3F        	and 03fh		;3931	e6 3f 	. ?
12936 3933 CD 56 39     	call sub_3956h		;3933	cd 56 39 	. V 9
12937 3936 18 0B        	jr l3943h		;3936	18 0b 	. .
12938 3938              l3938h:
12939 3938 E6 3F        	and 03fh		;3938	e6 3f 	. ?
12940 393A CB 6F        	bit 5,a		;393a	cb 6f 	. o
12941 393C 20 02        	jr nz,l3940h		;393c	20 02 	  .
12942 393E F6 40        	or 040h		;393e	f6 40 	. @
12943 3940              l3940h:
12944 3940 CD BA 3A     	call sub_3abah		;3940	cd ba 3a 	. . :
12945 3943              l3943h:
12946 3943 23           	inc hl			;3943	23 	#
12947 3944 10 DD        	djnz l3923h		;3944	10 dd 	. .
12948 3946 3E 0D        	ld a,00dh		;3946	3e 0d 	> .
12949 3948 CD BA 3A     	call sub_3abah		;3948	cd ba 3a 	. . :
12950 394B              ; -- test Ctrl+Break and execute Basic STOP command
12951 394B CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP			;394b	cd f8 3a 	. . :
12952 394E 0D           	dec c			;394e	0d 	.
12953 394F 79           	ld a,c			;394f	79 	y
12954 3950 B7           	or a			;3950	b7 	.
12955 3951 20 CE        	jr nz,l3921h		;3951	20 ce 	  .
12956 3953 E1           	pop hl			;3953	e1 	.
12957 3954 FB           	ei			;3954	fb 	.
12958 3955 C9           	ret			;3955	c9 	.
12959 3956              sub_3956h:
12960 3956 F5           	push af			;3956	f5 	.
12961 3957 C5           	push bc			;3957	c5 	.
12962 3958 D5           	push de			;3958	d5 	.
12963 3959 E5           	push hl			;3959	e5 	.
12964 395A 6F           	ld l,a			;395a	6f 	o
12965 395B 26 00        	ld h,000h		;395b	26 00 	& .
12966 395D 3E 08        	ld a,008h		;395d	3e 08 	> .
12967 395F CD BA 3A     	call sub_3abah		;395f	cd ba 3a 	. . :
12968 3962 06 04        	ld b,004h		;3962	06 04 	. .
12969 3964 E5           	push hl			;3964	e5 	.
12970 3965 D1           	pop de			;3965	d1 	.
12971 3966 B7           	or a			;3966	b7 	.
12972 3967              l3967h:
12973 3967 ED 5A        	adc hl,de		;3967	ed 5a 	. Z
12974 3969 10 FC        	djnz l3967h		;3969	10 fc 	. .
12975 396B E5           	push hl			;396b	e5 	.
12976 396C C1           	pop bc			;396c	c1 	.
12977 396D 21 94 3B     	ld hl,PrinterCharsDef	; table with char definitions for printer			;396d	21 94 3b 	! . ;
12978 3970 09           	add hl,bc			;3970	09 	.
12979 3971 3E FF        	ld a,0ffh		;3971	3e ff 	> .
12980 3973 CD BA 3A     	call sub_3abah		;3973	cd ba 3a 	. . :
12981 3976 06 05        	ld b,005h		;3976	06 05 	. .
12982 3978              l3978h:
12983 3978 7E           	ld a,(hl)			;3978	7e 	~
12984 3979 23           	inc hl			;3979	23 	#
12985 397A CD BA 3A     	call sub_3abah		;397a	cd ba 3a 	. . :
12986 397D 10 F9        	djnz l3978h		;397d	10 f9 	. .
12987 397F 3E FF        	ld a,0ffh		;397f	3e ff 	> .
12988 3981 CD BA 3A     	call sub_3abah		;3981	cd ba 3a 	. . :
12989 3984 3E 0F        	ld a,00fh		;3984	3e 0f 	> .
12990 3986 CD BA 3A     	call sub_3abah		;3986	cd ba 3a 	. . :
12991 3989 E1           	pop hl			;3989	e1 	.
12992 398A D1           	pop de			;398a	d1 	.
12993 398B C1           	pop bc			;398b	c1 	.
12994 398C F1           	pop af			;398c	f1 	.
12995 398D C9           	ret			;398d	c9 	.
12996 398E              l398eh:
12997 398E AF           	xor a			;398e	af 	.
12998 398F 32 D6 7A     	ld (FILENAMELEN),a	; length of file name for tape	;398f	32 d6 7a 	2 . z
12999 3992 32 D6 7A     	ld (FILENAMELEN),a	; length of file name for tape	;3992	32 d6 7a 	2 . z
13000 3995 3E 08        	ld a,008h		;3995	3e 08 	> .
13001 3997 CD BA 3A     	call sub_3abah		;3997	cd ba 3a 	. . :
13002 399A DD 21 D2 7A  	ld ix,TAPEFILETYPE	; file type read from Tape	;399a	dd 21 d2 7a 	. ! . z
13003 399E 21 00 70     	ld hl,VRAM		;399e	21 00 70 	! . p
13004 39A1 11 00 00     	ld de,$0000		;39a1	11 00 00 	. . .
13005 39A4              l39a4h:
13006 39A4 0E C0        	ld c,0c0h		;39a4	0e c0 	. .
13007 39A6              l39a6h:
13008 39A6              ; -- test Ctrl+Break and execute Basic STOP command
13009 39A6 CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP			;39a6	cd f8 3a 	. . :
13010 39A9 E5           	push hl			;39a9	e5 	.
13011 39AA CD C9 05     	call FillPrnBuffer		; Fill 4-byte Print Buffer with value in register A ;39aa	cd c9 05 	. . .
13012 39AD 06 03        	ld b,003h		;39ad	06 03 	. .
13013 39AF              l39afh:
13014 39AF 7E           	ld a,(hl)			;39af	7e 	~
13015 39B0 A1           	and c			;39b0	a1 	.
13016 39B1 C5           	push bc			;39b1	c5 	.
13017 39B2 47           	ld b,a			;39b2	47 	G
13018 39B3              l39b3h:
13019 39B3 CB 08        	rrc b		;39b3	cb 08 	. .
13020 39B5 CB 08        	rrc b		;39b5	cb 08 	. .
13021 39B7 CB 09        	rrc c		;39b7	cb 09 	. .
13022 39B9 CB 09        	rrc c		;39b9	cb 09 	. .
13023 39BB 79           	ld a,c			;39bb	79 	y
13024 39BC FE 03        	cp 003h		;39bc	fe 03 	. .
13025 39BE C2 B3 39     	jp nz,l39b3h		;39be	c2 b3 39 	. . 9
13026 39C1 78           	ld a,b			;39c1	78 	x
13027 39C2 C1           	pop bc			;39c2	c1 	.
13028 39C3 FE 03        	cp 003h		;39c3	fe 03 	. .
13029 39C5 28 0D        	jr z,l39d4h		;39c5	28 0d 	( .
13030 39C7 FE 02        	cp 002h		;39c7	fe 02 	. .
13031 39C9 28 0E        	jr z,l39d9h		;39c9	28 0e 	( .
13032 39CB FE 01        	cp 001h		;39cb	fe 01 	. .
13033 39CD 28 10        	jr z,l39dfh		;39cd	28 10 	( .
13034 39CF 11 00 00     	ld de,$0000		;39cf	11 00 00 	. . .
13035 39D2 18 0F        	jr l39e3h		;39d2	18 0f 	. .
13036 39D4              l39d4h:
13037 39D4 11 E0 E0     	ld de,0e0e0h		;39d4	11 e0 e0 	. . .
13038 39D7 18 0A        	jr l39e3h		;39d7	18 0a 	. .
13039 39D9              l39d9h:
13040 39D9 16 40        	ld d,040h		;39d9	16 40 	. @
13041 39DB 1E A0        	ld e,0a0h		;39db	1e a0 	. .
13042 39DD 18 04        	jr l39e3h		;39dd	18 04 	. .
13043 39DF              l39dfh:
13044 39DF 16 A0        	ld d,0a0h		;39df	16 a0 	. .
13045 39E1 1E 40        	ld e,040h		;39e1	1e 40 	. @
13046 39E3              l39e3h:
13047 39E3 DD 7E 00     	ld a,(ix+000h)		;39e3	dd 7e 00 	. ~ .
13048 39E6 CB 3F        	srl a		;39e6	cb 3f 	. ?
13049 39E8 CB 3F        	srl a		;39e8	cb 3f 	. ?
13050 39EA CB 3F        	srl a		;39ea	cb 3f 	. ?
13051 39EC E5           	push hl			;39ec	e5 	.
13052 39ED 21 D3 7A     	ld hl,TAPEBYTEBUF		;39ed	21 d3 7a 	! . z
13053 39F0 CD 6A 3A     	call sub_3a6ah		;39f0	cd 6a 3a 	. j :
13054 39F3 E1           	pop hl			;39f3	e1 	.
13055 39F4 B2           	or d			;39f4	b2 	.
13056 39F5 DD 77 00     	ld (ix+000h),a		;39f5	dd 77 00 	. w .
13057 39F8 DD 7E 02     	ld a,(ix+002h)		;39f8	dd 7e 02 	. ~ .
13058 39FB CB 3F        	srl a		;39fb	cb 3f 	. ?
13059 39FD CB 3F        	srl a		;39fd	cb 3f 	. ?
13060 39FF CB 3F        	srl a		;39ff	cb 3f 	. ?
13061 3A01 E5           	push hl			;3a01	e5 	.
13062 3A02 21 D5 7A     	ld hl,07ad5h		;3a02	21 d5 7a 	! . z
13063 3A05 CD 6A 3A     	call sub_3a6ah		;3a05	cd 6a 3a 	. j :
13064 3A08 E1           	pop hl			;3a08	e1 	.
13065 3A09 B3           	or e			;3a09	b3 	.
13066 3A0A DD 77 02     	ld (ix+002h),a		;3a0a	dd 77 02 	. w .
13067 3A0D 3E 20        	ld a,020h		;3a0d	3e 20 	>
13068 3A0F 85           	add a,l			;3a0f	85 	.
13069 3A10 6F           	ld l,a			;3a10	6f 	o
13070 3A11 3E 00        	ld a,000h		;3a11	3e 00 	> .
13071 3A13 8C           	adc a,h			;3a13	8c 	.
13072 3A14 67           	ld h,a			;3a14	67 	g
13073 3A15 10 50        	djnz l3a67h		;3a15	10 50 	. P
13074 3A17 CD 73 3A     	call sub_3a73h		;3a17	cd 73 3a 	. s :
13075 3A1A E1           	pop hl			;3a1a	e1 	.
13076 3A1B CB 39        	srl c		;3a1b	cb 39 	. 9
13077 3A1D CB 39        	srl c		;3a1d	cb 39 	. 9
13078 3A1F 79           	ld a,c			;3a1f	79 	y
13079 3A20 B7           	or a			;3a20	b7 	.
13080 3A21 20 83        	jr nz,l39a6h		;3a21	20 83 	  .
13081 3A23 23           	inc hl			;3a23	23 	#
13082 3A24 7D           	ld a,l			;3a24	7d 	}
13083 3A25 E6 1F        	and 01fh		;3a25	e6 1f 	. .
13084 3A27 C2 A4 39     	jp nz,l39a4h		;3a27	c2 a4 39 	. . 9
13085 3A2A CD E2 3A     	call sub_3ae2h		;3a2a	cd e2 3a 	. . :
13086 3A2D 3A D6 7A     	ld a,(FILENAMELEN)	; length of file name for tape	;3a2d	3a d6 7a 	: . z
13087 3A30 3C           	inc a			;3a30	3c 	<
13088 3A31 FE 03        	cp 003h		;3a31	fe 03 	. .
13089 3A33 20 01        	jr nz,l3a36h		;3a33	20 01 	  .
13090 3A35 AF           	xor a			;3a35	af 	.
13091 3A36              l3a36h:
13092 3A36 32 D6 7A     	ld (FILENAMELEN),a	; length of file name for tape	;3a36	32 d6 7a 	2 . z
13093 3A39 20 04        	jr nz,l3a3fh		;3a39	20 04 	  .
13094 3A3B 3E 40        	ld a,040h		;3a3b	3e 40 	> @
13095 3A3D 18 02        	jr l3a41h		;3a3d	18 02 	. .
13096 3A3F              l3a3fh:
13097 3A3F 3E 20        	ld a,020h		;3a3f	3e 20 	>
13098 3A41              l3a41h:
13099 3A41 85           	add a,l			;3a41	85 	.
13100 3A42 6F           	ld l,a			;3a42	6f 	o
13101 3A43 3E 00        	ld a,000h		;3a43	3e 00 	> .
13102 3A45 8C           	adc a,h			;3a45	8c 	.
13103 3A46 67           	ld h,a			;3a46	67 	g
13104 3A47 FE 78        	cp 078h		;3a47	fe 78 	. x
13105 3A49 D2 5F 3A     	jp nc,l3a5fh		;3a49	d2 5f 3a 	. _ :
13106 3A4C FE 77        	cp 077h		;3a4c	fe 77 	. w
13107 3A4E C2 A4 39     	jp nz,l39a4h		;3a4e	c2 a4 39 	. . 9
13108 3A51 7D           	ld a,l			;3a51	7d 	}
13109 3A52 FE E0        	cp 0e0h		;3a52	fe e0 	. .
13110 3A54 DA A4 39     	jp c,l39a4h		;3a54	da a4 39 	. . 9
13111 3A57 3E FF        	ld a,0ffh		;3a57	3e ff 	> .
13112 3A59 32 D6 7A     	ld (FILENAMELEN),a	; length of file name for tape	;3a59	32 d6 7a 	2 . z
13113 3A5C C3 A4 39     	jp l39a4h		;3a5c	c3 a4 39 	. . 9
13114 3A5F              l3a5fh:
13115 3A5F 3E 0F        	ld a,00fh		;3a5f	3e 0f 	> .
13116 3A61 CD BA 3A     	call sub_3abah		;3a61	cd ba 3a 	. . :
13117 3A64 E1           	pop hl			;3a64	e1 	.
13118 3A65 FB           	ei			;3a65	fb 	.
13119 3A66 C9           	ret			;3a66	c9 	.
13120 3A67              l3a67h:
13121 3A67 C3 AF 39     	jp l39afh		;3a67	c3 af 39 	. . 9
13122 3A6A              sub_3a6ah:
13123 3A6A D2 70 3A     	jp nc,l3a70h		;3a6a	d2 70 3a 	. p :
13124 3A6D CB C6        	set 0,(hl)		;3a6d	cb c6 	. .
13125 3A6F C9           	ret			;3a6f	c9 	.
13126 3A70              l3a70h:
13127 3A70 CB 86        	res 0,(hl)		;3a70	cb 86 	. .
13128 3A72 C9           	ret			;3a72	c9 	.
13129 3A73              sub_3a73h:
13130 3A73 CD 85 3A     	call sub_3a85h		;3a73	cd 85 3a 	. . :
13131 3A76 DD 23        	inc ix		;3a76	dd 23 	. #
13132 3A78 DD 23        	inc ix		;3a78	dd 23 	. #
13133 3A7A CD 85 3A     	call sub_3a85h		;3a7a	cd 85 3a 	. . :
13134 3A7D DD 2B        	dec ix		;3a7d	dd 2b 	. +
13135 3A7F DD 2B        	dec ix		;3a7f	dd 2b 	. +
13136 3A81 CD 85 3A     	call sub_3a85h		;3a81	cd 85 3a 	. . :
13137 3A84 C9           	ret			;3a84	c9 	.
13138 3A85              sub_3a85h:
13139 3A85 DD 7E 01     	ld a,(ix+001h)		;3a85	dd 7e 01 	. ~ .
13140 3A88 CB 0F        	rrc a		;3a88	cb 0f 	. .
13141 3A8A DD 7E 00     	ld a,(ix+000h)		;3a8a	dd 7e 00 	. ~ .
13142 3A8D F5           	push af			;3a8d	f5 	.
13143 3A8E 3A D6 7A     	ld a,(FILENAMELEN)	; length of file name for tape	;3a8e	3a d6 7a 	: . z
13144 3A91 FE 02        	cp 002h		;3a91	fe 02 	. .
13145 3A93 28 1D        	jr z,l3ab2h		;3a93	28 1d 	( .
13146 3A95 FE 01        	cp 001h		;3a95	fe 01 	. .
13147 3A97 28 16        	jr z,l3aafh		;3a97	28 16 	( .
13148 3A99 F1           	pop af			;3a99	f1 	.
13149 3A9A 17           	rla			;3a9a	17 	.
13150 3A9B              l3a9bh:
13151 3A9B F5           	push af			;3a9b	f5 	.
13152 3A9C 3A D6 7A     	ld a,(FILENAMELEN)	; length of file name for tape	;3a9c	3a d6 7a 	: . z
13153 3A9F FE FF        	cp 0ffh		;3a9f	fe ff 	. .
13154 3AA1 20 05        	jr nz,l3aa8h		;3aa1	20 05 	  .
13155 3AA3 F1           	pop af			;3aa3	f1 	.
13156 3AA4 E6 07        	and 007h		;3aa4	e6 07 	. .
13157 3AA6 18 01        	jr l3aa9h		;3aa6	18 01 	. .
13158 3AA8              l3aa8h:
13159 3AA8 F1           	pop af			;3aa8	f1 	.
13160 3AA9              l3aa9h:
13161 3AA9 F6 80        	or 080h		;3aa9	f6 80 	. .
13162 3AAB CD BA 3A     	call sub_3abah		;3aab	cd ba 3a 	. . :
13163 3AAE C9           	ret			;3aae	c9 	.
13164 3AAF              l3aafh:
13165 3AAF F1           	pop af			;3aaf	f1 	.
13166 3AB0 18 E9        	jr l3a9bh		;3ab0	18 e9 	. .
13167 3AB2              l3ab2h:
13168 3AB2 F1           	pop af			;3ab2	f1 	.
13169 3AB3 1F           	rra			;3ab3	1f 	.
13170 3AB4 18 E5        	jr l3a9bh		;3ab4	18 e5 	. .
13171 3AB6              sub_3ab6h:
13172 3AB6 B7           	or a			;3ab6	b7 	.
13173 3AB7 FA D8 3A     	jp m,l3ad8h		;3ab7	fa d8 3a 	. . :
13174 3ABA              sub_3abah:
13175 3ABA F5           	push af			;3aba	f5 	.
13176 3ABB              l3abbh:
13177 3ABB CD E8 3A     	call TestCtrlBreak	; Test if Ctrl+Break keys pressed	;3abb	cd e8 3a 	. . :
13178 3ABE D2 C4 3A     	jp nc,l3ac4h		; no - ;3abe	d2 c4 3a 	. . :
13179 3AC1 F1           	pop af			;3ac1	f1 	.
13180 3AC2 37           	scf			;3ac2	37 	7
13181 3AC3 C9           	ret			;3ac3	c9 	.
13182 3AC4              l3ac4h:
13183 3AC4 DB 00        	in a,(000h)		;3ac4	db 00 	. .
13184 3AC6 CB 47        	bit 0,a		;3ac6	cb 47 	. G
13185 3AC8 20 F1        	jr nz,l3abbh		;3ac8	20 f1 	  .
13186 3ACA F1           	pop af			;3aca	f1 	.
13187 3ACB D3 0E        	out (00eh),a		;3acb	d3 0e 	. .
13188 3ACD D3 0D        	out (00dh),a		;3acd	d3 0d 	. .
13189 3ACF FE 0D        	cp 00dh		;3acf	fe 0d 	. .
13190 3AD1 37           	scf			;3ad1	37 	7
13191 3AD2 3F           	ccf			;3ad2	3f 	?
13192 3AD3 C0           	ret nz			;3ad3	c0 	.
13193 3AD4 3E 0A        	ld a,00ah		;3ad4	3e 0a 	> .
13194 3AD6 18 E2        	jr sub_3abah		;3ad6	18 e2 	. .
13195 3AD8              l3ad8h:
13196 3AD8 CB 77        	bit 6,a		;3ad8	cb 77 	. w
13197 3ADA CA 73 2C     	jp z,sub_2c73h		;3ada	ca 73 2c 	. s ,
13198 3ADD E6 3F        	and 03fh		;3add	e6 3f 	. ?
13199 3ADF C3 56 39     	jp sub_3956h		;3adf	c3 56 39 	. V 9
13200 3AE2              sub_3ae2h:
13201 3AE2 3E 0D        	ld a,00dh		;3ae2	3e 0d 	> .
13202 3AE4 CD BA 3A     	call sub_3abah		;3ae4	cd ba 3a 	. . :
13203 3AE7 C9           	ret			;3ae7	c9 	.
13204 3AE8
13205 3AE8              ;***********************************************************************************
13206 3AE8              ; Test if Ctrl+Break keys pressed
13207 3AE8              ; OUT: CY - 1 Ctrl+Break detected, 0 - not detected
13208 3AE8              TestCtrlBreak:
13209 3AE8 B7           	or a			    ; clear Carry Flag (CY=0) - no Ctrl+Break pressed   ;3ae8	b7 	.
13210 3AE9 3A FD 68     	ld a,(KROW_CTRL)    ; read Keyboard Row with CTRL key		            ;3ae9	3a fd 68 	: . h
13211 3AEC CB 57        	bit 2,a		        ; is CTRL key pressed                               ;3aec	cb 57 	. W
13212 3AEE C0           	ret nz			    ; no ------------ End of Proc (CY=0) -------------- ;3aee	c0 	.
13213 3AEF 3A DF 68     	ld a,(KROW_BREAK)	; read Keyboard Row with BREAK key ('-' and '=')	;3aef	3a df 68 	: . h
13214 3AF2 37           	scf			        ; set Carry Flag (CY=1) - Ctrl+Break pressed        ;3af2	37 	7
13215 3AF3 CB 57        	bit 2,a		        ; is BREAK pressed ?                                ;3af3	cb 57 	. W
13216 3AF5 C8           	ret z			    ; yes ----------- End of Proc (CY=1) -------------- ;3af5	c8 	.
13217 3AF6 3F           	ccf			        ; invert Carry Flag (CY=0) - no Ctrl+Break pressed  ;3af6	3f 	?
13218 3AF7 C9           	ret			        ; --------------- End of Proc (CY=0) -------------- ;3af7	c9 	.
13219 3AF8
13220 3AF8
13221 3AF8              ;*****************************************************************************
13222 3AF8              ; Test if Ctrl+Break is pressed.
13223 3AF8              ; If Break then ckear Tape loading flags and pass control to Basic (STOP)
13224 3AF8              TapeTestBreak:
13225 3AF8              ; -- check if Ctrl+Break pressed
13226 3AF8 CD E8 3A     	call TestCtrlBreak	; Test if Ctrl+Break keys pressed	                ;3af8	cd e8 3a 	. . :
13227 3AFB D0           	ret nc			    ; no ------------ End of Proc --------------------- ;3afb	d0 	.
13228 3AFC              ; --
13229 3AFC E1           	pop hl			;3afc	e1 	.
13230 3AFD E1           	pop hl			;3afd	e1 	.
13231 3AFE
13232 3AFE              ;*****************************************************************************
13233 3AFE              ; Ckear Tape loading flags and pass control to Basic (STOP)
13234 3AFE              ; by sumulete Ctrl+Break key pressed (keycode=01)
13235 3AFE              TapeAbort:
13236 3AFE 3A 39 78     	ld a,(SYSFLAGS)		; System flags										;3afe	3a 39 78 	: 9 x
13237 3B01 E6 B7        	and %10110111		; clear VERIFY and CRUN flags						;3b01	e6 b7 	. .
13238 3B03 32 39 78     	ld (SYSFLAGS),a		; store updated System flags 						;3b03	32 39 78 	2 9 x
13239 3B06              ; -- enable interrupts and execute Basic STOP command
13240 3B06 3E 01        	ld a,1				; key pressed value - Ctrl+Break 					;3b06	3e 01 	> .
13241 3B08 FB           	ei					; enable interrupt 									;3b08	fb 	.
13242 3B09 C3 A0 1D     	jp sub_1da0h		;3b09	c3 a0 1d 	. . .
13243 3B0C
13244 3B0C
13245 3B0C              l3b0ch:
13246 3B0C 3A 9C 78     	ld a,(SysCurOutDev)		;3b0c	3a 9c 78 	: . x
13247 3B0F B7           	or a			;3b0f	b7 	.
13248 3B10 C2 64 21     	jp nz,l2164h		;3b10	c2 64 21 	. d !
13249 3B13              l3b13h:
13250 3B13 3A AF 7A     	ld a,(07aafh)		;3b13	3a af 7a 	: . z
13251 3B16 B7           	or a			;3b16	b7 	.
13252 3B17 20 FA        	jr nz,l3b13h		;3b17	20 fa 	  .
13253 3B19 C3 64 21     	jp l2164h		;3b19	c3 64 21 	. d !
13254 3B1C              sub_3b1ch:
13255 3B1C 3A AF 7A     	ld a,(07aafh)		;3b1c	3a af 7a 	: . z
13256 3B1F B7           	or a			;3b1f	b7 	.
13257 3B20 C0           	ret nz			;3b20	c0 	.
13258 3B21 3A A6 78     	ld a,(CURSORPOS)	; position of Cursor in Edited line				;3b21	3a a6 78 	: . x
13259 3B24 C9           	ret			;3b24	c9 	.
13260 3B25              sub_3b25h:
13261 3B25 21 EF 68     	ld hl,KROW_SPACE    ; select Keyboard Row with Space key		    ;3b25	21 ef 68 	! . h
13262 3B28 CB 66        	bit 4,(hl)		    ; is SPACE key pressed ?                        ;3b28	cb 66 	. f
13263 3B2A 20 18        	jr nz,l3b44h		; no - return with hl = -1                      ;3b2a	20 18 	  .
13264 3B2C              ; -- detected Space Key pressed
13265 3B2C CD 48 3B     	call DelaySpaceKey	; wait 14,8 ms delay                            ;3b2c	cd 48 3b 	. H ;
13266 3B2F              .waitForRelease:
13267 3B2F CB 66        	bit 4,(hl)		    ; is SPACE key pressed ?                        ;3b2f	cb 66 	. f
13268 3B31 28 FC        	jr z,.waitForRelease; yes - wait for release                        ;3b31	28 fc 	( .
13269 3B33              ; -- detected Space Key released
13270 3B33 CD 48 3B     	call DelaySpaceKey	; wait 14,8 ms and read keys row with space  	;3b33	cd 48 3b 	. H ;
13271 3B36              l3b36h:
13272 3B36              ; -- test Ctrl+Break and execute Basic STOP command
13273 3B36 CD F8 3A     	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP		;3b36	cd f8 3a 	. . :
13274 3B39 CB 66        	bit 4,(hl)		;3b39	cb 66 	. f
13275 3B3B 20 F9        	jr nz,l3b36h		;3b3b	20 f9 	  .
13276 3B3D CD 48 3B     	call DelaySpaceKey	; wait 14,8 ms and read keys row with space  	;3b3d	cd 48 3b 	. H ;
13277 3B40              l3b40h:
13278 3B40 CB 66        	bit 4,(hl)		    ; is SPACE key pressed ?                        ;3b40	cb 66 	. f
13279 3B42 28 FC        	jr z,l3b40h		    ; yes - wait for release                        ;3b42	28 fc 	( .
13280 3B44              l3b44h:
13281 3B44 21 FF FF     	ld hl,-1		;3b44	21 ff ff 	! . .
13282 3B47 C9           	ret			;3b47	c9 	.
13283 3B48
13284 3B48              ;*********************************************************************************************
13285 3B48              ; Delay 14,8 ms
13286 3B48              ; 10 + 2047 * 26 + 20 = 53252 T => 14,8 ms
13287 3B48              DelaySpaceKey:
13288 3B48 21 FF 07     	ld hl,2047		    ; delay counter                                                 ;3b48	21 ff 07 	! . .
13289 3B4B              .loop:
13290 3B4B 2B           	dec hl			    ; decrement counter                                             ;3b4b	2b 	+
13291 3B4C 7D           	ld a,l			    ; a - low byte of counter                                       ;3b4c	7d 	}
13292 3B4D B4           	or h			    ; is hl = 0 ?                                                   ;3b4d	b4 	.
13293 3B4E 20 FB        	jr nz,.loop		    ; no - continue                                                 ;3b4e	20 fb 	  .
13294 3B50 21 EF 68     	ld hl,KROW_SPACE	; restore hl to contain Keyboard Row with Space key 	        ;3b50	21 ef 68 	! . h
13295 3B53 C9           	ret			        ; --------------- End of Proc --------------------------------- ;3b53	c9 	.
13296 3B54
13297 3B54              ;*********************************************************************************************
13298 3B54              ; Send char to Tape via hardware register (IO_LATCH)
13299 3B54              ; IN: a - char to send
13300 3B54              TapeWriteChar:
13301 3B54 CD 11 35     	call TapeWriteByte	; Send char to Tape via hardware register (IO_LATCH)			;3b54	cd 11 35 	. . 5
13302 3B57 C9           	ret					; ------------------- End of Proc -----------------------------	;3b57	c9 	.
13303 3B58
13304 3B58
13305 3B58
13306 3B58              sub_3b58h:
13307 3B58 F3           	di			;3b58	f3 	.
13308 3B59 23           	inc hl			;3b59	23 	#
13309 3B5A 0E F2        	ld c,$f2		; file type - Binary ;3b5a	0e f2 	. .
13310 3B5C CD 58 35     	call TapeWriteHeader	; Send sync and file header to Tape	;3b5c	cd 58 35 	. X 5
13311 3B5F DA FE 3A     	jp c,TapeAbort	; Break - Cancel loading Tape and pass control to Basic ;3b5f	da fe 3a 	. . :
13312 3B62 2B           	dec hl			;3b62	2b 	+
13313 3B63 CF           	rst $08			; Assert next token is '"' ;3b63	cf 	.
13314 3B64 22           	defb '"'		; Basic '"' token - end oif string ;3b64	22 "
13315 3B65 CF           	rst $08			; Assert next token is ',' ;3b65	cf .
13316 3B66 2C           	defb ','		; Basic ',' token ;3b66	2c 	,
13317 3B67 C9           	ret			;3b67	c9 	.
13318 3B68              sub_3b68h:
13319 3B68 F3           	di			;3b68	f3 	.
13320 3B69 23           	inc hl			;3b69	23 	#
13321 3B6A              ; -- get filename from command parameter and store in Tape Filename Buffer
13322 3B6A CD 8C 35     	call TapeParseFilename	; parse filename into FileNameBuf					;3b6a	cd 8c 35 	. . 5
13323 3B6D 2B           	dec hl			;3b6d	2b 	+
13324 3B6E CF           	rst $08			; Assert next token is '"' ;3b6e	cf 	.
13325 3B6F 22           	defb '"'		; Basic '"' token - end of string ;3b6f	22 "
13326 3B70 CF           	rst $08			; Assert next token is ',' ;3b70	cf .
13327 3B71 2C           	defb ','		; Basic ',' token ;3b71	2c 	,
13328 3B72 E5           	push hl			;3b72	e5 	.
13329 3B73 CD B1 35     	call TapePrepScreen	; Prepeare Screen for TAPE info texts		;3b73	cd b1 35 	. . 5
13330 3B76 21 42 38     	ld hl,TXT_WAITING	; text 'WAITING'							;3b76	21 42 38 	! B 8
13331 3B79 CD F4 37     	call TapeDispOper	; Display Tape Operation Info 'WAITING'		;3b79	cd f4 37 	. . 7
13332 3B7C              l3b7ch:
13333 3B7C CD E7 35     	call TapeReadHeader	; Read sync, file type and name from Tape	;3b7c	cd e7 35 	. . 5
13334 3B7F 3A D2 7A     	ld a,(TAPEFILETYPE)	; file type read from Tape	;3b7f	3a d2 7a 	: . z
13335 3B82 FE F2        	cp 0f2h		;3b82	fe f2 	. .
13336 3B84 20 F6        	jr nz,l3b7ch		;3b84	20 f6 	  .
13337 3B86 E1           	pop hl			;3b86	e1 	.
13338 3B87 C9           	ret			;3b87	c9 	.
13339 3B88              sub_3b88h:
13340 3B88 CD 75 37     	call TapeReadByte	; Read 1 byte from Tape 	;3b88	cd 75 37 	. u 7
13341 3B8B FE 0D        	cp 00dh		;3b8b	fe 0d 	. .
13342 3B8D C0           	ret nz			;3b8d	c0 	.
13343 3B8E F5           	push af			;3b8e	f5 	.
13344 3B8F CD F9 20     	call SysNewLine		;3b8f	cd f9 20 	. .
13345 3B92 F1           	pop af			;3b92	f1 	.
13346 3B93 C9           	ret			;3b93	c9 	.
13347 3B94
13348 3B94              ;*********************************************************************************************
13349 3B94
13350 3B94              PrinterCharsDef:
13351 3B94 C1           	dg 	##-----#	; @		;3b94	c1 	.
13352 3B95 BE           	dg	#-#####-			;3b95	be 	.
13353 3B96 A2           	dg	#-#---#-			;3b96	a2 	.
13354 3B97 AE           	dg 	#-#-###-			;3b97	ae 	.
13355 3B98 B1           	dg	#-##---#			;3b98	b1 	.
13356 3B99
13357 3B99 83           	dg  #-----##	; A		;3b99	83 	.
13358 3B9A ED           	dg	###-##-#			;3b9a	ed 	.
13359 3B9B EE           	dg 	###-###-			;3b9b	ee 	. .
13360 3B9C ED           	dg	###-##-#			;3b9c	ed 	. .
13361 3B9D 83           	dg	#-----##			;3b9d	83 	.
13362 3B9E
13363 3B9E 80           	dg	#-------	; B		;3b9e	80 	.
13364 3B9F B6           	dg 	#-##-##-			;3b9f	b6 	.
13365 3BA0 B6           	dg	#-##-##-			;3ba0	b6 	.
13366 3BA1 B6           	dg 	#-##-##-			;3ba1	b6 	.
13367 3BA2 C1           	dg	##-----#			;3ba2	c1 	.
13368 3BA3
13369 3BA3 C1           	dg 	##-----#	; C		;3ba3	c1 	.
13370 3BA4 BE           	dg	#-#####-			;3ba4	be 	.
13371 3BA5 BE           	dg	#-#####-			;3ba5	be 	.
13372 3BA6 BE           	dg	#-#####-			;3ba6	be 	.
13373 3BA7 DD           	dg	##-###-#			;3ba7	dd
13374 3BA8
13375 3BA8 80           	dg	#-------	; D		;3ba8	80
13376 3BA9 BE           	dg  #-#####-			;3ba9	be 	. . .
13377 3BAA BE           	dg  #-#####-			;3baa	be 	.
13378 3BAB BE           	dg  #-#####-			;3bab	be 	.
13379 3BAC C1           	dg	##-----#			;3bac	c1 	.
13380 3BAD
13381 3BAD 80           	dg	#-------	; E		;3bad	80 	.
13382 3BAE B6           	dg	#-##-##-			;3bae	b6 	.
13383 3BAF B6           	dg	#-##-##-			;3baf	b6 	.
13384 3BB0 B6           	dg	#-##-##-			;3bb0	b6 	.
13385 3BB1 BE           	dg	#-#####-			;3bb1	be 	.
13386 3BB2
13387 3BB2 80           	dg	#-------	; F		;3bb2	80 	.
13388 3BB3 F6           	dg	####-##-			;3bb3	f6 	. .
13389 3BB4 F6           	dg	####-##-			;3bb4	f6 	. .
13390 3BB5 F6           	dg	####-##-			;3bb5	f6 	. .
13391 3BB6 FE           	dg	#######-			;3bb6	fe 	. .
13392 3BB7
13393 3BB7 C1           	dg	##-----#	; G		;3bb7	c1 	.
13394 3BB8 BE           	dg	#-#####-			;3bb8	be 	.
13395 3BB9 BE           	dg	#-#####-			;3bb9	be 	.
13396 3BBA AE           	dg	#-#-###-			;3bba	ae 	.
13397 3BBB 8C           	dg	#---##--			;3bbb	8c 	.
13398 3BBC
13399 3BBC 80           	dg	#-------	; H		;3bbc	80 	.
13400 3BBD F7           	dg	####-###			;3bbd	f7 	.
13401 3BBE F7           	dg	####-###			;3bbe	f7 	.
13402 3BBF F7           	dg	####-###			;3bbf	f7 	.
13403 3BC0 80           	dg	#-------			;3bc0	80 	.
13404 3BC1
13405 3BC1 FF           	dg	########	; I		;3bc1	ff 	.
13406 3BC2 BE           	dg	#-#####-			;3bc2	be 	.
13407 3BC3 80           	dg 	#-------			;3bc3	80 	.
13408 3BC4 BE           	dg	#-#####-			;3bc4	be 	.
13409 3BC5 FF           	dg	########			;3bc5	ff 	.
13410 3BC6
13411 3BC6 DF           	dg	##-#####	; J		;3bc6	df 	.
13412 3BC7 BF           	dg	#-######			;3bc7	bf 	.
13413 3BC8 BF           	dg	#-######			;3bc8	bf 	.
13414 3BC9 C0           	dg	##------			;3bc9	c0 	.
13415 3BCA FE           	dg	#######-			;3bca	fe 	. .
13416 3BCB
13417 3BCB 80           	dg	#-------	; K		;3bcb	80 	. .
13418 3BCC F7           	dg	####-###			;3bcc	f7 	.
13419 3BCD EB           	dg	###-#-##			;3bcd	eb 	.
13420 3BCE DD           	dg	##-###-#			;3bce	dd  	. . .
13421 3BCF BE           	dg	#-#####-			;3bcf	be 	. . .
13422 3BD0
13423 3BD0 80           	dg	#-------	; L		;3bd0	80 	. . .
13424 3BD1 BF           	dg	#-######			;3bd1	bf 	.
13425 3BD2 BF           	dg	#-######			;3bd2	bf 	.
13426 3BD3 BF           	dg	#-######			;3bd3	bf 	.
13427 3BD4 BF           	dg	#-######			;3bd4	bf 	.
13428 3BD5
13429 3BD5 80           	dg	#-------	; M		;3bd5	80 	.
13430 3BD6 FD           	dg	######-#			;3bd6	fd  	. . .
13431 3BD7 F3           	dg	####--##			;3bd7	f3 	. . .
13432 3BD8 FD           	dg	######-#			;3bd8	fd  	. . .
13433 3BD9 80           	dg	#-------			;3bd9	80 	.
13434 3BDA
13435 3BDA 80           	dg	#-------	; N		;3bda	80 	.
13436 3BDB FD           	dg	######-#			;3bdb	fd  	. . .
13437 3BDC FB           	dg	#####-##			;3bdc	fb 	. . .
13438 3BDD F7           	dg	####-###			;3bdd	f7 	. . .
13439 3BDE 80           	dg 	#-------			;3bde	80 	.
13440 3BDF
13441 3BDF C1           	dg	##-----#	; O		;3bdf	c1 	.
13442 3BE0 BE           	dg	#-#####-			;3be0	be 	.
13443 3BE1 BE           	dg	#-#####-			;3be1	be 	.
13444 3BE2 BE           	dg	#-#####-			;3be2	be 	.
13445 3BE3 C1           	dg	##-----#			;3be3	c1 	.
13446 3BE4
13447 3BE4 80           	dg	#-------	; P		;3be4	80 	.
13448 3BE5 F6           	dg	####-##-			;3be5	f6 	. .
13449 3BE6 F6           	dg	####-##-			;3be6	f6 	. .
13450 3BE7 F6           	dg	####-##-			;3be7	f6 	. .
13451 3BE8 F9           	dg	#####--#			;3be8	f9 	. .
13452 3BE9
13453 3BE9 C1           	dg	##-----#	; Q		;3be9	c1 	.
13454 3BEA BE           	dg	#-#####-			;3bea	be 	.
13455 3BEB AE           	dg	#-#-###-			;3beb	ae 	.
13456 3BEC DE           	dg	##-####-			;3bec	de 	. .
13457 3BED A1           	dg	#-#----#			;3bed	a1 	. .
13458 3BEE
13459 3BEE 80           	dg	#-------	; R		;3bee	80 	.
13460 3BEF F6           	dg	####-##-			;3bef	f6 	. .
13461 3BF0 E6           	dg	###--##-			;3bf0	e6 	. .
13462 3BF1 D6           	dg	##-#-##-			;3bf1	d6 	. .
13463 3BF2 B9           	dg	#-###--#			;3bf2	b9 	. .
13464 3BF3
13465 3BF3 D9           	dg	##-##--#	; S		;3bf3	d9 	.
13466 3BF4 B6           	dg	#-##-##-			;3bf4	b6 	.
13467 3BF5 B6           	dg	#-##-##-			;3bf5	b6 	.
13468 3BF6 B6           	dg	#-##-##-			;3bf6	b6 	.
13469 3BF7 CD           	dg	##--##-#			;3bf7	cd 	. . .
13470 3BF8
13471 3BF8 FE           	dg	#######-	; T		;3bf8	fe 	. . .
13472 3BF9 FE           	dg	#######-			;3bf9	fe 	. . .
13473 3BFA 80           	dg 	#-------			;3bfa	80 	.
13474 3BFB FE           	dg	#######-			;3bfb	fe 	. .
13475 3BFC FE           	dg	#######-			;3bfc	fe 	. .
13476 3BFD
13477 3BFD C0           	dg	##------	; U		;3bfd	c0 	.
13478 3BFE BF           	dg	#-######			;3bfe	bf 	.
13479 3BFF BF           	dg	#-######			;3bff	bf 	.
13480 3C00 BF           	dg	#-######			;3c00	bf 	.
13481 3C01 C0           	dg	##------			;3c01	c0 	.
13482 3C02
13483 3C02 F8           	dg	#####---	; V		;3c02	f8 	.
13484 3C03 E7           	dg	###--###			;3c03	e7 	.
13485 3C04 9F           	dg	#--#####			;3c04	9f 	.
13486 3C05 E7           	dg	###--###			;3c05	e7 	.
13487 3C06 F8           	dg	#####---			;3c06	f8 	.
13488 3C07
13489 3C07 80           	dg	#-------	; W		;3c07	80 	.
13490 3C08 DF           	dg	##-#####			;3c08	df 	.
13491 3C09 E7           	dg	###--###			;3c09	e7 	.
13492 3C0A DF           	dg	##-#####			;3c0a	df 	.
13493 3C0B 80           	dg	#-------			;3c0b	80 	.
13494 3C0C
13495 3C0C 9C           	dg	#--###--	; X		;3c0c	9c 	.
13496 3C0D ED           	dg	###-##-#			;3c0d	ed 	.
13497 3C0E F7           	dg	####-###			;3c0e	f7 	.
13498 3C0F EB           	dg	###-#-##			;3c0f	eb 	.
13499 3C10 9C           	dg	#--###--			;3c10	9c 	.
13500 3C11
13501 3C11 FC           	dg	######--	; Y		;3c11	fc 	. . .
13502 3C12 FB           	dg	#####-##			;3c12	fb 	. . .
13503 3C13 87           	dg	#----###			;3c13	87 	. . .
13504 3C14 FB           	dg	#####-##			;3c14	fb 	.
13505 3C15 FC           	dg	######--			;3c15	fc 	. . .
13506 3C16
13507 3C16 9E           	dg	#--####-	; Z		;3c16	9e 	. . .
13508 3C17 AE           	dg	#-#-###-			;3c17	ae 	. . .
13509 3C18 B6           	dg	#-##-##-			;3c18	b6 	.
13510 3C19 BA           	dg	#-###-#-			;3c19	ba 	.
13511 3C1A BC           	dg	#-####--			;3c1a	bc 	.
13512 3C1B
13513 3C1B FF           	dg	########	; [		;3c1b	ff 	.
13514 3C1C 80           	dg	#-------			;3c1c	80 	.
13515 3C1D BE           	dg	#-#####-			;3c1d	be 	.
13516 3C1E BE           	dg	#-#####-			;3c1e	be 	.
13517 3C1F FF           	dg	########			;3c1f	ff 	.
13518 3C20
13519 3C20 FD           	dg	######-#	; /		;3c20	fd 	. . .
13520 3C21 FB           	dg	#####-##			;3c21	fb 	. . .
13521 3C22 F7           	dg	####-###			;3c22	f7 	. . .
13522 3C23 EF           	dg	###-####			;3c23	ef 	.
13523 3C24 DF           	dg	##-#####			;3c24	df 	.
13524 3C25
13525 3C25 FF           	dg	########	; ]		;3c25	ff 	.
13526 3C26 BE           	dg	#-#####-			;3c26	be 	.
13527 3C27 BE           	dg	#-#####-			;3c27	be 	.
13528 3C28 80           	dg	#-------			;3c28	80 	.
13529 3C29 FF           	dg	########			;3c29	ff 	.
13530 3C2A
13531 3C2A FB           	dg	#####-##	; ^		;3c2a	fb 	.
13532 3C2B FD           	dg	######-#			;3c2b	fd 	. . .
13533 3C2C 80           	dg	#-------			;3c2c	80 	. . .
13534 3C2D FD           	dg	######-#			;3c2d	fd 	. . .
13535 3C2E FB           	dg	#####-##			;3c2e	fb 	.
13536 3C2F
13537 3C2F F7           	dg	####-###	; <-	;3c2f	f7 	.
13538 3C30 E3           	dg	###---##			;3c30	e3 	.
13539 3C31 D6           	dg	##-#-##-			;3c31	d6 . .
13540 3C32 F7           	dg	####-###			;3c32	f7 	. .
13541 3C33 F7           	dg	####-###			;3c33	f7 	. .
13542 3C34
13543 3C34 FF           	dg	########	; space	;3c34	ff 	.
13544 3C35 FF           	dg	########			;3c35	ff 	.
13545 3C36 FF           	dg	########			;3c36	ff 	.
13546 3C37 FF           	dg	########			;3c37	ff 	.
13547 3C38 FF           	dg	########			;3c38	ff 	.
13548 3C39
13549 3C39 FF           	dg	########	; !		;3c39	ff 	.
13550 3C3A FF           	dg	########			;3c3a	ff 	.
13551 3C3B A0           	dg	#-#-----			;3c3b	a0 	.
13552 3C3C FF           	dg	########			;3c3c	ff 	.
13553 3C3D FF           	dg	########			;3c3d	ff 	.
13554 3C3E
13555 3C3E FF           	dg	########	; "		;3c3e	ff 	.
13556 3C3F F8           	dg	#####---			;3c3f	f8 	.
13557 3C40 FF           	dg	########			;3c40	ff 	.
13558 3C41 F8           	dg	#####---			;3c41	f8 	.
13559 3C42 FF           	dg	########			;3c42	ff 	.
13560 3C43
13561 3C43 EB           	dg	###-#-##	; #		;3c43	eb 	.
13562 3C44 80           	dg	#-------			;3c44	80 	.
13563 3C45 EB           	dg	###-#-##			;3c45	eb 	.
13564 3C46 80           	dg	#-------			;3c46	80 	.
13565 3C47 ED           	dg	###-##-#			;3c47	ed 	.
13566 3C48
13567 3C48 DB           	dg	##-##-##	; $		;3c48	db 	. .
13568 3C49 D6           	dg	##-#-##-			;3c49	d6 	. .
13569 3C4A 80           	dg	#-------			;3c4a	80 	.
13570 3C4B D6           	dg	##-#-##-			;3c4b	d6 	. .
13571 3C4C ED           	dg	###-##-#			;3c4c	ed 	. .
13572 3C4D
13573 3C4D D9           	dg	##-##--#	; %		;3c4d	d9 	.
13574 3C4E E9           	dg	###-#--#			;3c4e	e9 	.
13575 3C4F F7           	dg	####-###			;3c4f	f7 	.
13576 3C50 CB           	dg	##--#-##			;3c50	cb 	. .
13577 3C51 CD           	dg	##--##-#			;3c51	cd 	. .
13578 3C52
13579 3C52 C9           	dg	##--#--#	; &		;3c52	c9 	.
13580 3C53 D6           	dg	##-#-##-			;3c53	d6 	. .
13581 3C54 A9           	dg	#-#-#--#			;3c54	a9 	. .
13582 3C55 DF           	dg	##-#####			;3c55	df 	.
13583 3C56 AF           	dg	#-#-####			;3c56	af 	.
13584 3C57
13585 3C57 F7           	dg	####-###	; '		;3c57	f7 	.
13586 3C58 F8           	dg	#####---			;3c58	f8 	.
13587 3C59 FC           	dg	######--			;3c59	fc 	. . .
13588 3C5A FF           	dg	########			;3c5a	ff 	. . .
13589 3C5B FF           	dg	########			;3c5b	ff 	. . .
13590 3C5C
13591 3C5C FF           	dg	########	; (		;3c5c	ff 	. . .
13592 3C5D E3           	dg	###---##			;3c5d	e3 	.
13593 3C5E DD           	dg	##-###-#			;3c5e	dd 	. . .
13594 3C5F BE           	dg	#-#####-			;3c5f	be 	. . .
13595 3C60 FF           	dg	########			;3c60	ff 	. . .
13596 3C61
13597 3C61 FF           	dg	########	; )		;3c61	ff 	.
13598 3C62 BE           	dg	#-#####-			;3c62	be 	.
13599 3C63 DD           	dg	##-###-#			;3c63	e3 	. .
13600 3C64 E3           	dg	###---##			;3c64	e3 	. .
13601 3C65 FF           	dg	########			;3c65	ff 	.
13602 3C66
13603 3C66 D6           	dg	##-#-##-	; *		;3c66	d6 	. .
13604 3C67 E3           	dg	###---##			;3c67	e3 	. .
13605 3C68 80           	dg	#-------			;3c68	80 	.
13606 3C69 E3           	dg	###---##			;3c69	e3 	.
13607 3C6A D5           	dg	##-#-#-#			;3c6a	d5 	.
13608 3C6B
13609 3C6B F7           	dg	####-###	; +		;3c6b	f7 	.
13610 3C6C F7           	dg	####-###			;3c6c	f7 	.
13611 3C6D C1           	dg	##-----#			;3c6d	c1 	.
13612 3C6E F7           	dg	####-###			;3c6e	f7 	.
13613 3C6F F7           	dg	####-###			;3c6f	f7 	.
13614 3C70
13615 3C70 DF           	dg	##-#####	; /		;3c70	df 	.
13616 3C71 C7           	dg	##---###			;3c71	c7 	.
13617 3C72 F7           	dg	####-###			;3c72	f7 	.
13618 3C73 FF           	dg	########			;3c73	ff 	.
13619 3C74 FF           	dg	########			;3c74	ff 	.
13620 3C75
13621 3C75 F7           	dg	####-###	; -		;3c75	f7 	.
13622 3C76 F7           	dg	####-###			;3c76	f7 	.
13623 3C77 F7           	dg	####-###			;3c77	f7 	.
13624 3C78 F7           	dg	####-###			;3c78	f7 	.
13625 3C79 F7           	dg	####-###			;3c79	f7 	.
13626 3C7A
13627 3C7A FF           	dg	########	; .		;3c7a	ff 	.
13628 3C7B 9F           	dg	#--#####			;3c7b	9f 	.
13629 3C7C 9F           	dg	#--#####			;3c7c	9f 	.
13630 3C7D FF           	dg	########			;3c7d	ff 	.
13631 3C7E FF           	dg	########			;3c7e	ff 	.
13632 3C7F
13633 3C7F DF           	dg	##-#####	; \		;3c7f	df 	.
13634 3C80 EF           	dg	###-####			;3c80	ef 	.
13635 3C81 F7           	dg	####-###			;3c81	f7 	.
13636 3C82 FB           	dg	#####-##			;3c82	fb 	.
13637 3C83 FD           	dg	######-#			;3c83	fd . . .
13638 3C84
13639 3C84 C1           	dg	##-----#	; 0		;3c84	c1 	. . .
13640 3C85 AE           	dg	#-#-###-			;3c85	ae 	. . .
13641 3C86 B6           	dg	#-##-##-			;3c86	b6 	.
13642 3C87 BA           	dg	#-###-#-			;3c87	ba 	.
13643 3C88 C1           	dg	##-----#			;3c88	c1 	.
13644 3C89
13645 3C89 FF           	dg	########	; 1		;3c89	ff 	.
13646 3C8A BD           	dg	#-####-#			;3c8a	bd 	.
13647 3C8B 80           	dg 	#-------			;3c8b	80 	.
13648 3C8C BF           	dg	#-######			;3c8c	bf 	.
13649 3C8D FF           	dg	########			;3c8d	ff 	.
13650 3C8E
13651 3C8E 9D           	dg	#--###-#	; 2		;3c8e	9d 	.
13652 3C8F AE           	dg	#-#-###-			;3c8f	ae 	.
13653 3C90 B6           	dg	#-##-##-			;3c90	b6 	.
13654 3C91 BA           	dg	#-###-#-			;3c91	ba 	.
13655 3C92 BD           	dg	#-####-#			;3c92	bd 	.
13656 3C93
13657 3C93 DD           	dg	##-###-#	;3		;3c93	dd  	. . .
13658 3C94 BB           	dg	#-###-##			;3c94	bb 	. . .
13659 3C95 BB           	dg	#-###-##			;3c95	bb 	. . .
13660 3C96 BB           	dg	#-###-##			;3c96	bb 	. . .
13661 3C97 C9           	dg	##--#--#			;3c97	c9 	.
13662 3C98
13663 3C98 E7           	dg	###--###	; 4		;3c98	e7 	.
13664 3C99 EB           	dg	###-#-##			;3c99	eb 	.
13665 3C9A ED           	dg	###-##-#			;3c9a	ed 	.
13666 3C9B 80           	dg	#-------			;3c9b	80 	.
13667 3C9C EF           	dg	###-####			;3c9c	ef 	.
13668 3C9D
13669 3C9D D8           	dg	##-##---	; 5		;3c9d	d8 	.
13670 3C9E BA           	dg	#-###-#-			;3c9e	ba 	.
13671 3C9F DA           	dg	##-##-#-			;3c9f	da	. . .
13672 3CA0 DA           	dg	##-##-#-			;3ca0	da 	. . .
13673 3CA1 C6           	dg	##---##-			;3ca1	c6 	. . .
13674 3CA2
13675 3CA2 C1           	dg	##-----#	; 6		;3ca2	c1 	.
13676 3CA3 B6           	dg	#-##-##-			;3ca3	b6 	.
13677 3CA4 B6           	dg	#-##-##-			;3ca4	b6 	.
13678 3CA5 B6           	dg	#-##-##-			;3ca5	b6 	.
13679 3CA6 CF           	dg	##--####			;3ca6	cf 	.
13680 3CA7
13681 3CA7 FC           	dg	######--	; 7		;3ca7	fc
13682 3CA8 FE           	dg	#######-			;3ca8	fe 	. . .
13683 3CA9 86           	dg	#----##-			;3ca9	86 	. . .
13684 3CAA FA           	dg	#####-#-			;3caa	fa 	. . .
13685 3CAB FC           	dg	######--			;3cab	fc 	. . .
13686 3CAC
13687 3CAC C9           	dg	##--#--#	; 8		;3cac	c9 	. . .
13688 3CAD B6           	dg	#-##-##-			;3cad	b6 	.
13689 3CAE B6           	dg	#-##-##-			;3cae	b6 	.
13690 3CAF B6           	dg	#-##-##-			;3caf	b6 	.
13691 3CB0 C9           	dg	##--#--#			;3cb0	c9 	.
13692 3CB1
13693 3CB1 F9           	dg	#####--#	; 9		;3cb1	f9 	.
13694 3CB2 B6           	dg	#-##-##-			;3cb2	b6 	.
13695 3CB3 B6           	dg	#-##-##-			;3cb3	b6 	.
13696 3CB4 B6           	dg	#-##-##-			;3cb4	b6 	.
13697 3CB5 C1           	dg	##-----#			;3cb5	c1 	.
13698 3CB6
13699 3CB6 FF           	dg	########	; :		;3cb6	ff 	.
13700 3CB7 C9           	dg	##--#--#			;3cb7	c9 	.
13701 3CB8 C9           	dg	##--#--#			;3cb8	c9 	.
13702 3CB9 FF           	dg 	########			;3cb9	ff 	.
13703 3CBA FF           	dg 	########			;3cba	ff 	.
13704 3CBB
13705 3CBB BF           	dg	#-######	; ;		;3cbb	bf 	.
13706 3CBC C4           	dg	##---#--			;3cbc	c4 	. . .
13707 3CBD E4           	dg	###--#--			;3cbd	e4 	. . .
13708 3CBE FF           	dg	########			;3cbe	ff 	.
13709 3CBF FF           	dg	########			;3cbf	ff 	.
13710 3CC0
13711 3CC0 F7           	dg	####-###	; <		;3cc0	f7 	.
13712 3CC1 EB           	dg	###-#-##			;3cc1	eb 	.
13713 3CC2 DD           	dg	##-###-#			;3cc2	dd 	. . .
13714 3CC3 DE           	dg	##-####-			;3cc3	de 	. . .
13715 3CC4 DE           	dg	##-####-			;3cc4	de 	. . .
13716 3CC5
13717 3CC5 EB           	dg	###-#-##	; =		;3cc5	eb 	.
13718 3CC6 EB           	dg	###-#-##			;3cc6	eb 	.
13719 3CC7 EB           	dg	###-#-##			;3cc7	eb 	.
13720 3CC8 EB           	dg	###-#-##			;3cc8	eb 	.
13721 3CC9 EB           	dg	###-#-##			;3cc9	eb 	.
13722 3CCA
13723 3CCA DE           	dg	##-####-	; >		;3cca	de 	. .
13724 3CCB DE           	dg	##-####-			;3ccb	de 	. .
13725 3CCC DD           	dg	##-###-#			;3ccc	dd 	. . .
13726 3CCD EB           	dg	###-#-##			;3ccd	eb 	. . .
13727 3CCE F7           	dg	####-###			;3cce	f7 	. . .
13728 3CCF
13729 3CCF FD           	dg	######-#	; ?		;3ccf	fd 	. . .
13730 3CD0 FE           	dg	#######-			;3cd0	fe 	. . .
13731 3CD1 A6           	dg	#-#--##-			;3cd1	a6 	. . .
13732 3CD2 FA           	dg	#####-#-			;3cd2	fa 	. . .
13733 3CD3 FD           	dg	######-#			;3cd3	fd 	. . .
13734 3CD4
13735 3CD4
13736 3CD4
13737 3CD4              ;*****************************************************************************************
13738 3CD4              ; Print text of Error taken from ErrorTextTable
13739 3CD4              ; First char of every error text (entry) in table is inverted in order to mark start of entry
13740 3CD4              ; IN: hl - address of table with texts for errors
13741 3CD4              ;     e -  error number (0,2,4,..44)
13742 3CD4              PrintErrorText:
13743 3CD4 CB 3B        	srl e			; e = Error number / 2 -> range 0..22						;3cd4	cb 3b 	.
13744 3CD6 1C           	inc e			; e = Error number in range 1..23							;3cd6	1c 	.
13745 3CD7              ; -- find start of Error text for given error number
13746 3CD7              .next:
13747 3CD7 7E           	ld a,(hl)		; a - char of text to test									;3cd7	7e 	~
13748 3CD8 23           	inc hl			; next char pointer											;3cd8	23 	#
13749 3CD9 B7           	or a			; is inverted? 												;3cd9	b7 	.
13750 3CDA F2 D7 3C     	jp p,.next		; no - check next char										;3cda	f2 d7 3c 	. . <
13751 3CDD              ; -- inverted char found - start of text
13752 3CDD 1D           	dec e			; is it error we are looking for?							;3cdd	1d 	.
13753 3CDE 20 F7        	jr nz,.next		; no - seek for next text									;3cde	20 f7 	  .
13754 3CE0              ; -- error text found (1st char already in register a and hl points to next char)
13755 3CE0 E6 7F        	and $7f			; remove char inversion 									;3ce0	e6 7f 	. 
13756 3CE2              .print:
13757 3CE2 CD 2A 03     	call PrintChar	; Print char on screen										;3ce2	cd 2a 03 	. * .
13758 3CE5 7E           	ld a,(hl)		; char of error text 										;3ce5	7e 	~
13759 3CE6 23           	inc hl			; next char													;3ce6	23 	#
13760 3CE7 B7           	or a			; is is inverted char (already next text entry)?			;3ce7	b7 	.
13761 3CE8 F2 E2 3C     	jp p,.print		; no - print char and get next								;3ce8	f2 e2 3c 	. . <
13762 3CEB C9           	ret				; ----------------- End of Proc ---------------------------	;3ceb	c9 	.
13763 3CEC
13764 3CEC
13765 3CEC
13766 3CEC              ;****************************************************************************************
13767 3CEC              ;  Error Messages
13768 3CEC              ; Every 1st byte of message text has 7 bit set meaning start of text (and end of previous)
13769 3CEC              ERR_TXT_TABLE:
13770 3CEC CE 45 58 54  	db $80|'N','EXT WITHOUT FOR'	; Error 00 - NEXT WITHOUT FOR	;3cec	ce 45 58 54 20 57 49 54 48 4f 55 54 20 46 4f 52 	R
13770 3CF0 20 57 49 54
13770 3CF4 48 4F 55 54
13770 3CF8 20 46 4F 52
13771 3CFC D3 59 4E 54  	db $80|'S','YNTAX'				; Error 02 - SYNTAX				;3cfc	d3 59 4e 54 41 58 	X
13771 3D00 41 58
13772 3D02 D2 45 54 27  	db $80|'R',"ET'N WITHOUT GOSUB"	; Error 04 - RET'N WITHOUT GOSUB;3d02	d2 45 54 27 4e 20 57 49 54 48 4f 55 54 20 47 4f 53 55 42 	B
13772 3D06 4E 20 57 49
13772 3D0A 54 48 4F 55
13772 3D0E 54 20 47 4F
13772 3D12 53 55 42
13773 3D15 CF 55 54 20  	db $80|'O','UT OF DATA'			; Error 06 - OUT OF DATA		;3d15	cf 55 54 20 4f 46 20 44 41 54 41 	A
13773 3D19 4F 46 20 44
13773 3D1D 41 54 41
13774 3D20 C6 55 4E 43  	db $80|'F','UNCTION CODE'		; Error 08 - FUNCTION CODE		;3d20	c6 55 4e 43 54 49 4f 4e 20 43 4f 44 45 	E
13774 3D24 54 49 4F 4E
13774 3D28 20 43 4F 44
13774 3D2C 45
13775 3D2D CF 56 45 52  	db $80|'O','VERFLOW'			; Error 0A - OVERFLOW 			;3d2d	cf 56 45 52 46 4c 4f 57 	W
13775 3D31 46 4C 4F 57
13776 3D35 CF 55 54 20  	db $80|'O','UT OF MEMORY'		; Error 0C - OUT OF MEMORY		;3d35	cf 55 54 20 4f 46 20 4d 45 4d 4f 52 59 	Y
13776 3D39 4F 46 20 4D
13776 3D3D 45 4D 4F 52
13776 3D41 59
13777 3D42 D5 4E 44 45  	db $80|'U',"NDEF'D STATEMENT"	; Error 0E - UNDEF'D STATEMENT	;3d42	d5 4e 44 45 46 27 44 20 53 54 41 54 45 4d 45 4e 54 	T
13777 3D46 46 27 44 20
13777 3D4A 53 54 41 54
13777 3D4E 45 4D 45 4E
13777 3D52 54
13778 3D53 C2 41 44 20  	db $80|'B','AD SUBSCRIPT'		; Error 10 - BAD SUBSCRIPT		;3d53	c2 41 44 20 53 55 42 53 43 52 49 50 54 	T
13778 3D57 53 55 42 53
13778 3D5B 43 52 49 50
13778 3D5F 54
13779 3D60 D2 45 44 49  	db $80|'R',"EDIM'D ARRAY"		; Error 12 - REDIM'D ARRAY		;3d60	d2 45 44 49 4d 27 44 20 41 52 52 41 59 	Y
13779 3D64 4D 27 44 20
13779 3D68 41 52 52 41
13779 3D6C 59
13780 3D6D C4 49 56 49  	db $80|'D','IVISION BY ZERO'	; Error 14 - DIVISION BY ZERO	;3d6d	c4 49 56 49 53 49 4f 4e 20 42 59 20 5a 45 52 4f 	O
13780 3D71 53 49 4F 4E
13780 3D75 20 42 59 20
13780 3D79 5A 45 52 4F
13781 3D7D C9 4C 4C 45  	db $80|'I','LLEGAL DIRECT'		; Error 16 - ILLEGAL DIRECT		;3d7d	c9 4c 4c 45 47 41 4c 20 44 49 52 45 43 54 	T
13781 3D81 47 41 4C 20
13781 3D85 44 49 52 45
13781 3D89 43 54
13782 3D8B D4 59 50 45  	db $80|'T','YPE MISMATCH'		; Error 18 - TYPE MISMACH		;3d8b	d4 59 50 45 20 4d 49 53 4d 41 54 43 48 	H
13782 3D8F 20 4D 49 53
13782 3D93 4D 41 54 43
13782 3D97 48
13783 3D98 CF 55 54 20  	db $80|'O','UT OF SPACE'		; Error 1A - OUT OF SPACE		;3d98	cf 55 54 20 4f 46 20 53 50 41 43 45 	E
13783 3D9C 4F 46 20 53
13783 3DA0 50 41 43 45
13784 3DA4 D3 54 52 49  	db $80|'S','TRING TOO LONG'		; Error 1C - STRING TOO LONG	;3da4	d3 54 52 49 4e 47 20 54 4f 4f 20 4c 4f 4e 47 	G
13784 3DA8 4E 47 20 54
13784 3DAC 4F 4F 20 4C
13784 3DB0 4F 4E 47
13785 3DB3 C6 4F 52 4D  	db $80|'F','ORMULA TOO COMPLEX'	; Error 1E - FORMULA TOO COMPLEX;3db3	c6 4f 52 4d 55 4c 41 20 54 4f 4f 20 43 4f 4d 50 4c 45 58 	X
13785 3DB7 55 4C 41 20
13785 3DBB 54 4F 4F 20
13785 3DBF 43 4F 4D 50
13785 3DC3 4C 45 58
13786 3DC6 C3 41 4E 27  	db $80|'C',"AN'T CONT"			; Error 20 - CAN'T CONT			;3dc6	c3 41 4e 27 54 20 43 4f 4e 54 	T
13786 3DCA 54 20 43 4F
13786 3DCE 4E 54
13787 3DD0 CE 4F 20 52  	db $80|'N','O RESUME'			; Error 22 - NO RESUME			;3dd0	ce 4f 20 52 45 53 55 4d 45 	E
13787 3DD4 45 53 55 4D
13787 3DD8 45
13788 3DD9 D2 45 53 55  	db $80|'R','ESUME WITHOUT' 		; Error 24 - RESUME WITHOUT		;3dd9	d2 45 53 55 4d 45 20 57 49 54 48 4f 55 54 	T
13788 3DDD 4D 45 20 57
13788 3DE1 49 54 48 4F
13788 3DE5 55 54
13789 3DE7 D5 4E 50 52  	db $80|'U','NPRINTABLE'			; Error 26 - UNPRINTABLE		;3de7	d5 4e 50 52 49 4e 54 41 42 4c 45 	E
13789 3DEB 49 4E 54 41
13789 3DEF 42 4C 45
13790 3DF2 CD 49 53 53  	db $80|'M','ISSING OPERAND' 	; Error 28 - MISSING OPERAND	;3df2	cd 49 53 53 49 4e 47 20 4f 50 45 52 41 4e 44 	D
13790 3DF6 49 4E 47 20
13790 3DFA 4F 50 45 52
13790 3DFE 41 4E 44
13791 3E01 C2 41 44 20  	db $80|'B','AD FILE DATA'		; Error 2A - BAD FILE DATA		;3e01	c2 41 44 20 46 49 4c 45 20 44 41 54 41 	A
13791 3E05 46 49 4C 45
13791 3E09 20 44 41 54
13791 3E0D 41
13792 3E0E C4 49 53 4B  	db $80|'D','ISK COMMAND'		; Error 2C - DISK COMMAND		;3e0e	c4 49 53 4b 20 43 4f 4d 4d 41 4e 44 	D
13792 3E12 20 43 4F 4D
13792 3E16 4D 41 4E 44
13793 3E1A
13794 3E1A              TXT_SYNTAXERROR:
13795 3E1A 3F 53 59 4E  	db '?SYNTAX ERROR',$0d,0		; Interractive Error - SYNTAX ERROR	;3e1a	3f 53 59 4e 54 41 58 20 45 52 52 4f 52 0d 00 	.
13795 3E1E 54 41 58 20
13795 3E22 45 52 52 4F
13795 3E26 52 0D 00
13796 3E29
13797 3E29              ; -- Make sure there is at least 1 char in Edit Buffer
13798 3E29              ; -- if 1st byte is 0 (Buffer is empty), puts one Space char
13799 3E29              ; IN: hl - start of Editor Line Buffer
13800 3E29              ;     [stack] - saved AF
13801 3E29              l3e29h:
13802 3E29 7E           	ld a,(hl)				; a - 1st char/byte from Edit Buffer							;3e29	7e 	~
13803 3E2A B7           	or a					; is it 0? (empty buffer)										;3e2a	b7 	.
13804 3E2B 20 07        	jr nz,.exit			; no - return 													;3e2b	20 07 	  .
13805 3E2D              ; -- buffer is empty - add Space char and 0 terminator
13806 3E2D 3E 20        	ld a,' '				; a - Space char 												;3e2d	3e 20 	>
13807 3E2F 77           	ld (hl),a				; store as 1st char in Buffer									;3e2f	77 	w
13808 3E30 23           	inc hl					; hl - point to next location in Buffer							;3e30	23 	#
13809 3E31 AF           	xor a					; a = 0 - null String Terminator								;3e31	af 	.
13810 3E32 77           	ld (hl),a				; put into Buffer												;3e32	77 	w
13811 3E33 2B           	dec hl					; hl - move pointer back to 1st char							;3e33	2b 	+
13812 3E34              .exit:
13813 3E34 2B           	dec hl					; hl - points to address just before beginig of Edit Buffer		;3e34	2b 	+
13814 3E35 F1           	pop af					; restore af - edit Abort/Commit state  						;3e35	f1 	.
13815 3E36 C9           	ret						; return 														;3e36	c9 	.
13816 3E37
13817 3E37
13818 3E37
13819 3E37              l3e37h:
13820 3E37 32 7D 78     	ld (OnCpuINT),a		;3e37	32 7d 78 	2 } x
13821 3E3A 3E 10        	ld a,010h		;3e3a	3e 10 	> .
13822 3E3C 32 46 78     	ld (FCOLOR),a	; Foreground Color	;3e3c	32 46 78 	2 F x
13823 3E3F C9           	ret			;3e3f	c9 	.
13824 3E40
13825 3E40
13826 3E40
13827 3E40               ifdef VER_12
13828 3E40              // *********************************************************************
13829 3E40              ; Dummy fill data
13830 3E40 00 00 00...  	defs 60,0			;3e40	00 	.
13831 3E7C 53           	db   $53			;3e7c	53 	S
13832 3E7D FF FF FF...  	defs 386,$ff
13833 3FFF 00           	db   0				;3fff	00 	.
13834 4000              // *********************************************************************
13835 4000
13836 4000
13837 4000               else ; VER_20
13838 4000 ~
13839 4000 ~            l3e40h:
13840 4000 ~            	ld a,(hl)			;3e40	7e 	~
13841 4000 ~            	bit 6,a		;3e41	cb 77 	. w
13842 4000 ~            	jr z,l3e4ah		;3e43	28 05 	( .
13843 4000 ~            	cp 080h		;3e45	fe 80 	. .
13844 4000 ~            	jp c,l3e5dh		;3e47	da 5d 3e 	. ] >
13845 4000 ~            l3e4ah:
13846 4000 ~            	pop bc			;3e4a	c1 	.
13847 4000 ~            	ld de,l3e53h		;3e4b	11 53 3e 	. S >
13848 4000 ~            	push de			;3e4e	d5 	.
13849 4000 ~            l3e4fh:
13850 4000 ~            	push bc			;3e4f	c5 	.
13851 4000 ~            	jp l0502h		;3e50	c3 02 05 	. . .
13852 4000 ~            l3e53h:
13853 4000 ~            	ret c			;3e53	d8 	.
13854 4000 ~            	ld hl,TXT_SYNTAXERROR		;3e54	21 1a 3e 	! . >
13855 4000 ~            l3e57h:
13856 4000 ~            	call PrintBasicStr		;3e57	cd a7 28 	. . (
13857 4000 ~            	jp ReadLine			; Read Line as typed by User	;3e5a	c3 e3 03 	. . .
13858 4000 ~            l3e5dh:
13859 4000 ~            	cp 062h		;3e5d	fe 62 	. b
13860 4000 ~            	jr nz,l3e9ah		;3e5f	20 39 	  9
13861 4000 ~            	and 0bfh		;3e61	e6 bf 	. .
13862 4000 ~            	ld (de),a			;3e63	12 	.
13863 4000 ~            	inc hl			;3e64	23 	#
13864 4000 ~            	inc de			;3e65	13 	.
13865 4000 ~            	dec b			;3e66	05 	.
13866 4000 ~            	jp z,FinishParse		;3e67	ca ee 04 	. . .
13867 4000 ~            l3e6ah:
13868 4000 ~            	ld a,(hl)			;3e6a	7e 	~
13869 4000 ~            	bit 7,a		;3e6b	cb 7f 	.
13870 4000 ~            	jr nz,l3e75h		;3e6d	20 06 	  .
13871 4000 ~            	bit 6,a		;3e6f	cb 77 	. w
13872 4000 ~            	jr nz,l3e7fh		;3e71	20 0c 	  .
13873 4000 ~            	jr l3e7bh		;3e73	18 06 	. .
13874 4000 ~            l3e75h:
13875 4000 ~            	and 08fh		;3e75	e6 8f 	. .
13876 4000 ~            	or 080h		;3e77	f6 80 	. .
13877 4000 ~            	jr l3e92h		;3e79	18 17 	. .
13878 4000 ~            l3e7bh:
13879 4000 ~            	or 0c0h		;3e7b	f6 c0 	. .
13880 4000 ~            	jr l3e92h		;3e7d	18 13 	. .
13881 4000 ~            l3e7fh:
13882 4000 ~            	cp 062h		;3e7f	fe 62 	. b
13883 4000 ~            	jr nz,l3e8ch		;3e81	20 09 	  .
13884 4000 ~            	push hl			;3e83	e5 	.
13885 4000 ~            	ld hl,07839h		;3e84	21 39 78 	! 9 x
13886 4000 ~            	bit 4,(hl)		;3e87	cb 66 	. f
13887 4000 ~            	pop hl			;3e89	e1 	.
13888 4000 ~            	jr z,l3e9ah		;3e8a	28 0e 	( .
13889 4000 ~            l3e8ch:
13890 4000 ~            	bit 5,a		;3e8c	cb 6f 	. o
13891 4000 ~            	jr z,l3e92h		;3e8e	28 02 	( .
13892 4000 ~            	and 0bfh		;3e90	e6 bf 	. .
13893 4000 ~            l3e92h:
13894 4000 ~            	ld (de),a			;3e92	12 	.
13895 4000 ~            	inc hl			;3e93	23 	#
13896 4000 ~            	inc de			;3e94	13 	.
13897 4000 ~            	djnz l3e6ah		;3e95	10 d3 	. .
13898 4000 ~            	jp FinishParse		;3e97	c3 ee 04 	. . .
13899 4000 ~            l3e9ah:
13900 4000 ~            	bit 5,a		;3e9a	cb 6f 	. o
13901 4000 ~            	jr z,l3ea0h		;3e9c	28 02 	( .
13902 4000 ~            	and 0bfh		;3e9e	e6 bf 	. .
13903 4000 ~            l3ea0h:
13904 4000 ~            	ld (de),a			;3ea0	12 	.
13905 4000 ~            	inc hl			;3ea1	23 	#
13906 4000 ~            	inc de			;3ea2	13 	.
13907 4000 ~            	djnz l3e40h		;3ea3	10 9b 	. .
13908 4000 ~            	jp FinishParse		;3ea5	c3 ee 04 	. . .
13909 4000 ~            l3ea8h:
13910 4000 ~            	ld a,(07818h)		;3ea8	3a 18 78 	: . x
13911 4000 ~            	or a			;3eab	b7 	.
13912 4000 ~            	jp nz,l04b8h		;3eac	c2 b8 04 	. . .
13913 4000 ~            	jp l3e6ah		;3eaf	c3 6a 3e 	. j >
13914 4000 ~            l3eb2h:
13915 4000 ~            	ld a,(07818h)		;3eb2	3a 18 78 	: . x
13916 4000 ~            	or a			;3eb5	b7 	.
13917 4000 ~            	jr nz,l3ebbh		;3eb6	20 03 	  .
13918 4000 ~            	res 6,(hl)		;3eb8	cb b6 	. .
13919 4000 ~            	ret			;3eba	c9 	.
13920 4000 ~            l3ebbh:
13921 4000 ~            	set 6,(hl)		;3ebb	cb f6 	. .
13922 4000 ~            	ret			;3ebd	c9 	.
13923 4000 ~            sub_3ebeh:
13924 4000 ~            	ld a,(07818h)		;3ebe	3a 18 78 	: . x
13925 4000 ~            	or a			;3ec1	b7 	.
13926 4000 ~            	ld a,020h		;3ec2	3e 20 	>
13927 4000 ~            	jr nz,l3ec8h		;3ec4	20 02 	  .
13928 4000 ~            	or 040h		;3ec6	f6 40 	. @
13929 4000 ~            l3ec8h:
13930 4000 ~            	ld (hl),a			;3ec8	77 	w
13931 4000 ~            	ret			;3ec9	c9 	.
13932 4000 ~            l3ecah:
13933 4000 ~            	push af			;3eca	f5 	.
13934 4000 ~            	ld a,(07818h)		;3ecb	3a 18 78 	: . x
13935 4000 ~            	or a			;3ece	b7 	.
13936 4000 ~            	jr z,l3ed8h		;3ecf	28 07 	( .
13937 4000 ~            	pop af			;3ed1	f1 	.
13938 4000 ~            	and 03fh		;3ed2	e6 3f 	. ?
13939 4000 ~            	push hl			;3ed4	e5 	.
13940 4000 ~            	jp l31abh		;3ed5	c3 ab 31 	. . 1
13941 4000 ~            l3ed8h:
13942 4000 ~            	pop af			;3ed8	f1 	.
13943 4000 ~            	or 040h		;3ed9	f6 40 	. @
13944 4000 ~            	push hl			;3edb	e5 	.
13945 4000 ~            	ld hl,07838h		;3edc	21 38 78 	! 8 x
13946 4000 ~            	bit 1,(hl)		;3edf	cb 4e 	. N
13947 4000 ~            	pop hl			;3ee1	e1 	.
13948 4000 ~            	jr z,l3ee6h		;3ee2	28 02 	( .
13949 4000 ~            	and 0bfh		;3ee4	e6 bf 	. .
13950 4000 ~            l3ee6h:
13951 4000 ~            	jp l31b5h		;3ee6	c3 b5 31 	. . 1
13952 4000 ~            sub_3ee9h:
13953 4000 ~            	ld a,(07818h)		;3ee9	3a 18 78 	: . x
13954 4000 ~            	or a			;3eec	b7 	.
13955 4000 ~            	ld a,(hl)			;3eed	7e 	~
13956 4000 ~            	jr nz,l3ef3h		;3eee	20 03 	  .
13957 4000 ~            	cp 060h		;3ef0	fe 60 	. `
13958 4000 ~            	ret			;3ef2	c9 	.
13959 4000 ~            l3ef3h:
13960 4000 ~            	cp 020h		;3ef3	fe 20 	.
13961 4000 ~            	ret			;3ef5	c9 	.
13962 4000 ~            sub_3ef6h:
13963 4000 ~            	ld a,(07818h)		;3ef6	3a 18 78 	: . x
13964 4000 ~            	or a			;3ef9	b7 	.
13965 4000 ~            	ld a,020h		;3efa	3e 20 	>
13966 4000 ~            	jr nz,l3f00h		;3efc	20 02 	  .
13967 4000 ~            	or 040h		;3efe	f6 40 	. @
13968 4000 ~            l3f00h:
13969 4000 ~            	ld (de),a			;3f00	12 	.
13970 4000 ~            	ret			;3f01	c9 	.
13971 4000 ~            sub_3f02h:
13972 4000 ~            	ld b,020h		;3f02	06 20 	.
13973 4000 ~            	ld a,(07818h)		;3f04	3a 18 78 	: . x
13974 4000 ~            	or a			;3f07	b7 	.
13975 4000 ~            	ld a,020h		;3f08	3e 20 	>
13976 4000 ~            	ret nz			;3f0a	c0 	.
13977 4000 ~            	or 040h		;3f0b	f6 40 	. @
13978 4000 ~            	ret			;3f0d	c9 	.
13979 4000 ~            sub_3f0eh:
13980 4000 ~            	ld de,071e0h		;3f0e	11 e0 71 	. . q
13981 4000 ~            	ld a,(07818h)		;3f11	3a 18 78 	: . x
13982 4000 ~            	or a			;3f14	b7 	.
13983 4000 ~            	ret nz			;3f15	c0 	.
13984 4000 ~            	pop af			;3f16	f1 	.
13985 4000 ~            l3f17h:
13986 4000 ~            	ld a,(hl)			;3f17	7e 	~
13987 4000 ~            	or a			;3f18	b7 	.
13988 4000 ~            	ret z			;3f19	c8 	.
13989 4000 ~            	res 6,a		;3f1a	cb b7 	. .
13990 4000 ~            	ld (de),a			;3f1c	12 	.
13991 4000 ~            	inc de			;3f1d	13 	.
13992 4000 ~            	inc hl			;3f1e	23 	#
13993 4000 ~            	jr l3f17h		;3f1f	18 f6 	. .
13994 4000 ~            sub_3f21h:
13995 4000 ~            	ld a,(07818h)		;3f21	3a 18 78 	: . x
13996 4000 ~            	or a			;3f24	b7 	.
13997 4000 ~            	ld a,(hl)			;3f25	7e 	~
13998 4000 ~            	jr nz,l3f2fh		;3f26	20 07 	  .
13999 4000 ~            	set 6,a		;3f28	cb f7 	. .
14000 4000 ~            	ld (de),a			;3f2a	12 	.
14001 4000 ~            	inc de			;3f2b	13 	.
14002 4000 ~            	ld a,07ah		;3f2c	3e 7a 	> z
14003 4000 ~            	ret			;3f2e	c9 	.
14004 4000 ~            l3f2fh:
14005 4000 ~            	ld (de),a			;3f2f	12 	.
14006 4000 ~            	ld a,03ah		;3f30	3e 3a 	> :
14007 4000 ~            	ret			;3f32	c9 	.
14008 4000 ~            sub_3f33h:
14009 4000 ~            	push af			;3f33	f5 	.
14010 4000 ~            	ld a,(07818h)		;3f34	3a 18 78 	: . x
14011 4000 ~            	or a			;3f37	b7 	.
14012 4000 ~            	jr nz,l3f3fh		;3f38	20 05 	  .
14013 4000 ~            	pop af			;3f3a	f1 	.
14014 4000 ~            	or 040h		;3f3b	f6 40 	. @
14015 4000 ~            	ld (de),a			;3f3d	12 	.
14016 4000 ~            	ret			;3f3e	c9 	.
14017 4000 ~            l3f3fh:
14018 4000 ~            	pop af			;3f3f	f1 	.
14019 4000 ~            	and 03fh		;3f40	e6 3f 	. ?
14020 4000 ~            	ld (de),a			;3f42	12 	.
14021 4000 ~            	ret			;3f43	c9 	.
14022 4000 ~            l3f44h:
14023 4000 ~            	push af			;3f44	f5 	.
14024 4000 ~            	ld a,(07818h)		;3f45	3a 18 78 	: . x
14025 4000 ~            	or a			;3f48	b7 	.
14026 4000 ~            	jr nz,l3f54h		;3f49	20 09 	  .
14027 4000 ~            	pop af			;3f4b	f1 	.
14028 4000 ~            	bit 6,a		;3f4c	cb 77 	. w
14029 4000 ~            	jp nz,l3938h		;3f4e	c2 38 39 	. 8 9
14030 4000 ~            	jp l3931h		;3f51	c3 31 39 	. 1 9
14031 4000 ~            l3f54h:
14032 4000 ~            	pop af			;3f54	f1 	.
14033 4000 ~            	bit 6,a		;3f55	cb 77 	. w
14034 4000 ~            	jp z,l3938h		;3f57	ca 38 39 	. 8 9
14035 4000 ~            	jp l3931h		;3f5a	c3 31 39 	. 1 9
14036 4000 ~            	jp l3931h		;3f5d	c3 31 39 	. 1 9
14037 4000 ~            l3f60h:
14038 4000 ~            	push af			;3f60	f5 	.
14039 4000 ~            	ld a,(07818h)		;3f61	3a 18 78 	: . x
14040 4000 ~            	or a			;3f64	b7 	.
14041 4000 ~            	jr nz,l3f6dh		;3f65	20 06 	  .
14042 4000 ~            	pop af			;3f67	f1 	.
14043 4000 ~            	and 03fh		;3f68	e6 3f 	. ?
14044 4000 ~            	jp l3154h		;3f6a	c3 54 31 	. T 1
14045 4000 ~            l3f6dh:
14046 4000 ~            	pop af			;3f6d	f1 	.
14047 4000 ~            	and 07fh		;3f6e	e6 7f 	.
14048 4000 ~            	jp l3154h		;3f70	c3 54 31 	. T 1
14049 4000 ~            sub_3f73h:
14050 4000 ~            	call TapeReadByte		;3f73	cd 75 37 	. u 7
14051 4000 ~            	ret nc			;3f76	d0 	.
14052 4000 ~            	pop hl			;3f77	e1 	.
14053 4000 ~            	jp TapeLoadError		;3f78	c3 11 37 	. . 7
14054 4000 ~            sub_3f7bh:
14055 4000 ~            	ld a,(07819h)		;3f7b	3a 19 78 	: . x
14056 4000 ~            	ld b,a			;3f7e	47 	G
14057 4000 ~            	ld a,(07818h)		;3f7f	3a 18 78 	: . x
14058 4000 ~            	cp b			;3f82	b8 	.
14059 4000 ~            	jp z,sub_30e8h		;3f83	ca e8 30 	. . 0
14060 4000 ~            	ld (07819h),a		;3f86	32 19 78 	2 . x
14061 4000 ~            	ld hl,07000h		;3f89	21 00 70 	! . p
14062 4000 ~            	ld bc,0200h		;3f8c	01 00 02 	. . .
14063 4000 ~            l3f8fh:
14064 4000 ~            	ld a,(hl)			;3f8f	7e 	~
14065 4000 ~            	or a			;3f90	b7 	.
14066 4000 ~            	jp m,l3f97h		;3f91	fa 97 3f 	. . ?
14067 4000 ~            	xor 040h		;3f94	ee 40 	. @
14068 4000 ~            	ld (hl),a			;3f96	77 	w
14069 4000 ~            l3f97h:
14070 4000 ~            	inc hl			;3f97	23 	#
14071 4000 ~            	dec bc			;3f98	0b 	.
14072 4000 ~            	ld a,b			;3f99	78 	x
14073 4000 ~            	or c			;3f9a	b1 	.
14074 4000 ~            	jr nz,l3f8fh		;3f9b	20 f2 	  .
14075 4000 ~            	jp sub_30e8h		;3f9d	c3 e8 30 	. . 0
14076 4000 ~
14077 4000 ~            sub_3fa0h:
14078 4000 ~            	ld a,(068fdh)		;3fa0	3a fd 68 	: . h
14079 4000 ~            	bit 2,a		;3fa3	cb 57 	. W
14080 4000 ~            	ld a,020h		;3fa5	3e 20 	>
14081 4000 ~            	jr nz,l3fb1h		;3fa7	20 08 	  .
14082 4000 ~            	or 040h		;3fa9	f6 40 	. @
14083 4000 ~            	ld (07818h),a		;3fab	32 18 78 	2 . x
14084 4000 ~            	ld (07819h),a		;3fae	32 19 78 	2 . x
14085 4000 ~            l3fb1h:
14086 4000 ~            	ld (0783ch),a		;3fb1	32 3c 78 	2 < x
14087 4000 ~            	jp CmdCLS		;3fb4	c3 c9 01 	. . .
14088 4000 ~
14089 4000 ~            	defs 57,0			;3fb7	00 	.
14090 4000 ~            	defs 16,$ff			;3ff0	ff 	.
14091 4000               endif
14092 4000              	;DISPLAY $
14093 4000              	ASSERT $ == 0x4000
# file closed: src\vtech12.asm
