

/***********************************************************************************************
 * 
 *  Laser 210/VZ210 ROM 1+2
 *  -----------------------
 *  $0000 - $3fff
 *
 *  Disassembled by z80dasm 1.1.2
 *  Command line: z80dasm.exe --address --labels --source --origin=0x0000 
                              --output=src/vtech12.asm bin/vtech12.org
 *  Verified by compare binary content with output file
 *  generated by SjASMPlus Z80 Cross-Assembler v1.18.3 (https://github.com/z00m128/sjasmplus)
 *
 *  Various Sources
 * ********************************************************************************************/
 ifndef VER_12
	ifndef VER_20
		DEFINE VER_12
	endif
 endif

	;DEFINE VER_20

	DEVICE NOSLOT64K

 ifdef VER_12
    OUTPUT "out/vtech12.rom"
 endif
 ifdef VER_20
    OUTPUT "out/vtech20.rom"
 endif
	
	include "vars.inc"
	
	ORG	$0000

; **********************************************************************************************
; ****************************************************************************
; ****************************************************************************






; ****************************************************************************
; PowerOn Reset
SysReset
	di						; Disable interrupts for initialisation phase						;0000	f3 	. 
; -- Clear state of Gfx Mode, Speaker and Cassette Out
	xor a					; GfxMode=0, Color=0, SpeakerOut={0,0}, CassetteOut={0,0}  			;0001	af 	. 
	ld (IO_LATCH),a		    ; set initial values 												;0002	32 00 68 	2 . h 
	jp SysInit				; continue System Initialization									;0005	c3 74 06 	. t . 
	// ------------------------------------------------------------------------



; ****************************************************************************
; COMPARE SYMBOL ROUTINE – “SYNTAX” or “RST08”
; ****************************************************************************
; Hardware Jump via Z80 instruction RST $08
; Jump to AssertToken [$1c96] via Jump Table
; This routine is used for scanning strings. It compares the character pointed to 
; by the HL register pair with the character pointed to by the return address 
; on the top of the stack (Note that a RST instruction is in effect a CALL and places 
; a return address on the stack) formula: (HL)=((SP))? 
; If they are not equal an SYNTAX ERROR will result; if they are equal then 
; the return address on the stack will be incremented to bypass the test character 
; and control will be passed to RST 10H logic. 
; RST 08H is used to look for expected characters in a string and then return with (HL) 
; pointing to the next non-blank character. (see RST l0H) (BC and DE registers unaffected.). 
; This routine can be used by CALLing 1C96H or RST 08H.
CpuRST08					ASSERT($==$0008)
	jp AssertTokenVect	    ; jump to AssertToken via RST Jump Table [$7800 -> $1c96]	    	;0008	c3 00 78 	. . x 
	

; ****************************************************************************
; DISK ROUTINE – “WHERE”
; ****************************************************************************
; POP HL followed by JP (EL) . Same as RET instruction except leaves
; return address in HL. Thus, a relocatable program car. CALL OO0BH, and
; upon return, the HL register pair will contain the current address of
; the Program Counter. In this way, a program can "find" itself in memory. 
ResolveRelocAddr:
	pop hl					; Get return address from CPU Stack									;000b	e1 	. 
	jp (hl)					; jump to that address - return to calling code						;000c	e9 	. 


 ifdef TRS
; ****************************************************************************
; [TRS Only] 000DH – DISK ROUTINE – “DBOOT” 
; ****************************************************************************
	jp $069F				; Jump to disk load and run sector routine at 069FH.

 else ; VER_12 or VER_20
; ****************************************************************************
;  --- deleted code ---
; ****************************************************************************
	nop : nop : nop			; deleted code
; ****************************************************************************

 endif



; ****************************************************************************
; NEXT TOKEN ROUTINE – “NEXTTOKEN” or “RST10”
; ****************************************************************************
; Hardware Jump via Z80 instruction RST $10
; This routine INCrements HL and tests the characters pointed to by the HL. 
; It will bypass any spaces and CHAR’S 9 and 10 (TAB and CR). 
; IN:  hl - pointer to last parsed token 
; OUT: hl - pointer to next non-blank character
;      a  - next non-blank character or 0 or ':'
;      Z=1 - found 0 (end of BASIC Line) or ':' (End of BASIC statement)
;      CY=1 - found numeric ASCII char ('0'..'9')
; BC and DE registers are unaffected.
CpuRST10:					ASSERT($==$0010)
	jp NextTokenVect			; go to $1d78 via RST Jump Table [$7803]						;0010	c3 03 78 	. . x 




; ****************************************************************************
; DCS INPUT ENTRY – “INBYTE”
; ****************************************************************************
; Read Byte from Device via Device Control Subsystem
; IN:  de - address of DCB of device to read from
; OUT: a - byte received from device
;      Z - flag set if device ready
DevSysReadByte:
	push bc					; save BC register													;0013	c5 	. 
	ld b,%0001				; Device/Operation Type Code (Read)									;0014	06 01 	. . 
	jr DevSysExecute		; execute DCS operation 						                	;0016	18 2e 	. . 
	



; ****************************************************************************
; COMPARE DE HL ROUTINE – “CMPDEHL” or “RST18"
; ****************************************************************************
; Hardware Jump via Z80 instruction RST $18
; This routine can be called by using RST 18H or CALL lC90H. 
; It compares two 16 bit unsigned values in HL and DE and sets the S and Z flags accordingly.
; All registers are unchanged except for A.
; IN: de - 16 bit unsigned value (0..65635)
;     hl - 16 bit unsigned value (0..65635)
; OUT: CY=1 - when hl < de
;      CY=0 - when hl >= de
;	   Z=1  - when hl == de
;      Z=0  - when hl != de
CpuRST18					ASSERT($==$0018)
	jp CmpHLDEVect			; go to $1c90 via RST Jump Table [$7806]							;0018	c3 06 78 	. . x 




; ****************************************************************************
; DCS OUTPUT ENTRY – “OUTBYTE”
; ****************************************************************************
; Write Byte to Device via Device Control Subsystem
; Outputs a byte to a device. When calling, A = output byte, DE
; IN:  de - address of DCB of device to write to
; 	   a - byte to send 
; OUT: Z - flag set if device ready
DevSysWriteByte:
	push bc					; save bc															;001b	c5 	. 
	ld b,%0010				; Device/Operation Type Code (Write)								;001c	06 02 	. . 
	jr DevSysExecute		; execute DCS operation		                						;001e	18 26 	. & 




; ****************************************************************************
; TEST NUMBER TYPE FLAG – “TESTNTF” or “RST20”
; ****************************************************************************
; Hardware Jump via Z80 instruction RST $20
; This CALL is used to determine the Type of the current value in ACC/REG1. 
; NTF (Number Type Flag) stores following values for variable types:
;   8 - Double Precision Number
;   4 - Single Precision Number
;   3 - String
;   2 - Integer (16bit) Number
; OUT: a - (NTF-3) -> -1(Integer), 0(String), 1(Single), 5(Double)
;      Z=1 - variable is String
;      CY=0 - variable is Double
;      PO=1 - variable is Single
;      M=1  - variable is Integer
CpuRST20					ASSERT($==$0020)
	jp TestNTFVect			; go to $25d9 via RST Jump Table [$7809]							;0020	c3 09 78 	. . x 




; ****************************************************************************
; DCS STATUS ROUTINE – “CTLBYTE”
; ****************************************************************************
; Read Status from Device via Device Control Subsystem

DevSysGetStatus:
	push bc					; save bc															;0023	c5 	. 
	ld b,%0100		        ; Device/Operation Type Code (Status ??)             				;0024	06 04 	. . 
	jr DevSysExecute		; execute DCS operation				               					;0026	18 1e 	. . 




; ****************************************************************************
; DOS BREAK ROUTINE – “DBREAK” or “RST28”
; ****************************************************************************
; Hardware Jump via Z80 instruction RST $28
; This vector is only used by Disk BASIC. It is called by the BREAK key routine, 
; and can be used to intercept the BREAK key logic
; In non-disk systems 780CH contains a RET instruction. 
; In a disk system this is the DOS FUNCTION CALL routine (which passes request code 
; in A-register to DOS for processing. The A register must contain a legitimate DOS
; function code. If the code is positive, the CALL is ignored and control returns 
; to the caller.
CpuRST28					ASSERT($==$0028)
	jp TestBreakKeyVect		; Not used by System - RET via RST Jump Table [$780C]				;0028	c3 0c 78 	. . x 




; ****************************************************************************
; KEYBOARD READ ROUTINE – “KBDSCN” or “$KBCHAR”
; ****************************************************************************
; Loads DE with address of keyboard DCB and scans keyboard. 
; OUT: a - ASCII character read from keyboard (0 if no key is pressed)
;      Z=1 - no key is pressed
KeysReadKey:
	ld de,KEYBOARD_DCB	    ; address of Keyboard Device Control Block							;002b	11 15 78 	. . x 
	jr DevSysReadByte		; Read ASCII char from Keboard via DCB								;002e	18 e3 	. . 
	



; ****************************************************************************
; DEBUG TRAP ROUTINE – “DEBUG” or “RST30”
; ****************************************************************************
; Hardware Jump via Z80 instruction RST $30
; This vector is only used by Disk BASIC.
; This is the LOAD DEBUG routine, and loads the DEBUG program and transfers control 
; to it. When DEBUG processing is complete, control is returned to the original caller. 
; For non-disk systems control is returned immediately (780FH contains a RET instruction). 
CpuRST30					ASSERT($==$0030)
	jp OnDebug				; Not used by System - RET via RST Jump Table [$780F]				;0030	c3 0f 78 	. . x 




; ****************************************************************************
; VIDEO ROUTINE – “VDCHAR”
; ****************************************************************************
; Loads DE with address of video DCB, and displays character stored in A 
; at current Cursor Position (stored at 7820-7821). 
; This routine also performs control functions (like Cursor Home, Cls, etc). 
; To save DE use routine at 033AH.
; IN: a - ASCII char to print on Screen or ASCII Control Char
ScrSendByte:
	ld de,SCREEN_DCB		; select Screen Device Control Block								;0033	11 1d 78 	. . x 
	jr DevSysWriteByte		; send Char to Screen via DCB			    						;0036	18 e3 	. . 
	
	



; ****************************************************************************
; INTERRUPT MAIN ENTRY – “INTMAIN” or “RST38”
; ****************************************************************************
; This is the INTERRUPT MAIN ENTRY POINT routine at RST 38H which is the system 
; entry point for all maskable interrupts. Interrupt is generated 60 (NTSC)
; or 50 (PAL) times per second by Video Display Generator (VDG) MC 6847.
; Cpu jumps here if INT signal is detected and CPU is in Interrupt Mode 1
; and Interrupts are Enabled (EI).
CpuRST38					ASSERT($==$0038)
	jp CpuINTHandler		; jump to Main Interrupt Handler routine							;0038	c3 b8 2e 	. . . 




; ****************************************************************************
; PRINTER ROUTINE – “PRCHAR” or LPTBYTE”
; ****************************************************************************
; Loads DE with address of Printer DCB, and print character in A 
; at current printer caret position. 
; This routine also performs control functions.
; IN: a - char to send to Printer
PRN_SendChar:
	ld de,PRINTER_DCB		; select PRINTER Device Control Block								;003b	11 25 78 	. % x 
	jr DevSysWriteByte		; send Char to Printer	via DCB										;003e	18 db 	. . 




; ****************************************************************************
; [TRS] INPUT ROUTINE – “KBLINE” (not used)
; ****************************************************************************
; TRS Line input routine - in this ROM this is Keyborard Scan routine. 
; Jump to 2EFDH - DCS Keyboard Driver routine
l0040h:
	jp l2efdh				; go directly to DCS Keyboard Driver routine						;0040	c3 fd 2e 	. . . 




; ****************************************************************************
; --- deleted code --- (probably jump)
; ****************************************************************************
l0043h:
	ret	: nop : nop			; deleted code														;0043	c9 00 00 	. 



; ****************************************************************************
; DCS ENTRY ROUTINE – DCSEXEC
; ****************************************************************************
; Jump to Device Control Subsystem execute entry 
; This routine executes I/O command via Device Control System. 
; This include Input a byte from device, send a byte to device or get device status. 
; DSC Execute routine assumes that BC register was saved on stack.
; IN: de - starting address of Device Control Block of device
;	  b - Device/Operation entry code (1-Read, 2-Write, 4-Status??)
;     a - byte to send to device if Write operation
; OUT: a - data byte received from device if Read operation or status code
;     Z=1 - when device is Ready
DevSysExecute:
	jp ExecuteDCBOperation	; Go Execute operation via Device Control Subsystem					;0046	c3 c2 03 	. . . 




; ****************************************************************************
; KEYBOARD ROUTINE – “$KBWAIT”
; ****************************************************************************
; Scan keyboard until key pressed (continuous calls to O02Bh).
; OUT: a - character read from keyboard
KeysWaitKey:
	call KeysReadKey	; read Key Pressed or none												;0049	cd 2b 00 	. + . 
	or a				; if any key is pressed?												;004c	b7 	. 
	ret nz				; yes ------------ End of Proc ---------------------------- 			;004d	c0 	. 
	jr KeysWaitKey		; read key until any is pressed 										;004e	18 f9 	. . 


    

; ****************************************************************************
; UPDATE CURSOR CHAR
; ****************************************************************************
; Update Cursor Char variable from current Cursor Position
UpdateCursorChar:
	ld hl,(CURSORADDR)		; hl - address of VRAM where is Cursor								;0050	2a 20 78 	*   x 




; ****************************************************************************
; SET CURSOR CHAR FROM (HL)
; ****************************************************************************
; Update Cursor Char variable from VRAM location pointed by HL
; IN: hl - VRAM address with char to set as Cursor
SetCursorFromHL:
	ld a,(hl)				; get char from VRAM memory pointed by hl register					;0053	7e 	~ 
	ld (CURSORCHAR),a	    ; store as current Cursor Char										;0054	32 3c 78 	2 < x 
	ret						; ------------ End of Proc ----------------------------				;0057	c9 	. 




; ****************************************************************************
; --- unused data ----
; ****************************************************************************
; Probably garbage data left from previous versions of ROM
	db $4c,$fe,$54,$20,$d6,$fd,$21,$f1															;0058	4c fe 54 20 d6 fd 21 f1 	. ! . . 




; **********************************************************************************
; DELAY ROUTINE – “$DELAY”
; **********************************************************************************
; This is a delay loop. The BC register pair is used as the loop counter. 
; The duration of the delay, in microseconds, is the value of BC times 5,86us plus 4,73us
; IN: bc - delay countdown value
SysDelayBC
	dec bc					; decrement delay counter											;0060	0b 	. ! . . 
	ld a,b					; Load A with the counter’s MSB in register B						;0061	78 	x 
	or c					; Combine with the LSB in register C. Test if BC==0					;0062	b1 	. 
	jr nz,SysDelayBC		; no - continue until bc == 0										;0063	20 fb 	  . 
	ret						; ---------------- End of Proc ----------------------------			;0065	c9 	. 



; **********************************************************************************
; NMI INTERRUPT ROUTINE	(not used)
; **********************************************************************************
; NMI Interrupt is NOT USED nor generated inside VZ/Laser machine.
; Below code is description is provided as described for TRS Level II BASIC
; [TRS] Determine if a disk controller is present, and if so a jump is taken to power-up (0000).
; [TRS] Otherwise the routine jumps to the BASIC re-entry point at 06CC
CpuNMI:						ASSERT($==$0066)
	ld sp,$0600				; [TRS] Set the stack pointer to 0600H								;0066	31 00 06 	1 . . 
	ld a,(KEYS_ROWS_NMI)	; [TRS] Load register A with the disk controller status 			;0069	3a ec 68 	: . h 
	inc a					; [TRS] Increment the disk controller status in register A.			;006c	3c 	< 
	cp 2					; [TRS] Check the value in register A to see if a disk is present. 
							; It is usually FFH if there is no expansion interface 				;006d	fe 02 	. . 
; -- jump to Reset Basic when value >= 2 
	jp nc,SysReset			; [TRS] If a disk is present go to Full Reset 						;006f	d2 00 00 	. . . 
	jp BAS_ReEntry			; [TRS] No disk present so Restart BASIC 							;0072	c3 cc 06 	. . . 




; ********************************************************************************************
; BASIC INITIALIZATION ROUTINE
; ********************************************************************************************
; Initialize RCA BASIC values and Self Modified Code (SMC) routines.
; This is part of the BASIC Initialization procedure. It moves a block of memory 
; from 18F7H to l9lEH up to 7880H to 78A7H. (reserved RAM area)
; Note:
;	7880H-788DH is a division support routine.
; 	788EH-788FH is the BASIC USR execute address
; 	7890H-7892H is a Random Seed Value (24bit)
; 	7893H-7895H is IO Read SMC routine
; 	7896H-7898H is IO Write SMC routine
BasicInit:
	ld de,BASIC_VARS_AREA	; destination - RAM address of RCA Basic values Block				;0075	11 80 78 	. . x 
	ld hl,BAS_RCAInitData	; source - ROM address of initial values/code to copy				;0078	21 f7 18 	! . . 
	ld bc,39				; size of block to copy (39 bytes)									;007b	01 27 00 	. ' . 
	ldir					; bulk copy 														;007e	ed b0 	. . 

; --- init BASIC separators
	ld hl,BAS_SEPARATORS	; hl - BASIC Separators address										;0080	21 e5 79 	! . y 
	ld (hl),':'				; store ':' - BASIC Statement separator								;0083	36 3a 	6 : 
	inc hl					; address 79E6H														;0085	23 	# 
	ld (hl),b				; store 0 - BASIC Line Terminator									;0086	70 	p 
	inc hl					; address 79E7H														;0087	23 	# 
	ld (hl),','				; store ',' - BASIC Parameter Separator								;0088	36 2c 	6 , 

; --- set default BASIC Line Buffer address 79E8H
	inc hl					; BASIC Line Buffer address											;008a	23 	# 
	ld (LINEBUFPTR),hl	    ; store 79E8H as address of BASIC Line Buffer 						;008b	22 a7 78 	" . x 

; Initialize DOS Vectors (7952-79A5) to raise DISK COMMAND ERROR 
	ld de,ErrRaiseDiskCmd	; adres of routine raising 'DISK COMMAND' Error						;008e	11 2d 01 	. - . 
	ld b,28					; 28 entries to fill with "jp ErrRaiseDiskCmd"						;0091	06 1c 	. . 
	ld hl,SysDosVectors		; address of DOS Vectors Table in RAM								;0093	21 52 79 	! R y 
.loop:
	ld (hl),$c3				; store JP opcode byte												;0096	36 c3 	6 . 
	inc hl					; inc destination address											;0098	23 	# 
	ld (hl),e				; store LSB of ErrRaiseDiskCmd routine address						;0099	73 	s 
	inc hl					; inc destination address											;009a	23 	# 
	ld (hl),d				; store MSB of ErrRaiseDiskCmd routine address						;009b	72 	r 
	inc hl					; inc destination address - next entry								;009c	23 	# 
	djnz .loop				; repeat for 28 jump vectors										;009d	10 f7 	. . 

; Initialize Extension Vectors (79A6-79E4) to RET
	ld b,21					; 21 entries to fill with RET opcode								;009f	06 15 	. . 
.loop1:
	ld (hl),$c9				; store RET opcode byte												;00a1	36 c9 	6 . 
	inc hl					; point to LSB byte (reserved when entry has JP XXXX)				;00a3	23 	# 
	inc hl					; point to MSB byte (reserved when entry has JP XXXX)				;00a4	23 	# 
	inc hl					; point to next Extension Vector Entry								;00a5	23 	# 
	djnz .loop1				; repeat for 21 Extension Vectors 									;00a6	10 f9 	. . 

; -- initialize BASIC Program start
	ld hl,BAS_PrgMemory-1	; address of byte just before BASIC Progrem Memory					;00a8	21 e8 7a 	! . z 
	ld (hl),b				; this byte must be 0												;00ab	70 	p 

; -- set CPU stack pointer temporarily in area where is BASIC Line Buffer - we dont know memory size yet
	ld sp,EditLineBuf+$10	; set CPU Stack in Line Buffer 										;00ac	31 f8 79 	1 . y 

; -- reset BASIC  (Stack, For loops, clear Variables)
	call ResetBasicStack	; reset Basic Stack and String Variables							;00af	cd 8f 1b 	. . . 
	call CmdCLS				; call Clear Screen routine											;00b2	cd c9 01 	. . . 


; ********************************************************************************************
; --- deleted code ---
; ********************************************************************************************
; This code in TRS machine was used to ask user for MEMORY SIZE? by displaying message 
; and input size typed by user.
l00b5h:
	nop : nop : nop			; deleted code														;00b5	00 00 00 	. 
	nop : nop : nop			; deleted code														;00b8	00 00 00 	. 
	nop	: nop : nop			; deleted code														;00bb	00 00 00 	. 


; ********************************************************************************************
; (cont.) BASIC INITIALIZATION ROUTINE
; ********************************************************************************************
	jr TestMemory			; Go to Memory Test routine (skip deprecated code)					;00be	18 04 	. . 
	


; ********************************************************************************************
; --- TRS deprecated code ---
; ********************************************************************************************
; This code in TRS machine was used to ask user for MEMORY SIZE? by displaying message 
; and input size typed by user.
	rst $10					; [TRS] hl - next valid BASIC program char							;00c0	d7 	. 
	or a					; [TRS] Test if entered text (Memory Size) is not empty				;00c1	b7 	. 
	jr nz,l00d6h			; TRS] Jump if user entered requested Memory Size					;00c2	20 12 	  . 
; -- [TRS] if entered text was empty program falls thru to determine size of Installed Memory




; ********************************************************************************************
; TEST MEMORY SIZE – “MEMSIZE”
; ********************************************************************************************
; Determine size of installed RAM by Write and Verify Memory locations starting at 7B4D
; and continuing upward until Verify fails means the end of memory (or a bad memory location) 
; is found. After that it jumps to rest of BASIC initialization process. 
TestMemory:
	ld hl,SysMinMemory	; hl - starting address of memory to test 		 						;00c4	21 4c 7b 	! L { 
.loop:
	inc hl				; next address to test													;00c7	23 	# 
	ld a,h				; check if hl is equal to 0												;00c8	7c 	| 
	or l				; .. is this end of memory (address wrapped)?							;00c9	b5 	. 
	jr z,l00e7h			; yes - end of memory test - we have full RAM (up to FFFFH)				;00ca	28 1b 	( . 
	ld a,(hl)			; read byte from memory													;00cc	7e 	~ 
	ld b,a				; save byte to restore it latter										;00cd	47 	G 
	cpl					; inverse bits of byte													;00ce	2f 	/ 
	ld (hl),a			; store inverted byte as test value										;00cf	77 	w 
	cp (hl)				; test if write was successful											;00d0	be 	. 
	ld (hl),b			; restore old value at this location									;00d1	70 	p 
	jr z,.loop			; continue if success													;00d2	28 f3 	( . 
	jr l00e7h			; fail - end of memory test - we have RAM up to HL-1					;00d4	18 11 	. . 




; ********************************************************************************************
; --- TRS deprecated code ---
; ********************************************************************************************
; This code in TRS machine was used to ask user for MEMORY SIZE? by displaying message 
; and input size typed by user.
l00d6h:
; -- hl containst text entered by User to answer MEMORY SIZE? prompt 
	call TextToInt		; [TRS] convert text pointed by hl to integer value (de = value)		;00d6	cd 5a 1e 	. Z . 
	or a				; [TRS] test conversion status - is it 0 (OK)?							;00d9	b7 	. 
	jp nz,ErrRaiseSyntax; [TRS] if non zero - Raise 'SYNTAX ERROR'								;00da	c2 97 19 	. . . 
	ex de,hl			; [TRS] Put Memory Size ito hl 											;00dd	eb 	. 
	dec hl				; [TRS] hl - last usable Memory address									;00de	2b 	+ 
	ld a,$8f			; [TRS] a - test value to verify RAM at this address					;00df	3e 8f 	> . 
	ld b,(hl)			; [TRS] save current byte from tested Memory location					;00e1	46 	F 
	ld (hl),a			; [TRS] write test byte to RAM											;00e2	77 	w 
	cp (hl)				; [TRS] Check to see if value was stored successfully					;00e3	be 	. 
	ld (hl),b			; [TRS] Restore the old memory content back.							;00e4	70 	p 
	jr nz,l00b5h		; [TRS] write failed - ask MEMORY SIZE again by jumping to 00B5H		;00e5	20 ce 	  . 




; ********************************************************************************************
; MEMORY SETUP – “MEMSETUP”
; ********************************************************************************************
; After Memory Test register hl contains top RAM address + 1 (one above last good RAM location) 
; IN: HL - memory address of 1st bad memory cell (fail) or 0000 (pass) 
l00e7h:
	dec hl					; address of last verified memory location							;00e7	2b 	+ 
sub_00e8h:
	ld de,MEMORY_MIN		; minimum address required by BASIC to operate						;00e8	11 14 7c 	. . | 
	rst $18					; compare if detected memory is above minimum						;00eb	df 	. 
	jp c,ErrRaiseOutOfMem	; no - raise 'OUT OF MEMORY' error 									;00ec	da 7a 19 	. z . 

; -- reserve top 50 bytes for BASIC String Area/Space
	ld de,-50				; need to reserve 50 bytes for BASIC String Area/Space				;00ef	11 ce ff 	. . . 
	ld (MEMORY_TOP),hl		; store Top of Memory available for Basic							;00f2	22 b1 78 	" . x 
	add hl,de				; substract 50 bytes for BASIC String Area/Space					;00f5	19 	. 
; -- start of BASIC String Area/Space is also Top of Stack Pointer
	ld (STACKTOPPTR),hl		; store address as CPU Stack Pointer for BASIC						;00f6	22 a0 78 	" . x 
	call DeleteAllBasic		; delete Basic Program, Variables, Pointers and Flags				;00f9	cd 4d 1b 	. M . 


; ----------------- ROM 1.2 only --------------------------------------------------------------
 ifdef VER_12
; -- display welcome message
	ld hl,TXT_VIDEOTECHBASIC; address of "VIDEO TECHNOLOGY BASIC V1.2" text						;00fc	21 0f 01 	! . . 
	call PrintBasicStr		; print text on Screen	pointed by hl								;00ff	cd a7 28 	. . ( 
	call sub_3484h			; Initialize IO Devices (Screen Cursor, Sound, Cassette, etc).		;0102	cd 84 34 	. . 4 

; ----------------- ROM 2.0 only --------------------------------------------------------------
 else 
 	call sub_3484h			; Initialize IO Devices (Screen Cursor, Sound, Cassette, etc).		;00fc	cd 84 34 	. . 4 
	ld hl,TXT_VIDEOTECHBASIC; address of "VIDEO TECHNOLOGY BASIC V2.0" text						;00ff	21 0f 01 	! . . 
	call PrintBasicStr		; print text on Screen	pointed by hl								;0102	cd a7 28 	. . ( 
 endif
; ----------------- common code --------------------------------------------------------------




; ********************************************************************************************
; CARTRIDGE TEST AND SETUP – “CARTSETUP”
; ********************************************************************************************
; At this point Basic Version is on Screen and Machine is ready to start.
; Following code will determine if any Cartridge/Extension is connected (i.e. Floppy with DOS)
; and give control to plugged in Cardridge or back system ROM.
	im 1					; set CPU Interrupt Mode 1 											;0105	ed 56 	. V 
	jp SysCartTest			; test if any Cartridge is connected and Init/Start	it				;0107	c3 8e 06 	. . . 


; ********************************************************************************************
; --- unused data ----
; ********************************************************************************************
; Probably garbage data or code left from previous versions of ROM

	db $00,$7e,$23,$fe,$0d				; unused data											;010a	00 7e 23 fe 0d 	. . 


; ********************************************************************************************
; BACIC VERSION MESSAGE DATA – “VTBASICMSG”
; ********************************************************************************************
TXT_VIDEOTECHBASIC:
	db "VIDEO TECHNOLOGY",$0d																	;010f	56 49 44 45 4f 20 54 45 43 48 4e 4f 4c 4f 47 59 0d 	. 

; ----------------- ROM 1.2 only --------------------------------------------------------------
 ifdef VER_12
	db "BASIC V1.2",$0d,$0d,0																	;0120	42 41 53 49 43 20 56 31 2e 32 0d 0d 00 	. 

; ----------------- ROM 2.0 only --------------------------------------------------------------
 else ; VER_20
 	db "BASIC V2.0",$0d,$0d,0																	;0120	42 41 53 49 43 20 56 32 2e 30 0d 0d 00 	. 
 endif

; ----------------- common code ---------------------------------------------------------------




; ********************************************************************************************
; DISK COMMAND ERROR ROUTINE
; ********************************************************************************************
; Sets Error Code to 2CH (DISK COMMAND) and jump to common routine to rise BASIC Error
ErrRaiseDiskCmd:
	ld e,#2c				; e - Error Code 2CH - DISK COMMAND									;012d	1e 2c 	. , 
	jp ErrRaiseError		; Raise 'DISK COMMAND' Error 										;012f	c3 a2 19 	. . . 



; ********************************************************************************************
; BASIC “POINT” COMMAND ENTRY POINT
; ********************************************************************************************
; Test pixel at provided Coordinates and returns it's Color
; IN: hl - current executed command parser pointer
;     a - program token
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
l0132h:
	rst $10					; Call NEXT SYMBOL routine at RST 10H								;0132	d7 	. 
	xor a					; Set A register to 0 – flag meaning the POINT command				;0133	af 	. 
	db $01 					; Z80 Trick to skip code											;0134	01 3e 80 	. > . 
; -- The byte at this memory location, 01H, create harmless 3 byte instruction LD BC,803EH.
; -- As an effect CPU skips 2 next bytes which sets flag to 80H – meaning the SET command. 
; -- This way, they didn’t have to jump over SET or RESET to get to the common graphics code.



; ********************************************************************************************
; BASIC "SET" COMMAND ENTRY POINT
; ********************************************************************************************
; Set pixel with current selected Color at provided Coordinates
; IN: hl - current executed command parser pointer
;     a - program token
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdSET
	ld a,$80				; a - flag meaning the SET command 									;0135	3e 80 	. > .
	db $01					;  Z80 Trick to skip code											;0137	01 3e 01 	. > . 
; -- The byte at this memory location, 01H, create harmless 3 byte instruction LD BC,013EH.
; -- As an effect CPU skips 2 next bytes which sets flag to 01H – meaning the RESET command. 
; -- This way, they didn’t have to jump over RESET to get to the common graphics code.



; ********************************************************************************************
; BASIC "RESET" COMMAND ENTRY POINT
; ********************************************************************************************
; Clear pixel at provided Coordinates
; IN: hl - current executed command parser pointer
;     a - program token
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdRESET
	ld a,$01				; a - flag meaning the RESET command								;0138	3e 01 	. > . 

; -- common code for POINT, SET and RESET command
; -- IN: a - BASIC command Flag:
;            0 - POINT
;            $80 - SET
;            1 - RESET
	push af					; Save the Command flag in register A on the stack					;013a	f5 	. 

; -- all SET/RESET/POINT commands need a “(” char to start with
	rst $08					; Verify Next Token is '('											;013b	cf 	. 
	defb '('				; Basic '(' token 													;013c	28

	call EvalByteExpr		; convert text parameter (X coordinate) to 8bit value				;013d	cd 	. 1c 2b 	+ 
	cp 128					; is X >= 128? (X must be in range 0..127) 							;0140	fe 80 	. . 
	jp nc,ErrRaiseFuncCode	; yes - raise FUNCTION CODE Error									;0142	d2 4a 1e 	. J . 
; -- A register = X pixel coordinate
	push af					; save X coordinate on Stack for future use							;0145	f5 	. 

; -- all SET/RESET/POINT commands must have X and Y parameter so ',' is expected
	rst $08					; Verify Next Token is ','											;0146	cf 	. 
	defb ','				; Basic ',' token 													;0147	2c 	, 
	call EvalByteExpr		; convert text parameter (Y coordinate) to 8bit value				;0148	cd 1c 2b 	. . + 
	cp 64					; is Y >= 64? (Y must be in range 0..63) 							;014b	fe 40 	. @ 
	jp nc,ErrRaiseFuncCode	; yes - raise FUNCTION CODE Error									;014d	d2 4a 1e 	. J . 

; -- calculate Video RAM address of byte defining pixel at X,Y coordinates
	ld e,a					; e - given Y coordinate (screen line number)						;0150	5f 	_ 
	xor a					; zero value for MSB 												;0151	af 	. 
	ld d,a					; de - given Y coordinate (screen line number)						;0152	57 	W 
; -- 32 bytes make one line on screen - multiply Y by 32
	ex de,hl				; hl - given Y coordinate (screen line number)						;0153	eb 	. 
	add hl,hl				; hl = Y * 2														;0154	29 	) 
	add hl,hl				; hl = Y * 4														;0155	29 	) 
	add hl,hl				; hl = Y * 8														;0156	29 	) 
	add hl,hl				; hl = Y * 16														;0157	29 	) 
	add hl,hl				; hl = Y * 32														;0158	29 	) 
	ex de,hl				; de - byte offset in bytes of line to work with					;0159	eb 	. 
; -- every byte makes 4 pixels on screen - divide X by 4
	pop af					; a - restore saved X coordinate from Stack							;015a	f1 	. 
	push af					; save X coordinate on Stack (we will need "fine" offset later)		;015b	f5 	. 
	srl a					; a = X/2															;015c	cb 3f 	. ? 
	srl a					; a = X/4															;015e	cb 3f 	. ? 
; -- calculate total VRAM byte offset
	add a,e					; add byte-in-line offset (X/4) to LSB of line offset (Y*32)		;0160	83 	. 
	ld e,a					; de - total offset of VRAM byte with pixel							;0161	5f 	_ 
; -- calculate absolute VRAM address
	ld a,d					; a - MSB of offset													;0162	7a 	z 
	or $70					; add $70 to MSB of offset (VRAM starts at 7000H)					;0163	f6 70 	. p 
	ld d,a					; de - absolute VRAM address for byte with our pixel				;0165	57 	W 
; -- prepeare mask and determine number of byte shifts to mask this pixel
	pop af					; a - restore saved X coordinate from Stack							;0166	f1 	. 
	and %00000011			; extract from X pixel-in-byte index (0..3)							;0167	e6 03 	. . 
	add a,a					; a - bit number (counted from left to right!) (0,2,4,6)			;0169	87 	. 
	ld b,a					; save in b as counter of shifts to do								;016a	47 	G 
; -- split code if we process POINT command
	pop af					; a - BASIC Command Flag 											;016b	f1 	. 
	or a					; is it 0 (POINT COmmand)?											;016c	b7 	. 
	jp z,l38e7h				; yes - jump to 38E7 routine 										;016d	ca e7 38 	. . 8 

; -- code for SET or RESET Command
	push af					; save on Stack BASIC Command Flag									;0170	f5 	. 
	ld c,%00111111			; c - pixel bitmask (set for pixel-in-byte index = 0)				;0171	0e 3f 	. ? 
	ld a,(FCOLOR)			; a - current selected Color (stored in high nibble)				;0173	3a 46 78 	: F x 
; -- convert Colot to 2bit value stored in bit 7 and bit 6 (4 colors allowed)
	sla a					; shift left Color value by 1 bit									;0176	cb 27 	. ' 
	sla a					; shift left Color value by 1 bit									;0178	cb 27 	. ' 
.loop:
	rrc a					; rotate right Color bits 											;017a	cb 0f 	. . 
	rrc c					; rotate right Mask bits											;017c	cb 09 	. . 
	djnz .loop				; repeat rotate as many bits as computes in b						;017e	10 fa 	. . 
; -- NOTE --
; Above code is bad in terms of performance. 
; When we address specific pixels like 0,4,8,12,… register B will contain 0 and Color (a)
; and Mask (c) already have required value. There is no need for rotating at all.
; But having 0 in register b, first djnz will make b equals 255 and in turn Color 
; and Mask will be rotated 256 times instead of none at all. 
	jp l3903h				; jump to execute SET or RESET Command								;0180	c3 03 39 	. . 9 




; ********************************************************************************************
; TAPE VERIFY EXIT WITH ERROR ROUTINE
; ********************************************************************************************
; Clears VERIFY Command Flag, displays 'ERROR' text and jumps back to finalize
; Tape Read  routine.
l0183h:
; -- clear flag meaning VERIFY in progress
	ld hl,SYSFLAGS			; hl - address of System Flags variable								;0183	21 39 78 	! 9 x 
	res 3,(hl)				; clear BASIC VERIFY Command Flag 									;0186	cb 9e 	. . 
; -- display ERROR text
	ld hl,TXT_ERROR			; hl - address of 'ERROR' text										;0188	21 84 03 	! . . 
	call PrintBasicStr		; print 'ERROR' text on Screen										;018b	cd a7 28 	. . ( 
	jp TapeReadExit			; Go finalize Read/Verify Tape routine and go back to BASIC 		;018e	c3 cf 36 	. . 6 
	


; ********************************************************************************************
; --- unknown deprecated data or code – not used ----
; ********************************************************************************************
; Probably garbage data or code left from previous versions of ROM
	db $f1,$fe,$20,$20,$14,$1a,$13,$fe				; unused data								;0191	f1 fe 20 20 14 1a 13 fe	. 
	db $20,$28,$fa,$fe								; unused data								;0199	20 28 fa fe 	( . 



; ********************************************************************************************
; BASIC "INKEY$" COMMAND ENTRY POINT
; ********************************************************************************************
; Create one-character string from keyboard input.
; Routine will create a one-character string using the contents of Last Key Pressed at 7899H. 
; However, if 7899H contains zero, the keyboard will be scanned and if a key is depressed,
; a string will be created using the character input from the keyboard. 
; If no key is depressed,, a null string (a string zero bytes in length) will be created.
; On exit, the VARPTRR to the string created by this routine will be found in the ACC,
; with the NTF set to 3.
; Also, note that the keyboard is normally scanned during BASIC program execution 
; for the presence of the BREAK keys. If a character other than that is pressed, 
; the character thus entered is stored in Last Key Pressed variable at 7899H. 
; Thus, a keystroke received between successive INKEY$ calls is held "in the buffer" 
; to be used at the next execution of INKEY$
; IN: hl - current executed command parser pointer
;     a - program token
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
l019dh:
	rst $10					; Call NEXT SYMBOL routine at RST 10H								;019d	d7 	. . 



; ********************************************************************************************
; BASIC "INKEY$" COMMAND SECOND ENTRY POINT
; ********************************************************************************************
; Create one-character string from keyboard input (see above description).
BAS_InkeySToACC:
	push hl					; save hl - interpreter current pointer								;019e	e5 	. 
; -- check if we already have key pressed in Last Key Pressed variable
	ld a,(KEYS_LASTKEY)		; a - Last Key Pressed												;019f	3a 99 78 	: . x 
	or a					; was key presset before?											;01a2	b7 	. 
	jr nz,.keypressed		; yes - consume this key and create one character String 			;01a3	20 06 	  . 
; -- no key in buffer - read key from user
	call KeysReadKeySaveDE	; scan keyboard to test if now key is pressed 						;01a5	cd 58 03 	. X . 
	or a					; was key pressed now?												;01a8	b7 	. 
	jr z,.setempty			; no - create Empty String											;01a9	28 11 	( . 
.keypressed:
; -- A contains Key Pressed 
	push af					; save key pressed on Stack											;01ab	f5 	. 
; -- consume key - clear Last Key variable 
	xor a					; a =0 - no key pressed												;01ac	af 	. 
	ld (KEYS_LASTKEY),a		; store 0 to clear Last Key Pressed variable						;01ad	32 99 78 	2 . x 
; -- allocate 1-char String
	inc a					; a = 1 - string length in bytes 									;01b0	3c 	< 
	call StrNew				; Allocate 1 char string and Create String Vector (VARPTR)			;01b1	cd 57 28 	. W ( 
; -- store char into allocated memory
	pop af					; restore af - key pressed (converted to char)						;01b4	f1 	. 
	ld hl,(StrVecBuf+1)		; hl - address of memory allocated for string						;01b5	2a d4 78 	* . x 
	ld (hl),a				; put char into String body		 									;01b8	77 	w 
; -- copy result to ACC/REG1
	jp l2884h				; copy created string to ACC/REG1									;01b9	c3 84 28 	. . ( 

.setempty:
; -- create Empty String variable directly in ACC/REG1
	ld hl,TXT_EMPTY			; hl points to char '\0' - End of String Terminator					;01bc	21 28 19 	! ( . 
	ld (ACC_SNG),hl			; store char address to ACC/REG1						 			;01bf	22 21 79 	" ! y 
	ld a,3					; a - Number Type Flag (NTF) = 3 (String type)						;01c2	3e 03 	> . 
	ld (MATH_NTF),a			; set NTF - ACC contains String Type value							;01c4	32 af 78 	2 . x 
	pop hl					; restore hl - interpreter current pointer							;01c7	e1 	. 
	ret						; ---------------- End of Proc ------------------------				;01c8	c9 	. 




; ********************************************************************************************
; BASIC CLS ROUTINE – “CLS“
; ********************************************************************************************
; Set Cursor Position to top left (Cursor Home) and clears Screen
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdCLS:
	ld a,#1c			; a - Cursor Home ASCII control char 									;01c9	3e 1c 	> . 
	call ScrSendByteSafe; send char to Screen - set Cursot to top-left 							;01cb	cd 3a 03 	. : . 
	ld a,#1f			; a - Clear Screen ASCII control char									;01ce	3e 1f 	> . 
	jp ScrSendByteSafe	; send char to Screen - clear Scree and reset Editor Variables			;01d0	c3 3a 03 	. : . 




; ********************************************************************************************
; BASIC RANDOM ROUTINE “RANDOM“
; ********************************************************************************************
; This routine takes a value out of the REFRESH register R and stores it in location 78ABH 
; which is middle byte of 24bit Random Seed variable.
CmdRANDOM
	ld a,r				; a - value from Refresh Memory Register R								;01d3	ed 5f 	. _ 
	ld (RANDOMSEED),a	; store 8bit value as middle byte of Random Seed variable				;01d5	32 ab 78 	2 . x 
	ret					; -------------- End of Proc -------------------------- 				;01d8	c9 	. 



; ********************************************************************************************
; KEYS TO ASCII or BASIC COMMAND CONVERSION TABLE
; ********************************************************************************************
; Keyboard Scan Code to Ascii Conversion Table
; 
; -- Normal (w/o Shift, w/o Ctrl, w/o Function)
TabKey2Char:
	db 'T','G','B','5','N','6','Y','H'															;01d9	54 47 42 35 4e 36 59 48 	H 
	db 'W','S','X','2','.','9','O','L'															;01e1	57 53 58 32 2e 39 4f 4c 	L 
	db  0,  0,  0,  0,  0, '-',$0d,':'															;01e9	00 00 00 00 00 2d 0d 3a	. 
	db 'E','D','C','3',',','8','I','K'															;01f1	45 44 43 33 2c 38 49 4b 	K 
	db 'Q','A','Z','1',' ','0','P',';'															;01f9	51 41 5a 31 20 30 50 3b 	; 
	db 'R','F','V','4','M','7','U','J'															;0201	52 46 56 34 4d 37 55 4a 	J 

; -- Shift (w/ Shift) 
; -- Values in range 80H..8FH are Semigraphic Chars 
TabShiftKey2Char:
	db $8c,$89, 0, '%','^','&',$83,$86															;0209	8c 89 00 25 5e 26 83 86 	. 
	db $8d,$82, 0, '"','>',')','[','?'															;0211	8d 82 00 22 3e 29 5b 3f 	? 
	db  0,  0,  0,  0,  0, '=',$0d,'*'															;0219	00 00 00 00 00 3d 0d 2a	. 
	db $8b,$84, 0, '#','<','(',$85,'/'															;0221	8b 84 00 23 3c 28 85 2f 	/ 
	db $8e,$81,$80,'!',' ','@',']','+'															;0229	8e 81 80 21 20 40 5d 2b 	+ 
	db $87,$88, 0, '$',$5c,$27,$8a,$8f															;0231	87 88 00 24 5c 27 8a 8f 	. 

; -- Ctrl (w/ Ctrl) 
; -- Values 80H and higher are BASIC Commands Tokens 
TabCtrlKey2Cmd:
; BASIC: THEN   GOTO  LLIST  LIST   COLOR   RUN     ELSE  CLS
	db 	 $ca,   $8d,  $b5,   $b4,   $97,    $8e,    $95,  $84									;0239	ca 8d b5 b4 97 8e 95 84 	. 
; BASIC: TO     STEP  POKE   CLOAD  <UP>    READ    LET   <INS>
	db   $bd,   $cc,  $b1,   $b9,   $1b,    $8b,    $8c,  $15									;0241	bd cc b1 b9 1b 8b 8c 15 	. 
; BASIC: <>     <>    <>     <>     <>      <BREAK> <>    <>
	db    0,    0,    0,     0,     0,      1,      0,    0										;0249	00 00 00 00 00 01 00 00 	. . . 
; BASIC: NEXT   DIM   CONT   CRUN   <RIGHT> NEW     INPUT TAB(
	db   $87,   $8a,  $b3,   $9c,   $09,    $bb,    $89,  $bc									;0251	87 8a b3 9c 09 bb 89 bc 	. 
; BASIC: FOR    MODE( PEEK(  CSAVE  <DOWN>  DATA    PRINT <RUBOUT>
	db   $81,   $9d,  $e5,   $ba,   $0a,    $88,    $b2,  $7f									;0259	81 9d e5 ba 0a 88 b2 7f 	
; BASIC: RETURN GOSUB LPRINT VERIFY <LEFT>  END     IF    REM
	db   $92,   $91,  $af,   $98,   $08,    $80,    $8f,  $93									;0261	92 91 af 98 08 80 8f 93 	. 

; -- Function (w/ Function active) 
; -- Values 80H and higher are BASIC Commands Tokens 
TabCtrlKey2Func:
; BASIC: MID$(  STOP    SOUND LOG(  USING EXP(    RIGHT$( SET
	db   $fa,   $94,    $9e,  $df,  $bf,  $e0,    $f9,    $83									;0269	fa 94 9e df bf e0 f9 83 	. 
; BASIC: VAL(   STR$(   OUT   COS(  <>    ABS(    OR      <> 
	db   $f5,   $f4,    $a0,  $e1,  0,    $d9,    $d3,    0										;0271	f5 f4 a0 e1 00 d9 d3 00 	. . 
; BASIC: <>     <>      <>    <>    <>    <BREAK> <>      <>
	db   0,     0,      0,    0,    0,    1,      0,      0										;0279	00 00 00 00 00 01 00 00 	. . . 
; BASIC: LEN(   RESTORE COPY  TAN(  <>    SQR(    AND     POINT
	db   $f3,   $90,    $96,  $e3,  0,    $dd,    $d2,    $c6									;0281	f3 90 96 e3 00 dd d2 c6 	. . . 
; BASIC: CHR$(  ASC(    INP   SIN(  <>    INT(    NOT     <>
	db   $f7,   $f6,    $db,  $e2,  0,    $d8,    $cb,    0										;0289	f7 f6 db e2 00 d8 cb 00 	. . 
; BASIC: LEFT$( RND(    USR   ATN(  <>    SGN(    INKEY$  RESET
	db   $f8,   $de,    $c1,  $e4,  0,    $d7,    $c9,$82										;0291	f8 de c1 e4 00 d7 c9 82	. 
	



; ********************************************************************************************
; BASIC FUNCTION TOKENS LIST
; ********************************************************************************************
; This is list of BASIC Functions Tokens that need to be appended with the '(' to output
; after key is pressed with active Function Mode (CTRL+RETURN).
l0299h:
	db $e2, $e1, $e3, $e4				; SIN, COS, TAN, ATN 									;0299	e2 e1 e3 e4 	. . . 
	db $df, $e0, $d7, $dd				; LOG, EXP, SNG, SQR									;029d	df e0 d7 dd . 
	db $d9, $d8							; ABS, INT 												;02a1	d9 d8. 
	db $f7, $f5, $f3, $f8, $f7, $f9		; CHR$, VAL, LEN, LEFT$, CHR$, RIGHT$					;02a3	f7 	. 
	db $9d								; MODE													;02a9	9d 	. 
	db $f6, $f4							; ASC, STR$												;02aa	f6 f4 	. . 
	db $de, $e5 						; RND, PEEK												;02ac	de e5 	. . 
	db $fa								; MID$													;02ae	fa  	. . . 



; ********************************************************************************************
; SEMIGRAPHIC CHARS DEFINITIONS
; ********************************************************************************************
; Table for outputting Semigraphic (Semi4) characters on a printer. 
; The table contains two bytes per character.
; Printer will use only 7 bits. Set bit (6..0) will plot a dot by Printer.
; TODO: How Printing with Dot Printer Works
l02afh:
	db %10000000,%10000000																		;02af	80 80 	. . . 
	db %10000000,%10111000 																		;02b1	80 b8 	. 
	db %10111000,%10000000 																		;02b3	b8 80 	. 
	db %10111000,%10111000																		;02b5	b8 b8 	. 
	db %10000000,%10000111																		;02b7	80 87 	. 
	db %10000000,%10111111																		;02b9	80 bf 	. 
	db %10111000,%10000111																		;02bb	b8 87 	. 
	db %10111000,%10111111																		;02bd	b8 bf 	. 
	db %10000111,%10000000																		;02bf	87 80 	. 
	db %10000111,%10111000																		;02c1	87 b8 	. 
	db %10111111,%10000000																		;02c3	bf 80 	. 
	db %10111111,%10111000																		;02c5	bf b8 	. 
	db %10000111,%10000111																		;02c7	87 87 	. 
	db %10000111,%10111111																		;02c9	87 bf 	. 
	db %10111111,%10000111																		;02cb	bf 87 	. 
	db %10111111,%10111111																		;02cd	bf bf 	. 




; ********************************************************************************************
; SOUND NOTES PERIOD DEFINITIONS
; ********************************************************************************************
; Table of 16bit values for every 30 Sound Notes. 
; Every entry is related to Sound wave cycle time (1/f). Higher value makes lower note.
; Used as counter init value in routine generating sound. 
SNDFREQTAB:
	dw	$0272							; A2													;02cf	72 02 	. 
	dw	$024f							; A#2													;02d1	4f 02 	. 
	dw	$022e							; B2													;02d3	2e 02 	. . 
	dw	$020e							; C3													;02d5	0e 02 	. . 
	dw	$01f1							; C#3													;02d7	f1 01	. 
	dw	$01d5							; D3													;02d9	d5 01 	. . . 
	dw	$01b7							; D#3													;02db	b7 01	. 
	dw	$019e							; E3													;02dd	9e 01 	. . . 
	dw	$0186							; F3													;02df	86 01	. 
	dw	$0170							; F#3													;02e1	70 01 	. p . 
	dw	$015b							; G3													;02e3	5b 01	[ 
	dw	$0148							; G#3													;02e5	48 01 	. H . 
	dw	$0135							; A3													;02e7	35 01	5 
	dw	$0123							; A#3													;02e9	23 01 	. # . 
	dw	$0113							; B3													;02eb	13 01	. 
	dw	$0103							; C4													;02ed	03 01 	. . . 
	dw	$00f4							; C#4													;02ef	f4 00 	. . . 
	dw	$00e6							; D4													;02f1	e6 00 	. 
	dw	$00d9							; D#4													;02f3	d9 00 	. 
	dw	$00cd							; E4													;02f5	cd 00 	. . . 
	dw	$00c1							; F4													;02f7	c1 00 	. 
	dw	$00b6							; F#4													;02f9	b6 00 	. 
	dw	$00ab							; G4													;02fb	ab 00 	. 
	dw	$00a1							; G#4													;02fd	a1 00 	. 
	dw	$0098							; A4													;02ff	98 00 	. 
	dw	$008f							; A#4													;0301	8f 00 	. 
	dw	$0087							; B4													;0303	87 00 	. 
	dw	$007f							; C5													;0305	7f 00 	. 
	dw	$0078							; C#5													;0307	78 00 	. 
	dw	$0070							; D5													;0309	70 00 	. 
	dw	$006a							; D#5													;030b	6a 00 	. 





; ********************************************************************************************
; REFRESH CURSOR
; ********************************************************************************************
; Refresh char at Cursor Position on Screen (remove Invert)
; Register A is preserved 
ScrRefreshCursor:
	ld b,a					; save a register													;030d	47 	G 
	ld a,(CURSORCHAR)	    ; a - stored current Cursor char at Cursor Position					;030e	3a 3c 78 	: < x 
	ld hl,(CURSORADDR)	    ; hl - Video RAM absolute address of Cursor 						;0311	2a 20 78 	*   x 
	ld (hl),a				; update char on Screen												;0314	77 	w 
	ld a,b					; restore a	regiser													;0315	78 	x 
	ret						; ------------------ End of Proc ------------------					;0316	c9 	. 




; ********************************************************************************************
; MOVE CURSOR UP
; ********************************************************************************************
; Moves Cursor Position 1 line up. This routine doesnt check if parameter is valid 
; (i.e. Cursor is at 1st line of screen).
; IN: hl - Video RAM address of current Cursor Position
sub_0317h:
	ld bc,32		        ; 32 chars per line                                 				;0317	01 20 00 	.   . 
	or a			        ; clear Carry flag                                  				;031a	b7 	. 
	sbc hl,bc		        ; subtract 32 bytes                                 				;031b	ed 42 	. B 
	ld (CURSORADDR),hl		; save as new Cursor address                        				;031d	22 20 78 	"   x 
	ret			            ; ------------------ End of Proc ------------------					;0320	c9 	. 




; ********************************************************************************************
; ; SOUND NOTES DURATION DEFINITIONS
; ********************************************************************************************
; Table of multiplers for Music Notes duration
; Entries for every valid 2nd param of SOUND Command (in range 1..9) 
SNDDURTAB:
; -- Notes:	1/8	 1/4  3/8  1/2  3/4	 1	 3/2	2	 3		
	db		1,	 2,	  3,   4,	6,	 8,	 12,	16,	 24											;0321	01 02 03 04 06 08 0c 10 18 	. . 




; ********************************************************************************************
; OUTPUT CHAR ROUTINE - “OUTCHR”
; ********************************************************************************************
; This is a general purpose output routine which outputs a byte/char from the A register to Screen,
; Tape or Printer. In order to use it, the Current Output Device variable must be loaded with:
;   0 for Screen 
;   1 for Printer
;  -1 for Tape/Cassette (any negative value 80H..FFH). 
; NOTE: Warning: This routine calls a [TODO] Disk BASIC link at address 79c1 
; which may have to be "plugged" with a RET (C9H) instruction.
; IN:  a - byte to send
;      [789CH] - Output Device Flag to send byte to
PrintChar:
	push bc					; save bc																	;032a	c5 	. 
	ld c,a					; save char/byte to send in C												;032b	4f 	O 
; -- call Extension Vector in case external device want intercept 
	call SysExtByteOut		; call Extension Vector at [79C1H] - just RET w/o installed Extension		;032c	cd c1 79 	. . y 
; -- determine Output Device 
	ld a,(SysCurOutDev)		; a - Current Output Device													;032f	3a 9c 78 	: . x 
	or a					; set flags: Z - screen, NZ - printer, M - tape								;0332	b7 	. 
; -- restore input data
	ld a,c					; restore a (byte/char to send)												;0333	79 	y 
	pop bc					; restore bc																;0334	c1 	. 
; -- output char/byte to DEvice
	jp m,TapeWriteChar		; M=1 - send char/byte to Tape Device										;0335	fa 54 3b 	. T ; 
	jr nz,PrinterSendByte	; Z=0 - send char/byte to Printer Device									;0338	20 62 	  b 
; -- Z=1 - send char to Screen Device





; *********************************************************************************************************
; OUTPUT CHAR TO SCREEN ROUTINE (SAFE)
; *********************************************************************************************************
; Saves contents of all registers and calls PrintChar routine
; IN: a - char to print on Screen
ScrSendByteSafe:
	push de					; save de 																	;033a	d5 	. 
	push af					; save af																	;033b	f5 	. 
	push bc					; save bc																	;033c	c5 	. 
	push hl					; save hl																	;033d	e5 	. 
	call ScrPrintChar		; print char on Screen at current Cursor position							;033e	cd 8b 30 	. . 0 
	pop hl					; restore hl																;0341	e1 	. 
	pop bc					; restore bc 																;0342	c1 	. 
	nop	: nop				; removed code																;0343	00 00 	. 
	pop af					; restore af																;0345	f1 	. 
	pop de					; restore de																;0346	d1 	. 
	ret						; -------------- End of Proc ------------------------------					;0347	c9 	. 




; *********************************************************************************************************
; [TRS] GET CURSOR POSITION IN LINE ---- not used ----
; *********************************************************************************************************
; Get the cursor location (taking into account whether we are in 32 or 64 character mode).
; Just like in VZ/Laser computers variable at 783BH shadows last value wrote to IOLATCH (6800H)
; in TRS-80 Computers variable at 403DH (in VZ200 it would be 783DH) contains last value wrote
; to IO PORT 0FFh with BITS meaning:
; - bit 3	Select video 32 character mode if set
; - bit 2 	Turns on cassette tape relay if set
; - bit 0,1	Are set for positive and negative audio pulses to the cassette "AUX" plug
; Not used in VZ/Laser ROM 1.2 nor ROM 2.0
; OUT: A - value in the range 0..63 or 0..31 depend on video display mode 
GetCursorInLine:
; -- check flag byte to determine if Video Display is in 32 or 64 chars/line mode.
	ld a,($783d)			; a - last value wrote to IO Port FFH - HW Latch							;0348	3a 3d 78 	: = x 
	and %00001000			; isolate and test bit 3 - is 32 chars/line mode ON							;034b	e6 08 	. . 
; -- low byte of Video RAM address is enough to determine CUrsor in line index
	ld a,(CURSORADDR)		; a - Cursor VRAM address LSB only 											;034d	3a 20 78 	:   x 
	jr z,.mode64			; no - active Mode 64 chars/line - skip rotation and next instruction		;0350	28 03 	( . 
; -- when 32 chars/line Mode is active 
	rrca					; divide address LSB by 2 													;0352	0f 	. 
	and $1f					; constrain value range to 0..31											;0353	e6 1f 	. . 
.mode64:
	and $1f					; constrain value range to 0..31 (see NOTE below)							;0355	e6 1f 	. . 
	ret						; return with value															;0357	c9 	. 
; NOTE: Originally in TRS ROM above instruction was "and $3f" which constrains value to 0..63
;       Hard to say why mask was changed to $1f and in the end of day routine was not used.





; *********************************************************************************************************
; GET KEY ROUTINE
; *********************************************************************************************************
; Calls standard Keyboard Read routine but preserve DE register and calls Extension Vector first.
; NOTE: You may bypass this Extension Vector call by entering the routine at 035BH.
; OUT: a - key pressed or 0 if none
KeysReadKeySaveDE:
	call SysExtKeyRead		; call DOS OnKeysRead hook													;0358	cd c4 79 	. . y 
	push de					; save de 																	;035b	d5 	. 
	call KeysReadKey		; read Key Pressed via standard Keyboard Read routine						;035c	cd 2b 00 	. + . 
	pop de					; restore de																;035f	d1 	. 
	ret						; --------------- End of Proc --------------------- 						;0360	c9 	. 




; *********************************************************************************************************
; SOUND NOTES PERIOD MULTIPLIERS DEFINITIONS
; *********************************************************************************************************
; Table with 8bit values for every Sound Notes
; Every entry contains how many times Sound Period must be played for 1/8 note 
SNDFCNTTAB:
	db	$0a					; A2																		;0361	0a 	. 
	db	$0b					; A#2																		;0362	0b 	. 
	db	$0c					; B2																		;0363	0c 	. 
	db 	$0c					; C3																		;0364	0c 	. 
	db	$0d					; C#3																		;0365	0d 	. 
	db	$0e					; D3																		;0366	0e  	. . 
	db	$0f					; D#3																		;0367	0f 	. . 
	db	$0f					; E3																		;0368	0f 	. 
	db	$10					; F3																		;0369	10 	. . 
	db	$11					; F#3																		;036a	11 	. . 
	db	$12					; G3																		;036b	12 	. 
	db	$13					; G#3																		;036c	13 	. 
	db	$15					; A3																		;036d	15 	. 
	db	$16					; A#3																		;036e	16 	. . 
	db	$17					; B3																		;036f	17 	. . 
	db	$19					; C4																		;0370	19 	. 
	db	$1a					; C#4																		;0371	1a 	. 
	db	$1c					; D4																		;0372	1c 	. 
	db	$1d					; D#4																		;0373	1d 	. 
	db	$1f					; E4																		;0374	1f 	. 
	db	$21					; F4																		;0375	21 	! # % 
	db	$23					; F#4																		;0376	23 	! # % 
	db	$25					; G4																		;0377	25 	! # % 
	db	$27					; G#4																		;0378	27 	' 
	db	$29					; A4																		;0379	29 	) 
	db	$2c					; A#4																		;037a	2c 	, 
	db	$2e					; B4																		;037b	2e 	. 1 
	db	$31					; C5																		;037b	31 	. 1 
	db	$34					; C#5																		;037d	34 	4 
	db	$35					; D5																		;037e	35 	5 
	db 	$3a					; D#5																		;037f	3a 	:





; *********************************************************************************************************
; VERIFY COMMAND STATUS TEXTS
; *********************************************************************************************************
; Text definitions used by BASIC VERIFY Command
TXT_OK:		db "OK",$d,0        																		;0380	4f 4b 0d 00 	. 
TXT_ERROR:	db "ERROR",$d,0																				;0384	45 52 52 4f 52 0d 00 	





; *********************************************************************************************************
; SET OUTPUT DEVICE TO SCREEN
; *********************************************************************************************************
; Reset current Output Device Flag at 789CH to 0 (output to Screen), also outputs 
; a CR to the Printer Device if printer's head is not at beginning of line 
; (determined by checking the contents of the Printer Line Position variable at 789BH 
; - if variable contains zero, printer's head is at start of line). 
; Note that if Printer Line Position does not contain zero (printing stopped in the middle of line)
; and the printer is not OnLine, the computer will "hang up" waiting for a "printer ready" signal. 
SwitchPrnToScr:
; -- set Screen as Current Output Device
	xor a					; a - Device Id 0 (Screen)													;038b	af 	. 
	ld (SysCurOutDev),a		; set Screen as Current Output Device										;038c	32 9c 78 	2 . x 

; -- flush line to Printer Device if printer's head position is not at start of line
	ld a,(PRN_PosInLine)	; a - current Printer Line Position  										;038f	3a 9b 78 	: . x 
	or a					; is it 0? (printer's head is at begining of the line						;0392	b7 	. 
	ret z					; yes - return - nothing to do												;0393	c8 	. 

; -- set CR char to Printer
	ld a,$0d				; a - CR char to send to Printer											;0394	3e 0d 	> . 
	push de					; save de (this become Device Control Block address)						;0396	d5 	. 
	call PrinterSendByte	; send CR to Printer Device													;0397	cd 9c 03 	. . . 
	pop de					; restore de																;039a	d1 	. 
	ret						; --------------- End of Proc ----------------------------- 				;039b	c9 	. 




; *********************************************************************************************************
; SEND CHAR TO PRINTER
; *********************************************************************************************************
; Outputs character in the A register to the Printer. 
; Also maintains the current printer's head position in Printer Line Position variable at 789BH.
; This variable is incremented for each character printed, except that it is reset to zero if character
; is line feed (0A), form feed (0C), or carriage return (0D).
; Line feed (OA) characters are changed to carriage return (0D) characters
; prior to calling the printer output routine. CALLs routine at 003BH.
; IN: a - char to print on Printer
PrinterSendByte:
; -- save registers used
	push af					; save af 																	;039c	f5 	. 
	push de					; save de																	;039d	d5 	. 
	push bc					; save bc																	;039e	c5 	. 
; -- check character to print
	ld c,a					; c - save char to print													;039f	4f 	O 
	ld e,0					; default Printer Line Position after print char (assuming LF,FF or CR)		;03a0	1e 00 	. . 
	cp #0c					; is this FormFeed (0CH) control character?									;03a2	fe 0c 	. . 
	jr z,.printChar			; yes - set new Printer Line Position to 0 and send FF to printer			;03a4	28 10 	( . 
	cp #0a					; is this LineFeed (0A) control character?									;03a6	fe 0a 	. . 
	jr nz,.checkCR			; no - skip replace LF to CR												;03a8	20 03 	  . 
; -- change LineFeed (0A) to CarriageReturn (0D)
	ld a,#0d				; set char as CR															;03aa	3e 0d 	> . 
	ld c,a					; set saved char as CR too													;03ac	4f 	O 
.checkCR:
	cp #0d					; is this CR char (or was LF)?												;03ad	fe 0d 	. . 
	jr z,.printChar			; yes - skip increment Printer Line Position - will be set to 0				;03af	28 05 	( . 
; -- increment Printer Line Position by 1
	ld a,(PRN_PosInLine)	; current Printer Line Position												;03b1	3a 9b 78 	: . x 
	inc a					; increment by 1															;03b4	3c 	< 
	ld e,a					; set as new value to set													;03b5	5f 	_ 
.printChar:
	ld a,e					; a - new Printer Line Position												;03b6	7b 	{ 
	ld (PRN_PosInLine),a	; update position variable 													;03b7	32 9b 78 	2 . x 
	ld a,c					; a - char to send to printer												;03ba	79 	y 
	call PRN_SendChar		; send char on Printer														;03bb	cd 3b 00 	. ; . 
	pop bc					; restore bc																;03be	c1 	. 
	pop de					; restore de																;03bf	d1 	. 
	pop af					; restore af																;03c0	f1 	. 
	ret						; -------------- End of Proc ------------------------------ 				;03c1	c9 	. 




; *********************************************************************************************************
; EXECUTE DCS OPERATION ROUTINE
; *********************************************************************************************************
; Executes operation (read/write/control) via Device Control Subsystem
; IN: de - address of selected Device Control Block
;	  b - operation/type (1-read, 2-write, 4-control)
;     a - byte to write if write operation selected 
ExecuteDCBOperation:
; -- save registers and set IX to point to DCB
	push hl					; save HL																	;03c2	e5 	. 
	push ix					; save IX																	;03c3	dd e5 	. . 
	push de					; copy Device Control Block address to IX									;03c5	d5 	. 
	pop ix					; ix - selected DCB															;03c6	dd e1 	. . 
	push de					; save DE																	;03c8	d5 	. 
; -- set return procedure to ensure restore saved registers
	ld hl,.exit				; address of code to execute on exit after operation						;03c9	21 dd 03 	! . . 
	push hl					; push on CPU stack return address  										;03cc	e5 	. 
; -- check if Device can do Operation and if not then return via DOS Vector 7833H 
	ld c,a					; c - data to send to Device												;03cd	4f 	O 
	ld a,(de)				; a - Device Capabilities													;03ce	1a 	. 
	and b					; mask only requested operation 											;03cf	a0 	. 
	cp b					; check if Device is capable to do this operation							;03d0	b8 	. 
	jp nz,07833h			; no - return via DOS Vector 7833H (w/o DOS this will be RET)				;03d1	c2 33 78 	. 3 x 
; -- execute Operation
	cp 2					; set FLAGS -> Z - Write Op, NC - Read Op, C - Control Op					;03d4	fe 02 	. . 
	ld l,(ix+1)				; l - DriverAddress LSB 													;03d6	dd 6e 01 	. n . 
	ld h,(ix+2)				; h - DriverAddress MSB														;03d9	dd 66 02 	. f . 
	jp (hl)					; call Driver																;03dc	e9 	. 
.exit:
	pop de					; restore de																;03dd	d1 	. 
	pop ix					; restore ix																;03de	dd e1 	. . 
	pop hl					; restore hl																;03e0	e1 	. 
	pop bc					; restore bc																;03e1	c1 	. 
	ret						; return to caller															;03e2	c9 	. 





; *********************************************************************************************************
; READ LINE FROM KEYBOARD INTO BUFFER
; *********************************************************************************************************
; Reading a text line from the keyboard into Buffer. 
; The line is read in until the RETURN or BREAK key is pressed, displayed on the screen 
; and then transferred to the Editor Buffer
; IN: c - length of prefix text (???)
ReadLine:
; -- set System Flag - text input is buffered
	ld hl,SYSFLAGS			; address of System Flags variable 											;03e3	21 39 78 	! 9 x 
	set 5,(hl)				; set buffered output flag													;03e6	cb ee 	. . 
; -- refresh Cursor on Screen
	ld hl,(CURSORADDR)		; hl - VRAM address of Cursor location on Screen 	                        ;03e8	2a 20 78 	*   x 
	call SetCursorFromHL	; update Cursor Char (refresh)				  		                        ;03eb	cd 53 00 	. S . 
; -- test if cursor is at the begining of last Screen line - hl == address 71e0
	ld a,h			    	; MSB of VRAM Cursor address                  								;03ee	7c 	| 
	cp $71		        	; is it bottom half of Screen ?                     						;03ef	fe 71 	. q 
	jr nz,.startInputLIne	; no - skip checking Editor status 											;03f1	20 10 	  . 
	ld a,l			    	; LSB of VRAM Cursor address                   								;03f3	7d 	} 
	cp $e0		        	; is it begin of last line on Screen ?              						;03f4	fe e0 	. . 
	jr nz,.startInputLIne	; no - skip checking Editor status											;03f6	20 0b 	  . 

; -- Test if this is 2nd line of Editor Line Data - could be 1 or 2 line 
	ld a,(EDITORLINES)		; first Editor Line info													;03f8	3a d7 7a 	: . z 
	or a					; is it second line of two-line-statement?									;03fb	b7 	. 
	jr nz,.startInputLIne	; no - no need to scroll screen up											;03fc	20 05 	  . 
; -- if 1st Editor line is a 2nd of two we need discard it scrolling up
	ld a,#0D		    	; a - CR character 															;03fe	3e 0d 	> . 
	call ScrPrintChar		; Print CR to Screen (move to next line)	        						;0400	cd 8b 30 	. . 0 
.startInputLIne:
; -- save Prompt Text length and read line via Interrupt routine
	ld b,c					; b - length of prompt text	(column)										;0403	41 	A 
	push bc					; save bc																	;0404	c5 	. 
; -- clear status of Editing
	ld hl,SYSFLAGS			; address of System Flags													;0405	21 39 78 	! 9 x 
	res 0,(hl)				; clear RETURN pressed Flag													;0408	cb 86 	. . 
	res 2,(hl)				; clear BREAK pressed Flag													;040a	cb 96 	. . 
.wait:
; -- wait until user pressed RETURN while typing line
	bit 0,(hl)				; is RETURN pressed Flag set?												;040c	cb 46 	. F 
	jr z,.wait				; no - wait until user end editing by pressing RETURN						;040e	28 fc 	( . 

; -- user pressed RETURN - end of editing - text is on Screen
; -- reset Cursor Position at start but save length of inserted text
	ld a,(CURSORPOS) 		; position of Cursor in Edited line											;0410	3a a6 78 	: . x 
	ld c,a					; store it as LSB of difference from start									;0413	4f 	O 
	xor a					; a - 0 for new Cursor Position and difference MSB							;0414	af 	. 
	ld (CURSORPOS),a 		; set Cursor at begining of line											;0415	32 a6 78 	2 . x 
	ld b,a					; bc - current edited line length (difference from starat)					;0418	47 	G 
	ld hl,(CURSORADDR)		; Cursor absolute Address in VRAM 											;0419	2a 20 78 	*   x 
	sbc hl,bc				; move back Cursor address to the beginig of edited line					;041c	ed 42 	. B 
	ld (CURSORADDR),hl		; set as new Cursor Address in VRAM 										;041e	22 20 78 	"   x 
; -- Cursor Position moved back at start of line
	ld de,EditLineBuf		; de - address of Editor Line Buffer										;0421	11 e8 79 	. . y 
	pop bc					; c=b - length of Prompt text in case we processing INPUT Command 			;0424	c1 	. 
; -- test if we're processing INPUT Command
	ld hl,SYSFLAGS			; address of System Flags													;0425	21 39 78 	! 9 x 
	bit 4,(hl)				; is bit 4 set? (BASIC INPUT Command in progress)							;0428	cb 66 	. f 
	ld hl,(CURSORADDR)		; hl - Cursor Address in VRAM - begining of entered line					;042a	2a 20 78 	*   x 
	jr z,l0471h				; no - is was interractive Edit 											;042d	28 42 	( B 

; -- Line was edited for INPUT Command
	push bc					; save bc - length of Prompt text											;042f	c5 	. 
	push hl					; save hl - VRAM address of entered text 									;0430	e5 	. 
	call GetEditorLineFlag	; Get status of Editor Line													;0431	cd a8 33 	. . 3 
	pop hl					; restore hl - VRAM address of entered text									;0434	e1 	. 
	pop bc					; restore bc - length of Prompt text										;0435	c1 	. 
	or a					; is the 2nd line of two-line-statement?									;0436	b7 	. 
	jr nz,.skipPrompt		; no - skip address correction 												;0437	20 08 	  . 
; -- it is 2nd line - move address to begining of 1st line
	ld a,l					; a - LSB of VRAM address													;0439	7d 	} 
	sub 32					; subtract 32 bytes (1 screen line)											;043a	d6 20 	.   
	ld l,a					; store back																;043c	6f 	o 
	ld a,h					; a - MSB of VRAM address													;043d	7c 	| 
	sbc a,0					; subtract Carry only (if any)												;043e	de 00 	. . 
	ld h,a					; hl - new adrress 1 screen line up											;0440	67 	g 
.skipPrompt:
; -- skip all characters already the same on Screen and in Edit Buffer
	ld c,b					; c - save Prompt/Prefix Text length										;0441	48 	H 
.next:
	ld a,(de)				; a - character from Edit Buffer											;0442	1a 	. 
	cp (hl)					; is the same on Screen?													;0443	be 	. 
	jr nz,.resetLength		; no - set length of Prompt Text to 0										;0444	20 07 	  . 
	inc hl					; hl - point to next character on screen									;0446	23 	# 
	inc de					; de - point to next character in Edit Buffer								;0447	13 	. 
	djnz .next				; repeat for whole Prompt/Prefix text										;0448	10 f8 	. . 
; -- Prompt/Prefix didn't changed
	push bc					; save bc - verified length of Prompt Text									;044a	c5 	. 
	jr .testEditor			; skip reset of length of Prompt Text 										;044b	18 04 	. . 
.resetLength:
	ld bc,0					; set length of Prompt Text to 0											;044d	01 00 00 	. . . 
	push bc					; save bc - length 0														;0450	c5 	. 
.testEditor:
	push hl					; save hl - address of begining text on Screen								;0451	e5 	. 
	call GetEditorLineFlag	; a - Editor Line Flag/Status pointed by hl								 	;0452	cd a8 33 	. . 3 
	pop hl					; restore hl																;0455	e1 	. 
	pop bc					; restore bc - length of Prompt Text										;0456	c1 	. 
	push bc					; save bc again																;0457	c5 	. 
	cp $80					; is this Single Editor Line												;0458	fe 80 	. . 
	jr z,.singleLine		; yes - set 32 bytes max													;045a	28 0a 	( . 
; -- two-line-text
	ld a,64					; maximum 64 bytes/chars in this text										;045c	3e 40 	> @ 
	sub c					; subtract detected previously Prompt length								;045e	91 	. 
	ld b,a					; b - max length of text w/o Prompt											;045f	47 	G 
	pop de					; de - saved length of Prompt Text											;0460	d1 	. 
	ld e,0					; clear LSB of length (MSB is already 0) - de = 0							;0461	1e 00 	. . 
	push de					; push back 0 value as Prompt length										;0463	d5 	. 
	jr .continue			; continue with 2 lines and text length in B								;0464	18 05 	. . 
.singleLine:
	ld b,32					; b - maximum 32 bytes/chars in this text									;0466	06 20 	.   
	ld hl,(CURSORADDR)		; VRAM address of Cursor Position on Screen 								;0468	2a 20 78 	*   x 
.continue:
	ld de,EditLineBuf		; de - address of Editor Line Buffer										;046b	11 e8 79 	. . y 
 
; ----------------- ROM 1.2 only --------------------------------------------------------------
 ifdef VER_12
	ld a,(hl)				; a - char from Screen at Cursor location									;046e	7e 	~ 
	jr l04c3h				;046f	18 52 	. R 

; ----------------- ROM 2.0 only --------------------------------------------------------------
 else
 	jp l3ea8h				; Check background color													;046e	c3 a8 3e 	. . > 
							; with green background go to 04B8H
							; with black background go to 3E6AH
 endif

; ----------------- common code ---------------------------------------------------------------



; Determine start of text address and maximum length if not INPUT command
; but user is editing BASIC Program Line or Statement
l0471h:
; -- Prompt
	ld bc,0					; bc = length of Prompt Text = 0 - (it's not INPUT Command)					;0471	01 00 00 	. . . 
	push bc					; save bc - length of Prompt Text 											;0474	c5 	. 
	push hl					; save hl - VRAM address of entered text									;0475	e5 	. 
	call GetEditorLineFlag	; a - Editor Line Flag/Status pointed by hl								 	;0476	cd a8 33 	. . 3 
	pop hl					; restore hl - VRAM address of entered text									;0479	e1 	. 
	cp $80					; is it single line statement?												;047a	fe 80 	. . 
	jr z,.set32max			; yes - set b to 32 bytes/chars maximum										;047c	28 0e 	( . 
	cp $81					; is it 1st line of two-line-statement?										;047e	fe 81 	. . 
	jr z,.set64max			; yes - set b to 64 bytes/chars maximum										;0480	28 06 	( . 

; -- 2nd line of two-line-statement - move hl pointer 1 line up
	ld bc,32				; bc - 32 bytes per line to correct start address in hl						;0482	01 20 00 	.   . 
	or a					; clear Carry flag															;0485	b7 	. 
	sbc hl,bc				; hl - address of start of 1st line of this statement						;0486	ed 42 	. B 
.set64max:
	ld b,64					; b - maximum 64 chars this text can have									;0488	06 40 	. @ 
	jr l048eh				; skip setting b 															;048a	18 02 	. . 
.set32max:
	ld b,32					; b - maximum 32 chars this text can have									;048c	06 20 	.   
 
 


; ----------------- ROM 1.2 only --------------------------------------------------------------

 ifdef VER_12
l048eh:
; -- transfer the data from the Screen to the I/0 buffer
	ld a,(hl)				; a - character from the Screen												;048e	7e 	~ 
	cp 64					; is it >= 64 - Graphic or Inverse char?									;048f	fe 40 	. @ 
	jp c,ParseScrChar		; no - proceed with Normal Char 											;0491	da b9 04 	. . . 
; -- if not INPUT, then Graphic or Inverse chars are only allowed in strings
	pop bc					; bc - length of Prompt Text												;0494	c1 	. 
	ld de,EditFailExit		; push Fail Exit routine address on the stack								;0495	11 9d 04 	. . . 
	push de																								;0498	d5 	. 
	push bc					; push length of Prompt Text on the Stack									;0499	c5 	. 
	jp l050dh				; Check end-of-text identification (or BREAK)								;049a	c3 0d 05 	. . . 
EditFailExit:
; -- Parsing failed but if BREAK was pressed we can ignore error
	ret c					; if BREAK was pressed go back to BASIC										;049d	d8 	. 

; -- display SYNTAX ERROR on Screen
	ld hl,TXT_SYNTAXERROR	; hl - address of "SYNTAX ERROR" text 										;049e	21 1a 3e 	! . > 
	call PrintBasicStr		; print 'SYNTAX ERROR' on Screen											;04a1	cd a7 28 	. . ( 

; -- display next BASIC line number if AUTO is ON (ROM 1.2 only)
	ld a,(AUTONUM_ON)		; a - Basic AUTO Flag 														;04a4	3a e1 78 	: . x 
	or a			    	; is auto number feature ON? 												;04a7	b7 	. 
	jp z,ReadLine			; no - go back to Read Line as typed by User								;04a8	ca e3 03 	. . . 

; -- AUTO is ON - print next BASIC Line number for User
	ld hl,(AUTONUM_LINE)	; hl - line number generated by AUTO feature								;04ab	2a e2 78 	* . x 
	call PrintLineNo		; Print Line number from hl (16bit) on Screen								;04ae	cd af 0f 	. . . 
	ld a,' '		    	; a - Space char to separate Line number from Body 							;04b1	3e 20 	>   
	call sub_3157h			; send ' ' to Screen														;04b3	cd 57 31 	. W 1 
; -- go back to Editor and auire Statement from User  
	jp ReadLine				; go back to Read Line as typed by User										;04b6	c3 e3 03 	. . . 



; Charcter on Screen is < 64 - NOT Graphiocs nor Inversed
; IN: a - character from Screen to parse
;     b - maximum number of characters (32 or 64)
;     hl - VRAM address where is parsed char
;     de - address of current location in Editor Line Buffer
ParseScrChar:
	cp '"'					; is it start of String value??												;04b9	fe 22 	. " 
	jr nz,l04eeh			; no - continue																;04bb	20 31 	  1 
; -- start of quoted String found
	ld (de),a				; save '"' Character into Editor Buffer										;04bd	12 	. 
	inc hl					; hl points to next character on Screen										;04be	23 	# 
	inc de					; de points to next location in Editor Buffer								;04bf	13 	. 
	dec b					; decrement mx number of chars to parse										;04c0	05 	. 
	jr z,FinishParse		; if all parsed - go Finish copying text to Edit Buffer						;04c1	28 36 	( 6 

; Parsing content of quoted String
; IN: hl - address of char on Screen 
;     de - address of location in Editor Line Buffer
l04c3h:
	ld a,(hl)				; a - next character from Screen											;04c3	7e 	~ 
	cp 64					; is it >= 64 - Graphic or Inverse char?									;04c4	fe 40 	. @ 
	jp c,l04d4h				; no - proceed with Normal Char 											;04c6	da d4 04 	. . . 
; -- Graphic or Inverse char
	cp 128					; is it >= 128 - SemiGraphic char?											;04c9	fe 80 	. . 
	jp c,l04d0h				; no - must be 	Inversed character											;04cb	da d0 04 	. . . 
; -- Semigraphic char - ignore Color bits 
	and %10001111			; clear color bits (6,5,4) in semigraphic character							;04ce	e6 8f 	. . 
l04d0h:
	or %10000000			; set bit 7 - flag for Semigraphic or Invered chars in String				;04d0	f6 80 	. . 
	jr l04e7h				; store "in-string" character and process next ones							;04d2	18 13 	. . 

; Parsing content of quoted String - Normal char as Screen Code
l04d4h:
	cp '"'					; is it end of quoted String?												;04d4	fe 22 	. " 
	jr nz,l04e1h			; no - convert to ASCII and store in Editor Buffer							;04d6	20 09 	  . 

; -- end of quoted String - check if we procesing text for BASIC INPUT Command
	push hl					; save hl - VRAM address of char											;04d8	e5 	. 
	ld hl,SYSFLAGS			; hl address of System Flags variable										;04d9	21 39 78 	! 9 x 
	bit 4,(hl)				; is bit 4 set? (BASIC INPUT Command in progress)							;04dc	cb 66 	. f 
	pop hl					; restore hl - VRAM address of char											;04de	e1 	. 
	jr z,l04eeh				; no - continue parsing text as BASIC Statement or Line						;04df	28 0d 	( . 
l04e1h:
	bit 5,a					; is bit 5 set? (code 20H..3FH)												;04e1	cb 6f 	. o 
	jr nz,l04e7h			; yes - no need to convert - it's the same as ASCII 						;04e3	20 02 	  . 
	or $40					; add 40H to codes 00 - 1FH -> 41H..5FH - valid ASCII						;04e5	f6 40 	. @ 


; store character in Edit Buffer and process next ones
l04e7h:
	ld (de),a				; store character in Editor Line Buffer										;04e7	12 	. 
	inc hl					; hl points to next character on Screen										;04e8	23 	# 
	inc de					; de points to next location in Editor Buffer								;04e9	13 	. 
	djnz l04c3h				; decrement max number of chars to parse									;04ea	10 d7 	. . 
	jr FinishParse		;04ec	18 0b 	. . 


; Parsing text as BASIC Statement or Line (no Inverse nor Semigraphics allowed)
l04eeh:
	bit 5,a					; is bit 5 set? (code 20H..3FH)												;04ee	cb 6f 	. o 
	jr nz,l04f4h			; yes - no need to convert - it's the same as ASCII 						;04f0	20 02 	  . 
	or $40					; add 40H to codes 00 - 1FH -> 41H..5FH - valid ASCII						;04f2	f6 40 	. @ 
l04f4h:
	ld (de),a				; store character in Editor Line Buffer										;04f4	12 	. 
	inc hl					; hl points to next character on Screen										;04f5	23 	# 
	inc de					; de points to next location in Editor Buffer								;04f6	13 	. 
	djnz l048eh				; decrement max number of chars to parse									;04f7	10 95 	. . 

; Copying finished, complete buffer content
FinishParse:
; -- trim trailing spaces (if any)
	dec de					; de - points to last character inserted into Editor Buffer					;04f9	1b 	. 
	ld a,d					; MSB of character address 													;04fa	7a 	z 
	cp $79					; is it MSB of Buffer address?												;04fb	fe 79 	. y 
	jr nz,l0505h			; no - test Space char in Buffer											;04fd	20 06 	  . 
	ld a,e					; LSB of character address 													;04ff	7b 	{ 
	cp $e8					; is DE < address of Editor Buffer?											;0500	fe e8 	. . 
	jp c,l050ah				; yes - done - put String Terminator (0) at the end							;0502	da 0a 05 	. . . 
l0505h:
	ld a,(de)				; a - character from Edit Buffer											;0505	1a 	. 
	cp ' '					; is it Space char?															;0506	fe 20 	.   
	jr z,FinishParse		; yes - continue trimming Spaces											;0508	28 ef 	( . 

l050ah:
; -- put String Terminator (0) at the end of trimmed text
	inc de					; de - address just after last char in Edit Buffer							;050a	13 	. 
	xor a					; string terminator (0)														;050b	af 	. 
	ld (de),a				; store into Editor Line Buffer												;050c	12 	. 

l050dh:
; -- move Screen Cursor to line after text (1 or 2 lines down)
	call GetEditorLineFlag	; a - Editor Line Flag/Status pointed by hl									;050d	cd a8 33 	. . 3 
	ld hl,(CURSORADDR)		; hl - VRAM address of Screen Cursor										;0510	2a 20 78 	*   x 
	cp $81					; is Cursor in 1st line of two-line-statment?								;0513	fe 81 	. . 
	call SetCursorFromHL	; refresh Cursor Char at cursor position									;0515	cd 53 00 	. S . 
	jr nz,.advCursor		; no - it's single line	text - move 1 line only 							;0518	20 04 	  . 
; -- advance Screen Cursor to begining of next Screen Line 
	xor a					; a - control character 0													;051a	af 	. 
	call ScrPrintChar		; send character to Screen/Editor											;051b	cd 8b 30 	. . 0 
.advCursor:
; -- advance Screen Cursor to begining of next Screen Line 
	xor a					; a - control character 0													;051e	af 	. 
	call ScrPrintChar		; send character to Screen/Editor											;051f	cd 8b 30 	. . 0 

; -- remove INVERSE mode from Keyboard State
	ld a,(KEYSFLAGS)		; get Keyboard's current State 												;0522	3a 38 78 	: 8 x 
	and %11111101		    ; clear bit 1 - INVERSE Flag 												;0525	e6 fd 	. . 
	ld (KEYSFLAGS),a		; store modified Keyboard State back 										;0527	32 38 78 	2 8 x 

; -- check if User pressed BREAK key (canceled edit)
	ld hl,SYSFLAGS			; hl - address of System Flags variable										;052a	21 39 78 	! 9 x 
	bit 2,(hl)				; is bit 2 set (BREAK Key pressed)?											;052d	cb 56 	. V 
	jr z,.commitState		; no - set state to Commit edits and continue  								;052f	28 05 	( . 
; -- set state to Abort edits - BREAK pressed
	ld a,1					; a=1 - BREAK key pressed													;0531	3e 01 	> . 
	scf						; set Carry Flag - Abort													;0533	37 	7 
	jr .skip				; skip setting state														;0534	18 01 	. . 
.commitState:
; -- set state to Commit edits - RETURN pressed
	xor a					; a=0 - no BREAK, Carry=0 - Commit											;0536	af 	. 
.skip:
; -- clear flag - BASIC INPUT Command is no longer in progress
	ld hl,SYSFLAGS			; hl - address of System Flags variable										;0537	21 39 78 	! 9 x 
	res 4,(hl)				; Reset INPUT Command flag													;053a	cb a6 	. . 
; -- set start of text inside Buffer
	ld hl,EditLineBuf		; address of Editor Line Buffer												;053c	21 e8 79 	! . y 
	pop bc					; length of Prompt text (in case INPUT was processed)						;053f	c1 	. 
	push af					; save Commit/Abort state on the Stack										;0540	f5 	. 
	add hl,bc				; add Prefix length - hl points to start of entered text					;0541	09 	. 
; -- make sure Buffer contains at least 1 char - add Space if needed and return  
	jp l3e29h				; chack Edit Buffer and correct if needed									;0542	c3 29 3e 	. ) > 



; *********************************************************************************************************
; COPY TEXT FROM SCREEN TO BUFFER AND TO INPUT 
; *********************************************************************************************************
; Part of the BASIC INPUT command routine reading a line into the Editor Line Buffer
; Maximum allowable text length is 64 characters. End of text is marked by 0 in buffer.
; OUT: hl - location prior to first character in Editor Buffer
;      CY=1 - Input was aborted by pressing BREAK key
; -- Wait until entered text is completed (by RETURN) or aborted (by BREAK)
;GetUserInputText:
;	ld a,(07aafh)			; a - number of characters in Edit Buffer left to process					;0545	3a af 7a 	: . z 
;	or a					; is it 0 (buffer empty)?													;0548	b7 	. 
;	jr nz,GetUserInputText	; no - wait for all chars copied											;0549	20 fa 	  . 
;; -- clear BASIC Edit Line Buffer (64 chars)
;	ld b,64					; buffer length - 64 chars 													;054b	06 40 	. @ 
;	ld hl,EditLineBuf		; hl - address of Editor Line Buffer										;054d	21 e8 79 	! . y 
;	ld a,' '				; a - Space char to fill buffer with										;0550	3e 20 	>   
;.loop:
;	ld (hl),a				; store Space char into buffer												;0552	77 	w 
;	inc hl					; points to next char location in buffer									;0553	23 	# 
;	djnz .loop				; fill all 64 bytes															;0554	10 fc 	. . 
;; -- terminate text with byte 0
;	xor a					; text terminator 0															;0556	af 	. 
;	ld (hl),a				; store at the end of buffer												;0557	77 	w 
;; -- correct Cursor Position if Cursor is on 2nd line of two-line-text
;	call GetEditorLineFlag	; a - Editor Line Flag														;0558	cd a8 33 	. . 3 
;	or a					; is it 2nd line of two-line-text?											;055b	b7 	. 
;	ld a,(CURSORPOS)		; a - current position of Cursor in Edited line	(column)					;055c	3a a6 78 	: . x 
;	jr nz,.skip				; it's not 2nd line - skip adjustment										;055f	20 02 	  . 
;	add a,32				; add 32 to Cursor in text position (one screen line)						;0561	c6 20 	.   
;.skip:
;; -- calculate length of text based on Cursor position
;	ld c,a					; c - Cursor position in line as length LSB 								;0563	4f 	O 
;	xor a					; a = 0 as difference MSB													;0564	af 	. 
;	ld b,a					; bc - text length - difference beetween Cursor and begining of 1st line	;0565	47 	G 
;	ld hl,(CURSORADDR)		; absolute address of Cursor 												;0566	2a 20 78 	*   x 
;; -- source address
;	sbc hl,bc				; hl - absolute address of begining of text									;0569	ed 42 	. B 
;; -- destination address 
;	ld de,EditLineBuf		; de - address of Editor Line Buffer										;056b	11 e8 79 	. . y 
;; -- copy text from VRAM (Screen)  to Edit Buffer
;	push bc					; save bc - length of text													;056e	c5 	. 
;	ldir					; copy bc bytes from VRAM to Edit Buffer									;056f	ed b0 	. . 
;	pop bc					; restore bc - length of text												;0571	c1 	. 
;; -- set flag meaning BASIC INPUT Command is in progress
;	ld hl,SYSFLAGS			; hl - address of System Flags variable										;0572	21 39 78 	! 9 x 
;	set 4,(hl)				; set BASIC INPUT Command flag												;0575	cb e6 	. . 
;; -- create/update BASIC variable from text
;	call ReadLine			; Process text in Edit Buffer												;0577	cd e3 03 	. . . 
;	ret						; return 																	;057a	c9 	. 

 ;endif ; VER_12

; *********************************************************************************************************
; CONST TEXT USED BY AUTORUN FEATURE 
; *********************************************************************************************************
;TXT_RUN:            db "RUN",0      																	;057b	52 55 4e 00 	. 

; ifdef VER_12 
; ASSERT($=0x057f)
; endif


 


; ifdef VER_12
; *********************************************************************************************************
; --- unknown deprecated data or code – not used ----
; *********************************************************************************************************
; Probably garbage data or code left from previous versions of ROM
;	defb 019h
 



 ; ----------------- ROM 2.0 only --------------------------------------------------------------

 else ; VER_20

l048eh:
	ld a,(07818h)			; Check background color													;048e	3a 18 78 	: . x 
	or a					; 0 = green, 1 = black														;0491	b7 	. 
	jp z,l3e40h				; with green background go to 3E40H											;0492	ca 40 3e 	. @ > 
l0495h:
; -- transfer the data from the Screen to the I/0 buffer
	ld a,(hl)				; a - character from the Screen												;0495	7e 	~ 
	cp 64					; is it >= 64 - Graphic or Inverse char?									;0496	fe 40 	. @ 
	jp c,ParseScrChar		; no - proceed with Normal Char 											;0498	da ae 04 	. . . 
; -- if not INPUT, then Graphic or Inverse chars are only allowed in strings
	pop bc					; bc - length of Prompt Text												;049b	c1 	. 
	ld de,EditFailExit		; push Fail Exit routine address on the Stack								;049c	11 a4 04 	. . . 
	push de																								;049f	d5 	. 
	push bc					; push length of Prompt Text on the Stack									;04a0	c5 	. 
	jp l0502h				; Check end-of-text identification (or BREAK)								;04a1	c3 02 05 	. . . 
EditFailExit:
; -- Parsing failed but if BREAK was pressed we can ignore error
	ret c					; if BREAK was pressed go back to BASIC										;04a4	d8 	. 
; -- display SYNTAX ERROR on Screen
	ld hl,TXT_SYNTAXERROR	; hl - address of "SYNTAX ERROR" text 										;04a5	21 1a 3e 	! . > 
	call PrintBasicStr		; print 'SYNTAX ERROR' on Screen											;04a8	cd a7 28 	. . ( 
; -- go back to Editor and auire Statement from User
	jp ReadLine				; go back to Read Line as typed by User										;04ab	c3 e3 03 	. . . 



; Charcter on Screen is < 64 - NOT Graphiocs nor Inversed
; IN: a - character from Screen to parse
;     b - maximum number of characters (32 or 64)
;     hl - VRAM address where is parsed char
;     de - address of current location in Editor Line Buffer 
ParseScrChar:
	cp '"'					; is it start of String value??												;04ae	fe 22 	. " 
	jr nz,l04e3h			; no - continue																;04b0	20 31 	  1 
; -- start of quoted String found
	ld (de),a				; save '"' Character into Editor Buffer										;04b2	12 	. 
	inc hl					; hl points to next character on Screen										;04b3	23 	# 
	inc de					; de points to next location in Editor Buffer								;04b4	13 	. 
	dec b					; decrement max number of chars to parse									;04b5	05 	. 
	jr z,FinishParse		; if all parsed - go Finish copying text to Edit Buffer						;04b6	28 36 	( 6 

; Parsing content of quoted String
; IN: hl - address of char on Screen 
;     de - address of location in Editor Line Buffer
l04b8h:
	ld a,(hl)				; a - next character from Screen											;04b8	7e 	~ 
	cp 64					; is it >= 64 - Graphic or Inverse char?									;04b9	fe 40 	. @ 
	jp c,l04c9h				; no - proceed with Normal Char 											;04bb	da c9 04 	. . . 
; -- Graphic or Inverse char
	cp 128					; is it >= 128 - SemiGraphic char?											;04be	fe 80 	. . 
	jp c,l04c5h				; no - must be 	Inversed character											;04c0	da c5 04 	. . . 
; -- Semigraphic char - ignore Color bits 
	and %10001111			; clear color bits (6,5,4) in semigraphic character							;04c3	e6 8f 	. . 
l04c5h:
	or %10000000			; set bit 7 - flag for Semigraphic or Invered chars in String				;04c5	f6 80 	. . 
	jr l04dch				; store "in-string" character and process next ones							;04c7	18 13 	. . 

; Parsing content of quoted String - Normal char as Screen Code
l04c9h:
	cp '"'					; is it end of quoted String?												String limiter '"'?							;04c9	fe 22 	. " 
	jr nz,l04d6h			; no - convert to ASCII and store in Editor Buffer							;04cb	20 09 	  . 

; -- end of quoted String - check if we procesing text for BASIC INPUT Command
	push hl					; save hl - VRAM address of char											;04cd	e5 	. 
	ld hl,SYSFLAGS			; hl address of System Flags variable										;04ce	21 39 78 	! 9 x 
	bit 4,(hl)				; is bit 4 set? (BASIC INPUT Command in progress)							;04d1	cb 66 	. f 
	pop hl					; restore hl - VRAM address of char											;04d3	e1 	. 
	jr z,l04e3h				; no - continue parsing text as BASIC Statement or Line						;04d4	28 0d 	( . 
l04d6h:
; -- convert to ASCII if Screen code in range 00H..1Fh ('@'..'_')
	bit 5,a					; is bit 5 set? (code 20H..3FH)												;04d6	cb 6f 	. o 
	jr nz,l04dch			; yes - no need to convert - it's the same as ASCII 						;04d8	20 02 	  . 
	or $40					; add 40H to codes 00 - 1FH -> 41H..5FH - valid ASCII						;04da	f6 40 	. @ 


; store character in Edit Buffer and process next ones
l04dch:
	ld (de),a				; store character in Editor Line Buffer										;04dc	12 	. 
	inc hl					; hl points to next character on Screen										;04dd	23 	# 
	inc de					; de points to next location in Editor Buffer								;04de	13 	. 
	djnz l04b8h				; decrement max number of chars to parse									;04df	10 d7 	. . 
	jr FinishParse			; = 0, done										;04e1	18 0b 	. . 


; Parsing text as BASIC Statement or Line (no Inverse nor Semigraphics allowed)
l04e3h:
	bit 5,a					; is bit 5 set? (code 20H..3FH)												;04e3	cb 6f 	. o 
	jr nz,l04e9h			; yes - no need to convert - it's the same as ASCII 						;04e5	20 02 	  . 
	or $40					; add 40H to codes 00 - 1FH -> 41H..5FH - valid ASCII						;04e7	f6 40 	. @ 
l04e9h:
	ld (de),a				; store character in Editor Line Buffer										;04e9	12 	. 
	inc hl					; hl points to next character on Screen										;04ea	23 	# 
	inc de					; de points to next location in Editor Buffer								;04eb	13 	. 
	djnz l0495h				; decrement max number of chars to parse									;04ec	10 a7 	. . 

; Copying finished, complete buffer content
FinishParse:
; -- trim trailing spaces (if any)
	dec de					; de - points to last character inserted into Editor Buffer					;04ee	1b 	. 
; -- check if DE points to start of Editor Buffer (79E8H)
	ld a,d					; MSB of character address 													;04ef	7a 	z 
	cp $79					; is it same as MSB of Buffer address?										;04f0	fe 79 	. y 
	jr nz,l04fah			; no - test Space char in Buffer											;04f2	20 06 	  . 
	ld a,e					; LSB of character address 													;04f4	7b 	{ 
	cp $e8					; is DE < address of Editor Buffer?											;04f5	fe e8 	. . 
	jp c,l04ffh				; yes - done - put String Terminator (0) at the end							;04f7	da ff 04 	. . . 
l04fah:
; -- check if we have trailing space
	ld a,(de)				; a - character from Edit Buffer											;04fa	1a 	. 
	cp ' '					; is it Space char?															;04fb	fe 20 	.   
	jr z,FinishParse		; yes - continue trimming Spaces											;04fd	28 ef 	( . 

l04ffh:
; -- put String Terminator (0) at the end of trimmed text
	inc de					; de - address just after last char in Edit Buffer							;04ff	13 	. 
	xor a					; string terminator (0)														;0500	af 	. 
	ld (de),a				; store into Editor Line Buffer												;0501	12 	. 


l0502h:
; -- move Screen Cursor to line after text (1 or 2 lines down)
	call GetEditorLineFlag	; a - Editor Line Flag/Status pointed by hl									;0502	cd a8 33 	. . 3 
	ld hl,(CURSORADDR)		; hl - VRAM address of Screen Cursor										;0505	2a 20 78 	*   x 
	cp $81					; is Cursor in 1st line of two-line-statment?								;0508	fe 81 	. . 
	call SetCursorFromHL	; refresh Cursor Char at cursor position									;050a	cd 53 00 	. S . 
	jr nz,.advCursor		; no - it's single line	text - move 1 line only 							;050d	20 04 	  . 
; -- advance Screen Cursor to begining of next Screen Line 
	xor a					; a - control character 0													;050f	af 	. 
	call ScrPrintChar		; send character to Screen/Editor											;0510	cd 8b 30 	. . 0 
.advCursor:
; -- advance Screen Cursor to begining of next Screen Line
	xor a					; a - control character 0													;0513	af 	. 
	call ScrPrintChar		; send character to Screen/Editor											;0514	cd 8b 30 	. . 0 

; -- remove INVERSE mode from Keyboard State	
	ld a,(KEYSFLAGS)		; get Keyboard's current State 												;0517	3a 38 78 	: 8 x 
	and %11111101			; clear bit 1 - INVERSE Flag 												;051a	e6 fd 	. . 
	ld (KEYSFLAGS),a		; store modified Keyboard State back 										;051c	32 38 78 	2 8 x 

; -- check if User pressed BREAK key (canceled edit) 
	ld hl,SYSFLAGS			; hl - address of System Flags variable										;051f	21 39 78 	! 9 x 
	bit 2,(hl)				; is bit 2 set (BREAK Key pressed)?											;0522	cb 56 	. V 
	jr z,.commitState		; no - set state to Commit editsand continue  								;0524	28 05 	( . 
; -- set state to Abort edits - BREAK pressed
	ld a,1					; a=1 - BREAK key pressed													;0526	3e 01 	> . 
	scf						; set Carry Flag - Abort													;0528	37 	7 
	jr .skip				; skip setting state														;0529	18 01 	. . 
.commitState:
; -- set state to Commit edits - RETURN pressed
	xor a					; a=0 - no BREAK, Carry=0 - Commit											;052b	af 	. 
.skip:
; -- clear flag - BASIC INPUT Command is no longer in progress
	ld hl,SYSFLAGS			; hl - address of System Flags variable										;052c	21 39 78 	! 9 x 
	res 4,(hl)				; Reset INPUT Command flag													;052f	cb a6 	. . 
; -- set start of text inside Buffer
	ld hl,EditLineBuf		; address of Editor Line Buffer												;0531	21 e8 79 	! . y 
	pop bc					; length of Prompt text (in case INPUT was processed)						;0534	c1 	. 
	push af					; save Commit/Abort state on the Stack										;0535	f5 	. 
	add hl,bc				; add Prefix length - hl points to start of entered text					;0536	09 	. 
; -- make sure Buffer contains at least 1 char - add Space if needed and return  
	jp l3e29h				; chack Edit Buffer and correct if needed									;0537	c3 29 3e 	. ) > 

 endif ; VER_20

; *********************************************************************************************************
; COPY TEXT FROM SCREEN TO BUFFER AND TO INPUT 
; *********************************************************************************************************
; Part of the BASIC INPUT command routine reading a line into the Editor Line Buffer
; Maximum allowable text length is 64 characters. End of text is marked by 0 in buffer.
; OUT: hl - location prior to first character in Editor Buffer
;      CY=1 - Input was aborted by pressing BREAK key
GetUserInputText:
; -- Wait until entered text is completed (by RETURN) or aborted (by BREAK)
	ld a,(07aafh)			; a - number of characters in Edit Buffer left to process					;053a	3a af 7a 	: . z 
	or a					; is it 0 (buffer empty)?													;053d	b7 	. 
	jr nz,GetUserInputText			; no - wait for all chars copied											;053e	20 fa 	  . 
; -- clear BASIC Edit Line Buffer (64 chars)
	ld b,64					; buffer length - 64 chars 													;0540	06 40 	. @ 
	ld hl,EditLineBuf		; hl - address of Editor Line Buffer										;0542	21 e8 79 	! . y 
	ld a,' '				; a - Space char to fill buffer with										;0545	3e 20 	>   
.loop:
	ld (hl),a				; store Space char into buffer												;0547	77 	w 
	inc hl					; points to next char location in buffer									;0548	23 	# 
	djnz .loop				; fill all 64 bytes															;0549	10 fc 	. . 
; -- terminate text with byte 0
	xor a					; text terminator 0															;054b	af 	. 
	ld (hl),a				; store at the end of buffer												;054c	77 	w 
; -- correct Cursor Position if Cursor is on 2nd line of two-line-text
	call GetEditorLineFlag	; a - Editor Line Flag														;054d	cd a8 33 	. . 3 
	or a					; is it 2nd line of two-line-text?											;0550	b7 	. 
	ld a,(CURSORPOS)		; a - current position of Cursor in Edited line	(column)					;0551	3a a6 78 	: . x 
	jr nz,.skip				; it's not 2nd line - skip adjustment										;0554	20 02 	  . 
	add a,32				; add 32 to Cursor in text position (one screen line)						;0556	c6 20 	.   
.skip:
; -- calculate length of text based on Cursor position
	ld c,a					; c - Cursor position in line as length LSB 								;0558	4f 	O 
	xor a					; a = 0 as difference MSB													;0559	af 	. 
	ld b,a					; bc - text length - difference beetween Cursor and begining of 1st line	;055a	47 	G 
	ld hl,(CURSORADDR)		; absolute address of Cursor 												;055b	2a 20 78 	*   x 
; -- source address
	sbc hl,bc				; hl - absolute address of begining of text									;055e	ed 42 	. B 
; -- destination address 
	ld de,EditLineBuf		; de - address of Editor Line Buffer										;0560	11 e8 79 	. . y 
; -- copy text from VRAM (Screen)  to Edit Buffer
	push bc					; save bc - length of text													;0563	c5 	. 
	ldir					; copy bc bytes from VRAM to Edit Buffer									;0564	ed b0 	. . 
	pop bc					; restore bc - length of text												;0566	c1 	. 
; -- set flag meaning BASIC INPUT Command is in progress
	ld hl,SYSFLAGS			; hl - address of System Flags variable										;0567	21 39 78 	! 9 x 
	set 4,(hl)				; set BASIC INPUT Command flag												;056a	cb e6 	. . 
; -- create/update BASIC variable from text  
	call ReadLine			; Process text in Edit Buffer												;056c	cd e3 03 	. . . 
	ret						; return 																	;056f	c9 	. 


 


; *********************************************************************************************************
; CONST TEXT USED BY AUTORUN FEATURE 
; *********************************************************************************************************
; Text is copied to Edit buffer and executed when BASIC CRUN Command is used
TXT_RUN:            db "RUN",0      																	;0570	52 55 4e 	N 

 ifdef VER_20  
 	ASSERT($=0x0574) 
 endif
 ifdef VER_12  
 	ASSERT($=0x057f) 
 endif

; *********************************************************************************************************
; --- unknown deprecated data or code – not used ----
; *********************************************************************************************************
; Probably garbage data or code left from previous versions of ROM
 ifdef VER_12
	dh "19"					
 else ; VER_20	
	dh "c4 33 32"			; call nz,03233h - not used -												;0574	c4 33 32 	. 3 2 
	dh "cd a3 1a"			; call 01aa3h    - not used -												;0577	cd a3 1a 	. . . 
	dh "cd d8 17"			; call 017d8h	 - not used -												;057a	cd d8 17 	. . . 
	dh "cd 0d 19"			; call 0190dh	 - not used -												;057d	cd 0d 19 	. . . 

 endif
; ----------------- common code ---------------------------------------------------------------



; *********************************************************************************************************
; --- unknown deprecated data or code – not used ----
; *********************************************************************************************************
; Probably garbage data or code left from previous versions of ROM
	dh "ca 5a 12"			; jp z,0125ah																;0580	ca 5a 12 	. Z . 
	dh "cd 49 1f"			; call sub_1f49h															;0583	cd 49 1f 	. I . 
	dh "38 18"				; jr c,$+26																	;0586	38 18 	8 . 
	dh "ef"					; rst 28h																	;0588	ef 	. 
	dh "3a 38 04"			; ld a,(00438h)																;0589	3a 38 04 	: 8 . 
	dh "dd"					;illegal sequence															;058c	dd  	. y . 



; *********************************************************************************************************
; PRINTER DRIVER 
; *********************************************************************************************************
; Printer Device Handler routine 
; IN: ix - Device Control Block
;     b - operation
;     c - data to send (if 0 only request Printer Status)
;     [ix+3] - defined number of Lines per Page
;     [ix+4] - number of Lines already printed on this Page
PRN_DevHandler:			ASSERT( $ == 0x058d)
; -- test if send 0 - only get Printer Status
	ld a,c					; a - data to send															;058d	79 	y . 
	or a					; is this 0 - only request Printer Status									;058e	b7 	.  
	jr z,GetPrinterStatus	; yes - read Printer Status and return to caller							;058f	28 33 	( 3 

; -- test if send 0BH or 0CH - FormFeed is requested
	cp #0b					; is this FormFeed (0B) control char?										;0591	fe 0b 	. . 
	jr z,.formFeed			; yes - set New Page on Printer												;0593	28 0a 	( . 
	cp #0c					; is this FormFeed (0C) control char?										;0595	fe 0c 	. . 
	jr nz,.printChar		; no - print char															;0597	20 14 	  . 

; -- FormFeed - send multiple CR if Lines Per Page defined
	xor a					; a = 0 - char to print if no Lines Per Page defined						;0599	af 	. 
	or (ix+3)				; is Lines Per Page defined? (or continuous print)							;059a	dd b6 03 	. . . 
	jr z,.printChar			; no - send Control Char (0) directly to Printer							;059d	28 0e 	( . 
.formFeed:
; -- calculate how many lines we need to skip
	ld a,(ix+3)				; a - defined number of Lines per Page										;059f	dd 7e 03 	. ~ . 
	sub (ix+4)				; subtract number of lines already printed									;05a2	dd 96 04 	. . . 

; -- send multiple CR to make Form Feed
	ld b,a					; set as loop counter - number of CR to send to Printer						;05a5	47 	G 
.sendCRloop:
	call sub_3ae2h			; send CR to Printer 														;05a6	cd e2 3a 	. . : 
	djnz .sendCRloop		; repeat until Printer is at top of New Page (b times)						;05a9	10 fb 	. . 
	jr .clrLinesPrinted		; reset number of lines already printed on this Page to 0 and return		;05ab	18 12 	. . 

.printChar:
	call sub_3ab6h			; send Char from A to Printer												;05ad	cd b6 3a 	. . : 
; -- update number of printed Lines if CR was sent to Printer
	ld a,c					; a - last printed char														;05b0	79 	y 
	cp #0d					; is printed char was CR/LF (need increment Lines Printed counter)?			;05b1	fe 0d 	. . 
	ret nz					; no - return to caller --------------------------------------- 			;05b3	c0 	. 
; -- update number of lines printed on this Page
	inc (ix+4)				; increment number of printed lines											;05b4	dd 34 04 	. 4 . 
	ld a,(ix+4)				; a - number of printed lines												;05b7	dd 7e 04 	. ~ . 
	cp (ix+3)				; is this equal to number of defined lines per page?						;05ba	dd be 03 	. . . 
	ld a,c					; a - last printed char														;05bd	79 	y 
	ret nz					; no - return to caller with Printer Status ------------------- 			;05be	c0 	. 
.clrLinesPrinted:
	ld (ix+4),0				; set Number of Lines Printed on Page to 0									;05bf	dd 36 04 00 	. 6 . . 
	ret						; ------------------ End of Proc ------------------------------ 			;05c3	c9 	. 




; *********************************************************************************************************
; GET PRINTER STATUS 
; *********************************************************************************************************
; Read Printer hardware Port (00H) to get Status.
; OUT: a - Printer Status Busy (1) or Ready (0)
GetPrinterStatus:
	in a,($00)				; read Printer I/O Port - get Status										;05c4	db 00 	. . 
	and %00000001			; only bit 0 is valid - 0=ready, 1=busy										;05c6	e6 01 	. . 
	ret						; ---------- return Printer Status -------------------- 					;05c8	c9 	. 




; *********************************************************************************************************
; FILL PRINT BUFFER 
; *********************************************************************************************************
; Fill 4-byte Print Buffer for graphics printing with value given in A
; IN: a - byte/char to fill buffer with
FillPrnBuffer:
	push bc					; save bc																	;05c9	c5 	. 
	push hl					; save hl																	;05ca	e5 	. 
	ld b,4					; b - init byte counter to 4 bytes											;05cb	06 04 	. . 
	ld hl,PRINTBUFFER		; hl - address of Print Buffer to fill 										;05cd	21 d2 7a 	! . z 
.next:
	ld (hl),a				; put byte/char into buffer													;05d0	77 	w 
	inc hl					; hl points to next byte													;05d1	23 	# 
	djnz .next				; repeat until 4 bytes was filled											;05d2	10 fc 	. . 
	pop hl					; restore hl																;05d4	e1 	. 
	pop bc					; restore bc																;05d5	c1 	. 
	ret						; ------------------- End of Proc ---------------------------------			;05d6	c9 	. 



; *********************************************************************************************************
; HANDLE KEYBOARD ROLLOVER 
; *********************************************************************************************************
; Part of the keyboard query. Handles pressing a second key before the first one was released (rollover).
; In KEYS_STATE variable (7838H), bits 3 and 4 are used to flag the status of the two keyboard buffers
; KEYCODE1 (7836H) and KEYCODE2 (7837H):
;	bit4 bit3
;    0    0		both KEYCODE1 and KEYCODE2 are empty (no key pressed)
;    0    1		KEYCODE1 has a valid key pressed, KEYCODE2 is empty 
;    1    0		KEYCODE1 is empty, KEYCODE2 has a valid key pressed 
;    1    1		both KEYCODE1 and KEYCODE2 have a valid keys pressed 
; IN: a - KeyCode of pressed key 
;     e - byte value just read from Keyboard Matrix
; OUT:a - KeyCOde accepted or 0 if 
l05d7h:
	ld hl,KEYSFLAGS			; hl - address of Keyboard State variable									;05d7	21 38 78 	! 8 x 
	bit 2,(hl)				; is bit 2 set (Function Active)?					    					;05da	cb 56 	. V 
	jr z,.noFnActive		; no - ;05dc	28 15 	( . 

; -- keyboard Function is Active (Ctrl+RETURN was pressed just before)
	ld d,a			    	; d - save key detected 													;05de	57 	W 
	ld a,(KEYS_DEBOUNCER)	; a - debounce delay counter 												;05df	3a 3a 78 	: : x 
	or a					; is it 0 (key was detected just now)?										;05e2	b7 	. 
	jr z,l05f4h				; yes - store KeyCode to one of key buffer									;05e3	28 0f 	( . 

; -- process debounce key - check if delay time elapsed: PAL - 0.84 sec., NTSC - 0.7 sec.
	inc a					; increment delay counter (once per frame)									;05e5	3c 	< 
	ld (KEYS_DEBOUNCER),a	; update debounce delay counter												;05e6	32 3a 78 	2 : x 
	cp 42					; is it 42 frames (0.84|0.7 sek.)?											;05e9	fe 2a 	. * 
	jr z,.exitClear			; yes - clear Function Active flag and return with no key					;05eb	28 02 	( . 
; -- ignore until delay elapsed
	xor a					; a - 0 - no valid key pressed (yet)										;05ed	af 	. 
	ret						; ----------------------- End of Proc -----------------------------------	;05ee	c9 	. 
.exitClear:
	res 2,(hl)				; clear Function Active flag in KEYSFLAGS variable							;05ef	cb 96 	. . 
	xor a					; a - 0 - no valid key pressed (yet)										;05f1	af 	. 
	ret						; ----------------------- End of Proc -----------------------------------	;05f2	c9 	. 

.noFnActive:
; -- keyboard Function is NOT Active (Ctrl+RETURN wasn't pressed just before)
	ld d,a					; d - save key detected 													;05f3	57 	W 

l05f4h:
; -- store KeyCode to one of 2 key buffers: KEYCODE1 or KEYCODE2
	ld hl,KEYSFLAGS			; hl - address of Keyboard State variable									;05f4	21 38 78 	! 8 x 
	ld a,(hl)				; a - Keyboard Flags														;05f7	7e 	~ 
	and %00011000			; test bit 3 and 4 - any of Key Buffers contains KeyCode? 					;05f8	e6 18 	. . 
	jr nz,l0607h			; yes - ;05fa	20 0b 	  . 
; -- both KEYCODE1 and KEYCODE2 are empty - store new key code in KEYCODE1
	set 3,(hl)				; set Flag - KEYCODE1 contains valid key code								;05fc	cb de 	. . 
	xor a					; a = 0 - no key code														;05fe	af 	. 
	ld (KEYCODE2),a			; clear 2nd Key buffer														;05ff	32 37 78 	2 7 x 
; -- store new Key Code in 1st Key Buffer
	ld a,d					; a - key detected															;0602	7a 	z 
	ld (KEYCODE1),a			; store detected key in 1st Key Buffer										;0603	32 36 78 	2 6 x 
	ret						; ----------------------- End of Proc -----------------------------------	;0606	c9 	. 
l0607h:
	bit 4,(hl)		    	; is bit 4 set (KEYCODE2 has value)? 										;0607	cb 66 	. f 
	jr nz,l0635h			; yes - ;0609	20 2a 	  * 

; -- Key Buffer KEYCODE2 is empty, KEYCODE1 has value - 
	ld a,(KEYCODE1)			; a - key stored before in 1st buffer										;060b	3a 36 78 	: 6 x 
	cp d					; is the same as just detected?												;060e	ba 	. 
	jr nz,.storeNewInB2		; no - new key detected	- store new Key Code in KEYCODE2					;060f	20 21 	  ! 
; -- detected key is the same as before - scan for other keys
	ld bc,(KEYS_SCAN_COORDS); bc - currently scanned Row and Column counters							;0611	ed 4b 42 78 	. K B x 
	ld hl,(KEYS_SCAN_ROWADR); hl - currently scanned Keyboard Matrix address							;0615	2a 44 78 	* D x 
	ld a,e					; a - value just read from Keyboard Matrix									;0618	7b 	{ 
	call sub_2f35h			; continue scan Keyboard Matrix from point where it was stopped 			;0619	cd 35 2f 	. 5 / 
	cp d					; is the same as before?													;061c	ba 	. 
	jp z,l2fd7h				; yes - try confim key pressed												;061d	ca d7 2f 	. . / 
	cp 0					; no more keys detected?													;0620	fe 00 	. . 
	jp z,l2fd7h				; yes - try confim key pressed												;0622	ca d7 2f 	. . / 

; -- IN: a = new key press detected
.storeInB2:
; -- store new Key Code in KEYCODE2 - update KEYSFLAGS
	ld hl,KEYSFLAGS			; hl - address of Keyboard State variable									;0625	21 38 78 	! 8 x 
	set 3,(hl)		    	; set bit 3 - KEYCODE1 has stored Key Code 									;0628	cb de 	. . 
	set 4,(hl)		    	; set bit 4 - KEYCODE2 has stored Key Code 									;062a	cb e6 	. . 
	res 2,(hl)		    	; clear bit 2 - inactive Keyboard Function Mode 							;062c	cb 96 	. . 
	ld (KEYCODE2),a			; put Key Code into 2nd Buffer 												;062e	32 37 78 	2 7 x 
	ret						; ----------------------- End of Proc -----------------------------------	;0631	c9 	. 

.storeNewInB2:
; -- store new Key Code in KEYCODE2
	ld a,d					; a - key detected															;0632	7a 	z 
	jr .storeInB2			; store Key Code in KEYCODE2 												;0633	18 f0 	. . 


l0635h:
; -- Key Buffer KEYCODE1 has value (if?) KEYCODE2 has value - 
	ld a,(KEYCODE1)			; a - Key Kode stored before in 1st Buffer									;0635	3a 36 78 	: 6 x 
	cp d					; is the same as detected?													;0638	ba 	. 
	jr z,l0643h				; yes - ;0639	28 08 	( . 
	ld a,(KEYCODE2)			; a - Key Kode stored before in 1st Buffer									;063b	3a 37 78 	: 7 x 
	cp d					; is the same as detected?													;063e	ba 	. 
	jr z,l0643h				; yes - ;063f	28 02 	( . 
; -- new Key Code is 3rd Key pressed - ignore it
	xor a					; return value - no key pressed												;0641	af 	. 
	ret						; ----------------------- End of Proc -----------------------------------	;0642	c9 	. 
l0643h:
; -- detected key is the same as before - scan for other keys
	ld bc,(KEYS_SCAN_COORDS); bc - currently scanned Row and Column counters							;0643	ed 4b 42 78 	. K B x 
	ld hl,(KEYS_SCAN_ROWADR); hl - currently scanned Keyboard Matrix address							;0647	2a 44 78 	* D x 
	ld a,e					; a - value just read from Keyboard Matrix									;064a	7b 	{ 
	call sub_2f35h			; continue scan Keyboard Matrix from point where it was stopped 			;064b	cd 35 2f 	. 5 / 
	cp d					; is the same as before?													;064e	ba 	. 
	jr z,l0656h				; yes - try confim key pressed												;064f	28 05 	( . 
	cp 0					; no more keys detected?													;0651	fe 00 	. . 
	jp nz,l2fd7h			; yes - try confim key pressed												;0653	c2 d7 2f 	. . / 
l0656h:
	ld hl,KEYSFLAGS			; hl - address of Keyboard State variable									;0656	21 38 78 	! 8 x 
	set 3,(hl)		    	; set bit 3 - KEYCODE1 has stored Key Code 									;0659	cb de 	. . 
	res 4,(hl)		    	; clear bit 4 - KEYCODE2 is empty		 									;065b	cb a6 	. . 
	ld a,(KEYCODE1)			; a - key code stored before												;065d	3a 36 78 	: 6 x 
	cp d					; is the same as detected?													;0660	ba 	. 
	jr nz,.move				; no - move KEYCODE2 to KEYCODE1 and clear KEYCODE2							;0661	20 05 	  . 
.clearB2:
	xor a					; a - return value - no key pressed											;0663	af 	. 
	ld (KEYCODE2),a			; clear 2nd buffer															;0664	32 37 78 	2 7 x 
	ret						; ----------------------- End of Proc -----------------------------------	;0667	c9 	. 
.move:
	ld a,(KEYCODE2)			; a - previous Key Code stored in 2nd buffer								;0668	3a 37 78 	: 7 x 
	ld (KEYCODE1),a			; move to 1st buffer														;066b	32 36 78 	2 6 x 
	jr .clearB2				; go clear 2nd buffer														;066e	18 f3 	. . 



; *********************************************************************************************************
; --- unknown deprecated data or code – not used ----
; *********************************************************************************************************
; Probably garbage data or code left from previous versions of ROM

	dh "dd cb 09 d6"			; unknown unused data													;0670	dd cb 09 d6 	. . . . 





; *********************************************************************************************************
; SYSTEM INITIALIZATION ROUTINE - POWER UP
; *********************************************************************************************************
; Initialize DCBs (Device Control Blocs), RCA BASIC values and Self Modified Code (SMC) routines.
SysInit:
	nop	: nop					; [TRS] out (FFH),a - clear I/O register for video/cassette (click)		;0675	00 	. 


; -- copy default values defined in ROM (06D2H..0707H) to RCA Area (7800H..7835H)
; -- repeated 128 times - probably  to ensure corectness (or to provide delay for other components stabilization).
.loop:
	ld hl,VectorsAndDCBInitData	; hl - address of default values of Vectors and DCBs (source)			;0676	21 d2 06 	! . . 
	ld de,RAMCommArea			; de - address of RAM Communication Area (destination)					;0679	11 00 78 	. . x 
	ld bc,54					; bc - size of block to copy (54 bytes)									;067c	01 36 00 	. 6 . 
	ldir						; bulk copy 54 bytes													;067f	ed b0 	. . 
	dec a						; decrement loop counter												;0681	3d 	= 
	dec a						; decrement loop counter												;0682	3d 	= 
	jr nz,.loop					; repeat copy 128 times													;0683	20 f1 	  . 

; -- clear RCA Area (7836H-785CH) - Variables for Keyboard, Cursor, etc
; IN: a - value to fill with = 0 
;     de - destination address = 7836
BAS_ResetClear:
	ld b,39						; size of memory block to clear (39 bytes)								;0685	06 27 	. ' 
.loop:
	ld (de),a					; store 0 																;0687	12 	. 
	inc de						; increment destination address											;0688	13 	. 
	djnz .loop					; repeat 39 times														;0689	10 fc 	. . 

; -- continue System Initialization
	jp BasicInit				; initialize RCA BASIC variables 										;068b	c3 75 00 	. u . 




; *********************************************************************************************************
; CARTRIDGES TEST AND INITIALIZATION ROUTINE
; *********************************************************************************************************
; Check Cartridges if they exists at defined Memory Slots: $4000, $6000 and $8000
; If valid Cartrighe is detected then 

SysCartTest:
	ld hl,$4000					; hl - address of First Cart Slot (DOS)									;068e	21 00 40 	! . @ 
	call SysCartInit			; Init Cart if exists													;0691	cd a4 06 	. . . 
	ld hl,$6000					; hl - address of Second Cart Slot (Other Devices)						;0694	21 00 60 	! . ` 
	call SysCartInit			; Init Cart if exists													;0697	cd a4 06 	. . . 
	ld hl,$8000					; hl - address of Third Cart Slot (Game)								;069a	21 00 80 	! . . 
	call SysCartInit			; Init Cart if exists													;069d	cd a4 06 	. . . 
; -- all cartridges tested and initialized  
	ei							; enable interrupt 														;06a0	fb 	. 
	jp BasicREADY				; jump to Basic Ready and display prompt to user 	          			;06a1	c3 19 1a 	. . . 

; -- validate Cartridge Header Sequence: AA 55 E7 18
SysCartInit:
	ld a,$aa					; 1st byte of Cart Signature AA											;06a4	3e aa 	> . 
	cp (hl)						; is expected value?													;06a6	be 	. 
	inc hl						; address of 2nd byte													;06a7	23 	# 
	ret nz						; no - end of proc														;06a8	c0 	. 
	cpl							; 2nd byte of Cart Signature 55 (AA inverted)							;06a9	2f 	/ 
	cp (hl)						; is expected value														;06aa	be 	. 
	inc hl						; address of 3rd byte													;06ab	23 	# 
	ret nz						; no - end of proc 														;06ac	c0 	. 
	ld a,$e7					; 3rd byte of Cart Signature E7											;06ad	3e e7 	> . 
	cp (hl)						; is expected value														;06af	be 	. 
	inc hl						; address of 4th byte													;06b0	23 	# 
	ret nz						; no - end of proc														;06b1	c0 	. 
	cpl							; 4th byte of Cart Signature 18 (E7 inverted)							;06b2	2f 	/ 
	cp (hl)						; is expected value														;06b3	be 	. 
	inc hl						; address of Init Routine on Cart										;06b4	23 	# 
	ret nz						; no - end of proc 														;06b5	c0 	. 
	ei							; enable interrupts														;06b6	fb 	. 
	jp (hl)						; Initialize Cartridge													;06b7	e9 	. 



; ********************************************************************************************
; --- unknown deprecated data or code – not used ----
; ********************************************************************************************

	ld c,002h		;06b8	0e 02 	. . 
	call 01a59h		;06ba	cd 59 1a 	. Y . 
	call 034b8h		;06bd	cd b8 34 	. . 4 
	call sub_18e3h		;06c0	cd e3 18 	. . . 
	jr z,BAS_ResetClear		;06c3	28 c0 	( . 
	rst 28h			;06c5	ef 	. 
	inc l			;06c6	2c 	, 
	jr z,$+22		;06c7	28 14 	( . 
	call 034f1h		;06c9	cd f1 34 	. . 4 


; *********************************************************************************************************
; ALTERNATIVE RE-ENTRY POINT ITO BASIC
; *********************************************************************************************************
; Re-entry point to BASIC
BAS_ReEntry:
	ld bc,BAS_ReadyPopBC	; address of routine BasicREADY (with pop bc)							;06cc	01 18 1a 	. . . 
	jp BasicEntryPoint		; set BasicREADY as exit initialize BASIC variables						;06cf	c3 ae 19 	. . . 




; *********************************************************************************************************
; RCA INIT DATA
; *********************************************************************************************************
; Default values for System Variables (RAM Communication Adresses) at $7800 - $7835  
VectorsAndDCBInitData:
; -- Default RST Vectors 
	jp AssertToken		    ; [$7800] called by RST 08 												;06d2	c3 96 1c 	. . . 
	jp NextToken			; [$7803] called by RST 10												;06d5	c3 78 1d 	. x . 
	jp CmpHLDE		        ; [$7806] called by RST 18												;06d8	c3 90 1c 	. . . 
	jp TestNTF			    ; [$7809] called by RST 20												;06db	c3 d9 25 	. . % 
	ret : nop : nop			; [$780c] called by RST 28	[TRS] (jump to 4BA2H for DOS)				;06de	c9 	. 
	ret : nop : nop			; [$780f] called by RST 30	[TRS] (jump to 44B4H for DOS)				;06e1	c9 	. 
	ei  : ret : nop			; [$7812] 					[TRS] (jump to 4518H for DOS)				;06e4	fb 	. 

; -- Default Keyboard DCB (Device Control Block) at $7815 - $781c
	dg .......1				; [$7815] Device Capabilities = 1 (read only)							;06e7	01
	dw KBD_DevHandler		; [$7816] Device Handler Address										;06e8	f4 2e 	. . . 
	db 0					; [$7818] Key Inverse Screen (TODO)										;06ea	00 	. 
	db 0					; [$7819] Key Inverse Typing (TODO)										;06eb	00 	. 
	db 0					; [$781a] TRS 0 (in Model III, time counting byte for blinking cursor)	;06ec	00 	. 
	db "KI"					; [$781b] Device Id (Keyboard Input)									;06ed	4b 49	K I

; -- Default Video DCB (Device Control Block) at $781d - $7824 (used partially by ROM 1.2)
	dg ........				; [$781d] Device Capabilities = 0 (none)								;06ef	00 	. 
	dw $0000				; [$781e] Device Handler Address (not exists)							;06f0	00 00	. 
	dw VRAM					; [$7820] Cursor VRAM Address 											;06f2	00 70	. 
	db 0					; [$7822] Device Custom Data Byte (not used)							;06f4	00 	. 
	dw $0000				; [$7823] Device Id (none)	(used as TapeDataChecksum)					;06f5	00 00 	. 

; -- Default Printer DCB (Device Control Block) at $7825 - $782c
	dg .....11.				; [$7825] Device Capabilities = 6 (write only)							;06f7	06 	. . 
	dw PRN_DevHandler		; [$7826] Device Handler Address										;06f8	8d 05 	. 
	db 67					; [$7828] LinesPerPage													;06fa	43 	C 
	db 0					; [$7829] LinesPrinted													;06fb	00 	. 
	db 0					; [$782a] CharsInLinePrinted (not used by ROM 1.2)						;06fc	00 	. 
	db "PR"					; [$782b] DeviceId (Printer)											;06fd	50 52	P R

; DOS Vectors (???)
	jp $5000				; [$782d] DOS ReEntry Jump												;06ff	c3 00 50 	. . P 
	rst 0 : nop : nop		; [$7830] Abnormal DOS ReEntry											;0702	c7 00 00	. 
	ld a,0 : ret			; [$7833] DOS Device Vectoring Routine									;0705	3e 00 	> . 
;---------------------------------------------------------------------------------------
							ASSERT( 54 == $ - VectorsAndDCBInitData)
;---------------------------------------------------------------------------------------


; *********************************************************************************************************
; SINGLE PRECISION ADDITION 0.5 TO ACC
; *********************************************************************************************************
; Math : ACC = ACC + 0.5 (Single)
sngACCadd05:
	ld hl,sngConst_05		; Constant Value 0.5 (Single)              								;0708	21 80 13 	! . . 

; *********************************************************************************************************
; SINGLE PRECISION ADDITION
; *********************************************************************************************************
; Math : ACC = (HL) + ACC (Single)
sngHLaddACC_DBL:
	call HLToBCDE	 		; Copy value from (HL) to BCDE (Single)   								;070b	cd c2 09 	. . . 
	jr sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 			;070e	18 06 	. . 


; *********************************************************************************************************
; SINGLE PRECISION SUBTRACTION
; *********************************************************************************************************
; Math : ACC = (HL) - ACC (Single)
sngHLsubACC_DBL:
	call HLToBCDE			; Copy value from (HL) to BCDE (Single)  								;0710	cd c2 09 	. . . 


; *********************************************************************************************************
; SINGLE PRECISION SUBTRACTION
; *********************************************************************************************************
; Math : ACC = BCDE - ACC (Single)
sngBCDEsubACC_DBL:
	call sngACCnegate		; ACC = -ACC (Single) 													;0713	cd 82 09 	. . . 


; *********************************************************************************************************
; SINGLE PRECISION ADDITION
; *********************************************************************************************************
; Math : ACC = BCDE + ACC (Single)
sngBCDEaddACC_DBL:
; -- test if BCDE == 0 - adding 0 doesn't change ACC
	ld a,b					; a - Exponent of BCDE value											;0716	78 	x 
	or a					; is it 0 (means BCDE value == 0)										;0717	b7 	. 
	ret z					; return (result already in ACC)										;0718	c8 	. 
; -- test if ACC == 0 - no addition needed just copy BCDE to ACC
	ld a,(MATH_ACC_EXP)		; a - Exponent of ACC value												;0719	3a 24 79 	: $ y 
	or a					; is it 0 (means ACC value == 0)										;071c	b7 	. 
	jp z,BCDEToACC_DBL		; skip addition code - copy value from BCDE to ACC (Single)				;071d	ca b4 09 	. . . 
; -- compare Exponents - calkulate difference in magnitude
	sub b					; subtract/compare Exponets (ACC < BCDE)?								;0720	90 	. 
	jr nc,.skipSwap			; yes - skip swap														;0721	30 0c 	0 . 
; -- negate Exponents difference (make it positive)
	cpl						; flip bits																;0723	2f 	/ 
	inc a					; add 1 - it makes negate 8 bit value									;0724	3c 	< 
; -- swap ACC and BCDE values
	ex de,hl				; save de register (will be used by Push routine)						;0725	eb 	. 
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)									;0726	cd a4 09 	. . . 
	ex de,hl				; restore de register													;0729	eb 	. 
	call BCDEToACC_DBL		; copy BCDE value to ACC (Single)										;072a	cd b4 09 	. . . 
	pop bc					; get bc from stack														;072d	c1 	. 
	pop de					; now BCDE has Single value from Stack (previous ACC)					;072e	d1 	. 
.skipSwap:
; -- if Exp difference is bigger than 24 the values cannot be added 
	cp 25					; is diff > 24															;072f	fe 19 	. . 
	ret nc					; yes - adding BCDE won't change ACC - result ready						;0731	d0 	. 
; -- compare ACC and BCDE signs
	push af					; save Exp difference on Stack											;0732	f5 	. 
	call MAT_sCmpSetSign	; compare signs - bit 7 of a = 1 if ACC and BCDE have same sign			;0733	cd df 09 	. . . 
	ld h,a					; h - save result of sign comparision									;0736	67 	g 
	pop af					; rstore Exponents difference											;0737	f1 	. 
; -- line up ACC and BCDE values to the same magnitude
	call sub_07d7h			; roll BCDE right by difference (align magnitudes)						;0738	cd d7 07 	. . . 
; -- after roll register b contains bits shifted out from register e
	or h					; are signs equal? (both positive or negative)							;073b	b4 	. 
	ld hl,ACC_SNG	 		; hl - address of Single value in ACC (4 bytes): 						;073c	21 21 79 	! ! y 
	jp p,l0754h				; jump if signs are different - perform subtraction of mantissas		;073f	f2 54 07 	. T . 
; -- signs are the same - perform addition
	call sub_07b7h			; add 24 bit mantisa values of [hl] and BCDE							;0742	cd b7 07 	. . . 
	jp nc,l0796h			; jump if no Carry from 24bit addition									;0745	d2 96 07 	. . . 
; -- Carry from 24bit add - increment Exponent of ACC
	inc hl					; hl - address of ACC Exponent											;0748	23 	# 
	inc (hl)				; increment Exponent													;0749	34 	4 
	jp z,ErrRaiseOverflow	; if Exp rollover to 0 Raise OVERFLOW Error								;074a	ca b2 07 	. . . 
; -- Carry from 24bit add - shift right Mantissa of ACC
	ld l,1					; l = shift by 1 bit 													;074d	2e 01 	. . 
	call sub_07ebh			; shift Mantissa of ACC by 1 bit										;074f	cd eb 07 	. . . 
	jr l0796h		;0752	18 42 	. B 


l0754h:
; -- signs are different - subtraction of the 24bit mantissas
	xor a					; a - 0 value 															;0754	af 	. 
	sub b					; a = 0 - b																;0755	90 	. 
	ld b,a					; store back b = -b														;0756	47 	G 
	ld a,(hl)				; a - LSB of Single value in ACC 										;0757	7e 	~ 
	sbc a,e					; subtract LSB of Single value in BCDE									;0758	9b 	. 
	ld e,a					; store back into e														;0759	5f 	_ 
	inc hl					; hl - points to middle byte of value in ACC							;075a	23 	# 
	ld a,(hl)				; a - middle byte														;075b	7e 	~ 
	sbc a,d					; subtract middle byte of value in BCDE									;075c	9a 	. 
	ld d,a					; store back into d														;075d	57 	W 
	inc hl					; hl - points to MSB of value in ACC						 			;075e	23 	# 
	ld a,(hl)				; a - MSB of Single value in ACC										;075f	7e 	~ 
	sbc a,c					; subtract MSB of Single value in BCDE									;0760	99 	. 
	ld c,a					; store back into c														;0761	4f 	O 
l0762h:
	call c,sub_07c3h		; if CY make mantissa negative 											;0762	dc c3 07 	. . . 


; Normalize mantisa extended to 32 bits - CDEB
l0765h:
	ld l,b					; l - Extended LSB of mantissa											;0765	68 	h 
	ld h,e					; h - LSB of Mantissa - now mantisa is packed in CDHL					;0766	63 	c 
; -- if possible shift 8 bit at once
	xor a					; shift counter/exponent difference  = 0								;0767	af 	. 
l0768h:
	ld b,a					; b - current value of exponent diff									;0768	47 	G 
	ld a,c					; a - MSB of mantissa													;0769	79 	y 
	or a					; is it 0 (can be reduced)?												;076a	b7 	. 
	jr nz,l0785h			; no - go normalize 1 bit at the time									;076b	20 18 	  . 
; -- shift left mantissa by 8bit (1byte) at once
	ld c,d					; c - middle byte of mantissa to MSB 									;076d	4a 	J 
	ld d,h					; d - LSB of mantissa to middle byte									;076e	54 	T 
	ld h,l					; h - extended LSB of 32bit mantissa to LSB								;076f	65 	e 
	ld l,a					; l - new extended LSB = 0												;0770	6f 	o 
	ld a,b					; a - current exponent 													;0771	78 	x 
	sub 8					; subtract 8 - number of 'decimal' places we shifted mantissa			;0772	d6 08 	. . 
	cp $e0					; is it -32? (we shifted 32 bits and mantissa equals 0)?				;0774	fe e0 	. . 
	jr nz,l0768h			; no - try again to shift 8 bits at once								;0776	20 f0 	  . 



; *********************************************************************************************************
; SINGLE PRECISION SET ZERO
; *********************************************************************************************************
; Math : ACC = 0 (Single or Double)
; Sets ACC value to 0. Normalized Single or Double Floating Point Number has Exponent set to 0 
; and values stored as Mantissa don't matter. 
MAT_sdSetACC_0:
	xor a					; value of Exponent of Single value equals 0							;0778	af 	. 
l0779h:
	ld (MATH_ACC_EXP),a		; store Exponent = 0													;0779	32 24 79 	2 $ y 
	ret						; return 																;077c	c9 	. 


; -- part of Floating Point Number normalization - 1bit at the time
l077dh:
	dec b					; decrement Exponent by 1												;077d	05 	. 
	add hl,hl				; shift left == multiply by 2 kow 16bit of CDHL							;077e	29 	) 
	ld a,d					; a - middle byte of mantissa											;077f	7a 	z 
	rla						; shift left == mul by 2 middle byte									;0780	17 	. 
	ld d,a					; store back as middle byte												;0781	57 	W 
	ld a,c					; a - MSB of mantissa													;0782	79 	y 
	adc a,a					; shift left == mul by 2 MSB											;0783	8f 	. 
	ld c,a					; store back as MSB														;0784	4f 	O 
l0785h:
	jp p,l077dh				; continue if bit7 of MSB is 0 - can be reduced							;0785	f2 7d 07 	. } . 
; -- 
	ld a,b					; a - Exponent correction (negative number of shifted bits)				;0788	78 	x 
	ld e,h					; e - LSB of CDHL - 32bit mantissa										;0789	5c 	\ 
	ld b,l					; now CDHL is stored back to CDEB										;078a	45 	E 
l078bh:
	or a					; is Exponent correction = 0? (no bits shifted) 						;078b	b7 	. 
	jr z,l0796h				; yes - skip exponnent correction 										;078c	28 08 	( . 
; -- correct Exponent of Single Value in ACC before storing Mantissa
	ld hl,MATH_ACC_EXP		; hl - address of ACC Exponent											;078e	21 24 79 	! $ y 
	add a,(hl)				; add Exponent of current value											;0791	86 	. 
	ld (hl),a				; store back modified Exponent of new Value								;0792	77 	w 
	jr nc,MAT_sdSetACC_0	; if Uunderflow go set ACC value to 0									;0793	30 e3 	0 . 
	ret z					; if sored Exponent = 0 we done - ACC value is already 0				;0795	c8 	. 
l0796h:
	ld a,b					; a - Extended LSB of 32bit mantissa									;0796	78 	x 
l0797h:
	ld hl,MATH_ACC_EXP		; hl - address of ACC Exponent											;0797	21 24 79 	! $ y 
	or a					; test bit 7 of Ext LSB - the only bit matters 							;079a	b7 	. 
	call m,sub_07a8h		; if bit 7=1 round up 24bit mantissa (CDE)								;079b	fc a8 07 	. . . 
	ld b,(hl)				; b - Exponent of ACC value												;079e	46 	F 
	inc hl					; hl - address of ACC MSB (having sign bit)								;079f	23 	# 
	ld a,(hl)				; a - MSB with Sign bit													;07a0	7e 	~ 
	and %10000000			; isolate Sign bit														;07a1	e6 80 	. . 
	xor c					; xor with Sign bit from CDE mantissa									;07a3	a9 	. 
	ld c,a					; store back as Mantissa MSB (CDE)										;07a4	4f 	O 
	jp BCDEToACC_DBL		; copy value from BCDE to ACC (Single)									;07a5	c3 b4 09 	. . . 



; *********************************************************************************************************
; SINGLE PRECISION ROUNDUP 24BIT VALUE (CDE)
; *********************************************************************************************************
; Increment by 1 value stored in CDE (24bit) with Overflow detection.
sub_07a8h:
	inc e					; increment LSB of 24bit value											;07a8	1c 	. 
	ret nz					; return if not 0 														;07a9	c0 	. 
	inc d					; increment middle byte													;07aa	14 	. 
	ret nz					; return if not 0														;07ab	c0 	. 
	inc c					; increment MSB of 24bit value											;07ac	0c 	. 
	ret nz					; return if not 0														;07ad	c0 	. 
; -- MSB was = ff so force negative mantissa and increment Exponent
	ld c,$80				; set Sign bit to 1 (negative)											;07ae	0e 80 	. . 
	inc (hl)				; increment ACC Exponent by 1											;07b0	34 	4 
	ret nz					; return if not 0 - otherwise it is Overflow							;07b1	c0 	. 



; *********************************************************************************************************
; RAISE OVERFLOW ERROR
; *********************************************************************************************************
ErrRaiseOverflow:
	ld e,#0a				; ERROR 0A - OVERFLOW													;07b2	1e 0a 	. . 
	jp ErrRaiseError		; Raise OVERFLOW Error													;07b4	c3 a2 19 	. . . 



; *********************************************************************************************************
; SINGLE PRECISION ADD 24BIT VALUES (CDE + [hl])
; *********************************************************************************************************
; Add Mantissas (24bit) of two Single Values: CDE = CDE + [hl]
sub_07b7h:
; add 24 bit mantisa values of [hl] and BCDE
	ld a,(hl)				; a - LSB of 24bit value from [hl] 										;07b7	7e 	~ 
	add a,e					; add LSB of 24bit value from CDE										;07b8	83 	. 
	ld e,a					; store back as LSB														;07b9	5f 	_ 
	inc hl					; hl - point to middle byte												;07ba	23 	# 
	ld a,(hl)				; a - middle byte of 24bit value										;07bb	7e 	~ 
	adc a,d					; add middle byte of CDE value											;07bc	8a 	. 
	ld d,a					; store back as middle byte												;07bd	57 	W 
	inc hl					; hl - point to MSB														;07be	23 	# 
	ld a,(hl)				; a - MSB of 24bit value from [hl]										;07bf	7e 	~ 
	adc a,c					; add MSB of CDE value													;07c0	89 	. 
	ld c,a					; store back as MSB														;07c1	4f 	O 
	ret						; return with result in CDE plus CPU flags								;07c2	c9 	. 


	
sub_07c3h:
	ld hl,MATH_ACC_SIGN		;07c3	21 25 79 	! % y 
	ld a,(hl)			;07c6	7e 	~ 
	cpl			;07c7	2f 	/ 
	ld (hl),a			;07c8	77 	w 
	xor a			;07c9	af 	. 
	ld l,a			;07ca	6f 	o 
	sub b			;07cb	90 	. 
	ld b,a			;07cc	47 	G 
	ld a,l			;07cd	7d 	} 
	sbc a,e			;07ce	9b 	. 
	ld e,a			;07cf	5f 	_ 
	ld a,l			;07d0	7d 	} 
	sbc a,d			;07d1	9a 	. 
	ld d,a			;07d2	57 	W 
	ld a,l			;07d3	7d 	} 
	sbc a,c			;07d4	99 	. 
	ld c,a			;07d5	4f 	O 
	ret			;07d6	c9 	. 


; Roll BCDE right
; IN: BCDE - single value 
;     a - number of bits 
; OUT: a - status
;     CY - status:  
sub_07d7h:
	ld b,0					; b = 0 - bits will be shifted info CDE Mantissa						;07d7	06 00 	. . 
.next8bits:
	sub 8					; sub 8 bits - can we just move byte by byte?							;07d9	d6 08 	. . 
	jr c,.rollBits			; no - roll by less than 8 bits											;07db	38 07 	8 . 
; -- roll right BCDE by 8 bits
	ld b,e					; shift right register e into register b								MSB;07dd	43 	C 
	ld e,d					; shift right register d into register e								;07de	5a 	Z 
	ld d,c					; shift right register c into register d								;07df	51 	Q 
	ld c,0					; shift in 8 bits (0) into register c									;07e0	0e 00 	. . 
	jr .next8bits			; continue rolling BCDE													;07e2	18 f5 	. . 
.rollBits:
	add a,9					; rollback "sub 8" above and add 1 (to compensate dec l checking)		;07e4	c6 09 	. . 
	ld l,a					; l - number of bits to roll BCDE										;07e6	6f 	o 
.next1bit:
	xor a					; a - return value;07e7	af 	. 
	dec l					; decrement loop counter - number of roll to do							;07e8	2d 	- 
	ret z					; all done - return														;07e9	c8 	. 
	ld a,c					; a - MSB of Mantissa (24bit)											;07ea	79 	y 
sub_07ebh:
; roll right 24bit Mantissa of BCDE by number of bit stored in l
	rra						; roll right MSB														;07eb	1f 	. 
	ld c,a					; store back rolled MSB value											;07ec	4f 	O 
	ld a,d					; a - middle byte 														;07ed	7a 	z 
	rra						; roll right middle byte (shift in bit fallen from MSB)					;07ee	1f 	. 
	ld d,a					; store back rolled middle byte											;07ef	57 	W 
	ld a,e					; a - LSB value															;07f0	7b 	{ 
	rra						; roll right LSB byte (shift in bit fallen from middle byte)			;07f1	1f 	. 
	ld e,a					; store back rolled LSB													;07f2	5f 	_ 
	ld a,b					; a - bits rolled previously from LSB (register e)						;07f3	78 	x 
	rra						; shift in CY flag (fallen from e)										;07f4	1f 	. 
	ld b,a					; store back bits for next loop											;07f5	47 	G 
	jr sub_07d7h.next1bit	; continue rolling 														;07f6	18 ef 	. . 


CONSTs_1:
	dword #81000000		; Single Constant Value = 1								;07f8	00 00 00 81 	. 
l07fch:
	inc bc			;07fc	03 	. 
	xor d			;07fd	aa 	. 
	ld d,(hl)			;07fe	56 	V 
	add hl,de			;07ff	19 	. 
l0800h:
	add a,b			;0800	80 	. 
	pop af			;0801	f1 	. 
	ld (08076h),hl		;0802	22 76 80 	" v . 
	ld b,l			;0805	45 	E 
	xor d			;0806	aa 	. 
	jr c,l078bh		;0807	38 82 	8 . 

; ********************************************************************************
; BASIC LOG Entry Point
; Math : ACC = LOG(ACC) (Any -> Single)
MAT_sLog_ACC_DBL:
FuncLOG:
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0809	cd 55 09 	. U . 
	or a			    ; set flags  ;080c	b7 	. 
	jp pe,ErrRaiseFuncCode	; raise FUNCTION CODE Error		;080d	ea 4a 1e 	. J . 
	ld hl,MATH_ACC_EXP		;0810	21 24 79 	! $ y 
	ld a,(hl)			;0813	7e 	~ 
	ld bc,08035h		                                    ;0814	01 35 80 	. 5 . 
	ld de,004f3h		; BCDE = Sqrt(0.5)                  ;0817	11 f3 04 	. . . 
	sub b			;081a	90 	. 
	push af			;081b	f5 	. 
	ld (hl),b			;081c	70 	p 
	push de			;081d	d5 	. 
	push bc			;081e	c5 	. 
	call sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 	;081f	cd 16 07 	. . . 
	pop bc			;0822	c1 	. 
	pop de			;0823	d1 	. 
	inc b			;0824	04 	. 
	call BCDEsDivACC_DBL	; ACC = BCDE / ACC (Single)	;0825	cd a2 08 	. . . 
	ld hl,CONSTs_1		; Constant value 1 (Single) ;0828	21 f8 07 	! . . 
	call sngHLsubACC_DBL		; ACC = 1 - ACC (Single) ;082b	cd 10 07 	. . . 
	ld hl,l07fch		;082e	21 fc 07 	! . . 
	call sub_149ah		;0831	cd 9a 14 	. . . 
	ld bc,$8080		                                                                ;0834	01 80 80 	. . . 
	ld de,$0000		    ; BCDE = -0.5                                                   ;0837	11 00 00 	. . . 
	call sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 	;083a	cd 16 07 	. . . 
	pop af			;083d	f1 	. 
	call sub_0f89h		;083e	cd 89 0f 	. . . 
sub_0841h:
	ld bc,08031h		;0841	01 31 80 	. 1 . 
	ld de,07218h		;0844	11 18 72 	. . r 


// ***********************************************************************
; Math : ACC = BCDE * ACC (Single)
sngBCDEmulACC_DBL:
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0847	cd 55 09 	. U . 
	ret z			    ; return if ACC=0                                       ;084a	c8 	. 
	ld l,000h		;084b	2e 00 	. . 
	call sub_0914h		;084d	cd 14 09 	. . . 
	ld a,c			;0850	79 	y 
	ld (MATH_ACC3_MSB-1),a		;0851	32 4f 79 	2 O y 
	ex de,hl			;0854	eb 	. 
	ld (MATH_ACC3_MSB),hl		;0855	22 50 79 	" P y 
	ld bc,$0000		;0858	01 00 00 	. . . 
	ld d,b			;085b	50 	P 
	ld e,b			;085c	58 	X 
	ld hl,l0765h		; address of normalize routine ;085d	21 65 07 	! e . 
	push hl			;0860	e5 	. 
	ld hl,l0869h		;0861	21 69 08 	! i . 
	push hl			;0864	e5 	. 
	push hl			;0865	e5 	. 
	ld hl,ACC_SNG	 ; Int,Single,String (2 or 4 bytes): 	;0866	21 21 79 	! ! y 
l0869h:
	ld a,(hl)			;0869	7e 	~ 
	inc hl			;086a	23 	# 
	or a			;086b	b7 	. 
	jr z,l0892h		;086c	28 24 	( $ 
	push hl			;086e	e5 	. 
	ld l,008h		;086f	2e 08 	. . 
l0871h:
	rra			;0871	1f 	. 
	ld h,a			;0872	67 	g 
	ld a,c			;0873	79 	y 
	jr nc,l0881h		;0874	30 0b 	0 . 
	push hl			;0876	e5 	. 
	ld hl,(MATH_ACC3_MSB)		;0877	2a 50 79 	* P y 
	add hl,de			;087a	19 	. 
	ex de,hl			;087b	eb 	. 
	pop hl			;087c	e1 	. 
	ld a,(MATH_ACC3_MSB-1)		;087d	3a 4f 79 	: O y 
	adc a,c			;0880	89 	. 
l0881h:
	rra			;0881	1f 	. 
	ld c,a			;0882	4f 	O 
	ld a,d			;0883	7a 	z 
	rra			;0884	1f 	. 
	ld d,a			;0885	57 	W 
	ld a,e			;0886	7b 	{ 
	rra			;0887	1f 	. 
	ld e,a			;0888	5f 	_ 
	ld a,b			;0889	78 	x 
	rra			;088a	1f 	. 
	ld b,a			;088b	47 	G 
	dec l			;088c	2d 	- 
	ld a,h			;088d	7c 	| 
	jr nz,l0871h		;088e	20 e1 	  . 
l0890h:
	pop hl			;0890	e1 	. 
	ret			;0891	c9 	. 
l0892h:
	ld b,e			;0892	43 	C 
	ld e,d			;0893	5a 	Z 
	ld d,c			;0894	51 	Q 
	ld c,a			;0895	4f 	O 
	ret			;0896	c9 	. 


// ***********************************************************************
; Math : ACC = ACC / 10 (Single)
MAT_sDiv_10:
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;0897	cd a4 09 	. . . 
	ld hl,MAT_sConst_10		;089a	21 d8 0d 	! . . 


// ***********************************************************************
; Math : ACC = STACK / (HL) (Single)
MAT_sDiv_STACK_HL
	call MAT_sCopyHLToACC_DBL		;089d	cd b1 09 	. . . 


// ***********************************************************************
; Math : ACC = STACK / ACC (Single)
MAT_sDiv_STACK_ACC_DBL:
	pop bc			;08a0	c1 	. 
	pop de			;08a1	d1 	. 


// ***********************************************************************
; Math : ACC = BCDE / ACC (Single)
BCDEsDivACC_DBL:
	call sngdblACCSign	    ; Check Sign of number in ACC (Single or Double)		;08a2	cd 55 09 	. U . 
	jp z,ErrRaiseDivByZero	; if ACC=0 Raise 'DIVISION BY ZERO' error	            ;08a5	ca 9a 19 	. . . 
	ld l,0ffh		;08a8	2e ff 	. . 
	call sub_0914h		;08aa	cd 14 09 	. . . 
	inc (hl)			;08ad	34 	4 
	inc (hl)			;08ae	34 	4 
	dec hl			;08af	2b 	+ 
	ld a,(hl)			;08b0	7e 	~ 
	ld (MAT_SubBHLArgB),a		;08b1	32 89 78 	2 . x 
	dec hl			;08b4	2b 	+ 
	ld a,(hl)			;08b5	7e 	~ 
	ld (MAT_SubBHLArgH),a		;08b6	32 85 78 	2 . x 
	dec hl			;08b9	2b 	+ 
	ld a,(hl)			;08ba	7e 	~ 
	ld (MAT_SubBHLArgL),a		;08bb	32 81 78 	2 . x 
	ld b,c			;08be	41 	A 
	ex de,hl			;08bf	eb 	. 
	xor a			;08c0	af 	. 
	ld c,a			;08c1	4f 	O 
	ld d,a			;08c2	57 	W 
	ld e,a			;08c3	5f 	_ 
	ld (MAT_SubBHLRetA),a		;08c4	32 8c 78 	2 . x 
l08c7h:
	push hl			;08c7	e5 	. 
	push bc			;08c8	c5 	. 
	ld a,l			;08c9	7d 	} 
	call MAT_SubBHLCust		;08ca	cd 80 78 	. . x 
	sbc a,000h		;08cd	de 00 	. . 
	ccf			;08cf	3f 	? 
	jr nc,l08d9h		;08d0	30 07 	0 . 
	ld (MAT_SubBHLRetA),a		;08d2	32 8c 78 	2 . x 
	pop af			;08d5	f1 	. 
	pop af			;08d6	f1 	. 
	scf			;08d7	37 	7 
	db $d2		; skips next 2 instructions - jp nc,0e1c1h never jump after scf (CY=1)		;08d8	d2 c1 e1 	. . . 
l08d9h:
	pop bc		;08d9	c1 	. . . 
	pop hl		;08da	e1 	. . . 
	ld a,c			;08db	79 	y 
	inc a			;08dc	3c 	< 
	dec a			;08dd	3d 	= 
	rra			;08de	1f 	. 
	jp m,l0797h		;08df	fa 97 07 	. . . 
	rla			;08e2	17 	. 
	ld a,e			;08e3	7b 	{ 
	rla			;08e4	17 	. 
	ld e,a			;08e5	5f 	_ 
	ld a,d			;08e6	7a 	z 
	rla			;08e7	17 	. 
	ld d,a			;08e8	57 	W 
	ld a,c			;08e9	79 	y 
	rla			;08ea	17 	. 
	ld c,a			;08eb	4f 	O 
	add hl,hl			;08ec	29 	) 
	ld a,b			;08ed	78 	x 
	rla			;08ee	17 	. 
	ld b,a			;08ef	47 	G 
	ld a,(MAT_SubBHLRetA)		;08f0	3a 8c 78 	: . x 
	rla			;08f3	17 	. 
	ld (MAT_SubBHLRetA),a		;08f4	32 8c 78 	2 . x 
	ld a,c			;08f7	79 	y 
	or d			;08f8	b2 	. 
	or e			;08f9	b3 	. 
	jr nz,l08c7h		;08fa	20 cb 	  . 
	push hl			;08fc	e5 	. 
	ld hl,MATH_ACC_EXP		;08fd	21 24 79 	! $ y 
	dec (hl)			;0900	35 	5 
	pop hl			;0901	e1 	. 
	jr nz,l08c7h		;0902	20 c3 	  . 
	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;0904	c3 b2 07 	. . . 
sub_0907h:
	ld a,0ffh		;0907	3e ff 	> . 
	ld l,0afh		;0909	2e af 	. . 
	ld hl,MATH_ACC2_MSB		;090b	21 2d 79 	! - y 
	ld c,(hl)			;090e	4e 	N 
	inc hl			;090f	23 	# 
	xor (hl)			;0910	ae 	. 
	ld b,a			;0911	47 	G 
	ld l,000h		;0912	2e 00 	. . 
sub_0914h:
	ld a,b			;0914	78 	x 
	or a			;0915	b7 	. 
	jr z,l0937h		;0916	28 1f 	( . 
	ld a,l			;0918	7d 	} 
	ld hl,MATH_ACC_EXP		;0919	21 24 79 	! $ y 
	xor (hl)			;091c	ae 	. 
	add a,b			;091d	80 	. 
	ld b,a			;091e	47 	G 
	rra			;091f	1f 	. 
	xor b			;0920	a8 	. 
	ld a,b			;0921	78 	x 
	jp p,l0936h		;0922	f2 36 09 	. 6 . 
	add a,080h		;0925	c6 80 	. . 
	ld (hl),a			;0927	77 	w 
	jp z,l0890h		;0928	ca 90 08 	. . . 
	call MAT_sCmpSetSign		;092b	cd df 09 	. . . 
	ld (hl),a			;092e	77 	w 
sub_092fh:
	dec hl			;092f	2b 	+ 
	ret			;0930	c9 	. 
l0931h:
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)	;0931	cd 55 09 	. U . 
	cpl			;0934	2f 	/ 
	pop hl			;0935	e1 	. 
l0936h:
	or a			;0936	b7 	. 
l0937h:
	pop hl			;0937	e1 	. 
	jp p,MAT_sdSetACC_0		;0938	f2 78 07 	. x . 
	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;093b	c3 b2 07 	. . . 


// ***********************************************************************
; Math : ACC = ACC * 10 (Single)
sngACCmul10:
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)	;093e	cd bf 09 	. . . 
	ld a,b			;0941	78 	x 
	or a			;0942	b7 	. 
	ret z			;0943	c8 	. 
	add a,002h		;0944	c6 02 	. . 
	jp c,ErrRaiseOverflow	; Raise OVERFLOW Error		;0946	da b2 07 	. . . 
	ld b,a			;0949	47 	G 
	call sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 ;094a	cd 16 07 	. . . 
	ld hl,MATH_ACC_EXP		;094d	21 24 79 	! $ y 
	inc (hl)			;0950	34 	4 
	ret nz			;0951	c0 	. 
	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;0952	c3 b2 07 	. . . 


; ********************************************************************************
; Math : Check Sign of number in ACC (Single or Double)
; OUT: a - -1 (negative), 0 (zero), +1 (positive)
sngdblACCSign:
	ld a,(MATH_ACC_EXP)		;0955	3a 24 79 	: $ y 
	or a			;0958	b7 	. 
	ret z			;0959	c8 	. 
	ld a,(ACC_SNG+2)	 ; Int,Single,String (2 or 4 bytes): 	;095a	3a 23 79 	: # y 
	cp 02fh		;095d	fe 2f 	. / 
SignBitToRegA:
	rla				; copy bit7 (sign bit) to CY flag				;095f	17 	. 


; Convert Carry Flag to value in reg A.
; IN: CY - flag 
; OUT: a - 1 (CY was 0) or -1 (CY was 1)
CarryToRegA:
	sbc a,a			; substract a from a using CY                   ;0960	9f 	. 
	ret nz			; return a = -1 (CY was set)                    ;0961	c0 	. 
; -- CY wasn't set so reg A is 0 now
	inc a			; set A = 1                                     ;0962	3c 	< 
	ret			    ; ------- End of Proc ------------------------- ;0963	c9 	. 


; ********************************************************************************
; Math : Convert from Integer (A) to Single (ACC)
MAT_iConvToSngA:
	ld b,088h		;0964	06 88 	. . 
	ld de,$0000		;0966	11 00 00 	. . . 
l0969h:
	ld hl,MATH_ACC_EXP		;0969	21 24 79 	! $ y 
	ld c,a			;096c	4f 	O 
	ld (hl),b			;096d	70 	p 
	ld b,000h		;096e	06 00 	. . 
	inc hl			;0970	23 	# 
	ld (hl),080h		;0971	36 80 	6 . 
	rla			;0973	17 	. 
	jp l0762h		;0974	c3 62 07 	. b . 

; **************************************************************************************************
; BASIC ABS Entry Point
; Math : ACC = ABS(ACC) (Any)
; IN: TODO
FuncABS
	call TestACCSign	; Check Sign of number in ACC - is it positive?			;0977	cd 94 09 	. . . 
	ret p				; yes --------------- End of Proc ---------------- 		;097a	f0 	. 
l097bh:
	rst #20				; test NTF - Number Type Format							;097b	e7 	. 
	jp m,MAT_iAbs_ACC_DBL	; Integer - ACC = ABS(ACC) (Integer)					;097c	fa 5b 0c 	. [ . 
	jp z,ErrRaiseTypeMismatch	; String - raise TYPE MISMATCH Error			;097f	ca f6 0a 	. . . 

// ***********************************************************************
; Math : ACC = -ACC (Single or Double)
sngACCnegate:
	ld hl,MATH_ACC_MSB	; MSB of ACC - bit 7 contain number sign				;0982	21 23 79 	! # y 
	ld a,(hl)			; a - MSB with Sign										;0985	7e 	~ 
	xor %10000000		; inverse Sign 											;0986	ee 80 	. . 
	ld (hl),a			; store new value										;0988	77 	w 
	ret					; ---------------- End of Proc ------------------------	;0989	c9 	. 

; ********************************************************************************
; BASIC SGN Entry Point
; Math : ACC (& HL) = SGN(ACC) (Any -> Integer)
FuncSNG
	call TestACCSign	; Check Sign of number in ACC (Any)	;098a	cd 94 09 	. . . 
sub_098dh:
	ld l,a			;098d	6f 	o 
	rla			;098e	17 	. 
	sbc a,a			;098f	9f 	. 
	ld h,a			;0990	67 	g 
	jp ACCfromHLValue	; copy value from hl to ACC as integer number	;0991	c3 9a 0a 	. . . 


; ********************************************************************************
; Math : Check Sign of number in ACC (Any)
; OUT: a - -1 (negative), 0 (zero), +1 (positive)
TestACCSign:
	rst #20				; test NTF (Number Type Flag)							;0994	e7 	. 
	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;0995	ca f6 0a 	. . . 
	jp p,sngdblACCSign	; SIngle or Double - Check Sign of number in ACC 		;0998	f2 55 09 	. U . 
;; -- Integer
; ********************************************************************************
; Math : Check Sign of number in ACC (Integer)
; OUT: a - -1 (negative), 0 (zero), +1 (positive)
MAT_iTestSign
	ld hl,(ACC_SNG)	 ; Integer value to hl 									;099b	2a 21 79 	* ! y 
TestHLSign:
; -- test if it's zero
	ld a,h				; high byte of value									;099e	7c 	| 
	or l				; are both zero?										;099f	b5 	. 
	ret z				; yes ---------------- End of Proc (a=0,Z=1) ----------	;09a0	c8 	. 
; -- not zero - test sign of high byte
	ld a,h				; high byte of hl value									;09a1	7c 	| 
	jr SignBitToRegA	; test sign of byte -----------------------------------	;09a2	18 bb 	. . 


// ***********************************************************************
; Math : Push value from ACC on Stack (Single)
; Place the Single precision value from ACC on the STACK 
; (7921-7922 PUSHed first, then 7923-7924)
sngACCcopyToSPUSH:
	ex de,hl			;09a4	eb 	. 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;09a5	2a 21 79 	* ! y 
	ex (sp),hl			;09a8	e3 	. 
	push hl			;09a9	e5 	. 
	ld hl,(ACC_SNG+2)	 ; Int,Single,String (2 or 4 bytes): 	;09aa	2a 23 79 	* # y 
	ex (sp),hl			;09ad	e3 	. 
	push hl			;09ae	e5 	. 
	ex de,hl			;09af	eb 	. 
	ret			;09b0	c9 	. 


// ***********************************************************************
; Math : Copy value from (HL) to ACC (Single)
MAT_sCopyHLToACC_DBL:
	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;09b1	cd c2 09 	. . . 


// ***********************************************************************
; Math : Copy value from BCDE to ACC (Single)
; IN: bc,de - number (single precision)
BCDEToACC_DBL:
	ex de,hl			; hl - low bytes of BCDE value							;09b4	eb 	. 
	ld (ACC_SNG),hl	; store as low bytes into ACC (Single)					;09b5	22 21 79 	" ! y 
	ld h,b																		;09b8	60 	` 
	ld l,c				; hl - high bytes of BCDE value 						;09b9	69 	i 
	ld (ACC_SNG+2),hl	; store as high bytes into ACC	(single)				;09ba	22 23 79 	" # y 
	ex de,hl			; restore hl											;09bd	eb 	. 
	ret					; ---------------- End of Proc ------------------------	;09be	c9 	. 


// ***********************************************************************
; Math : Copy value from ACC to BCDE (Single)
ACCToBCDE:
	ld hl,ACC_SNG		; address of accumulator (ACC)	Single					;09bf	21 21 79 	! ! y 


// ***********************************************************************
; Math : Copy value from (HL) to BCDE (Single)
HLToBCDE:
	ld e,(hl)			; e - low byte of value									;09c2	5e 	^ 
	inc hl				; points to next byte									;09c3	23 	# 
// ***********************************************************************
; Copy 3 bytes from (HL) to BCD
HLToBCD:
	ld d,(hl)			; d - middle byte of value								;09c4	56 	V 
	inc hl				; points to next byte									;09c5	23 	# 
	ld c,(hl)			; c - high byte of value								;09c6	4e 	N 
	inc hl				; points to next byte									;09c7	23 	# 
	ld b,(hl)			; b - exponent byte of value							;09c8	46 	F 
inc_hl:
	inc hl				; points to next byte									;09c9	23 	# 
	ret					; --------------- End of Proc -------------------------	;09ca	c9 	. 


// ***********************************************************************
; Math : Copy value from ACC to (HL) (Single)
MAT_sCopyACCToHL:
	ld de,ACC_SNG		 ; Int,Single,String (2 or 4 bytes): ;09cb	11 21 79 	. ! y 


// ***********************************************************************
; Math : Copy value from (DE) to (HL) (Single)
MAT_sCopyDEToHL	
	ld b,004h		;09ce	06 04 	. . 
	jr DEMemToHLMemLen	; Copy value from (DE) to (HL) (b bytes)	;09d0	18 05 	. . 



// ***********************************************************************
; Math : Copy value from (HL) to (DE) (Any)
HLMemToDEMem:
	ex de,hl			;09d2	eb 	. 


// ***********************************************************************
; Math : Copy value from (DE) to (HL) (Any)
DEMemToHLMem:
	ld a,(MATH_NTF)		;09d3	3a af 78 	: . x 
	ld b,a			;09d6	47 	G 


// ***********************************************************************
; Math : Copy value from (DE) to (HL) (b bytes)
; IN: de - source address
;     hl - destination address
;     b - number of bytes to copy
DEMemToHLMemLen:
	ld a,(de)			; a - byte from source									;09d7	1a 	. 
	ld (hl),a			; store to destination									;09d8	77 	w 
	inc de				; increment source pointer								;09d9	13 	. 
	inc hl				; increment destination pointer							;09da	23 	# 
	dec b				; decrement number of bytes to copy - all copied?		;09db	05 	. 
	jr nz,DEMemToHLMemLen	; no - continue copy B bytes						;09dc	20 f9 	  . 
	ret					; ----------------- End of Proc -----------------------	;09de	c9 	. 

// ***********************************************************************
; Math : Compare Sign and Set Sign Bits (ACC and BCDE) (Single)
; Bit 7 of the MSB of both numbers is set (making both numbers negative).
; Then the original Bit 7 (sign) bits of both numbers are compared.
; If both numbers had the same sign on entry (both were positive or both 
; were negative) the Z-80 sign flag will be set (M flag set), otherwise 
; the sign flag will be reset (P flag condition).
MAT_sCmpSetSign:
	ld hl,MATH_ACC_MSB		;09df	21 23 79 	! # y 
	ld a,(hl)			;09e2	7e 	~ 
	rlca			;09e3	07 	. 
	scf			;09e4	37 	7 
	rra			;09e5	1f 	. 
	ld (hl),a			;09e6	77 	w 
	ccf			;09e7	3f 	? 
	rra			;09e8	1f 	. 
	inc hl			;09e9	23 	# 
	inc hl			;09ea	23 	# 
	ld (hl),a			;09eb	77 	w 
	ld a,c			;09ec	79 	y 
	rlca			;09ed	07 	. 
	scf			;09ee	37 	7 
	rra			;09ef	1f 	. 
	ld c,a			;09f0	4f 	O 
	rra			;09f1	1f 	. 
	xor (hl)			;09f2	ae 	. 
	ret			;09f3	c9 	. 

// ***********************************************************************
; Math : Copy value from ACC2 to ACC (Any)
ACC2ToACC_DBL:
	ld hl,ACC2		; address of 2nd Accumulator ;09f4	21 27 79 	! ' y 


// ***********************************************************************
; Math : Copy value from (HL) to ACC (Any)
HLMemToACC_DBL:
	ld de,HLMemToDEMem	; routine - copy Math variable from (hl) to (de)	;09f7	11 d2 09 	. . . 
	jr l0a02h		;09fa	18 06 	. . 


// ***********************************************************************
; Math : Copy value from ACC to ACC2 (Any)
anyACCcopyToACC2:
	ld hl,ACC2		; address of 2nd Accumulator ;09fc	21 27 79 	! ' y 


// ***********************************************************************
; Math : Copy value from ACC to (HL) (Any)
ACCToHLMem
	ld de,DEMemToHLMem	; routine - copy math variable from (de) to (hl) mem	;09ff	11 d3 09 	. . . 
l0a02h:
	push de			;0a02	d5 	. 
GetACCMSBPtr:
	ld de,ACC_SNG	; start of ACC bytes when Single, Integer or String 		;0a03	11 21 79 	. ! y 
	rst #20			; test NTF - is it Single, Integer or String				;0a06	e7 	. 
	ret c			; yes - ----------- End of Proc (de = start)				;0a07	d8 	. 
	ld de,ACC_DBL	; start of ACC bytes when Double  							;0a08	11 1d 79 	. . y 
	ret				; ----------------- End of Proc (de = start)				;0a0b	c9 	. 

// ***********************************************************************
; Math : Compare ACC and BCDE (Single)
MAT_sCmp_ACC_BCDE:
	ld a,b			;0a0c	78 	x 
	or a			;0a0d	b7 	. 
	jp z,sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0a0e	ca 55 09 	. U . 
	ld hl,0095eh		;0a11	21 5e 09 	! ^ . 
	push hl			;0a14	e5 	. 
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0a15	cd 55 09 	. U . 
	ld a,c			;0a18	79 	y 
	ret z			;0a19	c8 	. 
	ld hl,ACC_SNG+2	 ; Int,Single,String (2 or 4 bytes): 	;0a1a	21 23 79 	! # y 
	xor (hl)			;0a1d	ae 	. 
	ld a,c			;0a1e	79 	y 
	ret m			;0a1f	f8 	. 
	call sub_0a26h		;0a20	cd 26 0a 	. & . 
l0a23h:
	rra			;0a23	1f 	. 
	xor c			;0a24	a9 	. 
	ret			;0a25	c9 	. 
sub_0a26h:
	inc hl			;0a26	23 	# 
	ld a,b			;0a27	78 	x 
	cp (hl)			;0a28	be 	. 
	ret nz			;0a29	c0 	. 
	dec hl			;0a2a	2b 	+ 
	ld a,c			;0a2b	79 	y 
	cp (hl)			;0a2c	be 	. 
	ret nz			;0a2d	c0 	. 
	dec hl			;0a2e	2b 	+ 
	ld a,d			;0a2f	7a 	z 
	cp (hl)			;0a30	be 	. 
	ret nz			;0a31	c0 	. 
	dec hl			;0a32	2b 	+ 
	ld a,e			;0a33	7b 	{ 
	sub (hl)			;0a34	96 	. 
	ret nz			;0a35	c0 	. 
	pop hl			;0a36	e1 	. 
	pop hl			;0a37	e1 	. 
	ret			;0a38	c9 	. 


// ***********************************************************************
; Math : Compare HL and DE (Integer)
MAT_iCmp_HL_DE:
	ld a,d			;0a39	7a 	z 
	xor h			;0a3a	ac 	. 
	ld a,h			;0a3b	7c 	| 
	jp m,SignBitToRegA		;0a3c	fa 5f 09 	. _ . 
	cp d			;0a3f	ba 	. 
	jp nz,CarryToRegA	; return with A=1 if a>d or A=-1 if a<d	        ;0a40	c2 60 09 	. ` . 
; -- compare low bytes of HL and DE
	ld a,l			    ; a - low bytes of HL                               ;0a43	7d 	} 
	sub e			    ; subtract low byte of DE                           ;0a44	93 	. 
	jp nz,CarryToRegA	; return with A=1 if a>e or A=-1 if a<e		    ;0a45	c2 60 09 	. ` . 
	ret			        ; -------- End of Proc (A=0) ------------------ ;0a48	c9 	. 


// ***********************************************************************
; Math : Compare ACC and (DE) (Double)
ACCCmpDEMem:
	ld hl,ACC2		; address of 2nd Accumulator ;0a49	21 27 79 	! ' y 
	call DEMemToHLMem	; copy math variable from (de) to ACC2		;0a4c	cd d3 09 	. . . 


// ***********************************************************************
; Math : Compare ACC and ACC2 (Double)
ACCCmpACC2:
	ld de,MATH_ACC2_EXP		;0a4f	11 2e 79 	. . y 
	ld a,(de)			;0a52	1a 	. 
	or a			;0a53	b7 	. 
	jp z,sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0a54	ca 55 09 	. U . 
	ld hl,0095eh		;0a57	21 5e 09 	! ^ . 
	push hl			;0a5a	e5 	. 
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0a5b	cd 55 09 	. U . 
	dec de			;0a5e	1b 	. 
	ld a,(de)			;0a5f	1a 	. 
	ld c,a			;0a60	4f 	O 
	ret z			;0a61	c8 	. 
	ld hl,ACC_SNG+2	 ; Int,Single,String (2 or 4 bytes): 	;0a62	21 23 79 	! # y 
	xor (hl)			;0a65	ae 	. 
	ld a,c			;0a66	79 	y 
	ret m			;0a67	f8 	. 
	inc de			;0a68	13 	. 
	inc hl			;0a69	23 	# 
	ld b,008h		;0a6a	06 08 	. . 
l0a6ch:
	ld a,(de)			;0a6c	1a 	. 
	sub (hl)			;0a6d	96 	. 
	jp nz,l0a23h		;0a6e	c2 23 0a 	. # . 
	dec de			;0a71	1b 	. 
	dec hl			;0a72	2b 	+ 
	dec b			;0a73	05 	. 
	jr nz,l0a6ch		;0a74	20 f6 	  . 
	pop bc			;0a76	c1 	. 
	ret			;0a77	c9 	. 


// ***********************************************************************
; Math : Compare ACC2 and ACC (Double)
MAT_dCmp_ACC2_ACC_DBL:
	call ACCCmpACC2	;  Compare ACC and ACC2 (Double)	;0a78	cd 4f 0a 	. O . 
	jp nz,0095eh		;0a7b	c2 5e 09 	. ^ . 
	ret			;0a7e	c9 	. 


; ********************************************************************************
; [TRS] BASIC CINT Entry Point
FuncCINT:
	rst #20				; test NTF - check if ACC contains Integer type 		;0a7f	e7 	. 
	ld hl,(ACC_SNG)	; load 2 bytes as Integer value 						;0a80	2a 21 79 	* ! y 
; -- fags are set: M - Integer, Z - String, NC - Double
	ret m				; Integer ----------------- End of Proc ---------------	;0a83	f8 	. 
	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;0a84	ca f6 0a 	. . . 
	call nc,DblToSng	; Double - Convert from Double to Single 				;0a87	d4 b9 0a 	. . . 

; Convert from Single to Integer (ACC) (result also in HL)
	ld hl,ErrRaiseOverflow	; Raise OVERFLOW Error routine						;0a8a	21 b2 07 	! . . 
	push hl				; set as return address									;0a8d	e5 	. 
sub_0a8eh:
	ld a,(MATH_ACC_EXP)	; exponent part of number								;0a8e	3a 24 79 	: $ y 
	cp $90				; is it in range (-512..512) - exp < $90 				;0a91	fe 90 	. . 
	jr nc,l0aa3h		; no - ;0a93	30 0e 	0 . 
	call sub_0afbh		;0a95	cd fb 0a 	. . . 
	ex de,hl			;0a98	eb 	. 
l0a99h:
	pop de			;0a99	d1 	. 

// ***********************************************************************
; Math : Copy value from HL to ACC (Integer)
; Routine sets NTF to 2 (Integer)
ACCfromHLValue:
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;0a9a	22 21 79 	" ! y 


; ********************************************************************************
; Math : Set NTF to Integer (ACC)
SetNTFInt
	ld a,2		; Number Type Integer							;0a9d	3e 02 	> . 
SetNTF:
	ld (MATH_NTF),a		;0a9f	32 af 78 	2 . x 
	ret			;0aa2	c9 	. 
l0aa3h:
	ld bc,$9080		;0aa3	01 80 90 	. . . 
	ld de,$0000		; BCDE = -32768 (minimum 16bit integer value)	;0aa6	11 00 00 	. . . 
	call MAT_sCmp_ACC_BCDE	; Compare ACC and BCDE (Single)	;0aa9	cd 0c 0a 	. . . 
	ret nz			;0aac	c0 	. 
	ld h,c			;0aad	61 	a 
	ld l,d			;0aae	6a 	j 
	jr l0a99h		;0aaf	18 e8 	. . 

; ********************************************************************************
; [TRS] BASIC CSNG Entry Point
FuncCSNG:
	rst #20			; test NTF (Number Type Format) 							;0ab1	e7 	. 
	ret po			; Single ----------- End of Proc --------------------------	;0ab2	e0 	. 
	jp m,MAT_iConvToSng	; Integer - Convert from Integer to Single (ACC)		;0ab3	fa cc 0a 	. . . 
	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;0ab6	ca f6 0a 	. . . 
; -- Double
; ********************************************************************************
; Math : Convert from Double to Single (ACC)
DblToSng:
	call ACCToBCDE	; Copy value from ACC to BCDE (High part of Double)			;0ab9	cd bf 09 	. . . 
	call SetNTFToSng; set Number Type Flag to Single 							;0abc	cd ef 0a 	. . . 
	ld a,b			;0abf	78 	x 
	or a			;0ac0	b7 	. 
	ret z			;0ac1	c8 	. 
	call MAT_sCmpSetSign		;0ac2	cd df 09 	. . . 
	ld hl,07920h		;0ac5	21 20 79 	!   y 
	ld b,(hl)			;0ac8	46 	F 
	jp l0796h		;0ac9	c3 96 07 	. . . 


; ********************************************************************************
; Math : Convert from Integer to Single (ACC)
MAT_iConvToSng:
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;0acc	2a 21 79 	* ! y 

; ********************************************************************************
; Math : Convert from Integer (HL) to Single (ACC)
MAT_iConvToSngHL:
	call SetNTFToSng		;0acf	cd ef 0a 	. . . 
	ld a,h			;0ad2	7c 	| 
	ld d,l			;0ad3	55 	U 
	ld e,000h		;0ad4	1e 00 	. . 
	ld b,090h		;0ad6	06 90 	. . 
	jp l0969h		;0ad8	c3 69 09 	. i . 

; ********************************************************************************
; [TRS] BASIC CDBL Entry Point
FuncCDBL:
	rst #20			; test NTF (Number Type Flag)								;0adb	e7 	. 
	ret nc			; Double ------------ End of Proc -------------------------	;0adc	d0 	. 
	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;0add	ca f6 0a 	. . . 
	call m,MAT_iConvToSng	; Integer - Convert from Integer to Single (ACC)	;0ae0	fc cc 0a 	. . . 
; -- now it's Single - convert it to Double

; ********************************************************************************
; Math : Convert ACC from Single to Double
sngACCconvToDbl:
	ld hl,$0000		; extra precision bytes of Double value 					;0ae3	21 00 00 	! . . 
	ld (ACC_DBL),hl		; store into Accumulator 									;0ae6	22 1d 79 	" . y 
	ld (ACC_DBL+2),hl	; store into Accumulator									;0ae9	22 1f 79 	" . y 
; -- extra digits set to zero - mark ACC as Double value

; ********************************************************************************
; Math : Set NTF to Double (ACC)
SetNTFDbl:
	ld a,8			; Number Type Double 										;0aec	3e 08 	> . 
	db $01			; trick byte - with next constructs irrevelant ld bc,l043eh	;0aee	01 3e 04 	. > . 
SetNTFToSng
	ld a,4			; Number Type Single										;0aef	3e 04 	. > . 
	jp SetNTF		; set NTF to 4 (Single)										;0af1	c3 9f 0a 	. . . 

; ********************************************************************************
; String : Assert ACC contains String
AssertACCIsString:
	rst #20			; test NTF (Number Type Format) is it String				;0af4	e7 	. 
	ret z			; String ----------------- End of Proc -------------------- ;0af5	c8 	. 
; -- ACC is not String - raise error
ErrRaiseTypeMismatch:
	ld e,#18		; ERROR 18 - TYPE MISMATCH									;0af6	1e 18 	. . 
	jp ErrRaiseError; Raise TYPE MISMATCH Error	-------------------------------	;0af8	c3 a2 19 	. . . 
sub_0afbh:
	ld b,a			;0afb	47 	G 
	ld c,a			;0afc	4f 	O 
	ld d,a			;0afd	57 	W 
	ld e,a			;0afe	5f 	_ 
	or a			;0aff	b7 	. 
	ret z			;0b00	c8 	. 
	push hl			;0b01	e5 	. 
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;0b02	cd bf 09 	. . . 
	call MAT_sCmpSetSign		;0b05	cd df 09 	. . . 
	xor (hl)			;0b08	ae 	. 
	ld h,a			;0b09	67 	g 
	call m,sub_0b1fh		;0b0a	fc 1f 0b 	. . . 
	ld a,098h		;0b0d	3e 98 	> . 
	sub b			;0b0f	90 	. 
	call sub_07d7h		;0b10	cd d7 07 	. . . 
	ld a,h			;0b13	7c 	| 
	rla			;0b14	17 	. 
	call c,sub_07a8h		;0b15	dc a8 07 	. . . 
	ld b,000h		;0b18	06 00 	. . 
	call c,sub_07c3h		;0b1a	dc c3 07 	. . . 
	pop hl			;0b1d	e1 	. 
	ret			;0b1e	c9 	. 
sub_0b1fh:
	dec de			;0b1f	1b 	. 
	ld a,d			;0b20	7a 	z 
	and e			;0b21	a3 	. 
	inc a			;0b22	3c 	< 
	ret nz			;0b23	c0 	. 
sub_0b24h:
	dec bc			;0b24	0b 	. 
	ret			;0b25	c9 	. 


; ********************************************************************************
; [TRS] BASIC FIX Entry Point
; Math : ACC = FIX(ACC) (Any)
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
FuncFIX
	rst #20			; test NTF (Number Type Format) 							;0b26	e7 	. 
	ret m			; Integer --------------- End of Proc ---------------------	;0b27	f8 	. 
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0b28	cd 55 09 	. U . 
	jp p,FuncINT		; positive number - convert ACC to Integer type			;0b2b	f2 37 0b 	. 7 . 
; -- number is negative - invert sign and then convert to Integer
	call sngACCnegate	;  ACC = -ACC (Single) 									;0b2e	cd 82 09 	. . . 
	call FuncINT		; convert ACC to Integer type							;0b31	cd 37 0b 	. 7 . 
	jp l097bh		;0b34	c3 7b 09 	. { . 

; ********************************************************************************
; [TRS] BASIC INT Entry Point
FuncINT:
	rst #20			; test NTF (Number Type Format)								;0b37	e7 	. 
	ret m			; Integer - ------------- End of Proc ---------------------	;0b38	f8 	. 
	jr nc,MAT_dInt_ACC_DBL	; Double - truncate to Integer [ACC = INT(ACC)]	-------	;0b39	30 1e 	0 . 
	jr z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error ----------	;0b3b	28 b9 	( . 
; -- ACC is Single - truncate to Integer

; ********************************************************************************
; Math : ACC = INT(ACC) (Single)
MAT_sInt_ACC_DBL:
	call sub_0a8eh	; convert Double to Single	;0b3d	cd 8e 0a 	. . . 
sub_0b40h:
	ld hl,MATH_ACC_EXP		;0b40	21 24 79 	! $ y 
	ld a,(hl)			;0b43	7e 	~ 
	cp 098h		;0b44	fe 98 	. . 
	ld a,(ACC_SNG)		 ; Int,Single,String (2 or 4 bytes): ;0b46	3a 21 79 	: ! y 
	ret nc			;0b49	d0 	. 
	ld a,(hl)			;0b4a	7e 	~ 
	call sub_0afbh		;0b4b	cd fb 0a 	. . . 
	ld (hl),098h		;0b4e	36 98 	6 . 
	ld a,e			;0b50	7b 	{ 
	push af			;0b51	f5 	. 
	ld a,c			;0b52	79 	y 
	rla			;0b53	17 	. 
	call l0762h		;0b54	cd 62 07 	. b . 
	pop af			;0b57	f1 	. 
	ret			;0b58	c9 	. 

; ********************************************************************************
; Math : ACC = INT(ACC) (Double)
MAT_dInt_ACC_DBL:
	ld hl,MATH_ACC_EXP		;0b59	21 24 79 	! $ y 
	ld a,(hl)			;0b5c	7e 	~ 
	cp 090h		;0b5d	fe 90 	. . 
	jp c,FuncCINT		; convert ACC to integer	;0b5f	da 7f 0a 	.  . 
	jr nz,l0b78h		;0b62	20 14 	  . 
	ld c,a			;0b64	4f 	O 
	dec hl			;0b65	2b 	+ 
	ld a,(hl)			;0b66	7e 	~ 
	xor 080h		;0b67	ee 80 	. . 
	ld b,006h		;0b69	06 06 	. . 
l0b6bh:
	dec hl			;0b6b	2b 	+ 
	or (hl)			;0b6c	b6 	. 
	dec b			;0b6d	05 	. 
	jr nz,l0b6bh		;0b6e	20 fb 	  . 
	or a			;0b70	b7 	. 
	ld hl,$8000		; hl = -32768 (max negative 16bit value)                ;0b71	21 00 80 	! . . 
	jp z,ACCfromHLValue	; copy value from hl to ACC as integer number		;0b74	ca 9a 0a 	. . . 
	ld a,c			;0b77	79 	y 
l0b78h:
	cp 0b8h		;0b78	fe b8 	. . 
	ret nc			;0b7a	d0 	. 
sub_0b7bh:
	push af			;0b7b	f5 	. 
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;0b7c	cd bf 09 	. . . 
	call MAT_sCmpSetSign		;0b7f	cd df 09 	. . . 
	xor (hl)			;0b82	ae 	. 
	dec hl			;0b83	2b 	+ 
	ld (hl),0b8h		;0b84	36 b8 	6 . 
	push af			;0b86	f5 	. 
	call m,sub_0ba0h		;0b87	fc a0 0b 	. . . 
	ld hl,ACC_SNG+2		 ; Int,Single,String (2 or 4 bytes): ;0b8a	21 23 79 	! # y 
	ld a,0b8h		;0b8d	3e b8 	> . 
	sub b			;0b8f	90 	. 
	call sub_0d69h		;0b90	cd 69 0d 	. i . 
	pop af			;0b93	f1 	. 
	call m,sub_0d20h		;0b94	fc 20 0d 	.   . 
	xor a			;0b97	af 	. 
	ld (MATH_ACC_CY),a		;0b98	32 1c 79 	2 . y 
	pop af			;0b9b	f1 	. 
	ret nc			;0b9c	d0 	. 
	jp l0cd8h		;0b9d	c3 d8 0c 	. . . 
sub_0ba0h:
	ld hl,ACC_DBL	; addres of Accumulator (Double) ;0ba0	21 1d 79 	! . y 
l0ba3h:
	ld a,(hl)			;0ba3	7e 	~ 
	dec (hl)			;0ba4	35 	5 
	or a			;0ba5	b7 	. 
	inc hl			;0ba6	23 	# 
	jr z,l0ba3h		;0ba7	28 fa 	( . 
	ret			;0ba9	c9 	. 


// ***********************************************************************
; Math : DE = BC * DE (Unsigned Integer)
MAT_iMul_BC_DE:
	push hl			;0baa	e5 	. 
	ld hl,$0000		;0bab	21 00 00 	! . . 
	ld a,b			;0bae	78 	x 
	or c			;0baf	b1 	. 
	jr z,l0bc4h		;0bb0	28 12 	( . 
	ld a,010h		;0bb2	3e 10 	> . 
l0bb4h:
	add hl,hl			;0bb4	29 	) 
	jp c,ErrRaiseBadSubscript	; raise BAD SUBSCRIPT ERROR		;0bb5	da 3d 27 	. = ' 
	ex de,hl			;0bb8	eb 	. 
	add hl,hl			;0bb9	29 	) 
	ex de,hl			;0bba	eb 	. 
	jr nc,l0bc1h		;0bbb	30 04 	0 . 
	add hl,bc			;0bbd	09 	. 
	jp c,ErrRaiseBadSubscript	; raise BAD SUBSCRIPT ERROR		;0bbe	da 3d 27 	. = ' 
l0bc1h:
	dec a			;0bc1	3d 	= 
	jr nz,l0bb4h		;0bc2	20 f0 	  . 
l0bc4h:
	ex de,hl			;0bc4	eb 	. 
	pop hl			;0bc5	e1 	. 
	ret			;0bc6	c9 	. 



// ***********************************************************************
; Math : ACC = DE - HL (Integer)
MAT_iSub_DEHL
	ld a,h			;0bc7	7c 	| 
	rla			;0bc8	17 	. 
	sbc a,a			;0bc9	9f 	. 
	ld b,a			;0bca	47 	G 
	call sub_0c51h		;0bcb	cd 51 0c 	. Q . 
	ld a,c			;0bce	79 	y 
	sbc a,b			;0bcf	98 	. 
	jr l0bd5h		;0bd0	18 03 	. . 

// ***********************************************************************
; Math : ACC = DE + HL (Integer)
MAT_iAdd_DEHL:
	ld a,h			;0bd2	7c 	| 
	rla			;0bd3	17 	. 
	sbc a,a			;0bd4	9f 	. 
l0bd5h:
	ld b,a			;0bd5	47 	G 
	push hl			;0bd6	e5 	. 
	ld a,d			;0bd7	7a 	z 
	rla			;0bd8	17 	. 
	sbc a,a			;0bd9	9f 	. 
	add hl,de			;0bda	19 	. 
	adc a,b			;0bdb	88 	. 
	rrca			;0bdc	0f 	. 
	xor h			;0bdd	ac 	. 
	jp p,l0a99h		;0bde	f2 99 0a 	. . . 
	push bc			;0be1	c5 	. 
	ex de,hl			;0be2	eb 	. 
	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)	;0be3	cd cf 0a 	. . . 
	pop af			;0be6	f1 	. 
	pop hl			;0be7	e1 	. 
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;0be8	cd a4 09 	. . . 
	ex de,hl			;0beb	eb 	. 
	call sub_0c6bh		;0bec	cd 6b 0c 	. k . 
	jp l0f8fh		;0bef	c3 8f 0f 	. . . 


// ***********************************************************************
; Math : ACC = DE * HL (Integer)
MAT_iMul_DEHL
	ld a,h			;0bf2	7c 	| 
	or l			;0bf3	b5 	. 
	jp z,ACCfromHLValue	; copy value from hl to ACC as integer number		;0bf4	ca 9a 0a 	. . . 
	push hl			;0bf7	e5 	. 
	push de			;0bf8	d5 	. 
	call sub_0c45h		;0bf9	cd 45 0c 	. E . 
	push bc			;0bfc	c5 	. 
	ld b,h			;0bfd	44 	D 
	ld c,l			;0bfe	4d 	M 
	ld hl,$0000		;0bff	21 00 00 	! . . 
	ld a,010h		;0c02	3e 10 	> . 
l0c04h:
	add hl,hl			;0c04	29 	) 
	jr c,$+33		;0c05	38 1f 	8 . 
	ex de,hl			;0c07	eb 	. 
	add hl,hl			;0c08	29 	) 
	ex de,hl			;0c09	eb 	. 
	jr nc,l0c10h		;0c0a	30 04 	0 . 
	add hl,bc			;0c0c	09 	. 
	jp c,00c26h		;0c0d	da 26 0c 	. & . 
l0c10h:
	dec a			;0c10	3d 	= 
	jr nz,l0c04h		;0c11	20 f1 	  . 
	pop bc			;0c13	c1 	. 
	pop de			;0c14	d1 	. 
	ld a,h			;0c15	7c 	| 
	or a			;0c16	b7 	. 
	jp m,l0c1fh		;0c17	fa 1f 0c 	. . . 
	pop de			;0c1a	d1 	. 
	ld a,b			;0c1b	78 	x 
	jp l0c4dh		;0c1c	c3 4d 0c 	. M . 
l0c1fh:
	xor 080h		;0c1f	ee 80 	. . 
	or l			;0c21	b5 	. 
	jr z,l0c37h		;0c22	28 13 	( . 
	ex de,hl			;0c24	eb 	. 
	ld bc,0e1c1h		;0c25	01 c1 e1 	. . . 
	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;0c28	cd cf 0a 	. . . 
	pop hl			;0c2b	e1 	. 
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;0c2c	cd a4 09 	. . . 
	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;0c2f	cd cf 0a 	. . . 

; ********************************************************************************
; Math : ACC = (SP) * ACC (Single)
sngSPOPmulACC_DBL:
	pop bc			;0c32	c1 	. 
	pop de			;0c33	d1 	. 
	jp sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;0c34	c3 47 08 	. G . 
l0c37h:
	ld a,b			;0c37	78 	x 
	or a			;0c38	b7 	. 
	pop bc			;0c39	c1 	. 
	jp m,ACCfromHLValue	; copy value from hl to ACC as integer number		;0c3a	fa 9a 0a 	. . . 
	push de			;0c3d	d5 	. 
	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;0c3e	cd cf 0a 	. . . 
	pop de			;0c41	d1 	. 
	jp sngACCnegate		; ACC = -ACC (Single) ;0c42	c3 82 09 	. . . 
sub_0c45h:
	ld a,h			;0c45	7c 	| 
	xor d			;0c46	aa 	. 
	ld b,a			;0c47	47 	G 
	call sub_0c4ch		;0c48	cd 4c 0c 	. L . 
	ex de,hl			;0c4b	eb 	. 
sub_0c4ch:
	ld a,h			;0c4c	7c 	| 
l0c4dh:
	or a			;0c4d	b7 	. 
	jp p,ACCfromHLValue	; copy value from hl to ACC as integer number		;0c4e	f2 9a 0a 	. . . 
sub_0c51h:
	xor a			;0c51	af 	. 
	ld c,a			;0c52	4f 	O 
	sub l			;0c53	95 	. 
	ld l,a			;0c54	6f 	o 
	ld a,c			;0c55	79 	y 
	sbc a,h			;0c56	9c 	. 
	ld h,a			;0c57	67 	g 
	jp ACCfromHLValue	; copy value from hl to ACC as integer number		;0c58	c3 9a 0a 	. . . 


; ********************************************************************************
; Math : ACC = ABS(ACC) (Integer)
MAT_iAbs_ACC_DBL:
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;0c5b	2a 21 79 	* ! y 
	call sub_0c51h		;0c5e	cd 51 0c 	. Q . 
	ld a,h			;0c61	7c 	| 
	xor 080h		;0c62	ee 80 	. . 
	or l			;0c64	b5 	. 
	ret nz			;0c65	c0 	. 
sub_0c66h:
	ex de,hl			;0c66	eb 	. 
	call SetNTFToSng		;0c67	cd ef 0a 	. . . 
	xor a			;0c6a	af 	. 
sub_0c6bh:
	ld b,098h		;0c6b	06 98 	. . 
	jp l0969h		;0c6d	c3 69 09 	. i . 


// ***********************************************************************
; Math : ACC = ACC - ACC2 (Double)
MAT_dSub_ACC2
	ld hl,MATH_ACC2_MSB		;0c70	21 2d 79 	! - y 
	ld a,(hl)			;0c73	7e 	~ 
	xor 080h		;0c74	ee 80 	. . 
	ld (hl),a			;0c76	77 	w 


// ***********************************************************************
; Math : ACC = ACC + ACC2 (Double)
ACCAddACC2:
	ld hl,MATH_ACC2_EXP		;0c77	21 2e 79 	! . y 
	ld a,(hl)			;0c7a	7e 	~ 
	or a			;0c7b	b7 	. 
	ret z			;0c7c	c8 	. 
	ld b,a			;0c7d	47 	G 
	dec hl			;0c7e	2b 	+ 
	ld c,(hl)			;0c7f	4e 	N 
	ld de,MATH_ACC_EXP		;0c80	11 24 79 	. $ y 
	ld a,(de)			;0c83	1a 	. 
	or a			;0c84	b7 	. 
	jp z,ACC2ToACC_DBL	; Copy value from ACC2 to ACC (Any)	;0c85	ca f4 09 	. . . 
	sub b			;0c88	90 	. 
	jr nc,l0ca1h		;0c89	30 16 	0 . 
	cpl			;0c8b	2f 	/ 
	inc a			;0c8c	3c 	< 
	push af			;0c8d	f5 	. 
	ld c,008h		;0c8e	0e 08 	. . 
	inc hl			;0c90	23 	# 
	push hl			;0c91	e5 	. 
l0c92h:
	ld a,(de)			;0c92	1a 	. 
	ld b,(hl)			;0c93	46 	F 
	ld (hl),a			;0c94	77 	w 
	ld a,b			;0c95	78 	x 
	ld (de),a			;0c96	12 	. 
	dec de			;0c97	1b 	. 
	dec hl			;0c98	2b 	+ 
	dec c			;0c99	0d 	. 
	jr nz,l0c92h		;0c9a	20 f6 	  . 
	pop hl			;0c9c	e1 	. 
	ld b,(hl)			;0c9d	46 	F 
	dec hl			;0c9e	2b 	+ 
	ld c,(hl)			;0c9f	4e 	N 
	pop af			;0ca0	f1 	. 
l0ca1h:
	cp 039h		;0ca1	fe 39 	. 9 
	ret nc			;0ca3	d0 	. 
	push af			;0ca4	f5 	. 
	call MAT_sCmpSetSign		;0ca5	cd df 09 	. . . 
	inc hl			;0ca8	23 	# 
	ld (hl),000h		;0ca9	36 00 	6 . 
	ld b,a			;0cab	47 	G 
	pop af			;0cac	f1 	. 
	ld hl,MATH_ACC2_MSB		;0cad	21 2d 79 	! - y 
	call sub_0d69h		;0cb0	cd 69 0d 	. i . 
	ld a,(MATH_ACC2_CY)		;0cb3	3a 26 79 	: & y 
	ld (MATH_ACC_CY),a		;0cb6	32 1c 79 	2 . y 
	ld a,b			;0cb9	78 	x 
	or a			;0cba	b7 	. 
	jp p,l0ccfh		;0cbb	f2 cf 0c 	. . . 
	call ACCAddACC2_MO	; Math : ACC = ACC + ACC2 (Double) MANTISSA only	;0cbe	cd 33 0d 	. 3 . 
	jp nc,l0d0eh		;0cc1	d2 0e 0d 	. . . 
	ex de,hl			;0cc4	eb 	. 
	inc (hl)			;0cc5	34 	4 
	jp z,ErrRaiseOverflow	; Raise OVERFLOW Error		;0cc6	ca b2 07 	. . . 
	call sub_0d90h		;0cc9	cd 90 0d 	. . . 
	jp l0d0eh		;0ccc	c3 0e 0d 	. . . 
l0ccfh:
	call MAT_dSub_ACC2_mo	; ACC = ACC - ACC2 (Double) MANTISSA ONLY	;0ccf	cd 45 0d 	. E . 
	ld hl,MATH_ACC_SIGN		;0cd2	21 25 79 	! % y 
	call c,sub_0d57h		;0cd5	dc 57 0d 	. W . 
l0cd8h:
	xor a			;0cd8	af 	. 
l0cd9h:
	ld b,a			;0cd9	47 	G 
	ld a,(ACC_SNG+2)	 ; Int,Single,String (2 or 4 bytes): 	;0cda	3a 23 79 	: # y 
	or a			;0cdd	b7 	. 
	jr nz,l0cfeh		;0cde	20 1e 	  . 
	ld hl,MATH_ACC_CY		;0ce0	21 1c 79 	! . y 
	ld c,008h		;0ce3	0e 08 	. . 
l0ce5h:
	ld d,(hl)			;0ce5	56 	V 
	ld (hl),a			;0ce6	77 	w 
	ld a,d			;0ce7	7a 	z 
	inc hl			;0ce8	23 	# 
	dec c			;0ce9	0d 	. 
	jr nz,l0ce5h		;0cea	20 f9 	  . 
	ld a,b			;0cec	78 	x 
	sub 008h		;0ced	d6 08 	. . 
	cp 0c0h		;0cef	fe c0 	. . 
	jr nz,l0cd9h		;0cf1	20 e6 	  . 
	jp MAT_sdSetACC_0		;0cf3	c3 78 07 	. x . 
l0cf6h:
	dec b			;0cf6	05 	. 
	ld hl,MATH_ACC_CY		;0cf7	21 1c 79 	! . y 
	call sub_0d97h		;0cfa	cd 97 0d 	. . . 
	or a			;0cfd	b7 	. 
l0cfeh:
	jp p,l0cf6h		;0cfe	f2 f6 0c 	. . . 
	ld a,b			;0d01	78 	x 
	or a			;0d02	b7 	. 
	jr z,l0d0eh		;0d03	28 09 	( . 
	ld hl,MATH_ACC_EXP		;0d05	21 24 79 	! $ y 
	add a,(hl)			;0d08	86 	. 
	ld (hl),a			;0d09	77 	w 
	jp nc,MAT_sdSetACC_0		;0d0a	d2 78 07 	. x . 
	ret z			;0d0d	c8 	. 
l0d0eh:
	ld a,(MATH_ACC_CY)		;0d0e	3a 1c 79 	: . y 
l0d11h:
	or a			;0d11	b7 	. 
	call m,sub_0d20h		;0d12	fc 20 0d 	.   . 
	ld hl,MATH_ACC_SIGN		;0d15	21 25 79 	! % y 
	ld a,(hl)			;0d18	7e 	~ 
	and 080h		;0d19	e6 80 	. . 
	dec hl			;0d1b	2b 	+ 
	dec hl			;0d1c	2b 	+ 
	xor (hl)			;0d1d	ae 	. 
	ld (hl),a			;0d1e	77 	w 
	ret			;0d1f	c9 	. 
sub_0d20h:
	ld hl,ACC_DBL	; addres of Accumulator (Double) ;0d20	21 1d 79 	! . y 
	ld b,007h		;0d23	06 07 	. . 
l0d25h:
	inc (hl)			;0d25	34 	4 
	ret nz			;0d26	c0 	. 
	inc hl			;0d27	23 	# 
	dec b			;0d28	05 	. 
	jr nz,l0d25h		;0d29	20 fa 	  . 
	inc (hl)			;0d2b	34 	4 
	jp z,ErrRaiseOverflow	; Raise OVERFLOW Error		;0d2c	ca b2 07 	. . . 
	dec hl			;0d2f	2b 	+ 
	ld (hl),080h		;0d30	36 80 	6 . 
	ret			;0d32	c9 	. 

// ***********************************************************************
; Math : ACC = ACC + ACC2 (Double)
; Routine operates on the MANTISSA ONLY (exponent byte ignored)
ACCAddACC2_MO:
	ld hl,ACC2		; address of 2nd Accumulator 								;0d33	21 27 79 	! ' y 
ACCAddHLMem_MO:
	ld de,ACC_DBL	; addres of Accumulator (Double) 									;0d36	11 1d 79 	. . y 
DEMemAddHLMem_MO:
	ld c,7			; 7 bytes words to add										;0d39	0e 07 	. . 
	xor a			; clear CY flag												;0d3b	af 	. 
.next:
	ld a,(de)		; a - byte from ACC											;0d3c	1a 	. 
	adc a,(hl)		; add byte from ACC2										;0d3d	8e 	. 
	ld (de),a		; store result into ACC										;0d3e	12 	. 
	inc de			; increment source address									;0d3f	13 	. 
	inc hl			; increment destination address								;0d40	23 	# 
	dec c			; decrement bytes counter - all added?						;0d41	0d 	. 
	jr nz,.next		; no - all all 7 bytes										;0d42	20 f8 	  . 
	ret				; --------------- End of Proc -----------------------------	;0d44	c9 	. 


// ***********************************************************************
; Math : ACC = ACC - ACC2 (Double)
; Routine operates on the MANTISSA ONLY (exponent byte ignored)
MAT_dSub_ACC2_mo:
	ld hl,ACC2		; address of 2nd Accumulator ;0d45	21 27 79 	! ' y 
sub_0d48h:
	ld de,ACC_DBL	; addres of Accumulator (Double) ;0d48	11 1d 79 	. . y 
sub_0d4bh:
	ld c,007h		;0d4b	0e 07 	. . 
	xor a			;0d4d	af 	. 
l0d4eh:
	ld a,(de)			;0d4e	1a 	. 
	sbc a,(hl)			;0d4f	9e 	. 
	ld (de),a			;0d50	12 	. 
	inc de			;0d51	13 	. 
	inc hl			;0d52	23 	# 
	dec c			;0d53	0d 	. 
	jr nz,l0d4eh		;0d54	20 f8 	  . 
	ret			;0d56	c9 	. 
sub_0d57h:
	ld a,(hl)			;0d57	7e 	~ 
	cpl			;0d58	2f 	/ 
	ld (hl),a			;0d59	77 	w 
	ld hl,MATH_ACC_CY		;0d5a	21 1c 79 	! . y 
	ld b,008h		;0d5d	06 08 	. . 
	xor a			;0d5f	af 	. 
l0d60h:
	ld c,a			;0d60	4f 	O 
l0d61h:
	ld a,c			;0d61	79 	y 
	sbc a,(hl)			;0d62	9e 	. 
	ld (hl),a			;0d63	77 	w 
	inc hl			;0d64	23 	# 
	dec b			;0d65	05 	. 
	jr nz,l0d61h		;0d66	20 f9 	  . 
	ret			;0d68	c9 	. 
sub_0d69h:
	ld (hl),c			;0d69	71 	q 
	push hl			;0d6a	e5 	. 
l0d6bh:
	sub 008h		;0d6b	d6 08 	. . 
	jr c,l0d7dh		;0d6d	38 0e 	8 . 
	pop hl			;0d6f	e1 	. 
sub_0d70h:
	push hl			;0d70	e5 	. 
	ld de,l0800h		;0d71	11 00 08 	. . . 
l0d74h:
	ld c,(hl)			;0d74	4e 	N 
	ld (hl),e			;0d75	73 	s 
	ld e,c			;0d76	59 	Y 
	dec hl			;0d77	2b 	+ 
	dec d			;0d78	15 	. 
	jr nz,l0d74h		;0d79	20 f9 	  . 
	jr l0d6bh		;0d7b	18 ee 	. . 
l0d7dh:
	add a,009h		;0d7d	c6 09 	. . 
	ld d,a			;0d7f	57 	W 
l0d80h:
	xor a			;0d80	af 	. 
	pop hl			;0d81	e1 	. 
	dec d			;0d82	15 	. 
	ret z			;0d83	c8 	. 
l0d84h:
	push hl			;0d84	e5 	. 
	ld e,008h		;0d85	1e 08 	. . 
l0d87h:
	ld a,(hl)			;0d87	7e 	~ 
	rra			;0d88	1f 	. 
	ld (hl),a			;0d89	77 	w 
	dec hl			;0d8a	2b 	+ 
	dec e			;0d8b	1d 	. 
	jr nz,l0d87h		;0d8c	20 f9 	  . 
	jr l0d80h		;0d8e	18 f0 	. . 
sub_0d90h:
	ld hl,ACC_SNG+2	 ; Int,Single,String (2 or 4 bytes): 	;0d90	21 23 79 	! # y 
	ld d,001h		;0d93	16 01 	. . 
	jr l0d84h		;0d95	18 ed 	. . 
sub_0d97h:
	ld c,008h		;0d97	0e 08 	. . 
l0d99h:
	ld a,(hl)			;0d99	7e 	~ 
	rla			;0d9a	17 	. 
	ld (hl),a			;0d9b	77 	w 
	inc hl			;0d9c	23 	# 
	dec c			;0d9d	0d 	. 
	jr nz,l0d99h		;0d9e	20 f9 	  . 
	ret			;0da0	c9 	. 


// ***********************************************************************
; Math : ACC = ACC * ACC2 (Double)
dblACCmulACC2:
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;0da1	cd 55 09 	. U . 
	ret z			    ; return if ACC=0 (Result must be 0)                    ;0da4	c8 	. 
	call 0090ah		;0da5	cd 0a 09 	. . . 
	call sub_0e39h		;0da8	cd 39 0e 	. 9 . 
	ld (hl),c			;0dab	71 	q 
	inc de			;0dac	13 	. 
	ld b,007h		;0dad	06 07 	. . 
l0dafh:
	ld a,(de)			;0daf	1a 	. 
	inc de			;0db0	13 	. 
	or a			;0db1	b7 	. 
	push de			;0db2	d5 	. 
	jr z,l0dcch		;0db3	28 17 	( . 
	ld c,008h		;0db5	0e 08 	. . 
l0db7h:
	push bc			;0db7	c5 	. 
	rra			;0db8	1f 	. 
	ld b,a			;0db9	47 	G 
	call c,ACCAddACC2_MO	; Math : ACC = ACC + ACC2 (Double) MANTISSA only	;0dba	dc 33 0d 	. 3 . 
	call sub_0d90h		;0dbd	cd 90 0d 	. . . 
	ld a,b			;0dc0	78 	x 
	pop bc			;0dc1	c1 	. 
	dec c			;0dc2	0d 	. 
	jr nz,l0db7h		;0dc3	20 f2 	  . 
l0dc5h:
	pop de			;0dc5	d1 	. 
	dec b			;0dc6	05 	. 
	jr nz,l0dafh		;0dc7	20 e6 	  . 
	jp l0cd8h		;0dc9	c3 d8 0c 	. . . 
l0dcch:
	ld hl,ACC_SNG+2	 ; Int,Single,String (2 or 4 bytes): 	;0dcc	21 23 79 	! # y 
	call sub_0d70h		;0dcf	cd 70 0d 	. p . 
	jr l0dc5h		;0dd2	18 f1 	. . 
dblConst_10:
	dword #00000000			; along with followin 4 bytes makes Double 10	;0dd4	00 00 00 00 	. 
MAT_sConst_10:
	dword #84200000			; Single 10 constant							;0dd8	00 00 20 84 	  . 


// ***********************************************************************
; Math : ACC = ACC / 10 (Double)
ACCDiv10:
	ld de,dblConst_10	; constant double value = 10.0					;0ddc	11 d4 0d 	. . . 
	ld hl,ACC2			; address of 2nd Accumulator 					;0ddf	21 27 79 	! ' y 
	call DEMemToHLMem	; copy 10.0D to ACC2							;0de2	cd d3 09 	. . . 



// ***********************************************************************
; Math : ACC = ACC / ACC2 (Double)
ACCDivACC2
	ld a,(MATH_ACC2_EXP)		;0de5	3a 2e 79 	: . y 
	or a			        ; is Exponent = 0 ;0de8	b7 	. 
	jp z,ErrRaiseDivByZero	; yes - Raise 'DIVISION BY ZERO' error		;0de9	ca 9a 19 	. . . 
	call sub_0907h		;0dec	cd 07 09 	. . . 
	inc (hl)			;0def	34 	4 
	inc (hl)			;0df0	34 	4 
	call sub_0e39h		;0df1	cd 39 0e 	. 9 . 
	ld hl,MATH_ACC3_EXP		;0df4	21 51 79 	! Q y 
	ld (hl),c			;0df7	71 	q 
	ld b,c			;0df8	41 	A 
l0df9h:
	ld de,MATH_ACC3_DBL		;0df9	11 4a 79 	. J y 
	ld hl,ACC2		; address of 2nd Accumulator ;0dfc	21 27 79 	! ' y 
	call sub_0d4bh		;0dff	cd 4b 0d 	. K . 
	ld a,(de)			;0e02	1a 	. 
	sbc a,c			;0e03	99 	. 
	ccf			;0e04	3f 	? 
	jr c,$+13		;0e05	38 0b 	8 . 
	ld de,MATH_ACC3_DBL		;0e07	11 4a 79 	. J y 
	ld hl,ACC2		; address of 2nd Accumulator ;0e0a	21 27 79 	! ' y 
	call DEMemAddHLMem_MO	; ACC = [DE] + [HL] - MANTISSA only		;0e0d	cd 39 0d 	. 9 . 
	xor a			;0e10	af 	. 
	jp c,00412h		;0e11	da 12 04 	. . . 
	ld a,(ACC_SNG+2)	 ; Int,Single,String (2 or 4 bytes): 	;0e14	3a 23 79 	: # y 
	inc a			;0e17	3c 	< 
	dec a			;0e18	3d 	= 
	rra			;0e19	1f 	. 
	jp m,l0d11h		;0e1a	fa 11 0d 	. . . 
	rla			;0e1d	17 	. 
	ld hl,ACC_DBL		; addres of Accumulator (Double) ;0e1e	21 1d 79 	! . y 
	ld c,007h		;0e21	0e 07 	. . 
	call l0d99h		;0e23	cd 99 0d 	. . . 
	ld hl,MATH_ACC3_DBL		;0e26	21 4a 79 	! J y 
	call sub_0d97h		;0e29	cd 97 0d 	. . . 
	ld a,b			;0e2c	78 	x 
	or a			;0e2d	b7 	. 
	jr nz,l0df9h		;0e2e	20 c9 	  . 
	ld hl,MATH_ACC_EXP		;0e30	21 24 79 	! $ y 
	dec (hl)			;0e33	35 	5 
	jr nz,l0df9h		;0e34	20 c3 	  . 
	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;0e36	c3 b2 07 	. . . 
sub_0e39h:
	ld a,c			;0e39	79 	y 
l0e3ah:
	ld (MATH_ACC2_MSB),a		;0e3a	32 2d 79 	2 - y 
	dec hl			;0e3d	2b 	+ 
	ld de,MATH_ACC3_MSB		;0e3e	11 50 79 	. P y 
	ld bc,00700h		;0e41	01 00 07 	. . . 
l0e44h:
	ld a,(hl)			;0e44	7e 	~ 
	ld (de),a			;0e45	12 	. 
	ld (hl),c			;0e46	71 	q 
	dec de			;0e47	1b 	. 
	dec hl			;0e48	2b 	+ 
	dec b			;0e49	05 	. 
	jr nz,l0e44h		;0e4a	20 f8 	  . 
	ret			;0e4c	c9 	. 


// ***********************************************************************
; Math : ACC = ACC * 10 (Double)
dblACCmul10:
	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;0e4d	cd fc 09 	. . . 
	ex de,hl			;0e50	eb 	. 
	dec hl			;0e51	2b 	+ 
	ld a,(hl)			;0e52	7e 	~ 
	or a			;0e53	b7 	. 
	ret z			;0e54	c8 	. 
	add a,002h		;0e55	c6 02 	. . 
	jp c,ErrRaiseOverflow	; Raise OVERFLOW Error		;0e57	da b2 07 	. . . 
	ld (hl),a			;0e5a	77 	w 
	push hl			;0e5b	e5 	. 
	call ACCAddACC2	; Math : ACC = ACC + ACC2 (Double)	;0e5c	cd 77 0c 	. w . 
	pop hl			;0e5f	e1 	. 
	inc (hl)			;0e60	34 	4 
	ret nz			;0e61	c0 	. 
	jp ErrRaiseOverflow	; Raise OVERFLOW Error		;0e62	c3 b2 07 	. . . 


; ********************************************************************************
; Math : Convert from ASCII const (HL) to Double (ACC)
; IN: hl - Address of Ascii string
StrToDbl:
	call MAT_sdSetACC_0		;0e65	cd 78 07 	. x . 
	call SetNTFDbl		;0e68	cd ec 0a 	. . . 
	db $f6				; trick byte - with next constructs irrevelant "or $af"		;0e6b	f6 af 	. . 

; ********************************************************************************
; Math : Convert from ASCII const (HL) to Any (ACC)
; Evaluate a numeric string that begins at the address pointed to by the HL register pair,
; store it in ACC and set the NTF, 
; This routine stops as soon as it encounters a character that is not part of the number
; (it will return a value of zero if no valid numeric characters are found). 
; It will accept signed values in Integer, Real or Scientific Notation. 
; Number returned will be in Integer format if possible, else single precision 
; unless the string has over seven digits (not including exponent), in which case 
; number will be returned as Double precision.
; IN: hl - Address of Ascii string
StrToNum:	
	xor a				;0e6c	af 	. . 
	ex de,hl			;0e6d	eb 	. 
	ld bc,00ffh		;0e6e	01 ff 00 	. . . 
	ld h,b			;0e71	60 	` 
	ld l,b			;0e72	68 	h 
	call z,ACCfromHLValue	; copy value from hl to ACC as integer number		;0e73	cc 9a 0a 	. . . 
	ex de,hl			;0e76	eb 	. 
	ld a,(hl)			;0e77	7e 	~ 
	cp 02dh		;0e78	fe 2d 	. - 
	push af			;0e7a	f5 	. 
	jp z,l0e83h		;0e7b	ca 83 0e 	. . . 
	cp 02bh		;0e7e	fe 2b 	. + 
	jr z,l0e83h		;0e80	28 01 	( . 
	dec hl			;0e82	2b 	+ 
l0e83h:
	rst $10			; move hl to next Basic token	;0e83	d7 	. 
	jp c,l0f29h		; call if found numeric constant ;0e84	da 29 0f 	. ) . 
	cp '.'		    ; is it '.' char - next is fractional part ;0e87	fe 2e 	. . 
	jp z,l0ee4h		; yes - ;0e89	ca e4 0e 	. . . 
	cp 'E'		    ; is it 'E' char - next is exponent part ;0e8c	fe 45 	. E 
	jr z,l0ea4h		; yes - ;0e8e	28 14 	( . 
	cp '%'		    ; is it '%' char - (???) modulo/binary ;0e90	fe 25 	. % 
	jp z,l0eeeh		; yes - ;0e92	ca ee 0e 	. . . 
	cp '#'		    ; is it '#' char - ;0e95	fe 23 	. # 
	jp z,l0ef5h		; yes - ;0e97	ca f5 0e 	. . . 
	cp '!'		    ; is it '!' char - (???) ;0e9a	fe 21 	. ! 
	jp z,l0ef6h		; yes - ;0e9c	ca f6 0e 	. . . 
	cp 'D'		    ; is it 'D' char - ;0e9f	fe 44 	. D 
	jr nz,l0ec7h	; yes - ;0ea1	20 24 	  $ 
	or a			;0ea3	b7 	. 

; -- found 'E' char 
l0ea4h:
	call sub_0efbh		;0ea4	cd fb 0e 	. . . 
	push hl			;0ea7	e5 	. 
	ld hl,l0ebdh		;0ea8	21 bd 0e 	! . . 
	ex (sp),hl			;0eab	e3 	. 
	rst $10			; move hl to next Basic token		;0eac	d7 	. 
	dec d			;0ead	15 	. 
	cp $ce		    ; is it Basic '-' token ;0eae	fe ce 	. . 
	ret z			; yes - ;0eb0	c8 	. 
	cp '-'		    ; is it '-' char? ;0eb1	fe 2d 	. - 
	ret z			; yes - ;0eb3	c8 	. 
	inc d			;0eb4	14 	. 
	cp $cd		    ; is it Basic '+' token ;0eb5	fe cd 	. . 
	ret z			; yes - ;0eb7	c8 	. 
	cp '+'		    ; is it '+' char ? ;0eb8	fe 2b 	. + 
	ret z			; yes - ;0eba	c8 	. 
	dec hl			;0ebb	2b 	+ 
	pop af			;0ebc	f1 	. 
l0ebdh:
	rst $10			; move hl to next Basic token		;0ebd	d7 	. 
	jp c,l0f94h		; jump if found numeric constant ;0ebe	da 94 0f 	. . . 
	inc d			;0ec1	14 	. 
	jr nz,l0ec7h		;0ec2	20 03 	  . 
	xor a			;0ec4	af 	. 
	sub e			;0ec5	93 	. 
	ld e,a			;0ec6	5f 	_ 
; -- found 'D' char
l0ec7h:
	push hl			;0ec7	e5 	. 
	ld a,e			;0ec8	7b 	{ 
	sub b			;0ec9	90 	. 
l0ecah:
	call p,MAT_sdMul_10		;0eca	f4 0a 0f 	. . . 
	call m,MAT_sdDiv_10		;0ecd	fc 18 0f 	. . . 
	jr nz,l0ecah		;0ed0	20 f8 	  . 
	pop hl			;0ed2	e1 	. 
	pop af			;0ed3	f1 	. 
	push hl			;0ed4	e5 	. 
	call z,l097bh		;0ed5	cc 7b 09 	. { . 
	pop hl			;0ed8	e1 	. 
	rst #20			; test NTF (Number Type Format) - is it Single? ;0ed9	e7 	. 
	ret pe			; no - ;0eda	e8 	. 
	push hl			;0edb	e5 	. 
	ld hl,l0890h		;0edc	21 90 08 	! . . 
	push hl			;0edf	e5 	. 
	call l0aa3h		;0ee0	cd a3 0a 	. . . 
	ret			;0ee3	c9 	. 
; -- found '.' char 
l0ee4h:
	rst #20			; test NTF (Number Type Format) ;0ee4	e7 	. 
	inc c			;0ee5	0c 	. 
	jr nz,l0ec7h		;0ee6	20 df 	  . 
	call c,sub_0efbh	; call if NTF is not Double	;0ee8	dc fb 0e 	. . . 
	jp l0e83h		;0eeb	c3 83 0e 	. . . 
; -- found '%' char 
l0eeeh:
	rst #20			; test NTF (Number Type Format)  ;0eee	e7 	. 
	jp p,ErrRaiseSyntax	; Single or Double - Raise 'SYNTAX ERROR'	;0eef	f2 97 19 	. . . 
l0ef2h:
	inc hl			;0ef2	23 	# 
	jr l0ec7h		;0ef3	18 d2 	. . 
; -- found '#' char
l0ef5h:
	or a			;0ef5	b7 	. 
; -- found '!' char 
l0ef6h:
	call sub_0efbh		;0ef6	cd fb 0e 	. . . 
	jr l0ef2h		;0ef9	18 f7 	. . 
sub_0efbh:
	push hl			;0efb	e5 	. 
	push de			;0efc	d5 	. 
	push bc			;0efd	c5 	. 
	push af			;0efe	f5 	. 
	call z,FuncCSNG		; convert ACC to Single value	;0eff	cc b1 0a 	. . . 
	pop af			;0f02	f1 	. 
	call nz,FuncCDBL	; convert ACC to Double value	;0f03	c4 db 0a 	. . . 
	pop bc			;0f06	c1 	. 
	pop de			;0f07	d1 	. 
	pop hl			;0f08	e1 	. 
	ret			;0f09	c9 	. 

// ***********************************************************************
; Math : ACC = ACC * 10 (Single or Double)
MAT_sdMul_10:
	ret z			;0f0a	c8 	. 
sub_0f0bh:
	push af			;0f0b	f5 	. 
	rst #20			; test NTF (Number Type Format)  ;0f0c	e7 	. 
	push af			; save af - Number Type Format ;0f0d	f5 	. 
	call po,sngACCmul10	; Single - ACC = ACC * 10 (Single) 	;0f0e	e4 3e 09 	. > . 
	pop af			;0f11	f1 	. 
	call pe,dblACCmul10	; ACC = ACC * 10 (Double)	;0f12	ec 4d 0e 	. M . 
	pop af			;0f15	f1 	. 
sub_0f16h:
	dec a			;0f16	3d 	= 
	ret			;0f17	c9 	. 

// ***********************************************************************
; Math : ACC = ACC / 10 (Single or Double)
MAT_sdDiv_10:
	push de			;0f18	d5 	. 
	push hl			;0f19	e5 	. 
	push af			;0f1a	f5 	. 
	rst #20			; test NTF (Number Type Format) ;0f1b	e7 	. 
	push af			; save af - Number Type Format	;0f1c	f5 	. 
	call po,MAT_sDiv_10	; Single - 	;0f1d	e4 97 08 	. . . 
	pop af			; restore af ;0f20	f1 	. 
	call pe,ACCDiv10; Double -  ACC = ACC / 10 (Double)	;0f21	ec dc 0d 	. . . 
	pop af			;0f24	f1 	. 
	pop hl			;0f25	e1 	. 
	pop de			;0f26	d1 	. 
	inc a			;0f27	3c 	< 
	ret			;0f28	c9 	. 
; -- found numeric constant (hl)
l0f29h:
	push de			;0f29	d5 	. 
	ld a,b			;0f2a	78 	x 
	adc a,c			;0f2b	89 	. 
	ld b,a			;0f2c	47 	G 
	push bc			;0f2d	c5 	. 
	push hl			;0f2e	e5 	. 
	ld a,(hl)			;0f2f	7e 	~ 
	sub 030h		;0f30	d6 30 	. 0 
	push af			;0f32	f5 	. 
	rst #20			; test NTF (Number Type Format) - is it Single or Double?	;0f33	e7 	. 
	jp p,l0f5dh		; yes - ;0f34	f2 5d 0f 	. ] . 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;0f37	2a 21 79 	* ! y 
	ld de,00ccdh		;0f3a	11 cd 0c 	. . . 
	rst #18			; Compare HL and DE ;0f3d	df 	. 
	jr nc,l0f59h		;0f3e	30 19 	0 . 
	ld d,h			;0f40	54 	T 
	ld e,l			;0f41	5d 	] 
	add hl,hl			;0f42	29 	) 
	add hl,hl			;0f43	29 	) 
	add hl,de			;0f44	19 	. 
	add hl,hl			;0f45	29 	) 
	pop af			;0f46	f1 	. 
	ld c,a			;0f47	4f 	O 
	add hl,bc			;0f48	09 	. 
	ld a,h			;0f49	7c 	| 
	or a			;0f4a	b7 	. 
	jp m,l0f57h		;0f4b	fa 57 0f 	. W . 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;0f4e	22 21 79 	" ! y 
l0f51h:
	pop hl			;0f51	e1 	. 
	pop bc			;0f52	c1 	. 
	pop de			;0f53	d1 	. 
	jp l0e83h		;0f54	c3 83 0e 	. . . 
l0f57h:
	ld a,c			;0f57	79 	y 
	push af			;0f58	f5 	. 
l0f59h:
	call MAT_iConvToSng	; Convert from Integer to Single (ACC)		;0f59	cd cc 0a 	. . . 
	scf			;0f5c	37 	7 
	

ld_BCDE:	macro Val32bit
			ld bc,Val32bit >> 16
			ld de,Val32bit & 0xffff
		endm


l0f5dh:
	jr nc,l0f77h		;0f5d	30 18 	0 . 
	;ld bc,$9474		;0f5f	01 74 94 	. t . 
	;ld de,$2400		;0f62	11 00 24 	. . $ 
	ld_BCDE $94742400
	call MAT_sCmp_ACC_BCDE	; Compare ACC and BCDE (Single)		;0f65	cd 0c 0a 	. . . 
	jp p,l0f74h		;0f68	f2 74 0f 	. t . 
	call sngACCmul10	; ACC = ACC * 10 (Single) 		;0f6b	cd 3e 09 	. > . 
	pop af			;0f6e	f1 	. 
	call sub_0f89h		;0f6f	cd 89 0f 	. . . 
	jr l0f51h		;0f72	18 dd 	. . 
l0f74h:
	call sngACCconvToDbl	; Convert ACC from Single to Double	;0f74	cd e3 0a 	. . . 
l0f77h:
	call dblACCmul10	        ; ACC = ACC * 10 (Double)	;0f77	cd 4d 0e 	. M . 
	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;0f7a	cd fc 09 	. . . 
	pop af			;0f7d	f1 	. 
	call MAT_iConvToSngA	; Convert from Integer (A) to Single (ACC)	;0f7e	cd 64 09 	. d . 
	call sngACCconvToDbl	; Convert ACC from Single to Double	;0f81	cd e3 0a 	. . . 
	call ACCAddACC2		; Math : ACC = ACC + ACC2 (Double);0f84	cd 77 0c 	. w . 
	jr l0f51h		;0f87	18 c8 	. . 
sub_0f89h:
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;0f89	cd a4 09 	. . . 
	call MAT_iConvToSngA	; Convert from Integer (A) to Single (ACC)	;0f8c	cd 64 09 	. d . 
l0f8fh:
	pop bc			;0f8f	c1 	. 
	pop de			;0f90	d1 	. 
	jp sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 ;0f91	c3 16 07 	. . . 
l0f94h:
	ld a,e			;0f94	7b 	{ 
	cp 00ah		;0f95	fe 0a 	. . 
	jr nc,$+11		;0f97	30 09 	0 . 
	rlca			;0f99	07 	. 
	rlca			;0f9a	07 	. 
	add a,e			;0f9b	83 	. 
	rlca			;0f9c	07 	. 
	add a,(hl)			;0f9d	86 	. 
	sub 030h		;0f9e	d6 30 	. 0 
	ld e,a			;0fa0	5f 	_ 
	jp m,0321eh		;0fa1	fa 1e 32 	. . 2 
	jp l0ebdh		;0fa4	c3 bd 0e 	. . . 

; ********************************************************************************
; Display "IN xxxxx" (line number)
; IN: hl - line number
PrintINLINE:
	push hl			        ; save hl                                               ;0fa7	e5 	. 
	ld hl,TXT_INLINE		; text "IN "                                            ;0fa8	21 24 19 	! $ . 
	call PrintBasicStr		; print "IN " text on Screen                            ;0fab	cd a7 28 	. . ( 
	pop hl			        ; restore hl                                            ;0fae	e1 	. 
; ********************************************************************************
; Print Line number (any unsigned 16 bit integer)
; IN: hl - line number
PrintLineNo:
	call ACCfromHLValue	; copy value from h; to ACC as integer number           ;0faf	cd 9a 0a 	. . . 
	xor a			;0fb2	af 	. 
	call sub_1034h		;0fb3	cd 34 10 	. 4 . 
	or (hl)			;0fb6	b6 	. 
	call sub_0fd9h		;0fb7	cd d9 0f 	. . . 
	jp BAS_SendStringInc	; print null terminated string (CStr) from [hl+1]	;0fba	c3 a6 28 	. . ( 


; ********************************************************************************
; Math: Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)
; Converts number in ACCUM to ASCII string stored in buffer, and HL register 
; will point to last leading space (that is, the space just before the first 
; non-space character of the created string). 
; When positive integers greater than zero (such as BASIC line numbers) are converted,, 
; the area from 7930 to 7936 is used, and the string is stored right justified 
; with leading spaces (7930 always contains a space character), while 7936
; always contains a zero byte to terminate the string. Other number types
; may be converted and stored differently within the buffer.
; IN: b - number of digits to left of decimal point (include commas)
;         but exclude space and sign character
;     c - number of digits to right of decimal point plus one (for dec point) 
NumToStr:
	xor a			;0fbd	af 	. 
; ********************************************************************************
; Math: Convert value from ACC (Any) to String in Buffer (7930-7941)
; Description above except additional formating flags are included in A:
;	bit 7 - perform edit
;   bit 6 - include commas
;	bit 5 - asterix fill
;	bit 4 - precede by $
;	bit 3 - force sign (+ or -)
;	bit 2 - trailing sign
;	bit 1 - ???
;	bit 0 - scientific notation
; IN: b - number of digits to left of decimal point (include commas)
;         but exclude space and sign character
;     c - number of digits to right of decimal point plus one (for dec point) 
;     a - format flags on bits 7..0
NumToStrFmt:
	call sub_1034h		;0fbe	cd 34 10 	. 4 . 
	and 008h		;0fc1	e6 08 	. . 
	jr z,l0fc7h		;0fc3	28 02 	( . 
	ld (hl),02bh		;0fc5	36 2b 	6 + 
l0fc7h:
	ex de,hl			;0fc7	eb 	. 
	call TestACCSign	; Check Sign of number in ACC (Any)		;0fc8	cd 94 09 	. . . 
	ex de,hl			;0fcb	eb 	. 
	jp p,sub_0fd9h		;0fcc	f2 d9 0f 	. . . 
	ld (hl),02dh		;0fcf	36 2d 	6 - 
	push bc			;0fd1	c5 	. 
	push hl			;0fd2	e5 	. 
	call l097bh		;0fd3	cd 7b 09 	. { . 
	pop hl			;0fd6	e1 	. 
	pop bc			;0fd7	c1 	. 
	or h			;0fd8	b4 	. 
sub_0fd9h:
	inc hl			;0fd9	23 	# 
	ld (hl),030h		;0fda	36 30 	6 0 
	ld a,(BAS_TempFlags)	; temporary byte	;0fdc	3a d8 78 	: . x 
	ld d,a			;0fdf	57 	W 
	rla			;0fe0	17 	. 
	ld a,(MATH_NTF)		;0fe1	3a af 78 	: . x 
	jp c,l109ah		;0fe4	da 9a 10 	. . . 
	jp z,l1092h		;0fe7	ca 92 10 	. . . 
	cp 004h		;0fea	fe 04 	. . 
	jp nc,l103dh		;0fec	d2 3d 10 	. = . 
	ld bc,$0000		;0fef	01 00 00 	. . . 
	call sub_132fh		;0ff2	cd 2f 13 	. / . 
sub_0ff5h:
	ld hl,SysConvBuffer		;0ff5	21 30 79 	! 0 y 
	ld b,(hl)			;0ff8	46 	F 
	ld c,020h		;0ff9	0e 20 	.   
	ld a,(BAS_TempFlags)	; temporary byte	;0ffb	3a d8 78 	: . x 
	ld e,a			;0ffe	5f 	_ 
	and 020h		;0fff	e6 20 	.   
	jr z,l100ah		;1001	28 07 	( . 
	ld a,b			;1003	78 	x 
	cp c			;1004	b9 	. 
	ld c,02ah		;1005	0e 2a 	. * 
	jr nz,l100ah		;1007	20 01 	  . 
	ld b,c			;1009	41 	A 
l100ah:
	ld (hl),c			;100a	71 	q 
	rst $10			; move hl to next Basic token		;100b	d7 	. 
	jr z,l1022h		; jump if '\0' or ':' - end of statement found ;100c	28 14 	( . 
	cp 'E'		    ; is it 'E' char ? ;100e	fe 45 	. E 
	jr z,l1022h		; yes - ;1010	28 10 	( . 
	cp 'D'		    ; is it 'D' char ? ;1012	fe 44 	. D 
	jr z,l1022h		; yes - ;1014	28 0c 	( . 
	cp '0'		    ; is iot '0' char? ;1016	fe 30 	. 0 
	jr z,l100ah		; yes - continue ...;1018	28 f0 	( . 
	cp ','		    ; is it ',' char ;101a	fe 2c 	. , 
	jr z,l100ah		; yes - continue ...;101c	28 ec 	( . 
	cp '.'		    ; is it '.' char ;101e	fe 2e 	. . 
	jr nz,l1025h	; no - 	;1020	20 03 	  . 
; -- found '\0', ':', 'E' or 'D'  
l1022h:
	dec hl			;1022	2b 	+ 
	ld (hl),'0'		;1023	36 30 	6 0 
l1025h:
	ld a,e			;1025	7b 	{ 
	and 010h		;1026	e6 10 	. . 
	jr z,l102dh		;1028	28 03 	( . 
	dec hl			;102a	2b 	+ 
	ld (hl),024h		;102b	36 24 	6 $ 
l102dh:
	ld a,e			;102d	7b 	{ 
	and 004h		;102e	e6 04 	. . 
	ret nz			;1030	c0 	. 
	dec hl			;1031	2b 	+ 
	ld (hl),b			;1032	70 	p 
	ret			;1033	c9 	. 
sub_1034h:
	ld (BAS_TempFlags),a	; temporary byte	;1034	32 d8 78 	2 . x 
	ld hl,SysConvBuffer		;1037	21 30 79 	! 0 y 
	ld (hl),' '		;103a	36 20 	6   
	ret			;103c	c9 	. 

; IN - a - NTF (4 for Single or 8 for Double)
l103dh:
	cp 5			; set CY=1 if Single										;103d	fe 05 	. . 
	push hl			; save hl ;103f	e5 	. 
	sbc a,0			; a - 3 for single, 8 for double ;1040	de 00 	. . 
	rla				; a - 1 for single, 4 for double ;1042	17 	. 
	ld d,a			; d - 1 for single, 4 for double ;1043	57 	W 
	inc d			; d - 2 for single, 5 for double ;1044	14 	. 
	call sub_1201h		;1045	cd 01 12 	. . . 
	ld bc,$0300		;1048	01 00 03 	. . . 
	add a,d			;104b	82 	. 
	jp m,l1057h		;104c	fa 57 10 	. W . 
	inc d			;104f	14 	. 
	cp d			;1050	ba 	. 
	jr nc,l1057h		;1051	30 04 	0 . 
	inc a			;1053	3c 	< 
	ld b,a			;1054	47 	G 
	ld a,002h		;1055	3e 02 	> . 
l1057h:
	sub 002h		;1057	d6 02 	. . 
	pop hl			;1059	e1 	. 
	push af			;105a	f5 	. 
	call sub_1291h		;105b	cd 91 12 	. . . 
	ld (hl),030h		;105e	36 30 	6 0 
	call z,inc_hl		;1060	cc c9 09 	. . . 
	call sub_12a4h		;1063	cd a4 12 	. . . 
l1066h:
	dec hl			;1066	2b 	+ 
	ld a,(hl)			;1067	7e 	~ 
	cp 030h		;1068	fe 30 	. 0 
	jr z,l1066h		;106a	28 fa 	( . 
	cp 02eh		;106c	fe 2e 	. . 
	call nz,inc_hl		;106e	c4 c9 09 	. . . 
	pop af			;1071	f1 	. 
	jr z,l1093h		;1072	28 1f 	( . 
sub_1074h:
	push af			;1074	f5 	. 
	rst #20			; test NTF (Number Type Format) ;1075	e7 	. 
	ld a,022h		;1076	3e 22 	> " 
	adc a,a			;1078	8f 	. 
	ld (hl),a			;1079	77 	w 
	inc hl			;107a	23 	# 
	pop af			;107b	f1 	. 
	ld (hl),02bh		;107c	36 2b 	6 + 
	jp p,l1085h		;107e	f2 85 10 	. . . 
	ld (hl),02dh		;1081	36 2d 	6 - 
	cpl			;1083	2f 	/ 
	inc a			;1084	3c 	< 
l1085h:
	ld b,02fh		;1085	06 2f 	. / 
l1087h:
	inc b			;1087	04 	. 
	sub 00ah		;1088	d6 0a 	. . 
	jr nc,l1087h		;108a	30 fb 	0 . 
	add a,03ah		;108c	c6 3a 	. : 
	inc hl			;108e	23 	# 
	ld (hl),b			;108f	70 	p 
	inc hl			;1090	23 	# 
	ld (hl),a			;1091	77 	w 
l1092h:
	inc hl			;1092	23 	# 
l1093h:
	ld (hl),000h		;1093	36 00 	6 . 
	ex de,hl			;1095	eb 	. 
	ld hl,SysConvBuffer		;1096	21 30 79 	! 0 y 
	ret			;1099	c9 	. 
l109ah:
	inc hl			;109a	23 	# 
	push bc			;109b	c5 	. 
	cp 004h		;109c	fe 04 	. . 
	ld a,d			;109e	7a 	z 
	jp nc,l1109h		;109f	d2 09 11 	. . . 
	rra			;10a2	1f 	. 
	jp c,l11a3h		;10a3	da a3 11 	. . . 
	ld bc,0603h		;10a6	01 03 06 	. . . 
	call sub_1289h		;10a9	cd 89 12 	. . . 
	pop de			;10ac	d1 	. 
	ld a,d			;10ad	7a 	z 
	sub 005h		;10ae	d6 05 	. . 
	call p,sub_1269h		;10b0	f4 69 12 	. i . 
	call sub_132fh		;10b3	cd 2f 13 	. / . 
l10b6h:
	ld a,e			;10b6	7b 	{ 
	or a			;10b7	b7 	. 
	call z,sub_092fh		;10b8	cc 2f 09 	. / . 
	dec a			;10bb	3d 	= 
	call p,sub_1269h		;10bc	f4 69 12 	. i . 
l10bfh:
	push hl			;10bf	e5 	. 
	call sub_0ff5h		;10c0	cd f5 0f 	. . . 
	pop hl			;10c3	e1 	. 
	jr z,l10c8h		;10c4	28 02 	( . 
	ld (hl),b			;10c6	70 	p 
	inc hl			;10c7	23 	# 
l10c8h:
	ld (hl),000h		;10c8	36 00 	6 . 
	ld hl,0792fh		;10ca	21 2f 79 	! / y 
l10cdh:
	inc hl			;10cd	23 	# 
l10ceh:
	ld a,(BAS_ExprTmpPtr)	;		;10ce	3a f3 78 	: . x 
	sub l			;10d1	95 	. 
	sub d			;10d2	92 	. 
	ret z			;10d3	c8 	. 
	ld a,(hl)			;10d4	7e 	~ 
	cp 020h		;10d5	fe 20 	.   
	jr z,l10cdh		;10d7	28 f4 	( . 
	cp 02ah		;10d9	fe 2a 	. * 
	jr z,l10cdh		;10db	28 f0 	( . 
	dec hl			;10dd	2b 	+ 
	push hl			;10de	e5 	. 
l10dfh:
	push af			;10df	f5 	. 
	ld bc,l10dfh		;10e0	01 df 10 	. . . 
	push bc			;10e3	c5 	. 
	rst $10			; move hl to next Basic token			;10e4	d7 	. 
	cp '-'		    ; is it '-' char ? ;10e5	fe 2d 	. - 
	ret z			; yes - continue ... ;10e7	c8 	. 
	cp '+'		    ; is it '+' char ? ;10e8	fe 2b 	. + 
	ret z			; yes - continue ... ;10ea	c8 	. 
	cp '$'		    ; is it '$' char ? ;10eb	fe 24 	. $ 
	ret z			; yes - continue ...;10ed	c8 	. 
	pop bc			;10ee	c1 	. 
	cp '0'		    ; is it '0' char ;10ef	fe 30 	. 0 
	jr nz,l1102h	; no - 	;10f1	20 0f 	  . 
	inc hl			;10f3	23 	# 
	rst $10			; move hl to next Basic token			;10f4	d7 	. 
	jr nc,l1102h	; jump if Letter found  	;10f5	30 0b 	0 . 
	dec hl			;10f7	2b 	+ 
; -- fake opcode to skip 
    ;ld bc,0772bh		;10f8	01 2b 77 	. + w 
    db $01		    ;10f8	01	. 
l10f9h:
    dec hl          ;10f9	2b 	+ 
    ld (hl),a		;10fa	77 	. + w 
	pop af			;10fb	f1 	. 
	jr z,l10f9h		;10fc	28 fb 	( . 
	pop bc			;10fe	c1 	. 
	jp l10ceh		;10ff	c3 ce 10 	. . . 
l1102h:
	pop af			;1102	f1 	. 
	jr z,l1102h		;1103	28 fd 	( . 
	pop hl			;1105	e1 	. 
	ld (hl),025h		;1106	36 25 	6 % 
	ret			;1108	c9 	. 
l1109h:
	push hl			;1109	e5 	. 
	rra			;110a	1f 	. 
	jp c,l11aah		;110b	da aa 11 	. . . 
	jr z,l1124h		;110e	28 14 	( . 
	ld de,l1384h		;1110	11 84 13 	. . . 
	call ACCCmpDEMem	; Compare ACC and (DE) (Double)	;1113	cd 49 0a 	. I . 
	ld d,010h		;1116	16 10 	. . 
	jp m,l1132h		;1118	fa 32 11 	. 2 . 
l111bh:
	pop hl			;111b	e1 	. 
	pop bc			;111c	c1 	. 
	call NumToStr	; Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)	;111d	cd bd 0f 	. . . 
	dec hl			;1120	2b 	+ 
	ld (hl),025h		;1121	36 25 	6 % 
	ret			;1123	c9 	. 
l1124h:
	ld bc,0b60eh		;1124	01 0e b6 	. . . 
	ld de,l1bcah		;1127	11 ca 1b 	. . . 
	call MAT_sCmp_ACC_BCDE		;112a	cd 0c 0a 	. . . 
	jp p,l111bh		;112d	f2 1b 11 	. . . 
	ld d,006h		;1130	16 06 	. . 
l1132h:
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;1132	cd 55 09 	. U . 
	call nz,sub_1201h		;1135	c4 01 12 	. . . 
	pop hl			;1138	e1 	. 
	pop bc			;1139	c1 	. 
	jp m,l1157h		;113a	fa 57 11 	. W . 
	push bc			;113d	c5 	. 
	ld e,a			;113e	5f 	_ 
	ld a,b			;113f	78 	x 
	sub d			;1140	92 	. 
	sub e			;1141	93 	. 
	call p,sub_1269h		;1142	f4 69 12 	. i . 
	call sub_127dh		;1145	cd 7d 12 	. } . 
	call sub_12a4h		;1148	cd a4 12 	. . . 
	or e			;114b	b3 	. 
	call nz,sub_1277h		;114c	c4 77 12 	. w . 
	or e			;114f	b3 	. 
	call nz,sub_1291h		;1150	c4 91 12 	. . . 
	pop de			;1153	d1 	. 
	jp l10b6h		;1154	c3 b6 10 	. . . 
l1157h:
	ld e,a			;1157	5f 	_ 
	ld a,c			;1158	79 	y 
	or a			;1159	b7 	. 
	call nz,sub_0f16h		;115a	c4 16 0f 	. . . 
	add a,e			;115d	83 	. 
	jp m,l1162h		;115e	fa 62 11 	. b . 
	xor a			;1161	af 	. 
l1162h:
	push bc			;1162	c5 	. 
	push af			;1163	f5 	. 
l1164h:
	call m,MAT_sdDiv_10		;1164	fc 18 0f 	. . . 
	jp m,l1164h		;1167	fa 64 11 	. d . 
	pop bc			;116a	c1 	. 
	ld a,e			;116b	7b 	{ 
	sub b			;116c	90 	. 
	pop bc			;116d	c1 	. 
	ld e,a			;116e	5f 	_ 
	add a,d			;116f	82 	. 
	ld a,b			;1170	78 	x 
	jp m,l117fh		;1171	fa 7f 11 	.  . 
	sub d			;1174	92 	. 
	sub e			;1175	93 	. 
	call p,sub_1269h		;1176	f4 69 12 	. i . 
	push bc			;1179	c5 	. 
	call sub_127dh		;117a	cd 7d 12 	. } . 
	jr l1190h		;117d	18 11 	. . 
l117fh:
	call sub_1269h		;117f	cd 69 12 	. i . 
	ld a,c			;1182	79 	y 
	call sub_1294h		;1183	cd 94 12 	. . . 
	ld c,a			;1186	4f 	O 
	xor a			;1187	af 	. 
	sub d			;1188	92 	. 
	sub e			;1189	93 	. 
	call sub_1269h		;118a	cd 69 12 	. i . 
	push bc			;118d	c5 	. 
	ld b,a			;118e	47 	G 
	ld c,a			;118f	4f 	O 
l1190h:
	call sub_12a4h		;1190	cd a4 12 	. . . 
	pop bc			;1193	c1 	. 
	or c			;1194	b1 	. 
	jr nz,l119ah		;1195	20 03 	  . 
	ld hl,(BAS_ExprTmpPtr)	; [TRS] expression parser current position	;1197	2a f3 78 	* . x 
l119ah:
	add a,e			;119a	83 	. 
	dec a			;119b	3d 	= 
	call p,sub_1269h		;119c	f4 69 12 	. i . 
	ld d,b			;119f	50 	P 
	jp l10bfh		;11a0	c3 bf 10 	. . . 
l11a3h:
	push hl			;11a3	e5 	. 
	push de			;11a4	d5 	. 
	call MAT_iConvToSng	; Convert from Integer to Single (ACC)		;11a5	cd cc 0a 	. . . 
	pop de			;11a8	d1 	. 
	xor a			;11a9	af 	. 
l11aah:
	jp z,011b0h		;11aa	ca b0 11 	. . . 
	ld e,010h		;11ad	1e 10 	. . 
	ld bc,0061eh		;11af	01 1e 06 	. . . 
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;11b2	cd 55 09 	. U . 
	scf			;11b5	37 	7 
	call nz,sub_1201h		;11b6	c4 01 12 	. . . 
	pop hl			;11b9	e1 	. 
	pop bc			;11ba	c1 	. 
	push af			;11bb	f5 	. 
	ld a,c			;11bc	79 	y 
	or a			;11bd	b7 	. 
	push af			;11be	f5 	. 
	call nz,sub_0f16h		;11bf	c4 16 0f 	. . . 
	add a,b			;11c2	80 	. 
	ld c,a			;11c3	4f 	O 
	ld a,d			;11c4	7a 	z 
	and 004h		;11c5	e6 04 	. . 
	cp 001h		;11c7	fe 01 	. . 
	sbc a,a			;11c9	9f 	. 
	ld d,a			;11ca	57 	W 
	add a,c			;11cb	81 	. 
	ld c,a			;11cc	4f 	O 
	sub e			;11cd	93 	. 
	push af			;11ce	f5 	. 
	push bc			;11cf	c5 	. 
l11d0h:
	call m,MAT_sdDiv_10		;11d0	fc 18 0f 	. . . 
	jp m,l11d0h		;11d3	fa d0 11 	. . . 
	pop bc			;11d6	c1 	. 
	pop af			;11d7	f1 	. 
	push bc			;11d8	c5 	. 
	push af			;11d9	f5 	. 
	jp m,l11deh		;11da	fa de 11 	. . . 
	xor a			;11dd	af 	. 
l11deh:
	cpl			;11de	2f 	/ 
	inc a			;11df	3c 	< 
	add a,b			;11e0	80 	. 
	inc a			;11e1	3c 	< 
	add a,d			;11e2	82 	. 
	ld b,a			;11e3	47 	G 
	ld c,000h		;11e4	0e 00 	. . 
	call sub_12a4h		;11e6	cd a4 12 	. . . 
	pop af			;11e9	f1 	. 
	call p,sub_1271h		;11ea	f4 71 12 	. q . 
	pop bc			;11ed	c1 	. 
	pop af			;11ee	f1 	. 
	call z,sub_092fh		;11ef	cc 2f 09 	. / . 
	pop af			;11f2	f1 	. 
	jr c,l11f8h		;11f3	38 03 	8 . 
	add a,e			;11f5	83 	. 
	sub b			;11f6	90 	. 
	sub d			;11f7	92 	. 
l11f8h:
	push bc			;11f8	c5 	. 
	call sub_1074h		;11f9	cd 74 10 	. t . 
	ex de,hl			;11fc	eb 	. 
	pop de			;11fd	d1 	. 
	jp l10bfh		;11fe	c3 bf 10 	. . . 
sub_1201h:
	push de			;1201	d5 	. 
	xor a			;1202	af 	. 
	push af			;1203	f5 	. 
	rst #20			; test NTF (Number Type Format)	- is it Single?	;1204	e7 	. 
	jp po,l1222h	; yes -	;1205	e2 22 12 	. " . 
l1208h:
	ld a,(MATH_ACC_EXP)		;1208	3a 24 79 	: $ y 
	cp 091h		;120b	fe 91 	. . 
	jp nc,l1222h		;120d	d2 22 12 	. " . 
	ld de,CONSTd_1e10	; constant double value 1e10	;1210	11 64 13 	. d . 
	ld hl,ACC2		; address of 2nd Accumulator ;1213	21 27 79 	! ' y 
	call DEMemToHLMem	; copy math variable from (de) to (hl) mem			;1216	cd d3 09 	. . . 
	call dblACCmulACC2	; ACC = ACC * ACC2 (Double)	;1219	cd a1 0d 	. . . 
	pop af			;121c	f1 	. 
	sub 00ah		;121d	d6 0a 	. . 
	push af			;121f	f5 	. 
	jr l1208h		;1220	18 e6 	. . 
l1222h:
	call sub_124fh		;1222	cd 4f 12 	. O . 
l1225h:
	rst #20			; test NTF (Number Type Format) ;1225	e7 	. 
	jp pe,l1234h	; Double - 	;1226	ea 34 12 	. 4 . 
; -- Single 
	ld bc,$9143		;1229	01 43 91 	. C . 
	ld de,$4ff9		; BCDE = 99999.9	;122c	11 f9 4f 	. . O 
	call MAT_sCmp_ACC_BCDE		;122f	cd 0c 0a 	. . . 
	jr l123ah		;1232	18 06 	. . 
l1234h:
	ld de,CONSTd_1e15	; constant double value 1e15	;1234	11 6c 13 	. l . 
	call ACCCmpDEMem	; Compare ACC and (DE) (Double)		;1237	cd 49 0a 	. I . 
l123ah:
	jp p,l124ch		;123a	f2 4c 12 	. L . 
	pop af			;123d	f1 	. 
	call sub_0f0bh		;123e	cd 0b 0f 	. . . 
	push af			;1241	f5 	. 
	jr l1225h		;1242	18 e1 	. . 
l1244h:
	pop af			;1244	f1 	. 
	call MAT_sdDiv_10		;1245	cd 18 0f 	. . . 
	push af			;1248	f5 	. 
	call sub_124fh		;1249	cd 4f 12 	. O . 
l124ch:
	pop af			;124c	f1 	. 
	pop de			;124d	d1 	. 
	ret			;124e	c9 	. 
sub_124fh:
	rst #20			; test NTF (Number Type Format) ;124f	e7 	. 
	jp pe,l125eh	; Double - 	;1250	ea 5e 12 	. ^ . 
; -- Single
	ld bc,$9474		;1253	01 74 94 	. t . 
	ld de,$23f8		; BCDE = 999999,5 ;1256	11 f8 23 	. . # 
	call MAT_sCmp_ACC_BCDE		;1259	cd 0c 0a 	. . . 
	jr l1264h		;125c	18 06 	. . 
l125eh:
	ld de,CONSTd_1e16	; constant double value	= 1e16	;125e	11 74 13 	. t . 
	call ACCCmpDEMem	; Compare ACC and (DE) (Double)		;1261	cd 49 0a 	. I . 
l1264h:
	pop hl			;1264	e1 	. 
	jp p,l1244h		;1265	f2 44 12 	. D . 
	jp (hl)			;1268	e9 	. 
sub_1269h:
	or a			;1269	b7 	. 
l126ah:
	ret z			;126a	c8 	. 
	dec a			;126b	3d 	= 
	ld (hl),030h		;126c	36 30 	6 0 
	inc hl			;126e	23 	# 
	jr l126ah		;126f	18 f9 	. . 
sub_1271h:
	jr nz,sub_1277h		;1271	20 04 	  . 
l1273h:
	ret z			;1273	c8 	. 
	call sub_1291h		;1274	cd 91 12 	. . . 
sub_1277h:
	ld (hl),030h		;1277	36 30 	6 0 
	inc hl			;1279	23 	# 
	dec a			;127a	3d 	= 
	jr l1273h		;127b	18 f6 	. . 
sub_127dh:
	ld a,e			;127d	7b 	{ 
	add a,d			;127e	82 	. 
	inc a			;127f	3c 	< 
	ld b,a			;1280	47 	G 
	inc a			;1281	3c 	< 
l1282h:
	sub 003h		;1282	d6 03 	. . 
	jr nc,l1282h		;1284	30 fc 	0 . 
	add a,005h		;1286	c6 05 	. . 
	ld c,a			;1288	4f 	O 
sub_1289h:
	ld a,(BAS_TempFlags)	; temporary byte	;1289	3a d8 78 	: . x 
	and 040h		;128c	e6 40 	. @ 
	ret nz			;128e	c0 	. 
	ld c,a			;128f	4f 	O 
	ret			;1290	c9 	. 
sub_1291h:
	dec b			;1291	05 	. 
	jr nz,l129ch		;1292	20 08 	  . 
sub_1294h:
	ld (hl),02eh		;1294	36 2e 	6 . 
	ld (BAS_ExprTmpPtr),hl	; [TRS] expression parser current position		;1296	22 f3 78 	" . x 
	inc hl			;1299	23 	# 
	ld c,b			;129a	48 	H 
	ret			;129b	c9 	. 
l129ch:
	dec c			;129c	0d 	. 
	ret nz			;129d	c0 	. 
	ld (hl),02ch		;129e	36 2c 	6 , 
	inc hl			;12a0	23 	# 
	ld c,003h		;12a1	0e 03 	. . 
	ret			;12a3	c9 	. 
sub_12a4h:
	push de			;12a4	d5 	. 
	rst #20			; test NTF (Number Type Format) ;12a5	e7 	. 
	jp po,l12eah	; Single - 	;12a6	e2 ea 12 	. . . 
	push bc			;12a9	c5 	. 
	push hl			;12aa	e5 	. 
	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;12ab	cd fc 09 	. . . 
	ld hl,sngConst_0		; Constant value 0 (Single) ;12ae	21 7c 13 	! | . 
	call HLMemToACC_DBL	; Copy value from (HL) to ACC (Any)	;12b1	cd f7 09 	. . . 
	call ACCAddACC2	; Math : ACC = ACC + ACC2 (Double)	;12b4	cd 77 0c 	. w . 
	xor a			;12b7	af 	. 
	call sub_0b7bh		;12b8	cd 7b 0b 	. { . 
	pop hl			;12bb	e1 	. 
	pop bc			;12bc	c1 	. 
	ld de,l138ch		;12bd	11 8c 13 	. . . 
	ld a,00ah		;12c0	3e 0a 	> . 
l12c2h:
	call sub_1291h		;12c2	cd 91 12 	. . . 
	push bc			;12c5	c5 	. 
	push af			;12c6	f5 	. 
	push hl			;12c7	e5 	. 
	push de			;12c8	d5 	. 
	ld b,02fh		;12c9	06 2f 	. / 
l12cbh:
	inc b			;12cb	04 	. 
	pop hl			;12cc	e1 	. 
	push hl			;12cd	e5 	. 
	call sub_0d48h		;12ce	cd 48 0d 	. H . 
	jr nc,l12cbh		;12d1	30 f8 	0 . 
	pop hl			;12d3	e1 	. 
	call ACCAddHLMem_MO	; ACC = ACC + [HL] - MANTISSA only	;12d4	cd 36 0d 	. 6 . 
	ex de,hl			;12d7	eb 	. 
	pop hl			;12d8	e1 	. 
	ld (hl),b			;12d9	70 	p 
	inc hl			;12da	23 	# 
	pop af			;12db	f1 	. 
	pop bc			;12dc	c1 	. 
	dec a			;12dd	3d 	= 
	jr nz,l12c2h		;12de	20 e2 	  . 
	push bc			;12e0	c5 	. 
	push hl			;12e1	e5 	. 
	ld hl,ACC_DBL		; addres of Accumulator (Double);12e2	21 1d 79 	! . y 
	call MAT_sCopyHLToACC_DBL		;12e5	cd b1 09 	. . . 
	jr l12f6h		;12e8	18 0c 	. . 
l12eah:
	push bc			;12ea	c5 	. 
	push hl			;12eb	e5 	. 
	call sngACCadd05	; ACC = ACC + 0.5 (Single)	;12ec	cd 08 07 	. . . 
	inc a			;12ef	3c 	< 
	call sub_0afbh		;12f0	cd fb 0a 	. . . 
	call BCDEToACC_DBL		; copy value from BCDE to ACC (Single)	;12f3	cd b4 09 	. . . 
l12f6h:
	pop hl			;12f6	e1 	. 
	pop bc			;12f7	c1 	. 
	xor a			;12f8	af 	. 
	ld de,l13d2h		;12f9	11 d2 13 	. . . 
l12fch:
	ccf			;12fc	3f 	? 
	call sub_1291h		;12fd	cd 91 12 	. . . 
	push bc			;1300	c5 	. 
	push af			;1301	f5 	. 
	push hl			;1302	e5 	. 
	push de			;1303	d5 	. 
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;1304	cd bf 09 	. . . 
	pop hl			;1307	e1 	. 
	ld b,02fh		;1308	06 2f 	. / 
l130ah:
	inc b			;130a	04 	. 
	ld a,e			;130b	7b 	{ 
	sub (hl)			;130c	96 	. 
	ld e,a			;130d	5f 	_ 
	inc hl			;130e	23 	# 
	ld a,d			;130f	7a 	z 
	sbc a,(hl)			;1310	9e 	. 
	ld d,a			;1311	57 	W 
	inc hl			;1312	23 	# 
	ld a,c			;1313	79 	y 
	sbc a,(hl)			;1314	9e 	. 
	ld c,a			;1315	4f 	O 
	dec hl			;1316	2b 	+ 
	dec hl			;1317	2b 	+ 
	jr nc,l130ah		;1318	30 f0 	0 . 
	call sub_07b7h		;131a	cd b7 07 	. . . 
	inc hl			;131d	23 	# 
	call BCDEToACC_DBL	; copy value from BCDE to ACC (Single)		;131e	cd b4 09 	. . . 
	ex de,hl			;1321	eb 	. 
	pop hl			;1322	e1 	. 
	ld (hl),b			;1323	70 	p 
	inc hl			;1324	23 	# 
	pop af			;1325	f1 	. 
	pop bc			;1326	c1 	. 
	jr c,l12fch		;1327	38 d3 	8 . 
	inc de			;1329	13 	. 
	inc de			;132a	13 	. 
	ld a,004h		;132b	3e 04 	> . 
	jr l1335h		;132d	18 06 	. . 
sub_132fh:
	push de			;132f	d5 	. 
	ld de,l13d8h		;1330	11 d8 13 	. . . 
	ld a,005h		;1333	3e 05 	> . 
l1335h:
	call sub_1291h		;1335	cd 91 12 	. . . 
	push bc			;1338	c5 	. 
	push af			;1339	f5 	. 
	push hl			;133a	e5 	. 
	ex de,hl			;133b	eb 	. 
	ld c,(hl)			;133c	4e 	N 
	inc hl			;133d	23 	# 
	ld b,(hl)			;133e	46 	F 
	push bc			;133f	c5 	. 
	inc hl			;1340	23 	# 
	ex (sp),hl			;1341	e3 	. 
	ex de,hl			;1342	eb 	. 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;1343	2a 21 79 	* ! y 
	ld b,02fh		;1346	06 2f 	. / 
l1348h:
	inc b			;1348	04 	. 
l1349h:
	ld a,l			;1349	7d 	} 
	sub e			;134a	93 	. 
	ld l,a			;134b	6f 	o 
	ld a,h			;134c	7c 	| 
	sbc a,d			;134d	9a 	. 
	ld h,a			;134e	67 	g 
	jr nc,l1348h		;134f	30 f7 	0 . 
	add hl,de			;1351	19 	. 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;1352	22 21 79 	" ! y 
	pop de			;1355	d1 	. 
	pop hl			;1356	e1 	. 
	ld (hl),b			;1357	70 	p 
	inc hl			;1358	23 	# 
	pop af			;1359	f1 	. 
	pop bc			;135a	c1 	. 
	dec a			;135b	3d 	= 
	jr nz,l1335h		;135c	20 d7 	  . 
	call sub_1291h		;135e	cd 91 12 	. . . 
	ld (hl),a			;1361	77 	w 
	pop de			;1362	d1 	. 
	ret			;1363	c9 	. 


CONSTd_1e10: // Double Value = 10 000 000 000
	dword	$00000000			;1364	00 00 00 00 	. 
	dword 	$a21502f9			;1368	f9 02 15 a2 	. 
CONSTd_1e15: // Double Value = 999 999 999 999 999,9
	dword 	$319ffffd			;136c	fd ff 9f 31	. . . 
	dword 	$b2635fa9			;1370	a9 5f 63 b2 	. 
CONSTd_1e16: // Double Value = 9 999 999 999 999 998
	dword 	$bf03fffe			;1374	fe ff 03 bf 	. 
	dword	$b60e1bc9			;1378	c9 1b 0e b6 	. . 

; ********************************************************************************
; Math : Constant Value 0 (Single)
sngConst_0:
	dword #00000000			;137c	00 00 00 00 	. 

; ********************************************************************************
; Math : Constant Value 0.5 (Single)
sngConst_05:
	dword #80000000			;1380	00 00 00 80 	. 
l1384h: // Double Value = 10 000 000 000 000 000
	nop			;1384	00 	. 
	nop			;1385	00 	. 
	inc b			;1386	04 	. 
	cp a			;1387	bf 	. 
	ret			;1388	c9 	. 
	dec de			;1389	1b 	. 
	ld c,0b6h		;138a	0e b6 	. . 
l138ch:
	nop			;138c	00 	. 
	add a,b			;138d	80 	. 
	add a,0a4h		;138e	c6 a4 	. . 
	ld a,(hl)			;1390	7e 	~ 
	adc a,l			;1391	8d 	. 
	inc bc			;1392	03 	. 
	nop			;1393	00 	. 
	ld b,b			;1394	40 	@ 
	ld a,d			;1395	7a 	z 
	djnz $-11		;1396	10 f3 	. . 
	ld e,d			;1398	5a 	Z 
	nop			;1399	00 	. 
	nop			;139a	00 	. 
	and b			;139b	a0 	. 
	ld (hl),d			;139c	72 	r 
	ld c,(hl)			;139d	4e 	N 
	jr l13a9h		;139e	18 09 	. . 
	nop			;13a0	00 	. 
	nop			;13a1	00 	. 
	djnz l1349h		;13a2	10 a5 	. . 
	call nc,sub_00e8h		;13a4	d4 e8 00 	. . . 
	nop			;13a7	00 	. 
	nop			;13a8	00 	. 
l13a9h:
	ret pe			;13a9	e8 	. 
	halt			;13aa	76 	v 
	ld c,b			;13ab	48 	H 
	rla			;13ac	17 	. 
	nop			;13ad	00 	. 
	nop			;13ae	00 	. 
	nop			;13af	00 	. 
	call po,0540bh		;13b0	e4 0b 54 	. . T 
	ld (bc),a			;13b3	02 	. 
	nop			;13b4	00 	. 
	nop			;13b5	00 	. 
	nop			;13b6	00 	. 
	db $ca,$9a,$3b		;13b7	ca 9a 3b 	. . ; 
	nop			;13ba	00 	. 
	nop			;13bb	00 	. 
	nop			;13bc	00 	. 
	nop			;13bd	00 	. 
	pop hl			;13be	e1 	. 
	push af			;13bf	f5 	. 
	dec b			;13c0	05 	. 
	nop			;13c1	00 	. 
	nop			;13c2	00 	. 
	nop			;13c3	00 	. 
	add a,b			;13c4	80 	. 
	sub (hl)			;13c5	96 	. 
	sbc a,b			;13c6	98 	. 
	nop			;13c7	00 	. 
	nop			;13c8	00 	. 
	nop			;13c9	00 	. 
	nop			;13ca	00 	. 
	ld b,b			;13cb	40 	@ 
	ld b,d			;13cc	42 	B 
	rrca			;13cd	0f 	. 
	nop			;13ce	00 	. 
	nop			;13cf	00 	. 
	nop			;13d0	00 	. 
	nop			;13d1	00 	. 
l13d2h:
	and b			;13d2	a0 	. 
	add a,(hl)			;13d3	86 	. 
	ld bc,l2710h		;13d4	01 10 27 	. . ' 
	nop			;13d7	00 	. 
l13d8h:
	djnz l1401h		;13d8	10 27 	. ' 
	ret pe			;13da	e8 	. 
	inc bc			;13db	03 	. 
	ld h,h			;13dc	64 	d 
	nop			;13dd	00 	. 
	ld a,(bc)			;13de	0a 	. 
	nop			;13df	00 	. 
	ld bc,l2100h		;13e0	01 00 21 	. . ! 
	add a,d			;13e3	82 	. 
	add hl,bc			;13e4	09 	. 
	ex (sp),hl			;13e5	e3 	. 
	jp (hl)			;13e6	e9 	. 
	
; ********************************************************************************
; [TRS] BASIC SQR Entry Point
; Math : ACC = SQR(ACC) (Any -> Single)
FuncSQR
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;13e7	cd a4 09 	. . . 
	ld hl,sngConst_05	; Constant Value 0.5 (Single)	;13ea	21 80 13 	! . . 
	call MAT_sCopyHLToACC_DBL		;13ed	cd b1 09 	. . . 
	jr SPsPowACC_DBL		;13f0	18 03 	. . 

; ********************************************************************************
; Math : ACC = STACK ^ ACC (Any -> Single)
STACKPowACC_DBL:
	call FuncCSNG	; convert ACC to Single value		;13f2	cd b1 0a 	. . . 

; ********************************************************************************
; Math : ACC = (STACK) ^ ACC (Single)
SPsPowACC_DBL:
	pop bc			;13f5	c1 	. 
	pop de			;13f6	d1 	. 

; ********************************************************************************
; Math : ACC = BCDE ^ ACC (Single)
BCDEsPowACC_DBL
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;13f7	cd 55 09 	. U . 
	ld a,b			;13fa	78 	x 
	jr z,FuncEXP		; compute EXP function		;13fb	28 3c 	( < 
	jp p,l1404h		;13fd	f2 04 14 	. . . 
	or a			;1400	b7 	. 
l1401h:
	jp z,ErrRaiseDivByZero	; if a = 0 Raise 'DIVISION BY ZERO' error	;1401	ca 9a 19 	. . . 
l1404h:
	or a			;1404	b7 	. 
	jp z,l0779h		;1405	ca 79 07 	. y . 
	push de			;1408	d5 	. 
	push bc			;1409	c5 	. 
	ld a,c			;140a	79 	y 
	or 07fh		;140b	f6 7f 	.  
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;140d	cd bf 09 	. . . 
	jp p,l1421h		;1410	f2 21 14 	. ! . 
	push de			;1413	d5 	. 
	push bc			;1414	c5 	. 
	call sub_0b40h		;1415	cd 40 0b 	. @ . 
	pop bc			;1418	c1 	. 
	pop de			;1419	d1 	. 
	push af			;141a	f5 	. 
	call MAT_sCmp_ACC_BCDE		;141b	cd 0c 0a 	. . . 
l141eh:
	pop hl			;141e	e1 	. 
	ld a,h			;141f	7c 	| 
	rra			;1420	1f 	. 
l1421h:
	pop hl			;1421	e1 	. 
	ld (ACC_SNG+2),hl	 ; Int,Single,String (2 or 4 bytes): 	;1422	22 23 79 	" # y 
	pop hl			;1425	e1 	. 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;1426	22 21 79 	" ! y 
	call c,013e2h		;1429	dc e2 13 	. . . 
	call z,sngACCnegate		;  ACC = -ACC (Single) ;142c	cc 82 09 	. . . 
	push de			;142f	d5 	. 
	push bc			;1430	c5 	. 
	call FuncLOG		; compute LOG function ;1431	cd 09 08 	. . . 
	pop bc			;1434	c1 	. 
	pop de			;1435	d1 	. 
	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;1436	cd 47 08 	. G . 

; ********************************************************************************
; [TRS] BASIC EXP Entry Point
; Math : ACC = EXP(ACC) (Any -> Single)
FuncEXP:
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;1439	cd a4 09 	. . . 
	ld bc,$8138		                        ;143c	01 38 81 	. 8 . 
	ld de,$aa3b		    ; BCDE = Log2(e)        ;143f	11 3b aa 	. ; . 
	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;1442	cd 47 08 	. G . 
	ld a,(MATH_ACC_EXP)		;1445	3a 24 79 	: $ y 
	cp 088h		;1448	fe 88 	. . 
	jp nc,l0931h		;144a	d2 31 09 	. 1 . 
	call sub_0b40h		;144d	cd 40 0b 	. @ . 
	add a,080h		;1450	c6 80 	. . 
	add a,002h		;1452	c6 02 	. . 
	jp c,l0931h		;1454	da 31 09 	. 1 . 
	push af			;1457	f5 	. 
	ld hl,CONSTs_1	; Constant value 1 (Single)	;1458	21 f8 07 	! . . 
	call sngHLaddACC_DBL	; ACC = ACC + 1 (Single)	;145b	cd 0b 07 	. . . 
	call sub_0841h		;145e	cd 41 08 	. A . 
	pop af			;1461	f1 	. 
	pop bc			;1462	c1 	. 
	pop de			;1463	d1 	. 
	push af			;1464	f5 	. 
	call sngBCDEsubACC_DBL	; ACC = BCDE - ACC (Single)	;1465	cd 13 07 	. . . 
	call sngACCnegate		;  ACC = -ACC (Single) ;1468	cd 82 09 	. . . 
	ld hl,l1479h		;146b	21 79 14 	! y . 
	call sub_14a9h		;146e	cd a9 14 	. . . 
	ld de,$0000		;1471	11 00 00 	. . . 
	pop bc			;1474	c1 	. 
	ld c,d			;1475	4a 	J 
	jp sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;1476	c3 47 08 	. G . 
l1479h:
	ex af,af'			;1479	08 	. 
	ld b,b			;147a	40 	@ 
	ld l,094h		;147b	2e 94 	. . 
	ld (hl),h			;147d	74 	t 
	ld (hl),b			;147e	70 	p 
	ld c,a			;147f	4f 	O 
	ld l,077h		;1480	2e 77 	. w 
	ld l,(hl)			;1482	6e 	n 
	ld (bc),a			;1483	02 	. 
	adc a,b			;1484	88 	. 
	ld a,d			;1485	7a 	z 
	and 0a0h		;1486	e6 a0 	. . 
	ld hl,(0507ch)		;1488	2a 7c 50 	* | P 
	xor d			;148b	aa 	. 
	xor d			;148c	aa 	. 
	ld a,(hl)			;148d	7e 	~ 
	rst 38h			;148e	ff 	. 
	rst 38h			;148f	ff 	. 
	ld a,a			;1490	7f 	 
	ld a,a			;1491	7f 	 
	nop			;1492	00 	. 
	nop			;1493	00 	. 
	add a,b			;1494	80 	. 
	add a,c			;1495	81 	. 

; ********************************************************************************
; Math : Constant value 1 (Single)

	dword #81000000		;1496	00 00 00 81 	. 
sub_149ah:
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;149a	cd a4 09 	. . . 
	ld de,sngSPOPmulACC_DBL	; routine ACC = (SP) * ACC (Single)	;149d	11 32 0c 	. 2 . 
	push de			;14a0	d5 	. 
	push hl			;14a1	e5 	. 
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;14a2	cd bf 09 	. . . 
	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;14a5	cd 47 08 	. G . 
	pop hl			;14a8	e1 	. 
sub_14a9h:
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;14a9	cd a4 09 	. . . 
	ld a,(hl)			;14ac	7e 	~ 
	inc hl			;14ad	23 	# 
	call MAT_sCopyHLToACC_DBL		;14ae	cd b1 09 	. . . 
	ld b,0f1h		;14b1	06 f1 	. . 
	pop bc			;14b3	c1 	. 
	pop de			;14b4	d1 	. 
	dec a			;14b5	3d 	= 
	ret z			;14b6	c8 	. 
	push de			;14b7	d5 	. 
	push bc			;14b8	c5 	. 
	push af			;14b9	f5 	. 
	push hl			;14ba	e5 	. 
	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;14bb	cd 47 08 	. G . 
	pop hl			;14be	e1 	. 
	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;14bf	cd c2 09 	. . . 
	push hl			;14c2	e5 	. 
	call sngBCDEaddACC_DBL	; ACC = BCDE + ACC (Single)                                 	;14c3	cd 16 07 	. . . 
	pop hl			;14c6	e1 	. 
	jr $-21		;14c7	18 e9 	. . 

; ********************************************************************************
; BASIC RND Entry Point
; Math : ACC = RND(ACC) (Any -> Single)
FuncRND
	call FuncCINT		; convert ACC to integer	;14c9	cd 7f 0a 	.  . 
	ld a,h			;14cc	7c 	| 
	or a			;14cd	b7 	. 
	jp m,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;14ce	fa 4a 1e 	. J . 
	or l			;14d1	b5 	. 
	jp z,MAT_sRnd_0		;14d2	ca f0 14 	. . . 
	push hl			;14d5	e5 	. 
	call MAT_sRnd_0		;14d6	cd f0 14 	. . . 
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;14d9	cd bf 09 	. . . 
	ex de,hl			;14dc	eb 	. 
	ex (sp),hl			;14dd	e3 	. 
	push bc			;14de	c5 	. 
	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;14df	cd cf 0a 	. . . 
	pop bc			;14e2	c1 	. 
	pop de			;14e3	d1 	. 
	call sngBCDEmulACC_DBL	; ACC = BCDE * ACC (Single)	;14e4	cd 47 08 	. G . 
	ld hl,CONSTs_1	; Constant value 1 (Single)		;14e7	21 f8 07 	! . . 
	call sngHLaddACC_DBL	; ACC = ACC + 1 (Single)	;14ea	cd 0b 07 	. . . 
	jp sub_0b40h		;14ed	c3 40 0b 	. @ . 
; ********************************************************************************
; Math : ACC = RND(0) (Single)
MAT_sRnd_0:
	ld hl,07890h		;14f0	21 90 78 	! . x 
	push hl			;14f3	e5 	. 
	ld de,$0000		;14f4	11 00 00 	. . . 
	ld c,e			;14f7	4b 	K 
	ld h,003h		;14f8	26 03 	& . 
l14fah:
	ld l,008h		;14fa	2e 08 	. . 
l14fch:
	ex de,hl			;14fc	eb 	. 
	add hl,hl			;14fd	29 	) 
	ex de,hl			;14fe	eb 	. 
	ld a,c			;14ff	79 	y 
	rla			;1500	17 	. 
	ld c,a			;1501	4f 	O 
	ex (sp),hl			;1502	e3 	. 
	ld a,(hl)			;1503	7e 	~ 
	rlca			;1504	07 	. 
	ld (hl),a			;1505	77 	w 
	ex (sp),hl			;1506	e3 	. 
	jp nc,l1516h		;1507	d2 16 15 	. . . 
	push hl			;150a	e5 	. 
	ld hl,(078aah)		;150b	2a aa 78 	* . x 
	add hl,de			;150e	19 	. 
	ex de,hl			;150f	eb 	. 
	ld a,(078ach)		;1510	3a ac 78 	: . x 
	adc a,c			;1513	89 	. 
	ld c,a			;1514	4f 	O 
	pop hl			;1515	e1 	. 
l1516h:
	dec l			;1516	2d 	- 
	jp nz,l14fch		;1517	c2 fc 14 	. . . 
	ex (sp),hl			;151a	e3 	. 
	inc hl			;151b	23 	# 
	ex (sp),hl			;151c	e3 	. 
	dec h			;151d	25 	% 
	jp nz,l14fah		;151e	c2 fa 14 	. . . 
	pop hl			;1521	e1 	. 
	ld hl,$b065		;1522	21 65 b0 	! e . 
	add hl,de			;1525	19 	. 
	ld (078aah),hl		;1526	22 aa 78 	" . x 
	call SetNTFToSng		;1529	cd ef 0a 	. . . 
	ld a,005h		;152c	3e 05 	> . 
	adc a,c			;152e	89 	. 
	ld (078ach),a		;152f	32 ac 78 	2 . x 
	ex de,hl			;1532	eb 	. 
	ld b,080h		;1533	06 80 	. . 
	ld hl,MATH_ACC_SIGN		;1535	21 25 79 	! % y 
	ld (hl),b			;1538	70 	p 
	dec hl			;1539	2b 	+ 
	ld (hl),b			;153a	70 	p 
	ld c,a			;153b	4f 	O 
	ld b,000h		;153c	06 00 	. . 
	jp l0765h			; Normalize Single Value ;153e	c3 65 07 	. e . 

; ********************************************************************************
; BASIC COS Entry Point
; Math : ACC = COS(ACC) (Any -> Single)
MAT_sCos_ACC_DBL:
FuncCOS:
	ld hl,CONSTs_PiDiv2	; Constant value Pi/2	;1541	21 8b 15 	! . . 
	call sngHLaddACC_DBL		; ACC = ACC + Pi/2 ;1544	cd 0b 07 	. . . 

; ********************************************************************************
; BASIC SIN Entry Point
; Math : ACC = SIN(ACC) (Any -> Single)
MAT_sSin_ACC_DBL:
FuncSIN:
	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;1547	cd a4 09 	. . . 
	ld bc,$8349		                ;154a	01 49 83 	. I . 
	ld de,$0fdb		; BCDE = 2*Pi   ;154d	11 db 0f 	. . . 
	call BCDEToACC_DBL		; copy value from BCDE to ACC (Single)	;1550	cd b4 09 	. . . 
	pop bc			;1553	c1 	. 
	pop de			;1554	d1 	. 
	call BCDEsDivACC_DBL	; ACC = BCDE / ACC (Single)		;1555	cd a2 08 	. . . 
	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;1558	cd a4 09 	. . . 
	call sub_0b40h		;155b	cd 40 0b 	. @ . 
	pop bc			;155e	c1 	. 
	pop de			;155f	d1 	. 
	call sngBCDEsubACC_DBL	; ACC = BCDE - ACC (Single)		;1560	cd 13 07 	. . . 
	ld hl,CONSTs_025	; Constant value 0.25 (Single) 	                        ;1563	21 8f 15 	! . . 
	call sngHLsubACC_DBL		; ACC = 0.25 - ACC (Single)                             ;1566	cd 10 07 	. . . 
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;1569	cd 55 09 	. U . 
	scf			;156c	37 	7 
	jp p,l1577h		;156d	f2 77 15 	. w . 
	call sngACCadd05	    ; ACC = ACC + 0.5 (Single)	                            ;1570	cd 08 07 	. . . 
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;1573	cd 55 09 	. U . 
	or a			;1576	b7 	. 
l1577h:
	push af			;1577	f5 	. 
	call p,sngACCnegate		;  ACC = -ACC (Single) ;1578	f4 82 09 	. . . 
	ld hl,CONSTs_025	; Constant value 0.25 (Single)	;157b	21 8f 15 	! . . 
	call sngHLaddACC_DBL		; ACC = ACC + 0.25  ;157e	cd 0b 07 	. . . 
	pop af			;1581	f1 	. 
	call nc,sngACCnegate		;  ACC = -ACC (Single) ;1582	d4 82 09 	. . . 
	ld hl,l1593h		;1585	21 93 15 	! . . 
	jp sub_149ah		;1588	c3 9a 14 	. . . 
CONSTs_PiDiv2:
	dword #81490fdb		; Single constant value = Pi/2							;158b	db 0f 49 81 	. 
CONSTs_025:
	dword #7f000000		; Single constant value = 0.25							;158f	00 00 00 7f 	 
l1593h:
	dec b			;1593	05 	. 
	cp d			;1594	ba 	. 
	rst $10			; move hl to next Basic token				;1595	d7 	. 
	ld e,086h		;1596	1e 86 	. . 
	ld h,h			;1598	64 	d 
	ld h,099h		;1599	26 99 	& . 
	add a,a			;159b	87 	. 
	ld e,b			;159c	58 	X 
	inc (hl)			;159d	34 	4 
	inc hl			;159e	23 	# 
	add a,a			;159f	87 	. 
	ret po			;15a0	e0 	. 
	ld e,l			;15a1	5d 	] 
	and l			;15a2	a5 	. 
	add a,(hl)			;15a3	86 	. 
	jp c,0490fh		;15a4	da 0f 49 	. . I 
	add a,e			;15a7	83 	. 


; ********************************************************************************
; BASIC TAN Entry Point
; Math : ACC = TAN(ACC) (Any -> Single)
MAT_sTan_ACC_DBL:
FuncTAN
	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;15a8	cd a4 09 	. . . 
	call FuncSIN				; calculate SIN function				;15ab	cd 47 15 	. G . 
	pop bc			;15ae	c1 	. 
	pop hl			;15af	e1 	. 
	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;15b0	cd a4 09 	. . . 
	ex de,hl			;15b3	eb 	. 
	call BCDEToACC_DBL		; copy value from BCDE to ACC (Single)	;15b4	cd b4 09 	. . . 
	call FuncCOS		; calculate COS function	;15b7	cd 41 15 	. A . 
	jp MAT_sDiv_STACK_ACC_DBL		;15ba	c3 a0 08 	. . . 


; ********************************************************************************
; BASIC ATN Entry Point
; Math : ACC = ATN(ACC) (Any -> Single)
FuncATN:
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;15bd	cd 55 09 	. U . 
	call m,013e2h		; call ??? if ACC < 0 ;15c0	fc e2 13 	. . . 
	call m,sngACCnegate		;  ACC = -ACC (Single) ;15c3	fc 82 09 	. . . 
	ld a,(MATH_ACC_EXP)		;15c6	3a 24 79 	: $ y 
	cp 081h		;15c9	fe 81 	. . 
	jr c,l15d9h		;15cb	38 0c 	8 . 
	ld bc,08100h		;15cd	01 00 81 	. . . 
	ld d,c			;15d0	51 	Q 
	ld e,c			;15d1	59 	Y 
	call BCDEsDivACC_DBL	; ACC = BCDE / ACC (Single)		;15d2	cd a2 08 	. . . 
	ld hl,sngHLsubACC_DBL		; address of routine ACC = (HL) - ACC (Single) ;15d5	21 10 07 	! . . 
	push hl			;15d8	e5 	. 
l15d9h:
	ld hl,l15e3h		;15d9	21 e3 15 	! . . 
	call sub_149ah		;15dc	cd 9a 14 	. . . 
	ld hl,CONSTs_PiDiv2	; Constant value Pi/2		;15df	21 8b 15 	! . . 
	ret			;15e2	c9 	. 
l15e3h:
	add hl,bc			;15e3	09 	. 
	ld c,d			;15e4	4a 	J 
	rst $10			; move hl to next Basic token			;15e5	d7 	. 
	dec sp			;15e6	3b 	; 
	ld a,b			;15e7	78 	x 
	ld (bc),a			;15e8	02 	. 
	ld l,(hl)			;15e9	6e 	n 
	add a,h			;15ea	84 	. 
	ld a,e			;15eb	7b 	{ 
	cp 0c1h		;15ec	fe c1 	. . 
	cpl			;15ee	2f 	/ 
	ld a,h			;15ef	7c 	| 
	ld (hl),h			;15f0	74 	t 
	ld sp,07d9ah		;15f1	31 9a 7d 	1 . } 
	add a,h			;15f4	84 	. 
	dec a			;15f5	3d 	= 
	ld e,d			;15f6	5a 	Z 
	ld a,l			;15f7	7d 	} 
	ret z			;15f8	c8 	. 
	ld a,a			;15f9	7f 	 
	sub c			;15fa	91 	. 
	ld a,(hl)			;15fb	7e 	~ 
	call po,04cbbh		;15fc	e4 bb 4c 	. . L 
	ld a,(hl)			;15ff	7e 	~ 
	ld l,h			;1600	6c 	l 
	xor d			;1601	aa 	. 
	xor d			;1602	aa 	. 
	ld a,a			;1603	7f 	 
	nop			;1604	00 	. 
	nop			;1605	00 	. 
	nop			;1606	00 	. 
	add a,c			;1607	81 	. 


;******************************************************************************************
; Table with pointers for Basic Functions
BasicFuncPointers:
	dw FuncSNG					; D7 SNG			;1608	8a 09 
	dw FuncINT					; D8 INT 			;160a	37 0b 	. 
	dw FuncABS					; D9 ABS			;160c	77 09 	. 
	dw FuncFRE					; DA {FRE}			;160e	d4 27 	. ' . 
	dw FuncINP					; DB INP			;1610	ef 2a 	. ' . 
	dw FuncPOS					; DC {POS}			;1611	f5 27 	* . ' 
	dw FuncSQR					; DD SQR			;1614	e7 13 	. 
	dw FuncRND					; DE RND			;1616	c9 14 	. 
	dw FuncLOG					; DF LOG			;1618	09 08 	. 
	dw FuncEXP					; E0 EXP			;161a	39 14 	. 
	dw FuncCOS					; E1 COS			;161c	41 15 	. 
	dw FuncSIN					; E2 SIN			;161e	47 15 	. 
	dw FuncTAN					; E3 TAN			;1620	a8 15 	. 
	dw FuncATN					; E4 ATN			;1622	bd 15 	. 
	dw FuncPEEK					; E5 PEEK			;1624	aa 2c 	, 
	dw SysDosCVI				; E6 {CVI}			;1626	52 79 	y 
	dw SysDosCVS				; E7 {CVS}			;1628	58 79 	y 
	dw SysDosCVD				; E8 {CVD}			;162a	5e 79 	y 
	dw SysDosEOF				; E9 {EOF}			;162c	61 79 	y 
	dw SysDosLOC				; EA {LOC}			;162e	64 79 	y 
	dw SysDosLOF				; EB {LOF}			;1630	67 79 	y 
	dw SysDosMKIS				; EC {MKI$}			;1632	6a 79 	y 
	dw SysDosMKSS				; ED {MKS$}			;1634	6d 79 	y 
	dw SysDosMKDS				; EE {MKD$}			;1636	70 79 	y 
	dw FuncCINT					; EF {CINT}			;1638	7f 0a 	. 
	dw FuncCSNG					; F0 {CSNG}			;163a	b1 0a 	. 
	dw FuncCDBL					; F1 {CDBL}			;163c	db 0a 	. . 
	dw FuncFIX					; F2 {FIX}			;163e	26 0b 	& . 
	dw FuncLEN					; F3 LEN			;1640	03 2a	. 
	dw FuncSTRS					; F4 STR$			;1642	36 28 	* 6 ( 
	dw FuncVAL					; F5 VAL			;1644	c5 2a	. 
	dw FuncASC					; F6 ASC			;1646	0f 2a 	* . * 
	dw FuncCHRS					; F7 CHR$			;1648	1f 2a	. 
	dw FuncLEFTS				; F8 LEFT$			;164a	61 2a 	* a * 
	dw FuncRIGHTS				; F9 RIGHT$			;164c	91 2a	. 
	dw FuncMIDS					; FA MID$			;164e	9a 2a 	* . * 

; ***********************************************************************************
; BASIC Commands and Function Names for Parser
; First byte of Name has bit 7 set to 1. End of table is marked with byte $80 (0 with 7th bit set).
; Some entries are removed and replaced with placeholder sequence $81,0,0,..0  
BasicCmdNames:
	db $80|'E','ND'				; 80 END			;1650	c5 4e 44 	D 
	db $80|'F','OR'				; 81 FOR			;1653	c6 4f 52 	R 
	db $80|'R','ESET'			; 82 RESET			;1656	d2 45 53 45 54 	T 
	db $80|'S','ET'				; 83 SET			;165b	d3 45 54 	T 
	db $80|'C','LS'				; 84 CLS			;165e	c3 4c 53 	. L S 
	db $80|1,0,0				; 85 {CMD}			;1661	81 00 00 	. 
	db $80|1,0,0,0,0,0			; 86 {RANDOM}		;1664	81 00 00 00 00 00 	. 
	db $80|'N','EXT'			; 87 NEXT			;166a	ce 45 58 54 	T 
	db $80|'D','ATA'			; 88 DATA			;166e	c4 41 54 41 	A 
    db $80|'I','NPUT'          	; 89 INPUT         	;1672 	c9 4e 50 55 54
    db $80|'D','IM'            	; 8A DIM           	;1677 	c4 49 4d 
    db $80|'R','EAD'           	; 8B READ          	;167a 	d2 45 41 44
    db $80|'L','ET'            	; 8C LET           	;167e 	cc 45 54
    db $80|'G','OTO'           	; 8D GOTO          	;1681 	c7 4f 54 4f
    db $80|'R','UN'            	; 8E RUN           	;1685 	d2 55 4e
    db $80|'I','F'             	; 8F IF            	;1688 	c9 46
    db $80|'R','ESTORE'        	; 90 RESTORE       	;168a 	d2 45 53 54 4f 52 45
    db $80|'G','OSUB'          	; 91 GOSUB         	;1691 	c7 4f 53 55 42
    db $80|'R','ETURN'         	; 92 RETURN        	;1696 	d2 45 54 55 52 4e
    db $80|'R','EM'            	; 93 REM           	;169c 	d2 45 4d
    db $80|'S','TOP'           	; 94 STOP          	;169f 	d3 54 4f 50
    db $80|'E','LSE'           	; 95 ELSE          	;16a3 	c5 4c 53 45
    db $80|'C','OPY'           	; 96 COPY          	;16a7 	c3 4f 50 59
    db $80|'C','OLOR'          	; 97 COLOR         	;16ab 	c3 4f 4c 4f 52
    db $80|'V','ERIFY'         	; 98 VERIFY        	;16b0 	d6 45 52 49 46 59
    db $80| 1,0,0,0,0,0        	; 99 {DEFINT}      	;16b6 	81 00 00 00 00 00
    db $80| 1,0,0,0,0,0        	; 9A {DEFSNG}      	;16bc 	81 00 00 00 00 00
    db $80| 1,0,0,0,0,0        	; 9B {DEFDBL}      	;16c2 	81 00 00 00 00 00
    db $80|'C','RUN'           	; 9C CRUN          	;16c8 	c3 52 55 4e
    db $80|'M','ODE'           	; 9D MODE          	;16cc 	cd 4f 44 45
    db $80|'S','OUND'          	; 9E SOUND         	;16d0 	d3 4f 55 4e 44
    db $80| 1, 0,0,0,0,0       	; 9F {RESUME}      	;16d5 	81 00 00 00 00 00
    db $80|'O','UT'            	; A0 OUT           	;16db 	cf 55 54
    db $80| 1,0                	; A1 {ON}          	;16de 	81 00
    db $80| 1,0,0,0            	; A2 [OPEN]        	;16e0 	81 00 00 00
    db $80| 1,0,0,0,0          	; A3 [FIELD]       	;16e4 	81 00 00 00 00
    db $80| 1,0,0              	; A4 [GET]         	;16e9 	81 00 00
    db $80| 1,0,0              	; A5 [PUT]         	;16ec 	81 00 00
    db $80| 1,0,0,0,0          	; A6 [CLOSE]       	;16ef 	81 00 00 00 00
    db $80| 1,0,0,0            	; A7 [LOAD]        	;16f4 	81 00 00 00
    db $80| 1,0,0,0,0          	; A8 [MERGE]       	;16f8 	81 00 00 00 00
    db $80| 1,0,0,0            	; A9 [NAME]        	;16fd 	81 00 00 00
    db $80| 1,0,0,0            	; AA [KILL]        	;1701 	81 00 00 00
    db $80| 1,0,0,0            	; AB [LSET]        	;1705 	81 00 00 00
    db $80| 1,0,0,0            	; AC [RSET]        	;1709 	81 00 00 00
    db $80| 1,0,0,0            	; AD [SAVE]        	;170d 	81 00 00 00
    db $80| 1,0,0,0,0,0        	; AE [SYSTEM]      	;1711 	81 00 00 00 00 00
    db $80|'L','PRINT'         	; AF LPRINT        	;1717 	cc 50 52 49 4e 54
    db $80| 1,0,0              	; B0 [DEF]         	;171d 	81 00 00
    db $80|'P','OKE'           	; B1 POKE          	;1720 	d0 4f 4b 45
    db $80|'P','RINT'          	; B2 PRINT         	;1724 	d0 52 49 4e 54
    db $80|'C','ONT'           	; B3 CONT          	;1729 	c3 4f 4e 54
    db $80|'L','IST'           	; B4 LIST          	;172d 	cc 49 53 54
    db $80|'L','LIST'          	; B5 LLIST         	;1731 	cc 4c 49 53 54
    db $80| 1,0,0,0,0,0        	; B6 {DELETE}      	;1736 	81 00 00 00 00 00
    db $80| 1,0,0,0            	; B7 {AUTO}        	;173c 	81 00 00 00
    db $80|'C','LEAR'          	; B8 CLEAR         	;1740 	c3 4c 45 41 52
    db $80|'C','LOAD'          	; B9 CLOAD         	;1745 	c3 4c 4f 41 44
    db $80|'C','SAVE'          	; BA CSAVE         	;174a 	c3 53 41 56 45
    db $80|'N','EW'            	; BB NEW           	;174f 	ce 45 57
;----------------------------------------------------------------------------------------------------------------------
    db $80|'T','AB('           	; BC TAB(          	;1752	d4 41 42 28
    db $80|'T','O'             	; BD TO            	;1756	d4 4f
    db $80| 1,0                	; BE [FN]          	;1758	81 00
    db $80|'U','SING'          	; BF USING         	;175a	d5 53 49 4e 47
    db $80| 1,0,0,0,0,0        	; C0 {VARPTR}      	;175f	81 00 00 00 00 00
    db $80|'U','SR'            	; C1 USR           	;1765	d5 53 52
    db $80| 1,0,0              	; C2 {ERL}         	;1768	81 00 00
    db $80| 1,0,0              	; C3 {ERR}         	;176b	81 00 00
    db $80| 1,0,0,0,0,0,0      	; C4 {STRING$}     	;176e	81 00 00 00 00 00 00
    db $80| 1,0,0,0,0          	; C5 [INSTR]       	;1775	81 00 00 00 00
    db $80|'P','OINT'          	; C6 POINT         	;177a	d0 4f 49 4e 54
    db $80| 1,0,0,0,0          	; C7 [TIME$]       	;177f	81 00 00 00 00
    db $80| 1,0,0              	; C8 {MEM}         	;1784	81 00 00
    db $80|'I','NKEY$'         	; C9 INKEY$        	;1787	c9 4e 4b 45 59 24
    db $80|'T','HEN'           	; CA THEN          	;178d	d4 48 45 4e
    db $80|'N','OT'            	; CB NOT           	;1791	ce 4f 54
    db $80|'S','TEP'           	; CC STEP          	;1794	d3 54 45 50
    db $80|'+'                 	; CD +             	;1798	ab
    db $80|'-'                 	; CE -             	;1799	ad
    db $80|'*'                 	; CF *             	;179a	aa
    db $80|'/'                 	; D0 /             	;179b	af
    db $80|'^'                 	; D1 ^             	;179c	de 
    db $80|'A','ND'            	; D2 AND           	;179d	c1 4e 44
    db $80|'O','R'             	; D3 OR            	;17a0	cf 52
    db $80|'>'                 	; D4 >             	;17a2	be
    db $80|'='                 	; D5 =             	;17a3	bd
    db $80|'<'                 	; D6 <             	;17a4	bc
;----------------------------------------------------------------------------------------------------------------------
    db $80|'S','GN'            	; D7 SGN           	;17a5	d3 47 4e
    db $80|'I','NT'            	; D8 INT           	;17a8	c9 4e 54
    db $80|'A','BS'            	; D9 ABS           	;17ab	c1 42 53
    db $80| 1,0,0              	; DA {FRE}         	;17ae	81 00 00
    db $80|'I','NP'            	; DB INP           	;17b1	c9 4e 50
    db $80| 1,0,0              	; DC {POS}         	;17b4	81 00 00
    db $80|'S','QR'            	; DD SQR           	;17b7	d3 51 52
    db $80|'R','ND'            	; DE RND           	;17ba	d2 4e 44
    db $80|'L','OG'            	; DF LOG           	;17bd	cc 4f 47
    db $80|'E','XP'            	; E0 EXP           	;17c0	c5 58 50
    db $80|'C','OS'            	; E1 COS           	;17c3	c3 4f 53
    db $80|'S','IN'            	; E2 SIN           	;17c6	d3 49 4e
    db $80|'T','AN'            	; E3 TAN           	;17c9	d4 41 4e
    db $80|'A','TN'            	; E4 ATN           	;17cc	c1 54 4e
    db $80|'P','EEK'           	; E5 PEEK          	;17cf	d0 45 45 4b
    db $80| 1,0,0              	; E6 [CVI]         	;17d3	81 00 00
    db $80| 1,0,0              	; E7 [CVS]         	;17d6	81 00 00
    db $80| 1,0,0              	; E8 [CVD]         	;17d9	81 00 00
    db $80| 1,0,0              	; E9 [EOF]         	;17dc	81 00 00
    db $80| 1,0,0              	; EA [LOC]         	;17df	81 00 00
    db $80| 1,0,0              	; EB [LOF]         	;17e2	81 00 00
    db $80| 1,0,0,0            	; EC [MKI$]        	;17e5	81 00 00 00
    db $80| 1,0,0,0            	; ED [MKS$]        	;17e9	81 00 00 00
    db $80| 1,0,0,0            	; EE [MKD$]        	;17ed	81 00 00 00
    db $80| 1,0,0,0            	; EF {CINT}        	;17f1	81 00 00 00
    db $80| 1,0,0,0            	; F0 {CSNG}        	;17f5	81 00 00 00
    db $80| 1,0,0,0            	; F1 {CDBL}        	;17f9	81 00 00 00
    db $80| 1,0,0              	; F2 {FIX}         	;17fd	81 00 00
    db $80|'L','EN'            	; F3 LEN           	;1800	cc 45 4e
    db $80|'S','TR$'           	; F4 STR$          	;1803	d3 54 52 24
    db $80|'V','AL'            	; F5 VAL           	;1807	d6 41 4c
    db $80|'A','SC'            	; F6 ASC           	;180a	c1 53 43
    db $80|'C','HR$'           	; F7 CHR$          	;180d	c3 48 52 24
    db $80|'L','EFT$'          	; F8 LEFT$         	;1811	cc 45 46 54 24
    db $80|'R','IGHT$'         	; F9 RIGHT$        	;1816	d2 49 47 48 54 24
    db $80|'M','ID$'           	; FA MID$          	;181c	cd 49 44 24

    db $80|"'"                 	; FB ' (REM)  		;1820	a7
    db $80| 0                  	; end of table  	;1821	80
BasicCmdPointers:
	dw CmdEND					; 80 END			;1822	ae 1d 	. 
	dw CmdFOR					; 81 FOR			;1824	a1 1c 	. 
	dw CmdRESET					; 82 RESET			;1826	38 01 	8 . 
	dw CmdSET					; 83 SET 			;1828	35 01	5 
	dw CmdCLS					; 84 CLS			;182a	c9 01 	. . . 
	dw SysDosCMD				; 85 {CMD}			;182c	73 79 	y 
	dw CmdRANDOM				; 86 {RANDOM}		;182e	d3 01 	. . 
	dw CmdNEXT					; 87 NEXT			;1830	b6 22	. 
	dw CmdDATA					; 88 DATA			;1832	05 1f 	" . . 
	dw CmdINPUT					; 89 INPUT			;1834	9a 21	. 
	dw CmdDIM					; 8A DIM			;1836	08 26 	! . & 
	dw CmdREAD					; 8B READ			;1838	ef 21	. 
	dw CmdLET					; 8C LET			;183a	21 1f 	! ! . 
	dw CmdGOTO					; 8D GOTO			;183c	c2 1e 	. . . 
	dw CmdRUN					; 8E RUN			;183e	a3 1e  	. 9 
	dw CmdIF					; 8F IF				;1840	39 20   . 
	dw CmdRESTORE				; 90 RESTORE		;1842	91 1d 	. 
	dw CmdGOSUB					; 91 GOSUB			;1844	b1 1e	. 
	dw CmdRETURN				; 92 RETURN			;1846	de 1e	. . 
	dw CmdREM					; 93 REM			;1848	07 1f 	. . 
	dw CmdSTOP					; 94 STOP			;184a	a9 1d 	. 
	dw CmdELSE					; 95 ELSE			;184c	07 1f 	. 
	dw CmdCOPY					; 96 COPY			;184e	12 39 	9 
	dw CmdCOLOR					; 97 COLOR			;1850	9d 38	. 
	dw CmdVERIFY				; 98 VERIFY			;1852	38 37 	7 
	dw CmdDEFINT				; 99 {DEFINT}		;1854	03 1e	. 
	dw CmdDEFSNG				; 9A {DEFSNG}		;1856	06 1e	. . 
	dw CmdDEFDBL				; 9B {DEFDBL}		;1858	09 1e	. . 
	dw CmdCRUN					; 9C CRUN			;185a	2e 37 	7 
	dw CmdMODE					; 9D MODE			;185c	63 2e	c 
	dw CmdSOUND					; 9E SOUND			;185e	f5 2b 	+ 
	dw CmdRESUME				; 9F {RESUME}		;1860	af 1f 	. 
	dw CmdOUT					; A0 OUT			;1862	fb 2a	. 
	dw CmdON					; A1 {ON}			;1864	6c 1f 	* l . 
	dw SysDosOPEN				; A2 {OPEN}			;1866	79 79 	y 
	dw SysDosFIELD				; A3 {FIELD}		;1868	7c 79 	y 
	dw SysDosGET				; A4 {GET}			;186a	7f 79 	y 
	dw SysDosPUT				; A5 {PUT}			;186c	82 79 	y 
	dw SysDosCLOSE				; A6 {CLOSE}		;186e	85 79 	y 
	dw SysDosLOAD				; A7 {LOAD}			;1870	88 79 	y 
	dw SysDosMERGE				; A8 {MERGE}		;1872	8b 79 	y 
	dw SysDosNAME				; A9 {NAME}			;1874	8e 79 	y 
	dw SysDosKILL				; AA {KILL}			;1876	91 79 	y 
	dw SysDosLSET				; AB {LSET}			;1878	97 79 	y 
	dw SysDosRSET				; AC {RSET}			;187a	9a 79 	y 
	dw SysDosSAVE				; AD {SAVE}			;187c	a0 79 	y 
	dw SysReset			    	; AE {SYSTEM}		;187e	00 00 	. 
	dw CmdLPRINT				; AF LPRINT			;1880	67 20	g 
	dw SysDosDEF				; B0 {DEF}			;1882	5b 79 	y 
	dw CmdPOKE					; B1 POKE			;1884	b1 2c 	, 
	dw CmdPRINT					; B2 PRINT			;1886	6f 20	o 
	dw CmdCONT					; B3 CONT			;1888	e4 1d 	. 
	dw CmdLIST					; B4 LIST			;188a	2e 2b 	. + 
	dw CmdLLIST					; B5 LLIST			;188c	29 2b 	+ 
	dw CmdDELETE				; B6 {DELETE}		;188e	c6 2b 	. + 
	dw CmdAUTO					; B7 {AUTO}			;1890	08 20	. 
	dw CmdCLEAR					; B8 CLEAR			;1892	7a 1e	  z 
	dw CmdCLOAD					; B9 CLOAD			;1894	56 36	. V 
	dw CmdCSAVE					; BA CSAVE			;1896	a9 34 	4 
	dw CmdNEW					; BB NEW			;1898	49 1b 	. 
l189ah:
	ld a,c			;189a	79 	y 
	ld a,c			;189b	79 	y 
	ld a,h			;189c	7c 	| 
	ld a,h			;189d	7c 	| 
	ld a,a			;189e	7f 	 
	ld d,b			;189f	50 	P 
	ld b,(hl)			;18a0	46 	F 

; 8 addresses Table for ???
l18a1h:
	dw FuncCDBL				; convert ACC to Double value		;18a1	db 0a 	. . 
	dw SysReset	    		; SYSTEM cmd						;18a3	00 00 	. 
	dw FuncCINT				; convert ACC to integer			;18a5	7f 0a 	. 
	dw AssertACCIsString 	; Assert ACC contains String		;18a7	f4 0a 	. . . 
	dw FuncCSNG				; convert ACC to Single value		;18a9	b1 0a 	. 
l18abh:
	ld (hl),a			;18ab	77 	w 
	inc c			;18ac	0c 	. 
	ld (hl),b			;18ad	70 	p 
	inc c			;18ae	0c 	. 
	and c			;18af	a1 	. 
	dec c			;18b0	0d 	. 
	push hl			;18b1	e5 	. 
	dec c			;18b2	0d 	. 
	ld a,b			;18b3	78 	x 
	ld a,(bc)			;18b4	0a 	. 
l18b5h:
	ld d,007h		;18b5	16 07 	. . 
	inc de			;18b7	13 	. 
	rlca			;18b8	07 	. 
	ld b,a			;18b9	47 	G 
	ex af,af'			;18ba	08 	. 
	and d			;18bb	a2 	. 
	ex af,af'			;18bc	08 	. 
	inc c			;18bd	0c 	. 
	ld a,(bc)			;18be	0a 	. 
l18bfh:
	jp nc,0c70bh		;18bf	d2 0b c7 	. . . 
	dec bc			;18c2	0b 	. 
	jp p,0900bh		;18c3	f2 0b 90 	. . . 
	inc h			;18c6	24 	$ 
	add hl,sp			;18c7	39 	9 
	ld a,(bc)			;18c8	0a 	. 
	ld c,(hl)			;18c9	4e 	N 
	ld b,(hl)			;18ca	46 	F 
	ld d,e			;18cb	53 	S 
	ld c,(hl)			;18cc	4e 	N 
	ld d,d			;18cd	52 	R 
	ld b,a			;18ce	47 	G 
	ld c,a			;18cf	4f 	O 
	ld b,h			;18d0	44 	D 
	ld b,(hl)			;18d1	46 	F 
	ld b,e			;18d2	43 	C 
	ld c,a			;18d3	4f 	O 
	ld d,(hl)			;18d4	56 	V 
	ld c,a			;18d5	4f 	O 
	ld c,l			;18d6	4d 	M 
	ld d,l			;18d7	55 	U 
	ld c,h			;18d8	4c 	L 
	ld b,d			;18d9	42 	B 
	ld d,e			;18da	53 	S 
	ld b,h			;18db	44 	D 
	ld b,h			;18dc	44 	D 
	cpl			;18dd	2f 	/ 
	jr nc,TXT_READY		;18de	30 49 	0 I 
	ld b,h			;18e0	44 	D 
	ld d,h			;18e1	54 	T 
	ld c,l			;18e2	4d 	M 
sub_18e3h:
	ld c,a			;18e3	4f 	O 
	ld d,e			;18e4	53 	S 
	ld c,h			;18e5	4c 	L 
	ld d,e			;18e6	53 	S 
	ld d,e			;18e7	53 	S 
	ld d,h			;18e8	54 	T 
	ld b,e			;18e9	43 	C 
	ld c,(hl)			;18ea	4e 	N 
	ld c,(hl)			;18eb	4e 	N 
	ld d,d			;18ec	52 	R 
	ld d,d			;18ed	52 	R 
	ld d,a			;18ee	57 	W 
	ld d,l			;18ef	55 	U 
	ld b,l			;18f0	45 	E 
	ld c,l			;18f1	4d 	M 
	ld c,a			;18f2	4f 	O 
	ld b,(hl)			;18f3	46 	F 
	ld b,h			;18f4	44 	D 
	ld c,h			;18f5	4c 	L 
	inc sp			;18f6	33 	3 

; ***************************************************************************************
; Initial BASIC Values for RCA: Sub, Inp, Out Routine, Basic USR Vector and BASIC state
; ----------------------------------------------------------------------------------------
; Routine to subtract 24 bit value from packed into 24 bit registers BHL.
; Rotine is moved to RAM area (MAT_SubBHLCust) so SMC (Self Modifing Code) is used
; to substract any 24bit value.
; In order to perform subtraction before call we must set 24bit value into:
;	7881 = LSB, 7885 = MSB, 7889 - MSB, 788c - ??? 
; Call address MAT_SubBHLCust
BAS_RCAInitData:
; Routine to subtract 24 bit value from packed into 24 bit registers BHL.
	sub 00			;[$7880]	;18f7	d6 00 	. . 
	ld l,a			;[$7882]	;18f9	6f 	o 
	ld a,h			;[$7883]	;18fa	7c 	| 
	sbc a,00		;[$7884]	;18fb	de 00 	. . 
	ld h,a			;[$7886]	;18fd	67 	g 
	ld a,b			;[$7887]	;18fe	78 	x 
	sbc a,00		;[$7888]	;18ff	de 00 	. . 
	ld b,a			;[$788a]	;1901	47 	G 
	ld a,00			;[$788b]	;1902	3e 00 	> . 
	ret				;[$788d]	;1904	c9 	. 

; Jump Vector
	dw ErrRaiseFuncCode	; [$788e] BASIC USR default run address						;1905	4a 1e	J 

; Random number seed initial bytes
	db $40,$e6,$4d		;[$7890] Random Seed Value									;1907	40 e6 4d 	. @ 


; Routine to read any port into register a
; Rotine is moved to RAM area (7893-7895) so SMC (Self Modifing Code) is used
; to set port number to read from.
; In order to read port before call we must set port number into: 7894
	DISP $7893		; Call address 7893
smcPortInAddr	equ smcPortIn+1	
smcPortIn:
	in a,(0)		;[$7893]	;190a	db 00 	. . 
	ret				;[$7895]	;190c	c9 	. 
	ENT

; Routine to write to any port value from register a
; Rotine is moved to RAM area (7896-7898) so SMC (Self Modifing Code) is used
; to set port number to write to.
; In order to write to port before call we must set port number into: 7897
	DISP $7896		; Call address 7896
smcPortOutAddr	equ smcPortOut+1	
smcPortOut:
	out (0),a		;[$7896]	;190d	d3 00 	. . 
	ret				;[$7898]	;190f	c9 	. 

	ENT
	db 0			;[$7899]	;1910	00 	. 
	db 0			;[$789a]	;1911	00 	. 
	db 0			;[$789b]	;1912	00 	. 
	db 0			;[$789c]	SysCurOutDev = Screen ;1913	00 	. 
	db 64		;[$789d] 	ScrLineMaxLen ;1914	40 	@ 
	db 48 		;[$789e]	ScrPrintZones ;1915	30 . 
	db 0		;[$789f] ;1916	00 	 
	ASSERT( $ == 0x1917)

; Basic initial values
l1917h:
	dw SysMinMemory		;[$78a0] Basic Stack Address					;1917	4c 	L 
	dw $fffe		;[$78a2] Current Basic Line Number (none)		;1919	fe ff 	. . 
	dw BAS_PrgMemory		;[$78a4] Program Start Address					;191b	e9 7a	. 

; ----------------------------------------------------------------------------------------
	ASSERT( $ == 0x191d)

TXT_EMPTY			equ		$1928		; pointer to char '\0' 
TXT_ERRORSUFFIX:	db " ERROR",0		;191d	20 45 52 52 4f 52 00 	. 
TXT_INLINE:			db " IN ",0			;1924	20 49 4e 20 00 	  . 
TXT_READY:			db "READY",$0d,0	;1929	52 45 41 44 59 0d 00 	. 
TXT_BREAK:			db "BREAK",0		;1930	42 52 45 41 4b 00 	. 
sub_1936h:
	ld hl,00004h		;1936	21 04 00 	! . . 
	add hl,sp			;1939	39 	9 
l193ah:
	ld a,(hl)			;193a	7e 	~ 
	inc hl			;193b	23 	# 
	cp 081h		;193c	fe 81 	. . 
	ret nz			;193e	c0 	. 
	ld c,(hl)			;193f	4e 	N 
	inc hl			;1940	23 	# 
	ld b,(hl)			;1941	46 	F 
	inc hl			;1942	23 	# 
	push hl			;1943	e5 	. 
	ld l,c			;1944	69 	i 
	ld h,b			;1945	60 	` 
	ld a,d			;1946	7a 	z 
	or e			;1947	b3 	. 
	ex de,hl			;1948	eb 	. 
	jr z,l194dh		;1949	28 02 	( . 
	ex de,hl			;194b	eb 	. 
	rst #18			; Compare HL and DE ;194c	df 	. 
l194dh:
	ld bc,$000e		;194d	01 0e 00 	. . . 
	pop hl			;1950	e1 	. 
	ret z			;1951	c8 	. 
	add hl,bc			;1952	09 	. 
	jr l193ah		;1953	18 e5 	. . 
sub_1955h:
	call 0196ch		;1955	cd 6c 19 	. l . 
sub_1958h:
	push bc			;1958	c5 	. 
	ex (sp),hl			;1959	e3 	. 
	pop bc			;195a	c1 	. 
l195bh:
	rst #18			; Compare HL and DE ;195b	df 	. 
	ld a,(hl)			;195c	7e 	~ 
	ld (bc),a			;195d	02 	. 
	ret z			;195e	c8 	. 
	dec bc			;195f	0b 	. 
	dec hl			;1960	2b 	+ 
	jr l195bh		;1961	18 f8 	. . 
sub_1963h:
	push hl			;1963	e5 	. 
l1964h:
	ld hl,(ArrEndPtr)	; address of End of Basic Array area	;1964	2a fd 78 	* . x 
	ld b,000h		;1967	06 00 	. . 
	add hl,bc			;1969	09 	. 
	add hl,bc			;196a	09 	. 
	ld a,0e5h		;196b	3e e5 	> . 
	ld a,0c6h		;196d	3e c6 	> . 
l196fh:
	sub l			;196f	95 	. 
	ld l,a			;1970	6f 	o 
	ld a,0ffh		;1971	3e ff 	> . 
	sbc a,h			;1973	9c 	. 
	jr c,ErrRaiseOutOfMem	; Raise OUT OF MEMORY Error						;1974	38 04 	8 . 
	ld h,a			;1976	67 	g 
	add hl,sp			;1977	39 	9 
	pop hl			;1978	e1 	. 
	ret c			;1979	d8 	. 
ErrRaiseOutOfMem:
	ld e,#0c			; ERROR 0C - OUT OF MEMORY		;197a	1e 0c 	. . 
	jr ErrRaiseError	; Raise OUT OF MEMORY Error					;197c	18 24 	. $ 
l197eh:
	ld hl,(BasicLineNo)	; Current Basic Line Number 							;197e	2a a2 78 	* . x 
	ld a,h			    ; high byte of Line Number 								;1981	7c 	| 
	and l			    ; will be $ff (-1) only if LineNo = 0xffff 				;1982	a5 	. 
	inc a			    ; a = 0 if Current Basic Line Number is $ffff 			;1983	3c 	< 
	jr z,l198eh		    ; jump if LineNo is -1 ;1984	28 08 	( . 
	ld a,(ERRORFLAG)	; error status 	;1986	3a f2 78 	: . x 
	or a			    ; has Error occurred ? ;1989	b7 	. 
	ld e,#22			; ERROR 22 - NO RESUME ;198a	1e 22 	. " 
	jr nz,ErrRaiseError	; yes - Raise 'NO RESUME' Error	;198c	20 14 	  . 
l198eh:
	jp l1dc1h		;198e	c3 c1 1d 	. . . 
l1991h:
	ld hl,(DATALineNo)	; Basic line with DATA cmd 	;1991	2a da 78 	* . x 
	ld (BasicLineNo),hl ; set as current Basic line	number	;1994	22 a2 78 	" . x 


// ***************************************************************************
; Raise Error 
; IN: STACK - <???>
ErrRaiseSyntax:
	ld e,#02			; ERROR 02 - SYNTAX ERROR									;1997	1e 02 	. . 
	db $01				; trick byte - with next constructs irrevelant ld bc,l141eh ;1999	01 1e 14 	. . . 
ErrRaiseDivByZero:
	ld e,#14 			; ERROR 14 - DIVISION BY ZERO								;199a	1e 14 	. . . 
	db $01				; trick byte - with next constructs irrevelant ld bc,$001e	;199c	01 1e 00 	. . . 
ErrRaiseNextWoFor:
	ld e,#00			; ERROR 00 - NEXT WITHOUT FOR								;199d	1e 00
	db $01				; trick byte - with next constructs irrevelant ld bc,0241eh	;199f	01 1e 24 	. . $ 
ErrRaiseResumeWo:
	ld e,#24			; ERROR 24 - RESUME WITHOUT 								;19a0	1e 24 	. . $ 

; ************************************************************************************
; IN e - error number to Raise
ErrRaiseError:
	ld hl,(BasicLineNo)		; Current Basic Line Number 	                        ;19a2	2a a2 78 	* . x 
	ld (ErrorLineNo),hl	    ; set as Line with Error	                            ;19a5	22 ea 78 	" . x 
	ld (EditLineNo),hl	    ; set as Edited Line	                                ;19a8	22 ec 78 	" . x 
l19abh:
	ld bc,l19b4h		;19ab	01 b4 19 	. . . 



; ************************************************************************************
; ALTERNATE ENTRY TO BASIC "READY"
; IN: bc - address of routine to exit from Basic Program execute 
BasicEntryPoint:
	ld hl,(BAS_StackPtr)	; top of Basic Stack	;19ae	2a e8 78 	* . x 
	jp ResetStringVars		; reset Stack and String Variables	;19b1	c3 9a 1b 	. . . 
l19b4h:
	pop bc			;19b4	c1 	. 
	ld a,e			    ; Error number ;19b5	7b 	{ 
	ld c,e			;19b6	4b 	K 
	ld (LASTERRORNO),a	; set as Last Error Number occurred	;19b7	32 9a 78 	2 . x 
	ld hl,(BAS_TmpCharPtr)	; last byte of code executed in current line	;19ba	2a e6 78 	* . x 
	ld (ErrorTokenPtr),hl	; Pointer to Basic Token when error occurred	;19bd	22 ee 78 	" . x 
	ex de,hl			;19c0	eb 	. 
	ld hl,(ErrorLineNo)	; Basic Line Number with Error 	;19c1	2a ea 78 	* . x 
	ld a,h			    ;19c4	7c 	| 
	and l			;19c5	a5 	. 
	inc a			;19c6	3c 	< 
	jr z,l19d0h		;19c7	28 07 	( . 
	ld (BAS_LastLineNo),hl	; last line number executed before STOP or END	;19c9	22 f5 78 	" . x 
	ex de,hl			;19cc	eb 	. 
	ld (BAS_StopedPtr),hl	; set as address of Basic code executed before STOP 	;19cd	22 f7 78 	" . x 
l19d0h:
	ld hl,(BAS_OnErrorPtr)	; address of Error hook routine (i.e. DOS)				;19d0	2a f0 78 	* . x 
	ld a,h			;19d3	7c 	| 
	or l			;19d4	b5 	. 
	ex de,hl			;19d5	eb 	. 
	ld hl,ERRORFLAG		; error status 	;19d6	21 f2 78 	! . x 
	jr z,l19e3h		;19d9	28 08 	( . 
	and (hl)			; has Error occurred ? ;19db	a6 	. 
	jr nz,l19e3h		; yes - ;19dc	20 05 	  . 
	dec (hl)			;19de	35 	5 
	ex de,hl			;19df	eb 	. 
	jp l1d36h		;19e0	c3 36 1d 	. 6 . 
l19e3h:
	xor a			;19e3	af 	. 
	ld (hl),a			;19e4	77 	w 
	ld e,c				; e - error number 							;19e5	59 	Y 
	call SysNewLine		; move Cursor to begin of the line ;19e6	cd f9 20 	. .   
	ld hl,ERR_TXT_TABLE	; Table with Error Texts	;19e9	21 ec 3c 	! . < 
	call SysExtErrMsg		;19ec	cd a6 79 	. . y 
	ld d,a			;19ef	57 	W 
	ld a,'?'		;19f0	3e 3f 	> ? 
	call PrintChar	; Print '?' char on screen	;19f2	cd 2a 03 	. * . 
	call PrintErrorText		;19f5	cd d4 3c 	. . < 
; -- removed code
	nop																;19f8	00 	. 
	nop																;19f9	00 	. 
	nop																;19fa	00 	. 
	nop																;19fb	00 	. 
	nop																;19fc	00 	. 
	nop																;19fd	00 	. 
	ld hl,TXT_ERRORSUFFIX	; text " ERROR"							;19fe	21 1d 19 	! . . 
	push hl					;1a01	e5 	. 
	ld hl,(ErrorLineNo)		; Basic Line Number with Error 		;1a02	2a ea 78 	* . x 
	ex (sp),hl			;1a05	e3 	. 
l1a06h:
	call PrintBasicStr	; print " ERROR" text on Screen	;1a06	cd a7 28 	. . ( 
	pop hl			;1a09	e1 	. 
	ld de,0fffeh		;1a0a	11 fe ff 	. . . 
	rst #18			; Compare HL and DE ;1a0d	df 	. 
	jp z,SysInit		; Warm Reset - reinitilization ;1a0e	ca 74 06 	. t . 
	ld a,h			;1a11	7c 	| 
	and l			;1a12	a5 	. 
	inc a			;1a13	3c 	< 
	call nz,PrintINLINE		;1a14	c4 a7 0f 	. . . 
	db $3e			; trick byte - with next constructs irrevelant: ;1a17	3e c1 	> . 
    ; ld a,$c1 
    ; ... to skip pop bc	

BAS_ReadyPopBC:
	pop bc			;1a18	c1 	> . 

; **************************************************************************************
; "OFFICIAL81 RETURN TO BASIC "READY"
; The entry point sanctioned by Radio Shack for a return the the BASIC "READY" prompt. 
; However, the disadvantage of using this entry is that it will often return 
; an "Out of Memory Error" message in response to the next command typed in from the keyboard, 
; even though an "out of memory" condition does not exist. 
; Model 1 programmers have often substituted 06CCH or 0072H as alternate entry points, 
; but as mentioned above, these will not work with the Model III. The use of the routine 
; at 19AEH is recommended.
BasicREADY:
	call SwitchPrnToScr	; Flush Printer and change current Out Device to Screeen	;1a19	cd 8b 03 	. . . 
	call OnBasicREADY	; External Routine Ready                                    ;1a1c	cd ac 79 	. . y 
; -- removed stuff 
	nop	: nop : nop		; removed TRS routine (turn off Cassette Recorder)          ;1a1f	00 00 00	. 
; -- print READY on screen 
	call SysNewLine		; move Cursor to new line                                   ;1a22	cd f9 20 	. .   
	ld hl,TXT_READY		; text "READY"                                              ;1a25	21 29 19 	! ) . 
	call PrintBasicStr	; print 'READY" text on Screen	                            ;1a28	cd a7 28 	. . ( 
; -- check last error (probably to print it on screen)
	ld a,(LASTERRORNO)	; Last Error Number occurred		                        ;1a2b	3a 9a 78 	: . x 
; -- removed stuff 
	sub 2		        ; check if 'SYNTAX ERROR' (02)          					;1a2e	d6 02 	. . 
	nop : nop : nop		; removed TRS routine - call to EDIT mode if error was 02 	;1a30	00 	. 
l1a33h:
; -- set current Basic Program line number to -1 -> Command Mode
	ld hl,$ffff		    ; line number = -1 -> Command Mode                			;1a33	21 ff ff 	! . . 
	ld (BasicLineNo),hl	; set as Current Basic Line Number 		                    ;1a36	22 a2 78 	" . x 
; -- check AUTONUM mode
	ld a,(AUTONUM_ON)	; Basic AUTO input flag [TRS].	                            ;1a39	3a e1 78 	: . x 
	or a			    ; is AUTO ON ?                                              ;1a3c	b7 	. 
	jr z,l1a79h		    ; no - skip to process user input                           ;1a3d	28 3a 	( : 

; -- generate line number for next line 
	ld hl,(AUTONUM_LINE); line number generated by AUTO				                ;1a3f	2a e2 78 	* . x 
	push hl			    ; save current line number                                  ;1a42	e5 	. 
	call PrintLineNo	; Print Line number on screen and into Buffer 	            ;1a43	cd af 0f 	. . . 
	ld a,' '		    ; space char to separate from line body                     ;1a46	3e 20 	>   
	call PrintChar	    ; Print ' ' on screen	                                    ;1a48	cd 2a 03 	. * . 
	pop de			    ; de - line number for edited line                          ;1a4b	d1 	. 
	push de			    ; save current line number                                  ;1a4c	d5 	. 
	call FindBasicLine	; find Basic line with number in de				            ;1a4d	cd 2c 1b 	. , . 
	call c,PrintBasicLine	; if line is found,	print it on screen                  ;1a50	dc 53 2e 	. S . 
	nop			                                                                    ;1a53	00 	. 
	call ReadLine		; Read Line as typed by User	;1a54	cd e3 03 	. . . 
	pop de			    ; de - line number for edited line                          ;1a57	d1 	. 
	jr nc,l1a60h		;1a58	30 06 	0 . 
l1a5ah:
; -- turn off AUTONUM Mode and reset back to Basic READY
	xor a			    ; turn Off AUTONUM flag                                     ;1a5a	af 	. 
	ld (AUTONUM_ON),a	; set Basic AUTO input flag to OFF	                        ;1a5b	32 e1 78 	2 . x 
	jr BasicREADY	 	; jump to Basic Ready and display prompt to user         	;1a5e	18 b9 	. . 

l1a60h:
; -- generate next number for next line 
	ld hl,(AUTONUM_INC)	; increment value for AUTONUM line number	                ;1a60	2a e4 78 	* . x 
	add hl,de			; add it to prevoius line number                            ;1a63	19 	. 
	jr c,l1a5ah		    ; line > 65535 - turn off AUTO and display READY            ;1a64	38 f4 	8 . 
	push de			    ; save new line number   		                            ;1a66	d5 	. 
	ld de,65529		    ; de - max Line NUmber allowed								;1a67	11 f9 ff 	. . . 
	rst #18			    ; is new line number is bigger than 65525 ?                 ;1a6a	df 	. 
	pop de			    ; de - new line number              	                    ;1a6b	d1 	. 
	jr nc,l1a5ah		; yes - turn off AUTO and display READY                     ;1a6c	30 ec 	0 . 
; -- new line number is less than Maximum Valid Number
	ld (AUTONUM_LINE),hl; set new line number generated by AUTO				        ;1a6e	22 e2 78 	" . x 
; -- removed stuff 
	nop	: nop		    ; probably set bit ???                                      ;1a71	00 00	. 
; -- 
	ld hl,EditLineBuf-1	; address just before Line Editor Buffer	                ;1a73	21 e7 79 	! . y 
	jp ParseEditBuf		; Parse text in Edit Line Buffer                                          ;1a76	c3 81 1a 	. . . 



; *****************************************************************************
; PROCESS INPUT FROM BASIC READY PROMPT
; Gets input from user (interractive mode), store in Buffer (??)
l1a79h:
	nop	: nop			; removed TRS code (ld a,'>' - basic prompt)				;1a79	00 00	. 
	call ReadLine		; Read Line as typed by User	;1a7b	cd e3 03 	. . . 
; -- hl points to memory just prior to buffer containing input to be parsed
; of CY is set then Break was pressed so we should reaturn to Ready prompt
; without procesing input
	jp c,l1a33h		; if Break pressed go to Ready Prompt	;1a7e	da 33 1a 	. 3 . 

; *****************************************************************************
; PROCESS INPUT FROM BASIC READY PROMPT
; The input will be compressed (BASIC commands as one-byte Tokens)
ParseEditBuf:
	rst $10			; move hl to next Basic token			                    ;1a81	d7 	. 
; -- CY = 1 if we have digit -> means user typed line number
	inc a			; preincrement to test a == 0			                    ;1a82	3c 	< 
	dec a			; is this end of statement?                                 ;1a83	3d 	= 
	jp z,l1a33h		; yes - go to Ready Prompt (nothing more to do)	            ;1a84	ca 33 1a 	. 3 . 
; -- we have edit lines to process
	push af			; save af - char or token found	    						;1a87	f5 	. 
	call TextToInt	; de - convert following text into Line Number 				;1a88	cd 5a 1e 	. Z . 


.next:
; -- move back to end of parsed number
	dec hl			; decrement to previous byte								;1a8b	2b 	+ 
	ld a,(hl)		; a - char in buffer										;1a8c	7e 	~ 
	cp ' '			; is it space char?											;1a8d	fe 20 	.   
	jr z,.next		; yes - move back to next char								;1a8f	28 fa 	( . 

	inc hl			; move pointer to first space after Line Number				;1a91	23 	# 
	ld a,(hl)		; a - char in buffer										;1a92	7e 	~ 
	cp ' '			; is it space char?											;1a93	fe 20 	.   
	call z,inc_hl	; yes - increment parse pointer 							;1a95	cc c9 09 	. . . 
	push de			; save de - Line Number 									;1a98	d5 	. 
	call TokenizeLine		;1a99	cd c0 1b 	. . . 
	pop de			; restore de 												;1a9c	d1 	. 
	pop af			; restore af - token at begin of line						;1a9d	f1 	. 
	ld (BAS_TmpCharPtr),hl	; save pointer to tokenized line					;1a9e	22 e6 78 	" . x 
	call SysExtTokenize; user external routine	after tokenize line					;1aa1	cd b2 79 	. . y 
; - line in Buffer is tokenized - ready to store or execute
	jp nc,l1d5ah	; if Line in Buffer hasn't have Number - execute 			;1aa4	d2 5a 1d 	. Z . 


; -- Line has Number - don't execute naw but store into Basic Program 
	push de			; save de - program Line Number								;1aa7	d5 	. 
	push bc			;1aa8	c5 	. 
; -- clear input flag 
	xor a			; 0 - Input Off												;1aa9	af 	. 
	ld (INPUTFLAG),a; clear Flag indicates whether inputing text				;1aaa	32 dd 78 	2 . x 
; -- check next token or End of Statement
	rst $10			; move hl to next Basic token								;1aad	d7 	. 
	or a			; is this End of Statement? 								;1aae	b7 	. 
	push af			; save af - token byte and flags							;1aaf	f5 	. 
; -- test if Basic Line with this number already exists
	ex de,hl		; hl - Basic Line Number									;1ab0	eb 	. 
	ld (EditLineNo),hl	; set as current Edited Basic Line Number				;1ab1	22 ec 78 	" . x 
	ex de,hl		; de - line number to find 									;1ab4	eb 	. 
	call FindBasicLine	; find Basic line with number in de					;1ab5	cd 2c 1b 	. , . 
; -- if LIne was found, CY=1 and bc contains address of this line and hl contains next line after that 
	push bc			; save bc - address of existing line (if found)				;1ab8	c5 	. 
	call c,DelBasicLines	; delete old Basic line 							;1ab9	dc e4 2b 	. . + 
	pop de			; temporary pop to reach af (token and flags)				;1abc	d1 	. 
	pop af			; restore af - token byte and flags							;1abd	f1 	. 
	push de			; push back address of old line								;1abe	d5 	. 
	jr z,l1ae8h		; finalize if End of Statement 								;1abf	28 27 	( ' 

; -- insert new line into Basic Program
	pop de			; de - address of deleted line                              ;1ac1	d1 	. 
	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program				;1ac2	2a f9 78 	* . x 
	ex (sp),hl		; push EOP, hl - ???						;1ac5	e3 	. 
	pop bc			; bc - End of Basic Program									;1ac6	c1 	. 
	add hl,bc			;1ac7	09 	. 
	push hl			;1ac8	e5 	. 
	call sub_1955h		;1ac9	cd 55 19 	. U . 
	pop hl			;1acc	e1 	. 
	ld (PrgEndPtr),hl	; set as address of End of Basic Program			;1acd	22 f9 78 	" . x 
	ex de,hl			;1ad0	eb 	. 
	ld (hl),h			;1ad1	74 	t 
	pop de			;1ad2	d1 	. 
	push hl			;1ad3	e5 	. 
	inc hl			;1ad4	23 	# 
	inc hl			;1ad5	23 	# 
	ld (hl),e			;1ad6	73 	s 
	inc hl			;1ad7	23 	# 
	ld (hl),d			;1ad8	72 	r 
	inc hl			;1ad9	23 	# 
	ex de,hl			;1ada	eb 	. 
	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;1adb	2a a7 78 	* . x 
	ex de,hl			;1ade	eb 	. 
	dec de			;1adf	1b 	. 
	dec de			;1ae0	1b 	. 
l1ae1h:
	ld a,(de)			;1ae1	1a 	. 
	ld (hl),a			;1ae2	77 	w 
	inc hl			;1ae3	23 	# 
	inc de			;1ae4	13 	. 
	or a			;1ae5	b7 	. 
	jr nz,l1ae1h		;1ae6	20 f9 	  . 
l1ae8h:
	pop de				; de - Basic line address to start from 	;1ae8	d1 	. 
	call AdjustBasLines	; Adjust BASIC line pointers ;1ae9	cd fc 1a 	. . . 
	call OnLineChanged	; call external OnLineChanged hook						;1aec	cd b5 79 	. . y 
	call ResetBasicPrg	; Reset Parse point, variables, arrays, strings, stack and error state		; "CLEAR" (adjust pointers)	;1aef	cd 5d 1b 	. ] . 
	call OnResetBasPrg	; call external OnResetBasPrg hook						;1af2	cd b8 79 	. . y 
	jp l1a33h		; go to Ready Prompt 	;1af5	c3 33 1a 	. 3 . 


; ******************************************************************************
; ADJUST BASIC POINTERS
; As stored in memory, the first two bytes of each line of BASIC program 
; point to the first byte of the following BASIC program line.
; When a program has been CLOADed, or after editing, these pointers may 
; not be correct. This routine adjusts all of these forward so that they 
; correctly point to the beginning of the next line, atarting with the first line 
; of the program.
	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 			;1af8	2a a4 78 	* . x 
	ex de,hl			; de - BASIC line address								;1afb	eb 	. 

; ******************************************************************************
; ADJUST BASIC POINTERS STARTING AT (DE)
; IN: de - BASIC line address to start from 
AdjustBasLines:
; -- copy Basic Line address to hl 
	ld h,d			; copy Basic Line address to hl								;1afc	62 	b 
	ld l,e																		;1afd	6b 	k 
; -- check if end of Basic lines - next line address equals 0
	ld a,(hl)		; Low byte of next line address 							;1afe	7e 	~ 
	inc hl			; pointer to high byte										;1aff	23 	# 
	or (hl)			; next line address equals 0? 								;1b00	b6 	. 
	ret z			; yes - no more lines to adjust ------- End of Proc -------	;1b01	c8 	. 
	inc hl			; points to  Basic Line Number								;1b02	23 	# 
; -- next Basic line exists - skip Basic Line number (16bit) 
	inc hl			; skip Basic line number (16bit)							;1b03	23 	# 
	inc hl																		;1b04	23 	# 
; -- find end of line (null char)
	xor a			; null char to compare										;1b05	af 	. 
.next:
	cp (hl)			; is this null char (end of line)?							;1b06	be 	. 
	inc hl			; points to next char or next Basic Line entry				;1b07	23 	# 
	jr nz,.next		; no - keep searching										;1b08	20 fc 	  . 
; -- end of line found - store this addrees into previous line entry as next line address
	ex de,hl		; de - address of current line entry, hl - previous line 	;1b0a	eb 	. 
	ld (hl),e		; store into previous line entry as next line address		;1b0b	73 	s 
	inc hl			; points to high address									;1b0c	23 	# 
	ld (hl),d		; store high byte of address								;1b0d	72 	r 
	jr AdjustBasLines	; process next lBasic lines ---------------------------	;1b0e	18 ec 	. . 



sub_1b10h:
	ld de,$0000		;1b10	11 00 00 	. . . 
	push de			;1b13	d5 	. 
	jr z,$+11		;1b14	28 09 	( . 
	pop de			;1b16	d1 	. 
	call sub_1e4fh		;1b17	cd 4f 1e 	. O . 
	push de			;1b1a	d5 	. 
	jr z,l1b28h		;1b1b	28 0b 	( . 
	rst $08			; Assert next token is '-' ;1b1d	cf 	. 
	defb $CE		; Basic '-' token ;1b1e	ce  . 
	ld de, $fffa	;1b1f	11 fa ff
	call nz,sub_1e4fh		;1b22	c4 4f 1e	O 
	jp nz,ErrRaiseSyntax	; Raise 'SYNTAX ERROR'	;1b25	c2 	97 19 	. 
l1b28h:
	ex de,hl			;1b28	eb 	. 
	pop de			;1b29	d1 	. 
sub_1b2ah:
	ex (sp),hl			;1b2a	e3 	. 
	push hl			;1b2b	e5 	. 


; *****************************************************************************
; SEARCH FOR A MATCHING BASIC LINE NUMBER
; IN: de - BASIC line number to find
; OUT: CY - 1 - line found, 0 - not found
;      Z - 1 - found exact or end, 0 - found line with greater number
;      bc - address of found line (exact or greater) or program end
;      hl - addres of next line after found one or program end
;      de - number of line searched for
FindBasicLine:
	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;1b2c	2a a4 78 	* . x 
l1b2fh:
	ld b,h			;1b2f	44 	D 
	ld c,l			;1b30	4d 	M 
	ld a,(hl)			;1b31	7e 	~ 
	inc hl			;1b32	23 	# 
	or (hl)			;1b33	b6 	. 
	dec hl			;1b34	2b 	+ 
	ret z			;1b35	c8 	. 
	inc hl			;1b36	23 	# 
	inc hl			;1b37	23 	# 
	ld a,(hl)			;1b38	7e 	~ 
	inc hl			;1b39	23 	# 
	ld h,(hl)			;1b3a	66 	f 
	ld l,a			;1b3b	6f 	o 
	rst #18			; Compare HL and DE ;1b3c	df 	. 
	ld h,b			;1b3d	60 	` 
	ld l,c			;1b3e	69 	i 
	ld a,(hl)			;1b3f	7e 	~ 
	inc hl			;1b40	23 	# 
	ld h,(hl)			;1b41	66 	f 
	ld l,a			;1b42	6f 	o 
	ccf			;1b43	3f 	? 
	ret z			;1b44	c8 	. 
	ccf			;1b45	3f 	? 
	ret nc			;1b46	d0 	. 
	jr l1b2fh		;1b47	18 e6 	. . 

; **************************************************************************************
; BASIC NEW Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdNEW
	ret nz				; return if not end of statement after NEW command		;1b49	c0 	. 
	call CmdCLS			; clear Screen - restore MODE 0 if needed				;1b4a	cd c9 01 	. . . 

; **************************************************************************************
; Wipe out the BASIC program currently in memory by reseting pointers associated 
; with it.
DeleteAllBasic:
	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;1b4d	2a a4 78 	* . x 
	call CmdTROFF		; disable Trace (return a = 0)							;1b50	cd f8 1d 	. . . 
	ld (AUTONUM_ON),a	; set AUTONUM function to OFF							;1b53	32 e1 78 	2 . x 
; -- first 2 bytes of Basic Program - $0000 means end of program reached
	ld (hl),a			; clear Basic Program area								;1b56	77 	w 
	inc hl				; next address											;1b57	23 	# 
	ld (hl),a			; clear Basic Program Area								;1b58	77 	w 
	inc hl				; address just after 2 first empty bytes				;1b59	23 	# 
	ld (PrgEndPtr),hl	; store as End of Basic Program							;1b5a	22 f9 78 	" . x 

; Reset Parse address, clear variables, arrays, strings, stack and error
; Switch to MODE 0 screen
; OUT: hl - Program Start-1 (parse point) 
ResetBasicPrg:
	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 			;1b5d	2a a4 78 	* . x 
	dec hl				; points just before Program Start					;1b60	2b 	+ 


; **************************************************************************************
; CLEAR ALL ¥AR1ABLBS
; This routine is CALLed whenever the BASIC program is changed like adding,
; deieting or editing lines. 
; * All variables are cleared, 
; * variables pointers are reset, 
; * various other flags and pointers are reset.
; IN: hl - start of BASIC program minus one
BAS_ResetVars:
; -- reset Basic Start pointer
	ld (PrgStart),hl		; reset Basic Program Start							;1b61	22 df 78 	" . x 
; -- clear Variable Table
	ld b,26					; 26 entries of VarTable (for every letter A..Z)	;1b64	06 1a 	. . 
	ld hl,BAS_VarTypesTab	; address of Variable Declarations Table			;1b66	21 01 79 	! . y 
.nextVar:
	ld (hl),4				; default 4 - single numeric type					;1b69	36 04 	6 . 
	inc hl					; points to next entry								;1b6b	23 	# 
	djnz .nextVar			; fill all 26 entries								;1b6c	10 fb 	. . 
; -- set Error status to OK
	xor a			    	; 0 - no error status                               ;1b6e	af 	. 
	ld (ERRORFLAG),a		; set as Error Status 	                            ;1b6f	32 f2 78 	2 . x 
; -- clear Error trap and Stopped pointers
	ld l,a			                                                            ;1b72	6f 	o 
	ld h,a			    	; hl = 0                                            ;1b73	67 	g 
	ld (BAS_OnErrorPtr),hl	; address of error trap routine (none)				;1b74	22 f0 78 	" . x 
	ld (BAS_StopedPtr),hl	; address where Program was Stopped (none)			;1b77	22 f7 78 	" . x 
; -- reset Strings Area pointer - no Strings stored
	ld hl,(MEMORY_TOP)		; top of available memory							;1b7a	2a b1 78 	* . x 
	ld (BAS_StrFreePtr),hl	; set as Strings Pointer - 0 bytes reserved 		;1b7d	22 d6 78 	" . x 
; -- Basic RESTORE command 
	call CmdRESTORE			; execute RESTORE 									;1b80	cd 91 1d 	. . . 
; -- reset Array Variables Area
	ld hl,(PrgEndPtr)		; first address above memory used by Program		;1b83	2a f9 78 	* . x 
	ld (ArrStartPtr),hl		; set as Start of Basic Arrays area					;1b86	22 fb 78 	" . x 
	ld (ArrEndPtr),hl		; set as End of Basic Arrays area - 0 bytes used	;1b89	22 fd 78 	" . x 
	call SysExtNew			; call external hook if defined (i.e. by DOS)		;1b8c	cd bb 79 	. . y 
ResetBasicStack:
	pop bc					; bc - return address to calling routine (00af)			;1b8f	c1 	. 
; -- set BASIC Stack Pointer and update 
	ld hl,(STACKTOPPTR)		; reset BASIC Stack pointer								;1b90	2a a0 78 	* . x 
	dec hl					; 														;1b93	2b 	+ 
	dec hl					; skip 2 bytes (one address pointer)					;1b94	2b 	+ 
	ld (BAS_StackPtr),hl	; set as new BASIC Stack Pointer						;1b95	22 e8 78 	" . x 
	inc hl					; 														;1b98	23 	# 
	inc hl					; restore value from MaxStackPtr						;1b99	23 	# 
ResetStringVars:
; -- initialize CPU Stack Pointer (discard all subroutine calls)
	ld sp,hl				; set as CPU stack Pointer								;1b9a	f9 	. 
; -- reset Variables area - (discard all variables)
	ld hl,BAS_StrVars		; address of BASIC String Variables Area				;1b9b	21 b5 78 	! . x 
	ld (BAS_StrNextVar),hl	; set as place for new variable	created					;1b9e	22 b3 78 	" . x 
; -- flush any pending printing and switch Out to Screen
	call SwitchPrnToScr	    ; Flush Printer and change current Out Device to Screeen;1ba1	cd 8b 03 	. . . 
	call SysSetOutAsScreen	; set Screen as Current Out Device						;1ba4	cd 69 21 	. i ! 
; -- clear for-next Flag (discard any pending For loop)
	xor a					; a - 0 					 							;1ba7	af 	. 
	ld h,a					;														;1ba8	67 	g 
	ld l,a					; hl - 0000 - SysReset address							;1ba9	6f 	o 
	ld (ForNextFlag),a		; - clear for-next Flag									;1baa	32 dc 78 	2 . x 
; -- reset CPU Stack content to only SysReset and calling routine return addres
	push hl					; set SysReset as Top Return Address					;1bad	e5 	. 
	push bc					; return to calling routine address (stored before) 	;1bae	c5 	. 
	ld hl,(PrgStart)		; hl - pointer to BASIC Program Start					;1baf	2a df 78 	* . x 
	ret						; ----------- End of Proc ----------------------------- ;1bb2	c9 	. 



; *********************************************************************************
; Displays prompt character (question mark followed by space) and then jumps 
; to routine at 0545 (see above).
BAS_Prompt:
	ld a,'?'		; a - question mark as prompt character						;1bb3	3e 3f 	> ? 
	call PrintChar	; Print '?' char on screen	    							;1bb5	cd 2a 03 	. * . 
	ld a,' '		; space character											;1bb8	3e 20 	>   
	call PrintChar	; Print ' ' char on screen	    							;1bba	cd 2a 03 	. * . 
 ifdef VER_12
	jp GetUserInputText		;1bbd	c3 45 05 	. E . 
 else ; VER_20
 	jp GetUserInputText		;1bbd	c3 3a 05 	. : . 
 endif

; *********************************************************************************
; COMPRESS BASIC LINE
; BASIC stores all reserved words as one-byte tokens. This routine will take a line 
; of text and compress it so that all BASIC reserved words are tokenized.
; Three 0 bytes will be placed at the end of encoded statement.
; Register bc will contain +5 to reserve room for full BASIC line (2 bytes forvard
; pointer, 2 bytes line number, 1 byte zero termination).
; Convert all aplhabetic char to uppercase (??) unless they are inside string literal.
; IN: hl - text null terminated to tokenize
; OUT: Buffer (pointed by 78a7 minus two) contains tokenized BASIC
;     hl - start of tokenized content minus one (contains ':')
;     de - last of 0 bytes at the end
;     bc - length of data w/o leading ':' and 3 ending bytes + 5
TokenizeLine:
	xor a			;1bc0	af 	. 
	ld (078b0h),a		;1bc1	32 b0 78 	2 . x 
	ld c,a			;1bc4	4f 	O 
	ex de,hl			;1bc5	eb 	. 
	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;1bc6	2a a7 78 	* . x 
	dec hl			;1bc9	2b 	+ 
l1bcah:
	dec hl			;1bca	2b 	+ 
	ex de,hl			;1bcb	eb 	. 
l1bcch:
	ld a,(hl)			;1bcc	7e 	~ 
	cp 020h		;1bcd	fe 20 	.   
	jp z,l1c5bh		;1bcf	ca 5b 1c 	. [ . 
	ld b,a			;1bd2	47 	G 
	cp 022h		;1bd3	fe 22 	. " 
	jp z,l1c77h		;1bd5	ca 77 1c 	. w . 
	or a			;1bd8	b7 	. 
	jp z,l1c7dh		;1bd9	ca 7d 1c 	. } . 
	ld a,(078b0h)		;1bdc	3a b0 78 	: . x 
	or a			;1bdf	b7 	. 
	ld a,(hl)			;1be0	7e 	~ 
	jp nz,l1c5bh		;1be1	c2 5b 1c 	. [ . 
	cp 03fh		;1be4	fe 3f 	. ? 
	ld a,0b2h		;1be6	3e b2 	> . 
	jp z,l1c5bh		;1be8	ca 5b 1c 	. [ . 
	ld a,(hl)			;1beb	7e 	~ 
	cp 030h		;1bec	fe 30 	. 0 
	jr c,l1bf5h		;1bee	38 05 	8 . 
	cp 03ch		;1bf0	fe 3c 	. < 
	jp c,l1c5bh		;1bf2	da 5b 1c 	. [ . 
l1bf5h:
	push de			;1bf5	d5 	. 
	ld de,0164fh		;1bf6	11 4f 16 	. O . 
	push bc			;1bf9	c5 	. 
	ld bc,l1c3dh		;1bfa	01 3d 1c 	. = . 
	push bc			;1bfd	c5 	. 
	ld b,07fh		;1bfe	06 7f 	.  
	ld a,(hl)			;1c00	7e 	~ 
	cp 061h		;1c01	fe 61 	. a 
	jr c,l1c0ch		;1c03	38 07 	8 . 
	cp 07bh		;1c05	fe 7b 	. { 
	jr nc,l1c0ch		;1c07	30 03 	0 . 
	and 05fh		;1c09	e6 5f 	. _ 
	ld (hl),a			;1c0b	77 	w 
l1c0ch:
	ld c,(hl)			;1c0c	4e 	N 
	ex de,hl			;1c0d	eb 	. 
l1c0eh:
	inc hl			;1c0e	23 	# 
	or (hl)			;1c0f	b6 	. 
	jp p,l1c0eh		;1c10	f2 0e 1c 	. . . 
	inc b			;1c13	04 	. 
	ld a,(hl)			;1c14	7e 	~ 
	and 07fh		;1c15	e6 7f 	.  
	ret z			;1c17	c8 	. 
	cp c			;1c18	b9 	. 
	jr nz,l1c0eh		;1c19	20 f3 	  . 
	ex de,hl			;1c1b	eb 	. 
	push hl			;1c1c	e5 	. 
l1c1dh:
	inc de			;1c1d	13 	. 
	ld a,(de)			;1c1e	1a 	. 
	or a			;1c1f	b7 	. 
	jp m,l1c39h		;1c20	fa 39 1c 	. 9 . 
	ld c,a			;1c23	4f 	O 
	ld a,b			;1c24	78 	x 
	cp 08dh		;1c25	fe 8d 	. . 
	jr nz,l1c2bh		;1c27	20 02 	  . 
	rst $10			; move hl to next Basic token			;1c29	d7 	. 
	dec hl			;1c2a	2b 	+ 
l1c2bh:
	inc hl			;1c2b	23 	# 
	ld a,(hl)			;1c2c	7e 	~ 
	cp 061h		;1c2d	fe 61 	. a 
	jr c,l1c33h		;1c2f	38 02 	8 . 
	and 05fh		;1c31	e6 5f 	. _ 
l1c33h:
	cp c			;1c33	b9 	. 
	jr z,l1c1dh		;1c34	28 e7 	( . 
	pop hl			;1c36	e1 	. 
	jr l1c0ch		;1c37	18 d3 	. . 
l1c39h:
	ld c,b			;1c39	48 	H 
	pop af			;1c3a	f1 	. 
	ex de,hl			;1c3b	eb 	. 
	ret			;1c3c	c9 	. 
l1c3dh:
	ex de,hl			;1c3d	eb 	. 
	ld a,c			;1c3e	79 	y 
	pop bc			;1c3f	c1 	. 
	pop de			;1c40	d1 	. 
	ex de,hl			;1c41	eb 	. 
	cp 095h		;1c42	fe 95 	. . 
	ld (hl),03ah		;1c44	36 3a 	6 : 
	jr nz,l1c4ah		;1c46	20 02 	  . 
	inc c			;1c48	0c 	. 
	inc hl			;1c49	23 	# 
l1c4ah:
	cp 0fbh		;1c4a	fe fb 	. . 
	jr nz,l1c5ah		;1c4c	20 0c 	  . 
	ld (hl),03ah		;1c4e	36 3a 	6 : 
	inc hl			;1c50	23 	# 
	ld b,093h		;1c51	06 93 	. . 
	ld (hl),b			;1c53	70 	p 
	inc hl			;1c54	23 	# 
	ex de,hl			;1c55	eb 	. 
	inc c			;1c56	0c 	. 
	inc c			;1c57	0c 	. 
	jr l1c77h		;1c58	18 1d 	. . 
l1c5ah:
	ex de,hl			;1c5a	eb 	. 
l1c5bh:
	inc hl			;1c5b	23 	# 
	ld (de),a			;1c5c	12 	. 
	inc de			;1c5d	13 	. 
	inc c			;1c5e	0c 	. 
	sub 03ah		;1c5f	d6 3a 	. : 
	jr z,l1c67h		;1c61	28 04 	( . 
	cp 04eh		;1c63	fe 4e 	. N 
	jr nz,l1c6ah		;1c65	20 03 	  . 
l1c67h:
	ld (078b0h),a		;1c67	32 b0 78 	2 . x 
l1c6ah:
	sub 059h		;1c6a	d6 59 	. Y 
	jp nz,l1bcch		;1c6c	c2 cc 1b 	. . . 
	ld b,a			;1c6f	47 	G 
l1c70h:
	ld a,(hl)			;1c70	7e 	~ 
	or a			;1c71	b7 	. 
	jr z,l1c7dh		;1c72	28 09 	( . 
	cp b			;1c74	b8 	. 
	jr z,l1c5bh		;1c75	28 e4 	( . 
l1c77h:
	inc hl			;1c77	23 	# 
	ld (de),a			;1c78	12 	. 
	inc c			;1c79	0c 	. 
	inc de			;1c7a	13 	. 
	jr l1c70h		;1c7b	18 f3 	. . 
l1c7dh:
	ld hl,$0005		;1c7d	21 05 00 	! . . 
	ld b,h			;1c80	44 	D 
	add hl,bc			;1c81	09 	. 
	ld b,h			;1c82	44 	D 
	ld c,l			;1c83	4d 	M 
	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;1c84	2a a7 78 	* . x 
	dec hl			;1c87	2b 	+ 
	dec hl			;1c88	2b 	+ 
	dec hl			;1c89	2b 	+ 
	ld (de),a			;1c8a	12 	. 
	inc de			;1c8b	13 	. 
	ld (de),a			;1c8c	12 	. 
	inc de			;1c8d	13 	. 
	ld (de),a			;1c8e	12 	. 
	ret			;1c8f	c9 	. 


; ********************************************************************************
; Math : Compare HL and DE (Unsigned Integer)
; System routine called via JumpTable using RST 18
; IN: hl - unsigned integer to compare
;     de - unsigned integer to compare
; OUT: flags - Z=1 if HL == DE, CY=1 if HL < DE
CmpHLDE:
	ld a,h				; a - high byte of hl									;1c90	7c 	| 
	sub d				; subtract high byte of de - different?					;1c91	92 	. 
	ret nz				; yes - CY=1 if H < D ---------------------------------	;1c92	c0 	. 
	ld a,l				; a - low byte of hl									;1c93	7d 	} 
	sub e				; subtract low byte of de - different?					;1c94	93 	. 
	ret					; ------ End of Proc (CY=1 if HL < DE, Z=1 if equal) --	;1c95	c9 	. 

// *************************************************************************
; System routine called via JumpTable using RST 08
; This routine is used by BASIC to check for an expected character.
; If that character is not present, a jump is taken to the Syntax Error routine. 
; An expected character is one that must be present to preserve proper syntax.
; IN: hl - address of char in BASIC program
; OUT: hl - next non-space char in BASIC program 
AssertToken:
	ld a,(hl)			; a - next char from BASIC program 						;1c96	7e 	~ 
	ex (sp),hl			; hl - return addres (byte just after RST 08)			;1c97	e3 	. 
	cp (hl)				; is char from BASIC == expected token					;1c98	be 	. 
	inc hl				; skip byte after RST 08								;1c99	23 	# 
	ex (sp),hl			; (sp) - modified return addres, hl - char in BASIC		;1c9a	e3 	. 
	jp z,NextToken	    ; yes - ; Move hl to next Basic token                   ;1c9b	ca 78 1d 	. x . 
	jp ErrRaiseSyntax	; no - Raise 'SYNTAX ERROR' 							;1c9e	c3 97 19 	. . . 


// *************************************************************************
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdFOR
; -- set for-bext flag - next parsed variable is for loop index 
	ld a,$64				; flag value 										;1ca1	3e 64 	> d 
	ld (ForNextFlag),a	; set flag - next variable is for loop index		;1ca3	32 dc 78 	2 . x 
	call CmdLET		;1ca6	cd 21 1f 	. ! . 
	ex (sp),hl			;1ca9	e3 	. 
	call sub_1936h		;1caa	cd 36 19 	. 6 . 
	pop de			;1cad	d1 	. 
	jr nz,l1cb5h		;1cae	20 05 	  . 
	add hl,bc			;1cb0	09 	. 
	ld sp,hl			;1cb1	f9 	. 
	ld (BAS_StackPtr),hl	; set as top of Basic Stack Pointer		;1cb2	22 e8 78 	" . x 
l1cb5h:
	ex de,hl			;1cb5	eb 	. 
	ld c,008h		;1cb6	0e 08 	. . 
	call sub_1963h		;1cb8	cd 63 19 	. c . 
	push hl			;1cbb	e5 	. 
	call CmdDATA		;1cbc	cd 05 1f 	. . . 
	ex (sp),hl			;1cbf	e3 	. 
	push hl			;1cc0	e5 	. 
	ld hl,(BasicLineNo)	; Current Basic Line Number 		;1cc1	2a a2 78 	* . x 
	ex (sp),hl			;1cc4	e3 	. 
	rst $08			; Assert next token is 'TO' ;1cc5	cf 	. 
	defb $BD		; Basic 'TO' token	;1cc6	bd 	. 
	rst #20			; test NTF (Number Type Format);1cc7	e7 	. 
	jp z,ErrRaiseTypeMismatch	; String - Raise TYPE MISMATCH Error			;1cc8	ca f6 0a 	. . . 
	jp nc,ErrRaiseTypeMismatch	; Double - Raise TYPE MISMATCH Error			;1ccb	d2 f6 0a 	. . . 
	push af			; save af - Number Type Format;1cce	f5 	. 
	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;1ccf	cd 37 23 	. 7 # 
	pop af			; restore af - Number Type Format	;1cd2	f1 	. 
	push hl			;1cd3	e5 	. 
	jp p,l1cech		; Single - ;1cd4	f2 ec 1c 	. . . 
	call FuncCINT	; convert ACC to integer		;1cd7	cd 7f 0a 	.  . 
	ex (sp),hl			;1cda	e3 	. 
	ld de,1		;1cdb	11 01 00 	. . . 
	ld a,(hl)			;1cde	7e 	~ 
	cp 0cch		;1cdf	fe cc 	. . 
	call z,sub_2b01h		;1ce1	cc 01 2b 	. . + 
	push de			;1ce4	d5 	. 
	push hl			;1ce5	e5 	. 
	ex de,hl			;1ce6	eb 	. 
	call TestHLSign	; Test HL sign	;1ce7	cd 9e 09 	. . . 
	jr l1d0eh		;1cea	18 22 	. " 
l1cech:
	call FuncCSNG		; convert ACC to Single value	;1cec	cd b1 0a 	. . . 
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;1cef	cd bf 09 	. . . 
	pop hl			;1cf2	e1 	. 
	push bc			;1cf3	c5 	. 
	push de			;1cf4	d5 	. 
	ld bc,08100h		;1cf5	01 00 81 	. . . 
	ld d,c			;1cf8	51 	Q 
	ld e,d			;1cf9	5a 	Z 
	ld a,(hl)			;1cfa	7e 	~ 
	cp 0cch		;1cfb	fe cc 	. . 
	ld a,001h		;1cfd	3e 01 	> . 
	jr nz,l1d0fh		;1cff	20 0e 	  . 
	call sub_2338h		;1d01	cd 38 23 	. 8 # 
	push hl			;1d04	e5 	. 
	call FuncCSNG		; convert ACC to Single value	;1d05	cd b1 0a 	. . . 
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;1d08	cd bf 09 	. . . 
	call sngdblACCSign	; Check Sign of number in ACC (Single or Double)		;1d0b	cd 55 09 	. U . 
l1d0eh:
	pop hl			;1d0e	e1 	. 
l1d0fh:
	push bc			;1d0f	c5 	. 
	push de			;1d10	d5 	. 
	ld c,a			;1d11	4f 	O 
	rst #20			; test NTF ;1d12	e7 	. 
	ld b,a			;1d13	47 	G 
	push bc			;1d14	c5 	. 
	push hl			;1d15	e5 	. 
	ld hl,(PrgStart); hl - pointer to BASIC Program Start						;1d16	2a df 78 	* . x 
	ex (sp),hl			;1d19	e3 	. 
l1d1ah:
	ld b,081h		;1d1a	06 81 	. . 
	push bc			;1d1c	c5 	. 
	inc sp			;1d1d	33 	3 
l1d1eh:
	call KeysReadKeySaveDE		;1d1e	cd 58 03 	. X . 
	or a			;1d21	b7 	. 
	call nz,sub_1da0h		;1d22	c4 a0 1d 	. . . 
	ld (BAS_TmpCharPtr),hl	; last byte of code executed in current line		;1d25	22 e6 78 	" . x 
	ld (BAS_StackPtr),sp		;1d28	ed 73 e8 78 	. s . x 
	ld a,(hl)			;1d2c	7e 	~ 
	cp 03ah		;1d2d	fe 3a 	. : 
	jr z,l1d5ah		;1d2f	28 29 	( ) 
	or a			;1d31	b7 	. 
	jp nz,ErrRaiseSyntax	; no - Raise 'SYNTAX ERROR'	;1d32	c2 97 19 	. . . 
	inc hl			;1d35	23 	# 
l1d36h:
	ld a,(hl)			;1d36	7e 	~ 
	inc hl			;1d37	23 	# 
	or (hl)			;1d38	b6 	. 
	jp z,l197eh		;1d39	ca 7e 19 	. ~ . 
	inc hl			;1d3c	23 	# 
	ld e,(hl)			;1d3d	5e 	^ 
	inc hl			;1d3e	23 	# 
	ld d,(hl)			;1d3f	56 	V 
	ex de,hl			;1d40	eb 	. 
	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;1d41	22 a2 78 	" . x 
	ld a,(TRACEFLAG)		;1d44	3a 1b 79 	: . y 
	or a			;1d47	b7 	. 
	jr z,l1d59h		;1d48	28 0f 	( . 
	push de			;1d4a	d5 	. 
	ld a,'<'		;1d4b	3e 3c 	> < 
	call PrintChar    ; Print '<' char on screen			;1d4d	cd 2a 03 	. * . 
	call PrintLineNo	; Print Line number 	;1d50	cd af 0f 	. . . 
	ld a,'>'		;1d53	3e 3e 	> > 
	call PrintChar	; Print '>' char on screen		;1d55	cd 2a 03 	. * . 
	pop de			;1d58	d1 	. 
l1d59h:
	ex de,hl			;1d59	eb 	. 
l1d5ah:
	rst $10			; move hl to next Basic token			;1d5a	d7 	. 

	ld de,l1d1eh		;1d5b	11 1e 1d 	. . . 
	push de			;1d5e	d5 	. 
l1d5fh:
	ret z			;1d5f	c8 	. 
l1d60h:
	sub $80				; is it less than ;1d60	d6 80 	. . 
	jp c,CmdLET			;1d62	da 21 1f 	. ! . 
	cp 60				; 60 Basic commands defined ;1d65	fe 3c 	. < 
	jp nc,l2ae7h		;1d67	d2 e7 2a 	. . * 
	rlca			;1d6a	07 	. 
	ld c,a			;1d6b	4f 	O 
	ld b,0			; bc - 16bit address offset ;1d6c	06 00 	. . 
	ex de,hl			;1d6e	eb 	. 
	ld hl,BasicCmdPointers	; All Basic Commands EntryPoint Table					;1d6f	21 22 18 	! " . 
	add hl,bc			; hl - address of entry point for Command ;1d72	09 	. 
	ld c,(hl)			; low byte of address	;1d73	4e 	N 
	inc hl				; points to hight byte ;1d74	23 	# 
	ld b,(hl)			; bc - address of entry point for this Command	;1d75	46 	F 
	push bc				; push on stack - set as return address ;1d76	c5 	. 
	ex de,hl			;1d77	eb 	. 

; **********************************************************************************
; System routine called via JumpTable using RST 10
; Advances HL register pair to point to the next character of a BASIC program. 
; During a run of a BASIC program, the HL register pair normally points to the next byte 
; of the BASIC program to be executed. The RST 10 instruction causes HL to be incremented, 
; skipping space (20) or linefeed (0A) characters 
; IN: hl - byte in BASIC program
; OUT: hl - next non-space char in BASIC program
;      a - char pointed by hl
;      Z - ':' or \0 found (end of BASIC statement)
;      CY - '0'..'9' found (number)
; Move hl to next Basic token
NextToken:
	inc hl				; (hl) - next char in BASIC program								;1d78	23 	# 
	ld a,(hl)			; a - char from basic program									;1d79	7e 	~ 
	cp ':'				; is ':' (end of statement) or greater (alpha or cmd code)		;1d7a	fe 3a 	. : 
	ret nc				; yes - return Z=1 (for ':'), CY=0 (letter ot cmd code)			;1d7c	d0 	. 
; -- range (00..39) number, space or one of nonprintable characters 
	cp ' '				; is this <space>												;1d7d	fe 20 	.   
	jp z,NextToken	    ; yes - skip and test next char									;1d7f	ca 78 1d 	. x . 
; -- range (00..1f,21..39) chack above 0A - digit or other
	cp #0B				; is in range 0B..39 (can be digit or other non-alpha char)		;1d82	fe 0b 	. . 
	jr nc,.digits		; yes - check if digit and return								;1d84	30 05 	0 . 
; -- range (00..0A) check below 0B
	cp #09				; is in range 09..0A (can be TAB or CR)							;1d86	fe 09 	. . 
	jp nc,NextToken	    ; yes - skip and test next char									;1d88	d2 78 1d 	. x . 
.digits:
; -- char is in range (0B..39) 
	cp '0'				; CY=0 if char in range 30 to 39 (digit)						;1d8b	fe 30 	. 0 
	ccf					; invert Carry flag (CY=1)										;1d8d	3f 	? 
; -- set Z flag (instruction "inc r" doesnt change CY but sets Z if r==0)
	inc a				; preincrement a for test										;1d8e	3c 	< 
	dec a				; restore a and set Z flag if a == 0							;1d8f	3d 	= 
	ret					; ----------- End of Proc ------------------------------------ 	;1d90	c9 	. 


; *******************************************************************************
; BASIC RESTORE Entry Point
; Resets the DATA pointer (at DatareadPtr) to point to the start of the BASIC program, 
; so that the next time a BASIC READ statement is executed, the first DATA item 
; in the program will be read,
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdRESTORE:
	ex de,hl				; save hl 											;1d91	eb 	. 
	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 			;1d92	2a a4 78 	* . x 
	dec hl					; minus one - interpreter pointer					;1d95	2b 	+ 
l1d96h:
	ld (DataReadPtr),hl	; save as new READ pointer 						;1d96	22 ff 78 	" . x 
	ex de,hl				; restore hl									;1d99	eb 	. 
	ret						; ------------- End of Proc ------------------- ;1d9a	c9 	. 


; *********************************************************************************
; ROM BASIC check for BREAK or SHIFT-@ characters. 
; Calls routine at 0358 (note warning for this routine - see above), decrements the A 
; register, and takes appropriate action if either key is pressed (suspends program 
; execution on SHIFT-@ or sets certain BASIC pointers, displays BREAK message, 
; and goes to BASIC READY _ state on BREAK) - otherwise returns with keyboard 
; character minus one- in A.
sub_1d9bh:
	call KeysReadKeySaveDE	; read Key Pressed if any								;1d9b	cd 58 03 	. X . 
	or a					; is any key pressed?									;1d9e	b7 	. 
	ret z					; no -------------- End of Proc ----------------------- ;1d9f	c8 	. 
sub_1da0h:
; -- removed TRS code 
	block 5					; removed TRS code 										;1da0	00 00 00 00 00 	. 
; -- save key pressed
	ld (KEYS_LASTKEY),a		; store last key pressed								;1da5	32 99 78 	2 . x 
	dec a					; check if BREAK key was pressed (a=01)					;1da8	3d 	= 
	
; ************************************************************************************************************
; BASIC STOP Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdSTOP	
	ret nz					; no - return key char minus 1							;1da9	c0 	. 
; -- BREAK was pressed 
	inc a					; restore key code as BREAK (a=01)						;1daa	3c 	< 
	jp l1db4h				; skip code (probably TRS specific)						;1dab	c3 b4 1d 	. . . 


; ************************************************************************************************************
; BASIC END Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdEND
	ret nz			;1dae	c0 	. 
	push af			;1daf	f5 	. 
	call z,SysExtNew		;1db0	cc bb 79 	. . y 
	pop af			;1db3	f1 	. 
l1db4h:
	ld (BAS_TmpCharPtr),hl	; last byte of code executed in current line		;1db4	22 e6 78 	" . x 
	ld hl,BAS_StrVars		; address of BASIC String Variables Area				;1db7	21 b5 78 	! . x 
	ld (BAS_StrNextVar),hl	; set as next location in literal string pool	;1dba	22 b3 78 	" . x 
	ld hl,0fff6h		;1dbd	21 f6 ff 	! . . 
	pop bc			;1dc0	c1 	. 
l1dc1h:
	ld hl,(BasicLineNo)	; Current Basic Line Number 		;1dc1	2a a2 78 	* . x 
	push hl			;1dc4	e5 	. 
	push af			;1dc5	f5 	. 
	ld a,l			    ; low byte of Current Basic Line number ;1dc6	7d 	} 
	and h			    ; a = $ff (-1) only if Line number is $ffff (-1) ;1dc7	a4 	. 
	inc a			    ; a = 0 if line number is $ffff (-1) ;1dc8	3c 	< 
	jr z,l1dd4h		    ; jump if interractive mode ;1dc9	28 09 	( . 
	ld (BAS_LastLineNo),hl	; last line number executed before STOP or END			;1dcb	22 f5 78 	" . x 
	ld hl,(BAS_TmpCharPtr)	; last byte of code executed in current line		;1dce	2a e6 78 	* . x 
	ld (BAS_StopedPtr),hl	; set as address of Basic code executed before STOP 		;1dd1	22 f7 78 	" . x 
l1dd4h:
	call SwitchPrnToScr		; Flush Printer and change current Out Device to Screeen	;1dd4	cd 8b 03 	. . . 
	call SysNewLine		    ; move cursor to begin of next line                 ;1dd7	cd f9 20 	. .   
	pop af			        ;1dda	f1 	. 
	ld hl,TXT_BREAK		;1ddb	21 30 19 	! 0 . 
	jp nz,l1a06h		;1dde	c2 06 1a 	. . . 
	jp BAS_ReadyPopBC		; take address from CPU stack and goto Basic READY state	;1de1	c3 18 1a 	. . . 

; ***********************************************************************************************
; BASIC CONT Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdCONT
	ld hl,(BAS_StopedPtr)	; address of Basic code executed just before STOP 		;1de4	2a f7 78 	* . x 
	ld a,h			;1de7	7c 	| 
	or l			;1de8	b5 	. 
	ld e,#20				; ERROR 20 - CAN'T CONT		;1de9	1e 20 	.   
	jp z,ErrRaiseError		; Raise Error if hl == 0 ;1deb	ca a2 19 	. . . 
	ex de,hl			;1dee	eb 	. 
	ld hl,(BAS_LastLineNo)	; last line number executed before STOP or END			;1def	2a f5 78 	* . x 
	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;1df2	22 a2 78 	" . x 
	ex de,hl			;1df5	eb 	. 
	ret			;1df6	c9 	. 

; ***********************************************************************************************
; BASIC TRON Entry Point
; Enables the BASIC trace function by setting TraceFlag to non-zero.
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdTRON
	db $3e				; trick byte - along with next makes ld a,$af	; a - non-zero - Trace ON	;1df7	3e af 	> . 
	; ld a,$af 			; skips next "xor a" instruction

; ***********************************************************************************************
; BASIC TRON Entry Point
; Disables the BASIC trace function by setting TraceFlag to zero.
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdTROFF
	xor a				; a - 0 - Trace Off														;1df8	af 	> . 
	ld (TRACEFLAG),a	; clear TraceFlag - Trace cmdTrOff										;1df9	32 1b 79 	2 . y 
	ret					; --------------------- End of Proc -----------------------------------	;1dfc	c9 	. 


	pop af			;1dfd	f1 	. 
	pop hl			;1dfe	e1 	. 
	ret			;1dff	c9 	. 

; ********************************************************************************
; [TRS] BASIC DEFSTR Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdDEFSTR
	ld e,3			; e - Number Type Format (String)								;1e00	1e 03 	. . 
	db $01 			; trick byte - with next constructs irrevelant ld bc,$021e		;1e02	01 1e 02 	. . . 

; ********************************************************************************
; [TRS] BASIC DEFINT Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdDEFINT
	ld e,2			; e - Number Type Format (Integer)								;1e03	1e 02 	. . . ;
	db $01 			; trick byte - with next constructs irrevelant ld bc,l041eh		;1e05	01 1e 04 	. . . 

; ********************************************************************************
; [TRS] BASIC DEFSNG Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdDEFSNG
	ld e,4			; e - Number Type Format (Single)								;1e06	1e 04 	. . . 
	db $01 			; trick byte - with next constructs irrevelant ld bc,l081eh		;1e08	01 1e 08 	. . . 

; ********************************************************************************
; [TRS] BASIC DEFDBL Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdDEFDBL
	ld e,8			; e - Number Type Format (Double)								;1e09	1e 08 	. . . 

l1e0bh:
	call SysIsLetter		;1e0b	cd 3d 1e 	. = . 
	ld bc,ErrRaiseSyntax	; routine Raise 'SYNTAX ERROR'	;1e0e	01 97 19 	. . . 
	push bc			        ; put routine as return address on Stack ;1e11	c5 	. 
	ret c			        ; Raise 'SYNTAX ERROR';1e12	d8 	. 
	sub 041h		;1e13	d6 41 	. A 
	ld c,a			;1e15	4f 	O 
	ld b,a			;1e16	47 	G 
	rst $10			; move hl to next Basic token			;1e17	d7 	. 
	cp $ce		    ; is it Basic '-' token ;1e18	fe ce 	. . 
	jr nz,l1e25h	; no - 	;1e1a	20 09 	  . 
	rst $10			; move hl to next Basic token			;1e1c	d7 	. 
	call SysIsLetter		;1e1d	cd 3d 1e 	. = . 
	ret c			;1e20	d8 	. 
	sub 041h		;1e21	d6 41 	. A 
	ld b,a			;1e23	47 	G 
	rst $10			; move hl to next Basic token				;1e24	d7 	. 
l1e25h:
	ld a,b			;1e25	78 	x 
	sub c			;1e26	91 	. 
	ret c			;1e27	d8 	. 
	inc a			;1e28	3c 	< 
	ex (sp),hl			;1e29	e3 	. 
	ld hl,BAS_VarTypesTab	; address of Variable Declarations Table				;1e2a	21 01 79 	! . y 
	ld b,000h		;1e2d	06 00 	. . 
	add hl,bc			;1e2f	09 	. 
l1e30h:
	ld (hl),e			;1e30	73 	s 
	inc hl			;1e31	23 	# 
	dec a			;1e32	3d 	= 
	jr nz,l1e30h		;1e33	20 fb 	  . 
	pop hl			;1e35	e1 	. 
	ld a,(hl)			;1e36	7e 	~ 
	cp 02ch		;1e37	fe 2c 	. , 
	ret nz			;1e39	c0 	. 
	rst $10			; move hl to next Basic token					;1e3a	d7 	. 
	jr l1e0bh		;1e3b	18 ce 	. . 

; ********************************************************************************
; CHECK FOR UPPERCASE ALPHABETIC CHARACTER AT (HL)
; If the byte pointed to by the HL register pair contains the ASCII code
; for an uppercase letter of the alphabet (A-Z), the C flag will not be set, 
; otherwise the C flag will be set on return.
; IN: (hl) - char to test
; OUT: CY - 0 - char in range 'A'..'Z', 1 - char outside of range
SysIsLetter:
	ld a,(hl)			; a - char to test											;1e3d	7e 	~ 
	cp 'A'				; is less than 'A'											;1e3e	fe 41 	. A 
	ret c				; yes - return with CY=1									;1e40	d8 	. 
	cp '['				; set CY=1 if les than '[' => in range 'A'..'Z' 			;1e41	fe 5b 	. [ 
	ccf					; invert CY													;1e43	3f 	? 
	ret					; return with CY ------------------------------------------	;1e44	c9 	. 


sub_1e45h:
	rst $10			; move hl to next Basic token					;1e45	d7 	. 

; *********************************************************************************
; LOAD POSITIVE INTEGER EXPRESSION INTO DE
; Same as following routine (at 1E5A) except that HL may also point to any valid 
; BASIC variable or expression, which must evaluate to a number in range to 32767 
; decimal (used to get argument of BASIC CLEAR command). 
; NOTE that this routine assumes that BASIC is operational. Results may be unpredictable 
; if this is not the case, particularly if a BASIC variable name (or something 
; that could be interpreted as such) is part of the string.
; IN: hl - address of BASIC expression
; OUT: de - number converted
BAS_uiConvExpToDE:
	call EvalIntExpr	; load integer expression ito de register				;1e46	cd 02 2b 	. . + 
	ret p					; if result positive ---- End of Proc ----------------	;1e49	f0 	. 
ErrRaiseFuncCode:
	ld e,#08			; ERROR 08 - FUNCTION CODE	;1e4a	1e 08 	. . 
	jp ErrRaiseError	; Raise FUNCTION CODE Error	;1e4c	c3 a2 19 	. . . 




sub_1e4fh:
	ld a,(hl)			;1e4f	7e 	~ 
	cp '.'		        ;1e50	fe 2e 	. . 
	ex de,hl			;1e52	eb 	. 
	ld hl,(EditLineNo)	; Basic Line Number currently Edited	;1e53	2a ec 78 	* . x 
	ex de,hl			;1e56	eb 	. 
	jp z,NextToken		; yes - move hl to next Basic token ;1e57	ca 78 1d 	. x . 

; *********************************************************************************
; LOAD POSITIVE INTEGER CONSTANT IN DE
; Evaluate the string at the address pointed to by HL register pair for a positive 
; integer value (such as a BASIC line number), stopping at the first non-numeric character.
; The result is returned in DE register pair. A value of zero is returned if no numeric 
; value is found. Maximum allowable number is 65529 dec.
; NOTE: If this routine is being used to obtain a BASIC line number, it may be CALLed 
; at 1E4F. In this case, a period ($2e) character at (HL) will cause the routine
; to return with the "current" BASIC line number as stored at BAS_EditLineNo)
; IN:  hl - address of ASCII string of number to convert
; OUT: de - number converted
;      a - token byte (0 if end of Basic Statement)
;      flags - like from NextToken 
TextToInt:
	dec hl				; set parse address just before text to convert				;1e5a	2b 	+ 
TextToInt2:
	ld de,$0000		    ; reset result value to 0                                   ;1e5b	11 00 00 	. . . 
.loop:
	rst $10			    ; move hl to next Basic token - is it Digit ?				;1e5e	d7 	. 
	ret nc			    ; not digit - return result ------------------------------- ;1e5f	d0 	. 
; -- a contains digit from (hl) address
	push hl			    ; save hl - parse current address                           ;1e60	e5 	. 
	push af			    ; save a - digit                                            ;1e61	f5 	. 
; -- assert line number (after one more decimal digit added) won't become bigger than max
	ld hl,6552		    ; 65520 (max line number) divided by 10                     ;1e62	21 98 19 	! . . 
	rst #18			    ; is current result (de) bigger than 6552 ?                 ;1e65	df 	. 
	jp c,ErrRaiseSyntax	; yes - raise 'SYNTAX ERROR'	                            ;1e66	da 97 19 	. . . 
; -- converted value less than max - multiply it by 10
	ld h,d			                                                                ;1e69	62 	b 
	ld l,e				; hl - value to multiply									;1e6a	6b 	k 
	add hl,de			; hl = value * 2											;1e6b	19 	. 
	add hl,hl			; hl = value * 4											;1e6c	29 	) 
	add hl,de			; hl = value * 5											;1e6d	19 	. 
	add hl,hl			; hl - value * 10											;1e6e	29 	) 
; -- add digit from text
	pop af				; digit char ('0'..'9')										;1e6f	f1 	. 
	sub $30				; a = value in range 0..9									;1e70	d6 30 	. 0 
	ld e,a				; e - value to low byte 									;1e72	5f 	_ 
	ld d,0				; de - value as 16bit										;1e73	16 00 	. . 
	add hl,de			; hl - converted number										;1e75	19 	. 
	ex de,hl			; set as return value										;1e76	eb 	. 
	pop hl				; restore hl - current parser address						;1e77	e1 	. 
	jr .loop			; continue as long as digit is next char					;1e78	18 e4 	. . 


; **********************************************************************************************
; BASIC CLEAR Entry Point
; CLEAR [<I>]
; Erases all variables currently in memory. If present, I indicates the amount of space 
; to be allocated for the string heap; otherwise, the default is 50 or 200 bytes (depending on ROM version).
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit

CmdCLEAR
; -- if Z=1 
	jp z,BAS_ResetVars	; no <I> argument - erase all Basic Variables 			;1e7a	ca 61 1b 	. a . 
; -- <I> is given - read expression to de
	call BAS_uiConvExpToDE	; load positive integer expression into de register	;1e7d	cd 46 1e 	. F . 
	dec hl				;1e80	2b 	+ 
	rst $10				; move hl to next Basic token							;1e81	d7 	. 
	ret nz				; return if not End of statement ('\0' or ':')			;1e82	c0 	. 


; **********************************************************************************************
; CLEAR n
; Reserves a number of bytes of memory for string storage (resets the "start of string
; space" pointer at 78A0), then jumps to the ResetVars
; IN: de - number of bytes to reserve
	push hl			; save hl 													;1e83	e5 	. 
	ld hl,(MEMORY_TOP)	; address of top memory (as detected at boot)			;1e84	2a b1 78 	* . x 
; -- subtract de - number of bytes to reserve
	ld a,l				; a - low byte of address								;1e87	7d 	} 
	sub e				; subtract low byte of number							;1e88	93 	. 
	ld e,a				; save to e												;1e89	5f 	_ 
	ld a,h				; a - high byte of address								;1e8a	7c 	| 
	sbc a,d				; subtract high byte of number (and CY)					;1e8b	9a 	. 
	ld d,a				; de - new top memory address							;1e8c	57 	W 
; -- CY=1 if try to reserve more memory we have
	jp c,ErrRaiseOutOfMem	; if < 0 - Raise OUT OF MEMORY Error				;1e8d	da 7a 19 	. z . 
; -- check if it's above memory taken by existing Basic Program 
	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program					;1e90	2a f9 78 	* . x 
	ld bc,40			; 40 bytes reserved (variables??)						;1e93	01 28 00 	. ( . 
	add hl,bc			; hl - minimum memory already taken						;1e96	09 	. 
	rst #18				; is hl > de ? 											;1e97	df 	. 
	jp nc,ErrRaiseOutOfMem	; yes - Raise OUT OF MEMORY Error					;1e98	d2 7a 19 	. z . 
; -- de is valid
	ex de,hl			; hl - new top memory address							;1e9b	eb 	. 
	ld (STACKTOPPTR),hl	; set top of Basic Stack pointer						;1e9c	22 a0 78 	" . x 
	pop hl				; restore hl											;1e9f	e1 	. 
	jp BAS_ResetVars	; reset all Basic Variables	and Basic Program state 	;1ea0	c3 61 1b 	. a . 


; *************************************************************************************
; BASIC RUN Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdRUN
	jp z,ResetBasicPrg	; Reset Parse point, variables, arrays, strings, stack and error state		;1ea3	ca 5d 1b 	. ] . 
	call SysExtRunFile		;1ea6	cd c7 79 	. . y 
	call BAS_ResetVars	; reset all Basic Variables	and Basic Program state 	;1ea9	cd 61 1b 	. a . 
	ld bc,l1d1eh		;1eac	01 1e 1d 	. . . 
	jr l1ec1h		;1eaf	18 10 	. . 



; *************************************************************************************
; BASIC GOSUB Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdGOSUB
	ld c,003h		;1eb1	0e 03 	. . 
	call sub_1963h		;1eb3	cd 63 19 	. c . 
	pop bc			;1eb6	c1 	. 
	push hl			;1eb7	e5 	. 
	push hl			;1eb8	e5 	. 
	ld hl,(BasicLineNo)	; Current Basic Line Number 		;1eb9	2a a2 78 	* . x 
	ex (sp),hl			;1ebc	e3 	. 
	ld a,091h		;1ebd	3e 91 	> . 
	push af			;1ebf	f5 	. 
	inc sp			;1ec0	33 	3 
l1ec1h:
	push bc			;1ec1	c5 	. 




; ************************************************************************************
; BASIC GOTO Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdGOTO:
	call TextToInt	; de - convert following text into Line Number 			;1ec2	cd 5a 1e 	. Z . 
l1ec5h:
	call CmdDATA+2		;1ec5	cd 07 1f 	. . . 
	push hl			;1ec8	e5 	. 
	ld hl,(BasicLineNo)	; Current Basic Line Number 		;1ec9	2a a2 78 	* . x 
	rst #18			; Compare HL and DE ;1ecc	df 	. 
	pop hl			;1ecd	e1 	. 
	inc hl			;1ece	23 	# 
	call c,l1b2fh		;1ecf	dc 2f 1b 	. / . 
	call nc,FindBasicLine	; find Basic line with number in de						;1ed2	d4 2c 1b 	. , . 
	ld h,b			;1ed5	60 	` 
	ld l,c			;1ed6	69 	i 
	dec hl			;1ed7	2b 	+ 
	ret c			;1ed8	d8 	. 
ErrRaiseUndefStatement:
	ld e,#0e			; ERROR 0E - UNDEF'D STATEMENT	;1ed9	1e 0e 	. . 
	jp ErrRaiseError	; Raise UNDEF'D STATEMENT Error	;1edb	c3 a2 19 	. . . 



; ******************************************************************************************
; BASIC RETURN Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdRETURN
	ret nz			;1ede	c0 	. 
	ld d,0ffh		;1edf	16 ff 	. . 
	call sub_1936h		;1ee1	cd 36 19 	. 6 . 
	ld sp,hl			;1ee4	f9 	. 
	ld (BAS_StackPtr),hl		;1ee5	22 e8 78 	" . x 
	cp $91		    ; is it Basic 'GOSUB' token ;1ee8	fe 91 	. . 
	ld e,#04			; ERROR 04 - RET'N WITHOUT GOSUB	;1eea	1e 04 	. . 
	jp nz,ErrRaiseError	; Raise Error if 	;1eec	c2 a2 19 	. . . 
	pop hl			;1eef	e1 	. 
	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;1ef0	22 a2 78 	" . x 
	inc hl			;1ef3	23 	# 
	ld a,h			;1ef4	7c 	| 
	or l			;1ef5	b5 	. 
	jr nz,l1effh		;1ef6	20 07 	  . 
	ld a,(INPUTFLAG)	; Flag indicates whether inputing text.	;1ef8	3a dd 78 	: . x 
	or a			;1efb	b7 	. 
	jp nz,BAS_ReadyPopBC	; take address from CPU stack and goto Basic READY state		;1efc	c2 18 1a 	. . . 
l1effh:
	ld hl,l1d1eh		;1eff	21 1e 1d 	! . . 
	ex (sp),hl			;1f02	e3 	. 
	ld a,0e1h		;1f03	3e e1 	> . 


; ************************************************************************************************
; BASIC DATA Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdDATA:
	db $01,$3a			; c = 3a - trick bytes - with next constructs ld bc,$0e3a : nop				;1f05	01 3a 0e 00	. : . 
; ************************************************************************************************
; BASIC REM Entry Point
; BASIC ELSE Entry Point
; INCREMENT HL (IF NECESSARY) UNTIL (HL)=0
; Used by BASIC to advance the program pointer (HL register pair) to the end 
; of the BASIC line (to skip REM statements or ELSE clauses that are not executed).
; On entry, if HL points to a zero byte no action is taken, otherwise HL is 
; incremented until it does point to a zero byte.
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdREM
CmdELSE
	ld c,0			;1f07	0e 00 	. 
	ld b,0			;1f09	06 00 	. . 
l1f0bh:
	ld a,c			;1f0b	79 	y 
	ld c,b			;1f0c	48 	H 
	ld b,a			;1f0d	47 	G 
l1f0eh:
	ld a,(hl)			;1f0e	7e 	~ 
	or a			;1f0f	b7 	. 
	ret z			;1f10	c8 	. 
	cp b			;1f11	b8 	. 
	ret z			;1f12	c8 	. 
	inc hl			;1f13	23 	# 
	cp 022h		;1f14	fe 22 	. " 
	jr z,l1f0bh		;1f16	28 f3 	( . 
	sub 08fh		;1f18	d6 8f 	. . 
	jr nz,l1f0eh		;1f1a	20 f2 	  . 
	cp b			;1f1c	b8 	. 
	adc a,d			;1f1d	8a 	. 
	ld d,a			;1f1e	57 	W 
	jr l1f0eh		;1f1f	18 ed 	. . 



; ******************************************************************************************
; BASIC LET Entry Point
; Evaluate and assign expression to BASIC variable 
; IN: (hl) - first char variable name followed by BASIC '=' (D5) and expression
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdLET:
	call GetVarAddr	; locate or create Basic Variable						;1f21	cd 0d 26 	. . & 
; -- de - address of BASIC variable
	rst $08			; Assert next token is '=' ;1f24	cf 	. 
	db $d5			; Basic token '=' ;1f25	d5 	. 
	ex de,hl			;1f26	eb 	. 
	ld (BAS_NewVarPtr),hl	; set as current Variable address					;1f27	22 df 78 	" . x 
	ex de,hl			;1f2a	eb 	. 
	push de			; save de - variable address ;1f2b	d5 	. 
	rst #20			; test NTF (Number Type Format)	;1f2c	e7 	. 
	push af			; save af - Number Type Format ;1f2d	f5 	. 
	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;1f2e	cd 37 23 	. 7 # 
	pop af			; restore af - Number Type Format ;1f31	f1 	. 
	ex (sp),hl			;1f32	e3 	. 
l1f33h:
	add a,003h		;1f33	c6 03 	. . 
	call sub_2819h		;1f35	cd 19 28 	. . ( 
	call GetACCMSBPtr	; de - start of ACC bytes	;1f38	cd 03 0a 	. . . 
	push hl			;1f3b	e5 	. 
	jr nz,l1f66h		;1f3c	20 28 	  ( 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;1f3e	2a 21 79 	* ! y 
	push hl			;1f41	e5 	. 
	inc hl			;1f42	23 	# 
	ld e,(hl)			;1f43	5e 	^ 
	inc hl			;1f44	23 	# 
	ld d,(hl)			;1f45	56 	V 
	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;1f46	2a a4 78 	* . x 
sub_1f49h:
	rst #18			; Compare HL and DE ;1f49	df 	. 
	jr nc,$+16		;1f4a	30 0e 	0 . 
	ld hl,(STACKTOPPTR)	; top of Basic Stack Pointer	;1f4c	2a a0 78 	* . x 
	rst #18			; Compare HL and DE ;1f4f	df 	. 
	pop de			;1f50	d1 	. 
	jr nc,l1f62h		;1f51	30 0f 	0 . 
	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program						;1f53	2a f9 78 	* . x 
	rst #18			; Compare HL and DE ;1f56	df 	. 
	jr nc,l1f62h		;1f57	30 09 	0 . 
	ld a,0d1h		;1f59	3e d1 	> . 
	call sub_29f5h		;1f5b	cd f5 29 	. . ) 
	ex de,hl			;1f5e	eb 	. 
	call sub_2843h		;1f5f	cd 43 28 	. C ( 
l1f62h:
	call sub_29f5h		;1f62	cd f5 29 	. . ) 
	ex (sp),hl			;1f65	e3 	. 
l1f66h:
	call DEMemToHLMem	; copy math variable from (de) to (hl) mem			;1f66	cd d3 09 	. . . 
	pop de			;1f69	d1 	. 
	pop hl			;1f6a	e1 	. 
	ret			;1f6b	c9 	. 


; ****************************************************************************************
; [TRS] BASIC ON EntryPoint
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdON:
	cp 09eh		;1f6c	fe 9e 	. . 
	jr nz,l1f95h		;1f6e	20 25 	  % 
	rst $10			; move hl to next Basic token				;1f70	d7 	. 
	rst $08			; Assert next token is 'GOTO' ;1f71	cf 	. 
	defb $8d		; Basic 'GOTO' token	;1f72	8d 	. 
	call TextToInt	; de - convert following text into Line Number 			;1f73	cd 5a 1e 	. Z . 
	ld a,d			;1f76	7a 	z 
	or e			;1f77	b3 	. 
	jr z,l1f83h		;1f78	28 09 	( . 
	call sub_1b2ah		;1f7a	cd 2a 1b 	. * . 
	ld d,b			;1f7d	50 	P 
	ld e,c			;1f7e	59 	Y 
	pop hl			;1f7f	e1 	. 
	jp nc,ErrRaiseUndefStatement	; Raise UNDEF'D STATEMENT Error			;1f80	d2 d9 1e 	. . . 
l1f83h:
	ex de,hl			;1f83	eb 	. 
	ld (078f0h),hl		;1f84	22 f0 78 	" . x 
	ex de,hl			;1f87	eb 	. 
	ret c			;1f88	d8 	. 
	ld a,(ERRORFLAG)	; Error Status										;1f89	3a f2 78 	: . x 
	or a			    ; has any Error occurred ? 							;1f8c	b7 	. 
	ret z			    ; no - return ------------------------------------- ;1f8d	c8 	. 
	ld a,(LASTERRORNO)	; Last Error Number		                            ;1f8e	3a 9a 78 	: . x 
	ld e,a			    ; e - Error NUmber to Raise ;1f91	5f 	_ 
	jp l19abh		;1f92	c3 ab 19 	. . . 
l1f95h:
	call EvalByteExpr	; expression ACC, de and a - must be 8bit value	;1f95	cd 1c 2b 	. . + 
	ld a,(hl)			;1f98	7e 	~ 
	ld b,a			;1f99	47 	G 
	cp 091h		;1f9a	fe 91 	. . 
	jr z,l1fa1h		;1f9c	28 03 	( . 
	rst $08			; Assert next token is 'GOTO' ;1f9e	cf 	. 
	defb $8D		; Basic 'GOTO' token	;1f9f	8d 	. 
	dec hl			;1fa0	2b 	+ 
l1fa1h:
	ld c,e			;1fa1	4b 	K 
l1fa2h:
	dec c			;1fa2	0d 	. 
	ld a,b			;1fa3	78 	x 
	jp z,l1d60h		;1fa4	ca 60 1d 	. ` . 
	call TextToInt2	; de - number from text at (hl) 	;1fa7	cd 5b 1e 	. [ . 
	cp 02ch		;1faa	fe 2c 	. , 
	ret nz			;1fac	c0 	. 
	jr l1fa2h		;1fad	18 f3 	. . 


; ********************************************************************************************
; [TRS] BASIC RESUME Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdRESUME
	ld de,ERRORFLAG		; address of Error Status Flag 					;1faf	11 f2 78 	. . x 
	ld a,(de)			; Error Status									;1fb2	1a 	. 
	or a			    ; has any Error occurred ? 						;1fb3	b7 	. 
	jp z,ErrRaiseResumeWo	; no - Raise 'RESUME WITHOUT' Error	;1fb4	ca a0 19 	. . . 
	inc a		;1fb7	3c 	< 
	ld (LASTERRORNO),a	; set as Last Error Number 	;1fb8	32 9a 78 	2 . x 
	ld (de),a			; set Error Status flag to ERROR ;1fbb	12 	. 
	ld a,(hl)			;1fbc	7e 	~ 
	cp 087h		;1fbd	fe 87 	. . 
	jr z,l1fcdh		;1fbf	28 0c 	( . 
	call TextToInt	; de - int number from text at (hl) address 	;1fc1	cd 5a 1e 	. Z . 
	ret nz			;1fc4	c0 	. 
	ld a,d			;1fc5	7a 	z 
	or e			;1fc6	b3 	. 
	jp nz,l1ec5h		;1fc7	c2 c5 1e 	. . . 
	inc a			;1fca	3c 	< 
	jr l1fcfh		;1fcb	18 02 	. . 
l1fcdh:
	rst $10			; move hl to next Basic token					;1fcd	d7 	. 
	ret nz			; return if not End of Statement ('\0' or ':');1fce	c0 	. 
l1fcfh:
	ld hl,(ErrorTokenPtr)	; Pointer to Basic Token when error occurred	;1fcf	2a ee 78 	* . x 
	ex de,hl			;1fd2	eb 	. 
	ld hl,(ErrorLineNo)	; Basic Line Number with Error 		;1fd3	2a ea 78 	* . x 
	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;1fd6	22 a2 78 	" . x 
	ex de,hl			;1fd9	eb 	. 
	ret nz			;1fda	c0 	. 
	ld a,(hl)			;1fdb	7e 	~ 
	or a			;1fdc	b7 	. 
	jr nz,l1fe3h		;1fdd	20 04 	  . 
	inc hl			;1fdf	23 	# 
	inc hl			;1fe0	23 	# 
	inc hl			;1fe1	23 	# 
	inc hl			;1fe2	23 	# 
l1fe3h:
	inc hl			;1fe3	23 	# 
	ld a,d			;1fe4	7a 	z 
	and e			;1fe5	a3 	. 
	inc a			;1fe6	3c 	< 
	jp nz,CmdDATA		;1fe7	c2 05 1f 	. . . 
	ld a,(INPUTFLAG)	; Flag indicates whether inputing text.	;1fea	3a dd 78 	: . x 
	dec a			;1fed	3d 	= 
	jp z,01dbeh		;1fee	ca be 1d 	. . . 
	jp CmdDATA		;1ff1	c3 05 1f 	. . . 

; ********************************************************************************
; [TRS] BASIC ERROR Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdERROR
	call EvalByteExpr	; expression ACC, de and a - must be 8bit value	;1ff4	cd 1c 2b 	. . + 
	ret nz			;1ff7	c0 	. 
	or a			;1ff8	b7 	. 
	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error		;1ff9	ca 4a 1e 	. J . 
	dec a			;1ffc	3d 	= 
	add a,a			;1ffd	87 	. 
	ld e,a			;1ffe	5f 	_ 
	cp 02dh		;1fff	fe 2d 	. - 
	jr c,l2005h		;2001	38 02 	8 . 
	ld e,#26		; ERROR 26 - UNPRINTABLE		;2003	1e 26 	. & 
l2005h:
	jp ErrRaiseError	; Raise Error 	;2005	c3 a2 19 	. . . 



; *************************************************************************************************
; [TRS] BASIC AUTO Entry Point
; AUTO [<StartLine> [,<Increment>]]
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit

CmdAUTO
	ld de,0000ah		;2008	11 0a 00 	. . . 
	push de			;200b	d5 	. 
	jr z,l2025h		;200c	28 17 	( . 
	call sub_1e4fh		;200e	cd 4f 1e 	. O . 
	ex de,hl			;2011	eb 	. 
	ex (sp),hl			;2012	e3 	. 
	jr z,l2026h		;2013	28 11 	( . 
	ex de,hl			;2015	eb 	. 
	rst $08			; Assert next token is ',' ;2016	cf 	. 
	defb ','		; Basic ',' token	;2017	2c 	, 
	ex de,hl			;2018	eb 	. 
	ld hl,(AUTONUM_INC)	; increment value for AUTONUM line number		;2019	2a e4 78 	* . x 
	ex de,hl			;201c	eb 	. 
	jr z,l2025h		;201d	28 06 	( . 
	call TextToInt	; de - int number from text at (hl) address 	;201f	cd 5a 1e 	. Z . 
	jp nz,ErrRaiseSyntax	; if no numeric value Raise 'SYNTAX ERROR'	;2022	c2 97 19 	. . . 
l2025h:
	ex de,hl			;2025	eb 	. 
l2026h:
	ld a,h			;2026	7c 	| 
	or l			;2027	b5 	. 
	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2028	ca 4a 1e 	. J . 
	ld (AUTONUM_INC),hl		; set increment value for AUTONUM line number	;202b	22 e4 78 	" . x 
	ld (AUTONUM_ON),a		; Basic AUTO input flag [TRS]. ;202e	32 e1 78 	2 . x 
	pop hl			;2031	e1 	. 
	ld (AUTONUM_LINE),hl	; line number generated by AUTO			;2032	22 e2 78 	" . x 
	pop bc			;2035	c1 	. 
	jp l1a33h		;2036	c3 33 1a 	. 3 . 


; *****************************************************************************************
; BASIC IF Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdIF
	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;2039	cd 37 23 	. 7 # 
	ld a,(hl)			;203c	7e 	~ 
	cp ','		        ; is it ',' token  ? ;203d	fe 2c 	. , 
	call z,NextToken	; yes - Move hl to next Basic token	;203f	cc 78 1d 	. x . 
	cp $ca		        ; is it 'THEN' token ? ;2042	fe ca 	. . 
	call z,NextToken	; yes - Move hl to next Basic token	;2044	cc 78 1d 	. x . 
	dec hl			;2047	2b 	+ 
	push hl			;2048	e5 	. 
	call TestACCSign	; Check Sign of number in ACC (Any)		;2049	cd 94 09 	. . . 
	pop hl			;204c	e1 	. 
	jr z,l2056h		;204d	28 07 	( . 
l204fh:
	rst $10			; move hl to next Basic token					;204f	d7 	. 
	jp c,CmdGOTO	; jump if digit found ('0'..'9')	;2050	da c2 1e 	. . . 
	jp l1d5fh		;2053	c3 5f 1d 	. _ . 
l2056h:
	ld d,001h		;2056	16 01 	. . 
l2058h:
	call CmdDATA		;2058	cd 05 1f 	. . . 
	or a			;205b	b7 	. 
	ret z			;205c	c8 	. 
	rst $10			; move hl to next Basic token					;205d	d7 	. 
	cp $95		    ; is it Basic 'ELSE' token ;205e	fe 95 	. . 
	jr nz,l2058h	; no -	;2060	20 f6 	  . 
	dec d			;2062	15 	. 
	jr nz,l2058h		;2063	20 f3 	  . 
	jr l204fh		;2065	18 e8 	. . 


; ************************************************************************************
; BASIC LPRINT Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdLPRINT
	ld a,$01				; 1 - Printer Device 											;2067	3e 01 	> . 
	ld (SysCurOutDev),a		; set Printer as Current Out Device								;2069	32 9c 78 	2 . x 
	jp l209bh		;206c	c3 9b 20 	. .   


; ************************************************************************************
; BASIC PRINT Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdPRINT
	call SysExtPrint	; call external hook for PRINT							;206f	cd ca 79 	. . y 
	cp '@'		;2072	fe 40 	. @ 
	jr nz,l208fh		;2074	20 19 	  . 
	call sub_2b01h		;2076	cd 01 2b 	. . + 
	cp 002h		;2079	fe 02 	. . 
	jp nc,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;207b	d2 4a 1e 	. J . 
; --
	push hl				; save hl ;207e	e5 	. 
	ld hl,VRAM			; hl - address of Video RAM								;207f	21 00 70 	! . p 
	add hl,de			; add offset ;2082	19 	. 
	ld (CURSORADDR),hl	; set as new Cursor Address in VRAM 	;2083	22 20 78 	"   x 
	ld a,e				; a - low byte of offset ;2086	7b 	{ 
	and $1f		        ; trim it to range 0..31 - position in line (column)	;2087	e6 1f 	. . 
	ld (CURSORPOS),a	; set as position of Cursor in Edited line				;2089	32 a6 78 	2 . x 
	pop hl				; restore hl ;208c	e1 	. 
	rst $08				; Assert next token is ',' ;208d	cf 	. 
	defb ','			; Basic ',' token	;208e	2c 	, 
l208fh:
	cp '#'		    	; is it '#' char - redirect to Tape/File device 		;208f	fe 23 	. # 
	jr nz,l209bh		; no - print to screen 									;2091	20 08 	  . 
	call sub_3b58h		;2093	cd 58 3b 	. X ; 
	ld a,$80			; 80 -> Tape Device Flag 								;2096	3e 80 	> . 
	ld (SysCurOutDev),a	; set Tape as Current Out Device						;2098	32 9c 78 	2 . x 
l209bh:
	dec hl			;209b	2b 	+ 
	rst $10			; move hl to next Basic token					;209c	d7 	. 
	call z,PrintCR  ; print CR if End Of Statement found ('\0' or ':')		;209d	cc fe 20 	. .   
l20a0h:
	jp z,SysSetOutAsScreen		;20a0	ca 69 21 	. i ! 
	cp 0bfh		;20a3	fe bf 	. . 
	jp z,l2cbdh		;20a5	ca bd 2c 	. . , 
	cp 0bch		;20a8	fe bc 	. . 
	jp z,l2137h		;20aa	ca 37 21 	. 7 ! 
	push hl			;20ad	e5 	. 
	cp 02ch		;20ae	fe 2c 	. , 
	jp z,l2108h		;20b0	ca 08 21 	. . ! 
	cp 03bh		;20b3	fe 3b 	. ; 
	jp z,l3b0ch		;20b5	ca 0c 3b 	. . ; 
	pop bc			;20b8	c1 	. 
	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;20b9	cd 37 23 	. 7 # 
	push hl			;20bc	e5 	. 
	rst #20			; test NTF (Number Type Format) ;20bd	e7 	. 
	jr z,l20f2h		; String - just print it on screen ;20be	28 32 	( 2 
; -- numeric value
	call NumToStr	; Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)		;20c0	cd bd 0f 	. . . 
	call strACCfromCStr	; create Basic string in ACC from null terminated str (hl)		;20c3	cd 65 28 	. e ( 
	call SysExtPrintNum		;20c6	cd cd 79 	. . y 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;20c9	2a 21 79 	* ! y 
	ld a,(SysCurOutDev)	; current Output Device		;20cc	3a 9c 78 	: . x 
	or a				; what is Current Output Device?	;20cf	b7 	. 
	jp m,l20e9h		; Tape - ;20d0	fa e9 20 	. .   
	jr z,l20ddh		; Screen - ;20d3	28 08 	( . 
; -- Current Output Device is Printer
	ld a,(PRN_PosInLine)		;20d5	3a 9b 78 	: . x 
	add a,(hl)			;20d8	86 	. 
	cp 084h		;20d9	fe 84 	. . 
	jr l20e6h		;20db	18 09 	. . 
l20ddh:
	ld a,(SCR_LINEMAXLEN)		;20dd	3a 9d 78 	: . x 
	ld b,a			;20e0	47 	G 
	ld a,(CURSORPOS)	; position of Cursor in Edited line	;20e1	3a a6 78 	: . x 
	add a,(hl)			;20e4	86 	. 
	cp b			;20e5	b8 	. 
l20e6h:
	call nc,PrintCR	; Print CR char on screen ;20e6	d4 fe 20 	. .   
l20e9h:
	call PrintACCStr; print Basic String from ACC on screen		;20e9	cd aa 28 	. . ( 
	ld a,' '		;20ec	3e 20 	>   
	call PrintChar	; Print ' ' char on screen		;20ee	cd 2a 03 	. * . 
	or a			;20f1	b7 	. 
l20f2h:
	call z,PrintACCStr; print Basic String from ACC on screen				;20f2	cc aa 28 	. . ( 
	pop hl			;20f5	e1 	. 
	jp l209bh		;20f6	c3 9b 20 	. .   

; ***********************************************************************************
; Outputs a carriage return to video if cursor is not already at the beginning 
; of a line.
SysNewLine:
	call sub_3b1ch		;20f9	cd 1c 3b 	. . ; 
	or a			;20fc	b7 	. 
	ret z			;20fd	c8 	. 

; **********************************************************************************
; Output a carriage return ($Od) to a device determined by flag stored at (SysCurOutDev). 
; NOTE: This routine may be called at $20F9H, in which case it will not perform 
; the above action if the video display cursor is already positioned at the beginning 
; of a line, as determined by checking the contents of the cursor position flag at 78a6 
; (if zero, cursor is at start of line). This routine CALLs the routine at 032a 
; and also CALLs a Disk BASIC link at 79d0. See the warning for the routine at 032a
PrintCR:
	ld a,$d				; a - CR char												;20fe	3e 0d 	> . 
l2100h:
	call PrintChar	; Print CR char on screen						;2100	cd 2a 03 	. * . 
sub_2103h:
	call SysExtPrintCR			;2103	cd d0 79 	. . y 
	xor a				; clear return status (0)									;2106	af 	. 
	ret					; ------------ End of Proc -------------------------------- ;2107	c9 	. 
l2108h:
	call SysExtPrintTab		;2108	cd d3 79 	. . y 
	ld a,(SysCurOutDev)		;210b	3a 9c 78 	: . x 
	or a			;210e	b7 	. 
	jp p,l2119h		;210f	f2 19 21 	. . ! 
	ld a,','		;2112	3e 2c 	> , 
	call PrintChar	; Print ',' char on screen		;2114	cd 2a 03 	. * . 
	jr l2164h		;2117	18 4b 	. K 
l2119h:
	jr z,l2123h		;2119	28 08 	( . 
	ld a,(PRN_PosInLine)		;211b	3a 9b 78 	: . x 
	cp 070h		;211e	fe 70 	. p 
	jp l212bh		;2120	c3 2b 21 	. + ! 
l2123h:
	ld a,(SCR_PRINTZONES)		;2123	3a 9e 78 	: . x 
	ld b,a			;2126	47 	G 
	ld a,(07aaeh)		;2127	3a ae 7a 	: . z 
	cp b			;212a	b8 	. 
l212bh:
	call nc,PrintCR	; Print CR on screen 	;212b	d4 fe 20 	. .   
	jr nc,l2164h		;212e	30 34 	0 4 
l2130h:
	sub 010h		;2130	d6 10 	. . 
	jr nc,l2130h		;2132	30 fc 	0 . 
	cpl			;2134	2f 	/ 
	jr l215ah		;2135	18 23 	. # 
l2137h:
	call sub_2b1bh		;2137	cd 1b 2b 	. . + 
	and 03fh		;213a	e6 3f 	. ? 
	ld e,a			;213c	5f 	_ 
	rst $08			; Assert next token is ')' ;213d	cf 	. 
	defb ')'		; Basic ')' token	;213e	29 	) 

; TRS ???
; TAB function for video or printer (determined by flag at SysCurOutDev). 
; This routine does extensive string processing and may not be the most efficient 
; method of achieving the desired result, particularly if it is desired only to tab 
; over a number of spaces. Also, this routine CALLs several Disk BASIC links 
; which may have to be "plugged". 
; IN:  e - desired TAB position
;      (hl) - message to display (0 if no message)

	dec hl			;213f	2b 	+ 
	push hl			;2140	e5 	. 
	call SysExtPrintTab		;2141	cd d3 79 	. . y 
	ld a,(SysCurOutDev)	; a - Device Id 										;2144	3a 9c 78 	: . x 
	or a				; where to send data									;2147	b7 	. 
	jp m,ErrRaiseFuncCode	; raise FUNCTION CODE Error				; to Tape ;2148	fa 4a 1e 	. J . 
	jp z,l2153h			; to Screen ;214b	ca 53 21 	. S ! 
; -- to Printer
	ld a,(PRN_PosInLine)		;214e	3a 9b 78 	: . x 
	jr l2156h		;2151	18 03 	. . 
l2153h:
	ld a,(CURSORPOS)	; position of Cursor in Edited line	;2153	3a a6 78 	: . x 
l2156h:
	cpl			;2156	2f 	/ 
	add a,e			;2157	83 	. 
	jr nc,l2164h		;2158	30 0a 	0 . 
l215ah:
	inc a			;215a	3c 	< 
	ld b,a			;215b	47 	G 
	ld a,' '		;215c	3e 20 	>   
l215eh:
	call PrintChar	; Print ' ' char on screen		;215e	cd 2a 03 	. * . 
	dec b			;2161	05 	. 
	jr nz,l215eh		;2162	20 fa 	  . 
l2164h:
	pop hl			;2164	e1 	. 
	rst $10			; move hl to next Basic token					;2165	d7 	. 
	jp l20a0h		;2166	c3 a0 20 	. .   

; **********************************************************************************
; Reset device type flag at SysCurOutDev to zero (output to video display), also turns off 
; cassette drive if necessary. CALLs Disk BASIC link at SysExtPrintEnd prior to return. 
; See also routine at 038b
SysSetOutAsScreen:
; -- removed TRS code  to turn off Cassette Drive if needed
	ld a,(SysCurOutDev)	; Current Device Id										;2169	3a 9c 78 	: . x 
	block 4				; TRS removed code										;216c	00 	. 
; -- set Current Out Device as Screen
	xor a				; Device Id 0 (Screen)									;2170	af 	. 
	ld (SysCurOutDev),a	; set as Current Out Device								;2171	32 9c 78 	2 . x 
	call SysExtPrintEnd	; call DOS hook									;2174	cd be 79 	. . y 
	ret					; --------------- End of Proc ------------------------- ;2177	c9 	. 

TXT_REDO:
	db "?REDO",$0d,0	; ?REDO text					;2178	3f 52 45 44 4f 0d 00 	. 

l217fh:
	ld a,(BAS_ReadInSrc)	; [TRS] READ (non-zero) or INPUT (zero) 	;217f	3a de 78 	: . x 
	or a			;2182	b7 	. 
	jp nz,l1991h		;2183	c2 91 19 	. . . 
	ld a,(SysINPUTSrcFlag)	; a - input from tape Flag 							;2186	3a a9 78 	: . x 
	or a					; is from Tape? 									;2189	b7 	. 
	ld e,#2a				; ERROR 2A - BAD FILE DATA		;218a	1e 2a 	. * 
	jp z,ErrRaiseError		; yes - Raise Error  ;218c	ca a2 19 	. . . 
	pop bc			;218f	c1 	. 
	ld hl,TXT_REDO		;2190	21 78 21 	! x ! 
	call PrintBasicStr	; print "REDO?" text on Screen	;2193	cd a7 28 	. . ( 
	ld hl,(BAS_TmpCharPtr)	; last byte of code executed in current line		;2196	2a e6 78 	* . x 
	ret			;2199	c9 	. 


; ************************************************************************************************
; BASIC INPUT Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdINPUT
	call sub_2828h		;219a	cd 28 28 	. ( ( 
	ld a,(hl)			;219d	7e 	~ 
	call SysExtInput		;219e	cd d6 79 	. . y 
	sub '#'		;21a1	d6 23 	. # 
	ld (SysINPUTSrcFlag),a	; set as input from tape Flag (0-true, other-false)	;21a3	32 a9 78 	2 . x 
	ld a,(hl)			;21a6	7e 	~ 
	jr nz,l21c9h		;21a7	20 20 	    
	call sub_3b68h		;21a9	cd 68 3b 	. h ; 
	push hl			;21ac	e5 	. 
	ld b,0fah		;21ad	06 fa 	. . 
	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;21af	2a a7 78 	* . x 
l21b2h:
	call sub_3b88h		;21b2	cd 88 3b 	. . ; 
	ld (hl),a			;21b5	77 	w 
	inc hl			;21b6	23 	# 
	cp 00dh		;21b7	fe 0d 	. . 
	jr z,l21bdh		;21b9	28 02 	( . 
	djnz l21b2h		;21bb	10 f5 	. . 
l21bdh:
	dec hl			;21bd	2b 	+ 
	ld (hl),000h		;21be	36 00 	6 . 
	nop			;21c0	00 	. 
	nop			;21c1	00 	. 
	nop			;21c2	00 	. 
	ld hl,(LINEBUFPTR)	; address of Line Buffer 	;21c3	2a a7 78 	* . x 
	dec hl			;21c6	2b 	+ 
	jr l21ebh		;21c7	18 22 	. " 




; *********************************************************************************
; ROM BASIC "INPUT" routine. Print prompt string (if any) and get user input to variable. 
; On entry : HL points to quotation mark (start of prompt string) or first character 
; of variable name (if no prompt string) immediately following "INPUT" command. 
; On exit: HL points to zero byte if input was valid, else prints "? REDO" (if certain 
; flags are set properly) and requests more input. 
; Syntax must be legal for BASIC "INPUT" statement, for example:
; 	"Prompt String"; VARIABLE NAME <zero byte> or simply:
;	VARIABLE NAME <zero byte>
; Multiple variables may be INPUT with one statements VARIABLE NAME, VARIABLE NAME, 
; ... VARIABLE NAME <zero byte>
; A colon may be used in place of the zero byte. See also 21E3H, including information 
; on which flags must be set to assure that the "?REDO" message is printed in the event 
; of an input error, and how to determine if an error has occured. 
; NOTE: The routine that displays the prompt string (if any) may be CALLed separately at 21CDH. 
; This routine will return immediately if the HL register pair does not point to a quotation mark 
; (22H) on entry. Otherwise, the prompt string must be terminated with a quotation mark
; followed by a semicolon (3BH), or else a syntax error will result.
l21c9h:
	ld bc,l21dbh		;21c9	01 db 21 	. . ! 
	push bc			;21cc	c5 	. 
	cp '"'		;21cd	fe 22 	. " 
	ret nz			;21cf	c0 	. 
	call BAS_MakeStrVecHL	; create StringVector from text enclosed with '"'	;21d0	cd 66 28 	. f ( 
	rst $08			; Assert next token is ';' ;21d3	cf 	. 
	defb ';'		; Basic ';' token - end of statement	;21d4	3b 	; 
	push hl			;21d5	e5 	. 
	call PrintACCStr; print Basic String from ACC on screen				;21d6	cd aa 28 	. . ( 
	pop hl			;21d9	e1 	. 
	ret			;21da	c9 	. 
l21dbh:
	push hl			;21db	e5 	. 
	call BAS_Prompt	; print "? " and read text line from user	;21dc	cd b3 1b 	. . . 
	pop bc			;21df	c1 	. 
	jp c,01dbeh		;21e0	da be 1d 	. . . 


; **********************************************************************************************
; ASSIGN STRING (S) TO BASIC VARIABLE
; This routine is part of the BACIC INPUT command routine, and can be used to process input 
; obtained from CALLing one of the keyboard input routines at 1BB3, 0361, etc. 
; On entry, BC must point to the first character of a string that contains the variable name(s).
; If more than one variable name is used the names must be separated by commas, than a zero byte 
; or colon must be placed after the last variable name). HL must point to the byte just prior 
; to the beginning of the input string (this is where it is placed by the above-mentioned 
; input routines - note that this byte is altered by this routine), and the string may contain 
; input for more than one variable (items must be separated by commas). 
; String must be terminated with zero byte. On exit, the numbers or strings in the input 
; will be assigned to the variables listed in the string containing the variable names. 
; Numeric or string variables may be used, but only valid characters for numeric input may
; be used with numeric variables (depending on how certain flags are set, a "?REDO" message 
; or an error will occur if this rule is violated. To force the "?REDO" message, make sure 
; that memory location BAS_ReadInSrc contains zero, and that location TapeInputFlag contains a non-zero value. 
; To determine if the "?REDO" message has occured, prior to calling the routine load memory 
; locations BAS_TmpCharPtr with zero. If the HL register pair contains zero on exit, then an error
; has occured and the "?REDO" message has been printed). 
; NOTE.: For proper operation, the input string should be in the BASIC input buffer
; (as it will be if one of the input routines mentioned above is used) when this routine 
; is CALLed. 
	inc hl			;21e3	23 	# 
	ld a,(hl)			;21e4	7e 	~ 
	or a			;21e5	b7 	. 
	dec hl			;21e6	2b 	+ 
	push bc			;21e7	c5 	. 
	jp z,01f04h		;21e8	ca 04 1f 	. . . 
l21ebh:
	ld (hl),02ch		;21eb	36 2c 	6 , 
	jr $+7		;21ed	18 05 	. . 


; *****************************************************************************
; BASIC READ Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdREAD
	push hl			;21ef	e5 	. 
	ld hl,(DataReadPtr)	; pointer where to continue READ from DATA			;21f0	2a ff 78 	* . x 
	or 0afh		;21f3	f6 af 	. . 
	ld (BAS_ReadInSrc),a	; [TRS] READ (non-zero) or INPUT (zero) 		;21f5	32 de 78 	2 . x 
	ex (sp),hl			;21f8	e3 	. 
	jr l21fdh		;21f9	18 02 	. . 
l21fbh:
	rst $08			; Assert next token is ',' ;21fb	cf 	. 
	defb ','		; Basic ',' token	;21fc	2c 	, 
l21fdh:
	call GetVarAddr		; locate or create Basic Variable					;21fd	cd 0d 26 	. . & 
	ex (sp),hl			;2200	e3 	. 
	push de			;2201	d5 	. 
	ld a,(hl)			;2202	7e 	~ 
	cp 02ch		;2203	fe 2c 	. , 
	jr z,l222dh		;2205	28 26 	( & 
	ld a,(BAS_ReadInSrc)	; [TRS] READ (non-zero) or INPUT (zero) 		;2207	3a de 78 	: . x 
	or a			;220a	b7 	. 
	jp nz,l2296h		;220b	c2 96 22 	. . " 
	ld a,(SysINPUTSrcFlag)	; a - input from tape Flag 									;220e	3a a9 78 	: . x 
	or a					; is this from Tape? ;2211	b7 	. 
	ld e,#06			; ERROR 06 - OUT OF DATA ;2212	1e 06 	. . 
	jp z,ErrRaiseError	; yes - Raise Error 	;2214	ca a2 19 	. . . 
	ld a,'?'		;2217	3e 3f 	> ? 
	call PrintChar	; Print '?' char on screen		;2219	cd 2a 03 	. * . 
	call BAS_Prompt	; print "? " and read text line from user		;221c	cd b3 1b 	. . . 
	pop de			;221f	d1 	. 
	pop bc			;2220	c1 	. 
	jp c,01dbeh		;2221	da be 1d 	. . . 
	inc hl			;2224	23 	# 
	ld a,(hl)			;2225	7e 	~ 
	or a			;2226	b7 	. 
	dec hl			;2227	2b 	+ 
	push bc			;2228	c5 	. 
	jp z,01f04h		;2229	ca 04 1f 	. . . 
	push de			;222c	d5 	. 
l222dh:
	call SysExtReadData		;222d	cd dc 79 	. . y 
	rst #20			; test NTF (Number Type Format) ;2230	e7 	. 
	push af			; save af - Number Type Format	;2231	f5 	. 
	jr nz,l224dh	; Number (not String)	;2232	20 19 	  . 
; -- String
	rst $10			; move hl to next Basic token					;2234	d7 	. 
	ld d,a			;2235	57 	W 
	ld b,a			;2236	47 	G 
	cp '"'		    ; is it Basic '"' token - start/end of string ;2237	fe 22 	. " 
	jr z,l2240h		; tak - ;2239	28 05 	( . 
	ld d,':'		;223b	16 3a 	. : 
	ld b,','		;223d	06 2c 	. , 
	dec hl			;223f	2b 	+ 
l2240h:
	call BAS_MakeStrVecDelim	; create StringVector from text 		;2240	cd 69 28 	. i ( 
l2243h:
	pop af			;2243	f1 	. 
	ex de,hl			;2244	eb 	. 
	ld hl,l225ah		;2245	21 5a 22 	! Z " 
	ex (sp),hl			;2248	e3 	. 
	push de			;2249	d5 	. 
	jp l1f33h		;224a	c3 33 1f 	. 3 . 
l224dh:
	rst $10			; move hl to next Basic token					;224d	d7 	. 
	pop af			;224e	f1 	. 
	push af			;224f	f5 	. 
	ld bc,l2243h		;2250	01 43 22 	. C " 
	push bc			;2253	c5 	. 
	jp c,StrToNum	;  Convert from ASCII const (HL) to Any (ACC)	;2254	da 6c 0e 	. l . 
	jp nc,StrToDbl	; convert string (hl) to number (double)	;2257	d2 65 0e 	. e . 
l225ah:
	dec hl			;225a	2b 	+ 
	rst $10			; move hl to next Basic token					;225b	d7 	. 
	jr z,l2263h		; jump if End of Statement found ('\0' or ':') ;225c	28 05 	( . 
	cp ','		    ; is it Basic ',' token ;225e	fe 2c 	. , 
	jp nz,l217fh	; no -	;2260	c2 7f 21 	.  ! 
l2263h:
	ex (sp),hl			;2263	e3 	. 
	dec hl			;2264	2b 	+ 
	rst $10			; move hl to next Basic token					;2265	d7 	. 
	jp nz,l21fbh	; jump if no End of Statement found ('\0' or ':')	;2266	c2 fb 21 	. . ! 
	pop de			;2269	d1 	. 
	nop			;226a	00 	. 
	nop			;226b	00 	. 
	nop			;226c	00 	. 
	nop			;226d	00 	. 
	nop			;226e	00 	. 
	ld a,(BAS_PrintUsingDelim)	; delimiter for PRINT USING	;226f	3a de 78 	: . x 
	or a			;2272	b7 	. 
	ex de,hl			;2273	eb 	. 
	jp nz,l1d96h		;2274	c2 96 1d 	. . . 
	push de			;2277	d5 	. 
	call SysExtExtraTest		;2278	cd df 79 	. . y 
	or (hl)			;227b	b6 	. 
	ld hl,TXT_EXTRAIGNORED	;227c	21 86 22 	! . " 
	call nz,PrintBasicStr	; print "?EXTRA IGNORED" text on Screen	;227f	c4 a7 28 	. . ( 
	pop hl			;2282	e1 	. 
	jp SysSetOutAsScreen		;2283	c3 69 21 	. i ! 
TXT_EXTRAIGNORED:
	defb "?EXTRA IGNORED",$d,0			;2286	3f 45 58 54 52 41 20 49 47 4e 4f 52 45 44 0d 00 	. 

l2296h:
	call CmdDATA		;2296	cd 05 1f 	. . . 
	or a			;2299	b7 	. 
	jr nz,l22aeh		;229a	20 12 	  . 
	inc hl			;229c	23 	# 
	ld a,(hl)			;229d	7e 	~ 
	inc hl			;229e	23 	# 
	or (hl)			;229f	b6 	. 
	ld e,#06			; ERROR 06 - OUT OF DATA ;22a0	1e 06 	. . 
	jp z,ErrRaiseError	; Raise Error if 	;22a2	ca a2 19 	. . . 
	inc hl			;22a5	23 	# 
	ld e,(hl)			;22a6	5e 	^ 
	inc hl			;22a7	23 	# 
	ld d,(hl)			;22a8	56 	V 
	ex de,hl			;22a9	eb 	. 
	ld (DATALineNo),hl	; Basic Line No with DATA cmd	;22aa	22 da 78 	" . x 
	ex de,hl			;22ad	eb 	. 
l22aeh:
	rst $10			; move hl to next Basic token				;22ae	d7 	. 
	cp $88		    ; is it Basic 'DATA' token ;22af	fe 88 	. . 
	jr nz,l2296h	; no -	;22b1	20 e3 	  . 
	jp l222dh		;22b3	c3 2d 22 	. - " 



; ***************************************************************************************
; BASIC NEXT Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdNEXT
	ld de,$0000		;22b6	11 00 00 	. . . 
sub_22b9h:
	call nz,GetVarAddr	; locate or create Basic Variable						;22b9	c4 0d 26 	. . & 
	ld (BAS_NewVarPtr),hl	; set as current Variable								;22bc	22 df 78 	" . x 
	call sub_1936h		;22bf	cd 36 19 	. 6 . 
	jp nz,ErrRaiseNextWoFor	; Raise 'NEXT WITHOUT FOR' Error	;22c2	c2 9d 19 	. . . 
	ld sp,hl			;22c5	f9 	. 
	ld (BAS_StackPtr),hl		;22c6	22 e8 78 	" . x 
	push de			;22c9	d5 	. 
	ld a,(hl)			;22ca	7e 	~ 
	inc hl			;22cb	23 	# 
	push af			;22cc	f5 	. 
	push de			;22cd	d5 	. 
	ld a,(hl)			;22ce	7e 	~ 
	inc hl			;22cf	23 	# 
	or a			;22d0	b7 	. 
	jp m,l22eah		;22d1	fa ea 22 	. . " 
	call MAT_sCopyHLToACC_DBL		;22d4	cd b1 09 	. . . 
l22d7h:
	ex (sp),hl			;22d7	e3 	. 
	push hl			;22d8	e5 	. 
	call sngHLaddACC_DBL	; ACC = (HL) + ACC (Single)	;22d9	cd 0b 07 	. . . 
	pop hl			;22dc	e1 	. 
	call MAT_sCopyACCToHL		;22dd	cd cb 09 	. . . 
	pop hl			;22e0	e1 	. 
	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;22e1	cd c2 09 	. . . 
	push hl			;22e4	e5 	. 
	call MAT_sCmp_ACC_BCDE		;22e5	cd 0c 0a 	. . . 
	jr l2313h		;22e8	18 29 	. ) 
l22eah:
	inc hl			;22ea	23 	# 
	inc hl			;22eb	23 	# 
	inc hl			;22ec	23 	# 
	inc hl			;22ed	23 	# 
	ld c,(hl)			;22ee	4e 	N 
	inc hl			;22ef	23 	# 
	ld b,(hl)			;22f0	46 	F 
	inc hl			;22f1	23 	# 
	ex (sp),hl			;22f2	e3 	. 
	ld e,(hl)			;22f3	5e 	^ 
	inc hl			;22f4	23 	# 
	ld d,(hl)			;22f5	56 	V 
	push hl			;22f6	e5 	. 
	ld l,c			;22f7	69 	i 
	ld h,b			;22f8	60 	` 
	call MAT_iAdd_DEHL	;  ACC = DE + HL (Integer)	;22f9	cd d2 0b 	. . . 
	ld a,(MATH_NTF)		;22fc	3a af 78 	: . x 
	cp 4			; is this variable type Single ;22ff	fe 04 	. . 
	jp z,ErrRaiseOverflow	; Raise OVERFLOW Error		;2301	ca b2 07 	. . . 
	ex de,hl			;2304	eb 	. 
	pop hl			;2305	e1 	. 
	ld (hl),d			;2306	72 	r 
	dec hl			;2307	2b 	+ 
	ld (hl),e			;2308	73 	s 
	pop hl			;2309	e1 	. 
	push de			;230a	d5 	. 
	ld e,(hl)			;230b	5e 	^ 
	inc hl			;230c	23 	# 
	ld d,(hl)			;230d	56 	V 
	inc hl			;230e	23 	# 
	ex (sp),hl			;230f	e3 	. 
	call MAT_iCmp_HL_DE	; Compare HL and DE (Integer)	;2310	cd 39 0a 	. 9 . 
l2313h:
	pop hl			;2313	e1 	. 
	pop bc			;2314	c1 	. 
	sub b			;2315	90 	. 
	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;2316	cd c2 09 	. . . 
	jr z,l2324h		;2319	28 09 	( . 
	ex de,hl			;231b	eb 	. 
	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;231c	22 a2 78 	" . x 
	ld l,c			;231f	69 	i 
	ld h,b			;2320	60 	` 
	jp l1d1ah		;2321	c3 1a 1d 	. . . 
l2324h:
	ld sp,hl			;2324	f9 	. 
	ld (BAS_StackPtr),hl		;2325	22 e8 78 	" . x 
	ld hl,(PrgStart)	; hl - pointer to BASIC Program Start							;2328	2a df 78 	* . x 
	ld a,(hl)			;232b	7e 	~ 
	cp 02ch		;232c	fe 2c 	. , 
	jp nz,l1d1eh		;232e	c2 1e 1d 	. . . 
	rst $10			; move hl to next Basic token					;2331	d7 	. 
	call sub_22b9h		;2332	cd b9 22 	. . " 



; ***********************************************************************************
; EVALUATE PARENTHESIZED EXPRESSION AT (HL)
; Evaluate BASIC string expression (may include constants, BASIC variables, 
; BASIC functions, operators, etc.) and place result in ACC (also set NTF). 
; On entry, HL must point to a left parenthesis (which precedes the expression 
; to be evaluated) or a BASIC syntax error will result. 
; On exit, HL will point to the string delimiter - a right parenthesis. 
; IN: hl - expression enclosed with parenthesis
EvalParam:
	rst $08		; Assert next token is '('	;2335	cf 	. 
	db '('		; Basic '(' token ;2336	28 ( 

; ***********************************************************************************
; EVALUATE EXPRESSION AT (HL)
; Evaluate BASIC string expression (may include constants, BASIC variables, 
; BASIC functions, operators, etc.) and place result in ACC (also set NTF). 
; On entry, HL must point to first character of the string to be evaluated. 
; On exit, HL will point to the string delimiter, which must be an acceptable 
; BASIC expression terminator (such as a zero byte, a colon, a right parenthesis, etc.). 
; NOTE: This routine may be entered at 2335, in which case the HL register pair 
; MUST point to a left parenthesis (which precedes the expression to be evaluated) 
; or a BASIC syntax error will result.
EvalExpr:
	dec hl			;2337	2b
sub_2338h:
	ld d,000h		;2338	16 00 	. . 
l233ah:
	push de			;233a	d5 	. 
	ld c,001h		;233b	0e 01 	. . 
	call sub_1963h		;233d	cd 63 19 	. c . 
	call sub_249fh		;2340	cd 9f 24 	. . $ 
	ld (BAS_ExprTmpPtr),hl	; [TRS] expression parser current position		;2343	22 f3 78 	" . x 
l2346h:
	ld hl,(BAS_ExprTmpPtr)	; [TRS] expression parser current position		;2346	2a f3 78 	* . x 
l2349h:
	pop bc			;2349	c1 	. 
	ld a,(hl)			;234a	7e 	~ 
	ld d,000h		;234b	16 00 	. . 
l234dh:
	sub 0d4h		;234d	d6 d4 	. . 
	jr c,l2364h		;234f	38 13 	8 . 
	cp 003h		;2351	fe 03 	. . 
	jr nc,l2364h		;2353	30 0f 	0 . 
	cp 001h		;2355	fe 01 	. . 
	rla			;2357	17 	. 
	xor d			;2358	aa 	. 
	cp d			;2359	ba 	. 
	ld d,a			;235a	57 	W 
	jp c,ErrRaiseSyntax	; Raise 'SYNTAX ERROR'	;235b	da 97 19 	. . . 
	ld (BAS_TempPtr),hl	; temporary pointer	;235e	22 d8 78 	" . x 
	rst $10			; move hl to next Basic token				;2361	d7 	. 
	jr l234dh		;2362	18 e9 	. . 
l2364h:
	ld a,d			;2364	7a 	z 
	or a			;2365	b7 	. 
	jp nz,l23ech		;2366	c2 ec 23 	. . # 
	ld a,(hl)			;2369	7e 	~ 
	ld (BAS_TempPtr),hl	; temporary pointer	;236a	22 d8 78 	" . x 
	sub 0cdh		;236d	d6 cd 	. . 
	ret c			;236f	d8 	. 
	cp 007h		;2370	fe 07 	. . 
	ret nc			;2372	d0 	. 
	ld e,a			;2373	5f 	_ 
	ld a,(MATH_NTF)		;2374	3a af 78 	: . x 
	sub 003h		;2377	d6 03 	. . 
	or e			;2379	b3 	. 
	jp z,l298fh		;237a	ca 8f 29 	. . ) 
	ld hl,l189ah		;237d	21 9a 18 	! . . 
	add hl,de			;2380	19 	. 
	ld a,b			;2381	78 	x 
	ld d,(hl)			;2382	56 	V 
	cp d			;2383	ba 	. 
	ret nc			;2384	d0 	. 
	push bc			;2385	c5 	. 
	ld bc,l2346h		;2386	01 46 23 	. F # 
	push bc			;2389	c5 	. 
	ld a,d			;238a	7a 	z 
	cp 07fh		;238b	fe 7f 	.  
	jp z,l23d4h		;238d	ca d4 23 	. . # 
	cp 051h		;2390	fe 51 	. Q 
	jp c,l23e1h		;2392	da e1 23 	. . # 
l2395h:
	ld hl,ACC_SNG	 ; Int,Single,String (2 or 4 bytes): 	;2395	21 21 79 	! ! y 
	or a			;2398	b7 	. 
	ld a,(MATH_NTF)		;2399	3a af 78 	: . x 
	dec a			;239c	3d 	= 
	dec a			;239d	3d 	= 
	dec a			;239e	3d 	= 
	jp z,ErrRaiseTypeMismatch	; Raise TYPE MISMATCH Error						;239f	ca f6 0a 	. . . 
	ld c,(hl)			;23a2	4e 	N 
	inc hl			;23a3	23 	# 
	ld b,(hl)			;23a4	46 	F 
	push bc			;23a5	c5 	. 
	jp m,l23c5h		;23a6	fa c5 23 	. . # 
	inc hl			;23a9	23 	# 
	ld c,(hl)			;23aa	4e 	N 
	inc hl			;23ab	23 	# 
	ld b,(hl)			;23ac	46 	F 
	push bc			;23ad	c5 	. 
	push af			;23ae	f5 	. 
	or a			;23af	b7 	. 
	jp po,023c4h		;23b0	e2 c4 23 	. . # 
	pop af			;23b3	f1 	. 
	inc hl			;23b4	23 	# 
	jr c,l23bah		;23b5	38 03 	8 . 
	ld hl,ACC_DBL		; addres of Accumulator ;23b7	21 1d 79 	! . y 
l23bah:
	ld c,(hl)			;23ba	4e 	N 
	inc hl			;23bb	23 	# 
	ld b,(hl)			;23bc	46 	F 
	inc hl			;23bd	23 	# 
	push bc			;23be	c5 	. 
	ld c,(hl)			;23bf	4e 	N 
	inc hl			;23c0	23 	# 
	ld b,(hl)			;23c1	46 	F 
	push bc			;23c2	c5 	. 
	ld b,0f1h		;23c3	06 f1 	. . 
l23c5h:
	add a,003h		;23c5	c6 03 	. . 
	ld c,e			;23c7	4b 	K 
	ld b,a			;23c8	47 	G 
	push bc			;23c9	c5 	. 
	ld bc,l2406h		;23ca	01 06 24 	. . $ 
l23cdh:
	push bc			;23cd	c5 	. 
	ld hl,(BAS_TempPtr)	; temporary pointer	;23ce	2a d8 78 	* . x 
	jp l233ah		;23d1	c3 3a 23 	. : # 
l23d4h:
	call FuncCSNG		; convert ACC to Single value	;23d4	cd b1 0a 	. . . 
	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;23d7	cd a4 09 	. . . 
	ld bc,STACKPowACC_DBL		; routine -  ACC = STACK ^ ACC (Any -> Single);23da	01 f2 13 	. . . 
	ld d,07fh		;23dd	16 7f 	.  
	jr l23cdh		;23df	18 ec 	. . 
l23e1h:
	push de			;23e1	d5 	. 
	call FuncCINT	; convert ACC to integer		;23e2	cd 7f 0a 	.  . 
	pop de			;23e5	d1 	. 
	push hl			;23e6	e5 	. 
	ld bc,l25e9h		;23e7	01 e9 25 	. . % 
	jr l23cdh		;23ea	18 e1 	. . 
l23ech:
	ld a,b			;23ec	78 	x 
	cp 064h		;23ed	fe 64 	. d 
	ret nc			;23ef	d0 	. 
	push bc			;23f0	c5 	. 
	push de			;23f1	d5 	. 
	ld de,06404h		;23f2	11 04 64 	. . d 
	ld hl,l25b8h		;23f5	21 b8 25 	! . % 
	push hl			;23f8	e5 	. 
	rst #20			; test NTF (Number Type Format) ;23f9	e7 	. 
	jp nz,l2395h	; Number (not String) -	;23fa	c2 95 23 	. . # 
; -- String
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;23fd	2a 21 79 	* ! y 
	push hl			;2400	e5 	. 
	ld bc,CmpStrACC_DBL	; Compare 2 strings (ACC) == (STACK)	;2401	01 8c 25 	. . % 
	jr l23cdh		;2404	18 c7 	. . 
l2406h:
	pop bc			;2406	c1 	. 
	ld a,c			;2407	79 	y 
	ld (078b0h),a		;2408	32 b0 78 	2 . x 
	ld a,b			;240b	78 	x 
	cp 008h		;240c	fe 08 	. . 
	jr z,l2438h		;240e	28 28 	( ( 
	ld a,(MATH_NTF)		;2410	3a af 78 	: . x 
	cp 8		; is this variable type Double ;2413	fe 08 	. . 
	jp z,l2460h		;2415	ca 60 24 	. ` $ 
	ld d,a			;2418	57 	W 
	ld a,b			;2419	78 	x 
	cp 004h		;241a	fe 04 	. . 
	jp z,l2472h		;241c	ca 72 24 	. r $ 
	ld a,d			;241f	7a 	z 
	cp 003h		;2420	fe 03 	. . 
	jp z,ErrRaiseTypeMismatch	; Raise TYPE MISMATCH Error						;2422	ca f6 0a 	. . . 
	jp nc,l247ch		;2425	d2 7c 24 	. | $ 
	ld hl,l18bfh		;2428	21 bf 18 	! . . 
	ld b,000h		;242b	06 00 	. . 
	add hl,bc			;242d	09 	. 
	add hl,bc			;242e	09 	. 
	ld c,(hl)			;242f	4e 	N 
	inc hl			;2430	23 	# 
	ld b,(hl)			;2431	46 	F 
	pop de			;2432	d1 	. 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2433	2a 21 79 	* ! y 
	push bc			;2436	c5 	. 
	ret			;2437	c9 	. 
l2438h:
	call FuncCDBL			; convert ACC to Double value	;2438	cd db 0a 	. . . 
	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;243b	cd fc 09 	. . . 
	pop hl			;243e	e1 	. 
	ld (ACC_DBL+2),hl		; addres of Accumulator (Double) + 2;243f	22 1f 79 	" . y 
	pop hl			;2442	e1 	. 
	ld (ACC_DBL),hl		; addres of Accumulator (Double) ;2443	22 1d 79 	" . y 
l2446h:
	pop bc			;2446	c1 	. 
	pop de			;2447	d1 	. 
	call BCDEToACC_DBL	; copy value from BCDE to ACC (Single)		;2448	cd b4 09 	. . . 
l244bh:
	call FuncCDBL		; convert ACC to Double value	;244b	cd db 0a 	. . . 
	ld hl,l18abh		;244e	21 ab 18 	! . . 
l2451h:
	ld a,(078b0h)		;2451	3a b0 78 	: . x 
	rlca			;2454	07 	. 
	push bc			;2455	c5 	. 
	ld c,a			;2456	4f 	O 
	ld b,000h		;2457	06 00 	. . 
	add hl,bc			;2459	09 	. 
	pop bc			;245a	c1 	. 
	ld a,(hl)			;245b	7e 	~ 
	inc hl			;245c	23 	# 
	ld h,(hl)			;245d	66 	f 
	ld l,a			;245e	6f 	o 
	jp (hl)			;245f	e9 	. 
l2460h:
	push bc			;2460	c5 	. 
	call anyACCcopyToACC2	; Copy value from ACC to ACC2 (Any)	;2461	cd fc 09 	. . . 
	pop af			;2464	f1 	. 
	ld (MATH_NTF),a		;2465	32 af 78 	2 . x 
	cp 4		; is this variable type Single	;2468	fe 04 	. . 
	jr z,l2446h		;246a	28 da 	( . 
	pop hl			;246c	e1 	. 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;246d	22 21 79 	" ! y 
	jr l244bh		;2470	18 d9 	. . 
l2472h:
	call FuncCSNG		; convert ACC to Single value	;2472	cd b1 0a 	. . . 
	pop bc			;2475	c1 	. 
	pop de			;2476	d1 	. 
l2477h:
	ld hl,l18b5h		;2477	21 b5 18 	! . . 
	jr l2451h		;247a	18 d5 	. . 
l247ch:
	pop hl			;247c	e1 	. 
	call sngACCcopyToSPUSH		; Push value from ACC on Stack (Single)	;247d	cd a4 09 	. . . 
	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;2480	cd cf 0a 	. . . 
	call ACCToBCDE	; Copy value from ACC to BCDE (Single)		;2483	cd bf 09 	. . . 
	pop hl			;2486	e1 	. 
	ld (ACC_SNG+2),hl	 ; Int,Single,String (2 or 4 bytes): 	;2487	22 23 79 	" # y 
	pop hl			;248a	e1 	. 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;248b	22 21 79 	" ! y 
	jr l2477h		;248e	18 e7 	. . 


// ***********************************************************************
; Math : ACC = DE / HL (Integer)
MAT_iDiv_DEHL
	push hl			;2490	e5 	. 
	ex de,hl			;2491	eb 	. 
	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;2492	cd cf 0a 	. . . 
	pop hl			;2495	e1 	. 
	call sngACCcopyToSPUSH	; Push value from ACC on Stack (Single)		;2496	cd a4 09 	. . . 
	call MAT_iConvToSngHL	; Convert from Integer (HL) to Single (ACC)		;2499	cd cf 0a 	. . . 
	jp MAT_sDiv_STACK_ACC_DBL		;249c	c3 a0 08 	. . . 


sub_249fh:
	rst $10			    ; move hl to next Basic token					;249f	d7 	. 
	ld e,#28			; ERROR 28 - MISSING OPERAND 		;24a0	1e 28 	. ( 
	jp z,ErrRaiseError	; Raise Error if End of Statement found ('\0' or ':')	;24a2	ca a2 19 	. . . 
	jp c,StrToNum		; digit found -  Convert from ASCII const (HL) to Any (ACC) ;24a5	da 6c 0e 	. l . 
	call SysIsLetter	; is this letter A..Z? (variable name instead of value) 	;24a8	cd 3d 1e 	. = . 
	jp nc,BAS_VarToAcc	; yes - locate or create variable and load into ACC	;24ab	d2 40 25 	. @ % 
	cp 0cdh		;24ae	fe cd 	. . 
	jr z,sub_249fh		;24b0	28 ed 	( . 
	cp 02eh		;24b2	fe 2e 	. . 
	jp z,StrToNum		; yes - Convert from ASCII const (HL) to Any (ACC);24b4	ca 6c 0e 	. l . 
	cp 0ceh		;24b7	fe ce 	. . 
	jp z,l2532h		;24b9	ca 32 25 	. 2 % 
l24bch:
	cp '"'		;24bc	fe 22 	. " 
	jp z,BAS_MakeStrVecHL	; create StringVector from text enclosed with '"'		;24be	ca 66 28 	. f ( 
	cp 0cbh		;24c1	fe cb 	. . 
	jp z,l25c4h		;24c3	ca c4 25 	. . % 
	cp 026h		;24c6	fe 26 	. & 
	jp z,SysDosAND		;24c8	ca 94 79 	. . y 
	cp 0c3h		;24cb	fe c3 	. . 
	jr nz,l24d9h		;24cd	20 0a 	  . 
	rst $10			    ; move hl to next Basic token				;24cf	d7 	. 
	ld a,(LASTERRORNO)	; Last Error Number occurred		;24d0	3a 9a 78 	: . x 
	push hl			;24d3	e5 	. 
	call ByteToAcc	; Copy a to ACC		;24d4	cd f8 27 	. . ' 
	pop hl			;24d7	e1 	. 
	ret			;24d8	c9 	. 
l24d9h:
	cp 0c2h		;24d9	fe c2 	. . 
	jr nz,l24e7h		;24db	20 0a 	  . 
	rst $10			; move hl to next Basic token				;24dd	d7 	. 
	push hl			;24de	e5 	. 
	ld hl,(ErrorLineNo)	; Basic Line Number with Error 		;24df	2a ea 78 	* . x 
	call sub_0c66h		;24e2	cd 66 0c 	. f . 
	pop hl			;24e5	e1 	. 
	ret			;24e6	c9 	. 
l24e7h:
	cp 0c0h		;24e7	fe c0 	. . 
	jr nz,l24ffh		;24e9	20 14 	  . 
	rst $10			; move hl to next Basic token				;24eb	d7 	. 
	rst $08			; Assert next token is '(' ;24ec	cf 	. 
	defb '('		; Basic '(' token ;24ed	28 ( . 
	call $260d			;24ee	cd 0d 26	. 
	rst $08		    ; Assert next token is ')' ;24f1	cf 	. 
	defb ')'		; Basic ')' token 	;24f2	29 	) 
	push hl			;24f3	e5 	. 
	ex de,hl			;24f4	eb 	. 
	ld a,h			;24f5	7c 	| 
	or l			;24f6	b5 	. 
	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;24f7	ca 4a 1e 	. J . 
	call ACCfromHLValue	; copy value from hl to ACC as integer number		;24fa	cd 9a 0a 	. . . 
	pop hl			;24fd	e1 	. 
	ret			;24fe	c9 	. 
l24ffh:
	cp 0c1h		;24ff	fe c1 	. . 
	jp z,l27feh		;2501	ca fe 27 	. . ' 
	cp 0c5h		;2504	fe c5 	. . 
	jp z,SysDosINSTR		;2506	ca 9d 79 	. . y 
	cp 0c8h		;2509	fe c8 	. . 
	jp z,l27c9h		;250b	ca c9 27 	. . ' 
	cp 0c7h		;250e	fe c7 	. . 
	jp z,SysDosTIMES		;2510	ca 76 79 	. v y 
	cp 0c6h		;2513	fe c6 	. . 
	jp z,l0132h		;2515	ca 32 01 	. 2 . 
	cp 0c9h		;2518	fe c9 	. . 
	jp z,0019dh		;251a	ca 9d 01 	. . . 
	cp 0c4h		;251d	fe c4 	. . 
	jp z,l2a2fh		;251f	ca 2f 2a 	. / * 
	cp 0beh		;2522	fe be 	. . 
	jp z,SysDosFN		;2524	ca 55 79 	. U y 
	sub 0d7h		;2527	d6 d7 	. . 
	jp nc,l254eh		;2529	d2 4e 25 	. N % 

; *************************************************************************************
; EVALUATE PARENTHESIZED EXPRESSION
; Evaluate any valid BASIC expression enclosed in parenthesis. A BASIC syntax error will 
; result if expression is not terminated with a right parenthesis
EvalSubExpression:
	call EvalParam	; assert 1st char is '(' and evaluate expression into ACC	;252c	cd 35 23 	. 5 # 
	rst $08			; Assert next token is ')' 									;252f	cf 	. 
	db ')'			; Basic ')' token 											;2530	29 	) 
	ret				; -------------------- End of Proc ------------------------	;2531	c9 	. 


l2532h:
	ld d,07dh		;2532	16 7d 	. } 
	call l233ah		;2534	cd 3a 23 	. : # 
	ld hl,(BAS_ExprTmpPtr)	; [TRS] expression parser current position		;2537	2a f3 78 	* . x 
	push hl			;253a	e5 	. 
	call l097bh		;253b	cd 7b 09 	. { . 
l253eh:
	pop hl			;253e	e1 	. 
	ret			;253f	c9 	. 

; ***************************************************************************************
; LOAD ACC WITH VALUE OF BASIC VARIABLE
; Get value of BASIC variable and put in ACCOM (also put precision of variable in NTF). 
; IN: hl - points to first character of variable name. 
; OUT: hl - point to first character following variable name.
BAS_VarToAcc:
	call GetVarAddr	; locate or create Basic Variable						;2540	cd 0d 26 	. . & 
l2543h:
	push hl			;2543	e5 	. 
	ex de,hl			;2544	eb 	. 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;2545	22 21 79 	" ! y 
	rst #20			; test NTF (Number Type Format) ;2548	e7 	. 
	call nz,HLMemToACC_DBL	; Number (not String) - Copy value from (HL) to ACC (Any)	;2549	c4 f7 09 	. . . 
	pop hl			;254c	e1 	. 
	ret			;254d	c9 	. 
l254eh:
	ld b,000h		;254e	06 00 	. . 
	rlca			;2550	07 	. 
	ld c,a			;2551	4f 	O 
	push bc			;2552	c5 	. 
	rst $10			; move hl to next Basic token				;2553	d7 	. 
	ld a,c			;2554	79 	y 
	cp 041h		;2555	fe 41 	. A 
	jr c,l256fh		;2557	38 16 	8 . 
	call EvalParam	; assert 1st char is '(' and evaluate expression 		;2559	cd 35 23 	. 5 # 
	rst $08				; Assert next token is ',' 								;255c	cf 	. 
	defb ','			; Basic ',' token 										;255d	2c 	, 
	call AssertACCIsString	; Assert ACC contains String						;255e	cd f4 0a 	. . . 
	ex de,hl			;2561	eb 	. 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2562	2a 21 79 	* ! y 
	ex (sp),hl			;2565	e3 	. 
	push hl			;2566	e5 	. 
	ex de,hl			;2567	eb 	. 
	call EvalByteExpr	; expression ACC, de and a - must be 8bit value	;2568	cd 1c 2b 	. . + 
	ex de,hl			;256b	eb 	. 
	ex (sp),hl			;256c	e3 	. 
	jr l2583h		;256d	18 14 	. . 
l256fh:
	call EvalSubExpression	; evaluate expression (starts with '(' and ends with ')'	;256f	cd 2c 25 	. , % 
	ex (sp),hl			;2572	e3 	. 
	ld a,l			;2573	7d 	} 
	cp 00ch		;2574	fe 0c 	. . 
	jr c,l257fh		;2576	38 07 	8 . 
	cp 01bh		;2578	fe 1b 	. . 
	push hl			;257a	e5 	. 
	call c,FuncCSNG		; convert ACC to Single value	;257b	dc b1 0a 	. . . 
	pop hl			;257e	e1 	. 
l257fh:
	ld de,l253eh		;257f	11 3e 25 	. > % 
	push de			;2582	d5 	. 
l2583h:
	ld bc,BasicFuncPointers		;2583	01 08 16 	. . . 

; IN: hl - base jump table 
;     bc - offset for address entry
SysJmpHLPlusBC:
	add hl,bc		; add offset to base address of table				;2586	09 	. 
	ld c,(hl)		; c - LSB of destination jump address				;2587	4e 	N 
	inc hl			; point to MSB of destination jump address			;2588	23 	# 
	ld h,(hl)		; h - MSB of destination jump address				;2589	66 	f 
	ld l,c			; hl - destination jump address						;258a	69 	i 
	jp (hl)			; jump to address taken from table					;258b	e9 	. 


; ********************************************************************************************
; Compare 2 strings (ACC) == (STACK)
; IN: STACK: <ret addr> <varptr(String1)>
;     ACC: varptr(String2)
; OUT: a,f - compare result (-1, 0, 1)
CmpStrACC_DBL:
	call sub_29d7h		;258c	cd d7 29 	. . ) 
; -- hl points to StringVector structure (1 byte length + 2 bytes address of text)
	ld a,(hl)		; a - length of 1st string 	;258f	7e 	~ 
	inc hl			; address of String text member ;2590	23 	# 
	ld c,(hl)		; low byte of address of text		;2591	4e 	N 
	inc hl			; points to high byte of address ;2592	23 	# 
	ld b,(hl)		; bc - address of text 		;2593	46 	F 
	pop de			;2594	d1 	. 
	push bc			; save text address ;2595	c5 	. 
	push af			; save text length ;2596	f5 	. 
	call sub_29deh		;2597	cd de 29 	. . ) 
	pop de			; d - length of 1st string ;259a	d1 	. 
; -- hl points to StringVector structure (1 byte length + 2 bytes address of text)
	ld e,(hl)		; e - length of 2nd string 	;259b	5e 	^ 
	inc hl			; address of String text member;259c	23 	# 
	ld c,(hl)		; low byte of address of text	;259d	4e 	N 
	inc hl			; points to high byte of address ;259e	23 	# 
	ld b,(hl)		; bc - address of text 	;259f	46 	F 
	pop hl			; hl - text address for 1st string ;25a0	e1 	. 



; ********************************************************************************************
; Compare 2 strings in memory (hl) == (bc)
; IN: hl - String1
;	  d - String1 length 
;     bc - String2
;     e - String2 length
; OUT: a,f - compare result (-1, 0, 1)
.compareNext:
; -- check if all bytes already compared beetween both strings
	ld a,e			; a - number bytes left in 2nd string           ;25a1	7b 	{ 
	or d			; or'ed number bytes left in 1st string         ;25a2	b2 	. 
	ret z			; both are 0  - 1st strin == 2nd string         ;25a3	c8 	. 
; -- decrement 1st string bytes counter
	ld a,d			; a - bytes left in 1st string                      ;25a4	7a 	z 
	sub 1		    ; decrement - is it less than 0 ?                   ;25a5	d6 01 	. . 
	ret c			; yes - 1st string < 2nd string (is shorter)        ;25a7	d8 	. 
; -- check 2nd string byte counter
	xor a			; a = 0 and CY = 0                                  ;25a8	af 	. 
	cp e			; is bytes counter = 0 ?                            ;25a9	bb 	. 
	inc a			; set return value to 1 (1st nstring is greater)    ;25aa	3c 	< 
	ret nc			; yes - 1st string > 2nd string                     ;25ab	d0 	. 
; -- both strings have bytes left to compare  
	dec d			; decrement 1st string bytes counter                ;25ac	15 	. 
	dec e			; decrement 2nd string bytes counter                ;25ad	1d 	. 
	ld a,(bc)		; a - char from 2nd string	                        ;25ae	0a 	. 
	cp (hl)			; compare to char from 1st stroing                  ;25af	be 	. 
; -- increment char pointers for both strings
	inc hl			; address of next char in 1st string                ;25b0	23 	# 
	inc bc			; address of next char in 2nd string                ;25b1	03 	. 
	jr z,.compareNext	; if chars are equal continue comparision	        ;25b2	28 ed 	( . 
; -- chars are different - CY=1 when 1st string > 2nd string 
	ccf			    ; inverse CY flag  - CY=1 when 1st string < 2nd string ;25b4	3f 	? 
	jp CarryToRegA	; convert CY flag to -1 or 1 and return 	;25b5	c3 60 09 	. ` . 
l25b8h:
	inc a			;25b8	3c 	< 
	adc a,a			;25b9	8f 	. 
	pop bc			;25ba	c1 	. 
	and b			;25bb	a0 	. 
	add a,0ffh		;25bc	c6 ff 	. . 
	sbc a,a			;25be	9f 	. 
	call sub_098dh		;25bf	cd 8d 09 	. . . 
	jr l25d6h		;25c2	18 12 	. . 
l25c4h:
	ld d,05ah		;25c4	16 5a 	. Z 
	call l233ah		;25c6	cd 3a 23 	. : # 
	call FuncCINT	; convert ACC to integer		;25c9	cd 7f 0a 	.  . 
	ld a,l			;25cc	7d 	} 
	cpl			;25cd	2f 	/ 
	ld l,a			;25ce	6f 	o 
	ld a,h			;25cf	7c 	| 
	cpl			;25d0	2f 	/ 
	ld h,a			;25d1	67 	g 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;25d2	22 21 79 	" ! y 
	pop bc			;25d5	c1 	. 
l25d6h:
	jp l2346h		;25d6	c3 46 23 	. F # 


; ********************************************************************************
; Math : Test NTF (Number Type Format) of number in ACC
; IN: ACC - numbert to test it's type 
; OUT: Flags: NC - Double, Z - String, M - Integer, P - Single (or Double), PO - Single
;      a - -1 (integer), 0 (String), 1 (single), 5 (double) 
TestNTF:
	ld a,(MATH_NTF)	; a - NTF (Number Type Format)								;25d9	3a af 78 	: . x 
	cp 8			; is this Double type?										;25dc	fe 08 	. . 
	jr nc,.isDouble	; yes -	set reg a and flags for Double type					;25de	30 05 	0 . 
; -- ACC contains Single (4), Integer (2) or String (3)
	sub 3			; a - 1 (Single), 0 (String), -1 (Integer)					;25e0	d6 03 	. . 
	or a			; set Z and M/P flags										;25e2	b7 	. 
	scf				; set CY=1 (Single,String or Integer type)					;25e3	37 	7 
	ret				; ---------------- End of Proc ----------------------------	;25e4	c9 	. 
.isDouble:
	sub 3			; a - 5 for Double type										;25e5	d6 03 	. . 
	or a			; set P/M flags 											;25e7	b7 	. 
	ret				; ---------------- End of Proc ----------------------------	;25e8	c9 	. 




l25e9h:
	push bc			;25e9	c5 	. 
	call FuncCINT	; convert ACC to integer		;25ea	cd 7f 0a 	.  . 
	pop af			;25ed	f1 	. 
	pop de			;25ee	d1 	. 
	ld bc,l27fah		;25ef	01 fa 27 	. . ' 
	push bc			;25f2	c5 	. 
	cp 046h		;25f3	fe 46 	. F 
	jr nz,MAT_iAnd_HL_DE	; A,L = HL & DE (Integer)	;25f5	20 06 	  . 


; ********************************************************************************
; Math : A,L = HL | DE (Integer)
MAT_iOr_HL_DE
	ld a,e			;25f7	7b 	{ 
	or l			;25f8	b5 	. 
	ld l,a			;25f9	6f 	o 
	ld a,h			;25fa	7c 	| 
	or d			;25fb	b2 	. 
	ret			;25fc	c9 	. 
; ********************************************************************************
; Math : A,L = HL & DE (Integer)
MAT_iAnd_HL_DE:
	ld a,e			;25fd	7b 	{ 
	and l			;25fe	a5 	. 
	ld l,a			;25ff	6f 	o 
	ld a,h			;2600	7c 	| 
	and d			;2601	a2 	. 
	ret			;2602	c9 	. 
l2603h:
	dec hl			;2603	2b 	+ 
	rst $10			; move hl to next Basic token				;2604	d7 	. 
	ret z			; return if End of Statement found          ;2605	c8 	. 
	rst $08			; Assert next token is ',' ;2606	cf 	. 
	defb ','		; Basic ',' token 	;2607	2c 	, 


; *******************************************************************************************************
; BASIC DIM Entry Point
; Dimension one or more BASIC variables. 
; On entry, HL must point to the first character of a string which contains one or more 
; variable names and desired dimensions (same syntax as would be required immediately
; following a BASIC DIM statement) . String must be terminated with a zero byte or colon.
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdDIM:
	ld bc,l2603h		;2608	01 03 26 	. . & 
	push bc			;260b	c5 	. 
	db $f6 			; trick byte - with next constructs or 0afh		;260c	f6 af 	. . 
	; or $af		; flag non-zero -> force Create or Error 

; *******************************************************************************************************
; LOCATE OR CREATE A BASIC VARIABLE
; This routine will locate the storage area in memory for an existing BASIC variable, 
; or will assign a storage area for the specified variable if one does not exist.
; On exit, HL will point to the next character following the variable name, and DE will 
; contain the address of the variable storage area. 
; NOTE: If the variable name does not contain a type declaration character (I, %, #, or § as
; the final character of the variable name), the variable will be set to the precission as defined 
; by the variable type declaration table (BAS_VarTypesTab). 
; IN: hl - variable name
; OUT: de - variable storage address
GetVarAddr
	xor a					; 0 -> Locate Variable and Create if not exists		;260d	af 	. . 
	ld (CreateVarFlag),a	; set flag to create variable if not found			;260e	32 ae 78 	2 . x 
; -- variable name must be 1 letter ('A'..'Z'), 2 letters or letter+digit
	ld b,(hl)				; first letter of variable name						;2611	46 	F 
	call SysIsLetter		; check if it's letter ('A'..'Z')					;2612	cd 3d 1e 	. = . 
	jp c,ErrRaiseSyntax		; no - Raise 'SYNTAX ERROR'							;2615	da 97 19 	. . . 
; -- first char is letter
	xor a					; 0 for variable with 1 letter name					;2618	af 	. 
	ld c,a					; assumed as 1 letter name							;2619	4f 	O 
; -- check next char 
	rst $10					; move hl to next Basic token - is it digit?		;261a	d7 	. 
	jr c,.set_bc			; yes - set variable name in register bc            ;261b	38 05 	8 . 
; -- it is not digit - is this letter?
	call SysIsLetter		; check if it's letter ('A'..'Z')					;261d	cd 3d 1e 	. = . 
	jr c,.detectVarType		; no - detect variable type							;2620	38 09 	8 . 
.set_bc:
	ld c,a					; variable name stored in bc register 				;2622	4f 	O 
.next:
; -- ignore rest of variable name (obly 2 chars matter)
	rst $10					; move hl to next Basic token - is it digit?		;2623	d7 	. 
	jr c,.next				; yes - skip this char and check next one			;2624	38 fd 	8 . 
	call SysIsLetter		; check if it's letter ('A'..'B')					;2626	cd 3d 1e 	. = . 
	jr nc,.next				; yes - skip this char and check next one			;2629	30 f8 	0 . 
.detectVarType:
; -- bc contains variable name
	ld de,l2652h			; address of l2652h routine  						;262b	11 52 26 	. R & 
	push de					; push address of l2652h as return point 			;262e	d5 	. 
; -- test type of variable: is it Integer Type?
	ld d,2					; 2 - integer variable								;262f	16 02 	. . 
	cp '%'					; is it "integer suffix"?							;2631	fe 25 	. % 
	ret z					; yes - continue - integer type variable			;2633	c8 	. 
; -- test type of variable: is it String Type?
	inc d					; 3 - string variable								;2634	14 	. 
	cp '$'					; is it "string suffix"?							;2635	fe 24 	. $ 
	ret z					; yes - continue - string type variable				;2637	c8 	. 
; -- probably removed code (other variable types?)
	nop																			;2638	00 	. 
	nop																			;2639	00 	. 
	nop																			;263a	00 	. 
	nop																			;263b	00 	. 
	nop																			;263c	00 	. 
	nop																			;263d	00 	. 
	nop																			;263e	00 	. 
	nop																			;263f	00 	. 
	nop																			;2640	00 	. 
; -- numeric variable type (without suffix)
	ld a,b				; a - first letter of variable name						;2641	78 	x 
	sub 'A'				; shift range from A..Z to 0..26						;2642	d6 41 	. A 
	and $7f				; constrain range to positive number					;2644	e6 7f 	.  
	ld e,a				; e - variable index (0..26)							;2646	5f 	_ 
	ld d,0				; de - variable index 									;2647	16 00 	. . 
	push hl				; save hl - basic parse point							;2649	e5 	. 
	ld hl,BAS_VarTypesTab	; stored types of variables for 'A'..'Z'			;264a	21 01 79 	! . y 
	add hl,de			; address in Variable Types Table						;264d	19 	. 
	ld d,(hl)			; d - variable type 									;264e	56 	V 
	pop hl				; restore hl 											;264f	e1 	. 
	dec hl				; move back basic parse point							;2650	2b 	+ 
	ret					; continue - default type variable						;2651	c9 	. 
l2652h:
; IN: d - variable type, bc - variable name
	ld a,d				; a - variable type										;2652	7a 	z 
	ld (MATH_NTF),a		; set variable type in Accumulator						;2653	32 af 78 	2 . x 
; -- test if it is for-next loop index variable
	rst $10				; move hl to next Basic token							;2656	d7 	. 
	ld a,(ForNextFlag)	; flag indicating we are parsing for-next loop		;2657	3a dc 78 	: . x 
	or a				; is this for-next loop index variable?					;265a	b7 	. 
	jp nz,l2664h		; yes - skip - this variable cannot be array			;265b	c2 64 26 	. d & 
; -- test if it is indexed array
	ld a,(hl)			; a - char next to variable name						;265e	7e 	~ 
	sub '('				; is it open bracked? 									;265f	d6 28 	. ( 
	jp z,l26e9h			; yes - ;2661	ca e9 26 	. . & 
l2664h:
	xor a				; 0 - for-loop flag 									;2664	af 	. 
	ld (ForNextFlag),a	; clear flag  										;2665	32 dc 78 	2 . x 
; -- 
	push hl				; save hl - basic parse point							;2668	e5 	. 
	push de				; save de - d - variable type, e - variable index (name);2669	d5 	. 
	ld hl,(PrgEndPtr)	; address where variables are stored (above code)		;266a	2a f9 78 	* . x 
l266dh:
	ex de,hl			; de - address where variables are stored				;266d	eb 	. 
	ld hl,(ArrStartPtr)	; address where array variables are stored			;266e	2a fb 78 	* . x 
	rst #18				; are both addresses equal? - end of VarTable			;2671	df 	. 
	pop hl				; restore hl - type and index of variable				;2672	e1 	. 
	jr z,l268eh			; yes - ;2673	28 19 	( . 
; -- test if variable exists already
	ld a,(de)			; a - existing variable type 							;2675	1a 	. 
	ld l,a				; set as new type										;2676	6f 	o 
	cp h				; is the same as requested?								;2677	bc 	. 
	inc de				; points to next entry in VarTable						;2678	13 	. 
	jr nz,.next			;2679	20 0b 	  . 
	ld a,(de)			;267b	1a 	. 
	cp c			;267c	b9 	. 
	jr nz,.next		;267d	20 07 	  . 
	inc de			;267f	13 	. 
	ld a,(de)			;2680	1a 	. 
	cp b			;2681	b8 	. 
	jp z,l26cch		;2682	ca cc 26 	. . & 
	db $3e 			; ld a,013h	used to skip 1st "inc de" 						;2685	3e 13 	> . 
.next
	inc de		;2686	13 	> . 
	inc de			;2687	13 	. 
	push hl			;2688	e5 	. 
	ld h,000h		;2689	26 00 	& . 
	add hl,de			;268b	19 	. 
	jr l266dh		;268c	18 df 	. . 
l268eh:
	ld a,h			;268e	7c 	| 
	pop hl			;268f	e1 	. 
	ex (sp),hl			;2690	e3 	. 
	push af			;2691	f5 	. 
	push de			;2692	d5 	. 
	ld de,024f1h		;2693	11 f1 24 	. . $ 
	rst #18			; Compare HL and DE ;2696	df 	. 
	jr z,l26cfh		;2697	28 36 	( 6 
	ld de,l2543h		;2699	11 43 25 	. C % 
	rst #18			; Compare HL and DE ;269c	df 	. 
	pop de			;269d	d1 	. 
	jr z,l26d5h		;269e	28 35 	( 5 
	pop af			;26a0	f1 	. 
	ex (sp),hl			;26a1	e3 	. 
	push hl			;26a2	e5 	. 
	push bc			;26a3	c5 	. 
	ld c,a			;26a4	4f 	O 
	ld b,000h		;26a5	06 00 	. . 
	push bc			;26a7	c5 	. 
	inc bc			;26a8	03 	. 
	inc bc			;26a9	03 	. 
	inc bc			;26aa	03 	. 
	ld hl,(ArrEndPtr)	; address of End of Basic Array area		;26ab	2a fd 78 	* . x 
	push hl			;26ae	e5 	. 
	add hl,bc			;26af	09 	. 
	pop bc			;26b0	c1 	. 
	push hl			;26b1	e5 	. 
	call sub_1955h		;26b2	cd 55 19 	. U . 
	pop hl			;26b5	e1 	. 
	ld (ArrEndPtr),hl	; address of End of Basic Array area		;26b6	22 fd 78 	" . x 
	ld h,b			;26b9	60 	` 
	ld l,c			;26ba	69 	i 
	ld (ArrStartPtr),hl	; address of Start of Basic Array area			;26bb	22 fb 78 	" . x 
l26beh:
	dec hl			;26be	2b 	+ 
	ld (hl),000h		;26bf	36 00 	6 . 
	rst #18			; Compare HL and DE ;26c1	df 	. 
	jr nz,l26beh		;26c2	20 fa 	  . 
	pop de			;26c4	d1 	. 
	ld (hl),e			;26c5	73 	s 
	inc hl			;26c6	23 	# 
	pop de			;26c7	d1 	. 
	ld (hl),e			;26c8	73 	s 
	inc hl			;26c9	23 	# 
	ld (hl),d			;26ca	72 	r 
	ex de,hl			;26cb	eb 	. 
l26cch:
	inc de			;26cc	13 	. 
	pop hl			;26cd	e1 	. 
	ret			;26ce	c9 	. 
l26cfh:
	ld d,a			;26cf	57 	W 
	ld e,a			;26d0	5f 	_ 
	pop af			;26d1	f1 	. 
	pop af			;26d2	f1 	. 
	ex (sp),hl			;26d3	e3 	. 
	ret			;26d4	c9 	. 
l26d5h:
	ld (MATH_ACC_EXP),a		;26d5	32 24 79 	2 $ y 
	pop bc			;26d8	c1 	. 
	ld h,a			;26d9	67 	g 
	ld l,a			;26da	6f 	o 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;26db	22 21 79 	" ! y 
	rst #20			; test NTF (Number Type Format) ;26de	e7 	. 
	jr nz,l26e7h	; Number (not String) - 	;26df	20 06 	  . 
; -- String
	ld hl,TXT_EMPTY	; points to char '\0' - end of string		;26e1	21 28 19 	! ( . 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;26e4	22 21 79 	" ! y 
l26e7h:
	pop hl			;26e7	e1 	. 
	ret			;26e8	c9 	. 
l26e9h:
; -- variable is array
	push hl			;26e9	e5 	. 
	ld hl,(CreateVarFlag)		;26ea	2a ae 78 	* . x 
	ex (sp),hl			;26ed	e3 	. 
	ld d,a			;26ee	57 	W 
l26efh:
	push de			;26ef	d5 	. 
	push bc			;26f0	c5 	. 
	call sub_1e45h		;26f1	cd 45 1e 	. E . 
	pop bc			;26f4	c1 	. 
	pop af			;26f5	f1 	. 
	ex de,hl			;26f6	eb 	. 
	ex (sp),hl			;26f7	e3 	. 
	push hl			;26f8	e5 	. 
	ex de,hl			;26f9	eb 	. 
	inc a			;26fa	3c 	< 
	ld d,a			;26fb	57 	W 
	ld a,(hl)			;26fc	7e 	~ 
	cp 02ch		;26fd	fe 2c 	. , 
	jr z,l26efh		;26ff	28 ee 	( . 
	rst $08			; Assert next token is ')' ;2701	cf 	. 
	defb ')'		; Basic ')' token 	;2702	29 	) 
	ld (BAS_ExprTmpPtr),hl	; [TRS] expression parser current position		;2703	22 f3 78 	" . x 
	pop hl			;2706	e1 	. 
	ld (CreateVarFlag),hl		;2707	22 ae 78 	" . x 
	push de			;270a	d5 	. 
	ld hl,(ArrStartPtr)	; address of Start of Basic Array area			;270b	2a fb 78 	* . x 
	ld a,019h		;270e	3e 19 	> . 
l2710h:
	ex de,hl			;2710	eb 	. 
	ld hl,(ArrEndPtr)	; address of End of Basic Array area		;2711	2a fd 78 	* . x 
	ex de,hl			;2714	eb 	. 
	rst #18			; Compare HL and DE ;2715	df 	. 
	ld a,(MATH_NTF)		;2716	3a af 78 	: . x 
	jr z,l2742h		;2719	28 27 	( ' 
	cp (hl)			;271b	be 	. 
	inc hl			;271c	23 	# 
	jr nz,$+10		;271d	20 08 	  . 
	ld a,(hl)			;271f	7e 	~ 
	cp c			;2720	b9 	. 
	inc hl			;2721	23 	# 
	jr nz,l2728h		;2722	20 04 	  . 
	ld a,(hl)			;2724	7e 	~ 
	cp b			;2725	b8 	. 
	ld a,023h		;2726	3e 23 	> # 
l2728h:
	inc hl			;2728	23 	# 
	ld e,(hl)			;2729	5e 	^ 
	inc hl			;272a	23 	# 
	ld d,(hl)			;272b	56 	V 
	inc hl			;272c	23 	# 
	jr nz,$-30		;272d	20 e0 	  . 
	ld a,(CreateVarFlag) ; Flag is used by BASIC locate or Create Variable routine.		;272f	3a ae 78 	: . x 
	or a			        ; raise errir if Array not exists? ;2732	b7 	. 
	ld e,#12				; ERROR 12 - REDIM'D ARRAY		;2733	1e 12 	. . 
	jp nz,ErrRaiseError	    ; yes - Raise REDIM'D ARRAY error 	;2735	c2 a2 19 	. . . 
	pop af			;2738	f1 	. 
	sub (hl)			;2739	96 	. 
	jp z,l2795h		;273a	ca 95 27 	. . ' 



ErrRaiseBadSubscript:
	ld e,#10			; ERROR number 10 - BAD SUBSCRIPT						;273d	1e 10 	. . 
	jp ErrRaiseError	; Raise Error											;273f	c3 a2 19 	. . . 



l2742h:
	ld (hl),a			;2742	77 	w 
	inc hl			;2743	23 	# 
	ld e,a			;2744	5f 	_ 
	ld d,000h		;2745	16 00 	. . 
	pop af			;2747	f1 	. 
	ld (hl),c			;2748	71 	q 
	inc hl			;2749	23 	# 
	ld (hl),b			;274a	70 	p 
	inc hl			;274b	23 	# 
	ld c,a			;274c	4f 	O 
	call sub_1963h		;274d	cd 63 19 	. c . 
	inc hl			;2750	23 	# 
	inc hl			;2751	23 	# 
	ld (BAS_TempPtr),hl	; temporary pointer	;2752	22 d8 78 	" . x 
	ld (hl),c			;2755	71 	q 
	inc hl			;2756	23 	# 
	ld a,(CreateVarFlag)		;2757	3a ae 78 	: . x 
	rla			;275a	17 	. 
	ld a,c			;275b	79 	y 
l275ch:
	ld bc,11		;275c	01 0b 00 	. . . 
	jr nc,l2763h		;275f	30 02 	0 . 
	pop bc			;2761	c1 	. 
	inc bc			;2762	03 	. 
l2763h:
	ld (hl),c			;2763	71 	q 
	inc hl			;2764	23 	# 
	ld (hl),b			;2765	70 	p 
	inc hl			;2766	23 	# 
	push af			;2767	f5 	. 
	call MAT_iMul_BC_DE	; DE = BC * DE (Unsigned Integer)	;2768	cd aa 0b 	. . . 
	pop af			;276b	f1 	. 
	dec a			;276c	3d 	= 
	jr nz,l275ch		;276d	20 ed 	  . 
	push af			;276f	f5 	. 
	ld b,d			;2770	42 	B 
	ld c,e			;2771	4b 	K 
	ex de,hl			;2772	eb 	. 
	add hl,de			;2773	19 	. 
	jr c,ErrRaiseBadSubscript	; raise BAD SUBSCRIPT ERROR	;2774	38 c7 	8 . 
	call 0196ch		;2776	cd 6c 19 	. l . 
	ld (ArrEndPtr),hl	; address of End of Basic Array area		;2779	22 fd 78 	" . x 
l277ch:
	dec hl			;277c	2b 	+ 
	ld (hl),000h		;277d	36 00 	6 . 
	rst #18			; Compare HL and DE ;277f	df 	. 
	jr nz,l277ch		;2780	20 fa 	  . 
	inc bc			;2782	03 	. 
	ld d,a			;2783	57 	W 
	ld hl,(BAS_TempPtr)	; temporary pointer	;2784	2a d8 78 	* . x 
	ld e,(hl)			;2787	5e 	^ 
	ex de,hl			;2788	eb 	. 
	add hl,hl			;2789	29 	) 
	add hl,bc			;278a	09 	. 
	ex de,hl			;278b	eb 	. 
	dec hl			;278c	2b 	+ 
	dec hl			;278d	2b 	+ 
	ld (hl),e			;278e	73 	s 
	inc hl			;278f	23 	# 
	ld (hl),d			;2790	72 	r 
	inc hl			;2791	23 	# 
	pop af			;2792	f1 	. 
	jr c,l27c5h		;2793	38 30 	8 0 
l2795h:
	ld b,a			;2795	47 	G 
	ld c,a			;2796	4f 	O 
	ld a,(hl)			;2797	7e 	~ 
	inc hl			;2798	23 	# 
	ld d,0e1h		;2799	16 e1 	. . 
	ld e,(hl)			;279b	5e 	^ 
	inc hl			;279c	23 	# 
	ld d,(hl)			;279d	56 	V 
	inc hl			;279e	23 	# 
	ex (sp),hl			;279f	e3 	. 
	push af			;27a0	f5 	. 
	rst #18			; Compare HL and DE ;27a1	df 	. 
	jp nc,ErrRaiseBadSubscript	; raise BAD SUBSCRIPT ERROR		;27a2	d2 3d 27 	. = ' 
	call MAT_iMul_BC_DE	; DE = BC * DE (Unsigned Integer)	;27a5	cd aa 0b 	. . . 
	add hl,de			;27a8	19 	. 
	pop af			;27a9	f1 	. 
	dec a			;27aa	3d 	= 
	ld b,h			;27ab	44 	D 
	ld c,l			;27ac	4d 	M 
	jr nz,$-19		;27ad	20 eb 	  . 
	ld a,(MATH_NTF)		;27af	3a af 78 	: . x 
	ld b,h			;27b2	44 	D 
	ld c,l			;27b3	4d 	M 
	add hl,hl			;27b4	29 	) 
	sub 004h		;27b5	d6 04 	. . 
	jr c,l27bdh		;27b7	38 04 	8 . 
	add hl,hl			;27b9	29 	) 
	jr z,l27c2h		;27ba	28 06 	( . 
	add hl,hl			;27bc	29 	) 
l27bdh:
	or a			;27bd	b7 	. 
	jp po,l27c2h		;27be	e2 c2 27 	. . ' 
	add hl,bc			;27c1	09 	. 
l27c2h:
	pop bc			;27c2	c1 	. 
	add hl,bc			;27c3	09 	. 
	ex de,hl			;27c4	eb 	. 
l27c5h:
	ld hl,(BAS_ExprTmpPtr)	; [TRS] expression parser current position		;27c5	2a f3 78 	* . x 
	ret			;27c8	c9 	. 


l27c9h:
	xor a			;27c9	af 	. 
	push hl			;27ca	e5 	. 
	ld (MATH_NTF),a		;27cb	32 af 78 	2 . x 
	call FuncFRE	; get amount free memory into ACC	;27ce	cd d4 27 	. . ' 
	pop hl			;27d1	e1 	. 
	rst $10			; move hl to next Basic token				;27d2	d7 	. 
	ret			;27d3	c9 	. 

; ********************************************************************************
; [TRS] BASIC FRE Entry Point
; GET AMOUNT OF FREE MEMORY TO ACCUM
; On entry, the NTF must NOT be set to 3 (string), but it may be set 
; to any other precision or may contain zero. 
; On exit, the number of bytes of remaining free memory will be stored in ACC, 
; in single-precision format (NTF=4).
FuncFRE:
	ld hl,(ArrEndPtr)	; address of End of Basic Array area		;27d4	2a fd 78 	* . x 
	ex de,hl			;27d7	eb 	. 
	ld hl,$0000		;27d8	21 00 00 	! . . 
	add hl,sp			;27db	39 	9 
	rst #20				; test NTF (Number Type Format) ;27dc	e7 	. 
	jr nz,l27ech		; Number (not String) ;27dd	20 0d 	  . 

; ********************************************************************************
; FRE(x$) Get number of bytes free string space to ACC.
; OUT: ACC - number of bytes of free string space remaining in the string storage area. (Single)
	call sub_29dah		;27df	cd da 29 	. . ) 
	call sub_28e6h		;27e2	cd e6 28 	. . ( 
	ld hl,(STACKTOPPTR)	; top of Basic Stack Pointer	;27e5	2a a0 78 	* . x 
	ex de,hl			;27e8	eb 	. 
	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;27e9	2a d6 78 	* . x 
l27ech:
	ld a,l			;27ec	7d 	} 
	sub e			;27ed	93 	. 
	ld l,a			;27ee	6f 	o 
	ld a,h			;27ef	7c 	| 
	sbc a,d			;27f0	9a 	. 
	ld h,a			;27f1	67 	g 
	jp sub_0c66h		;27f2	c3 66 0c 	. f . 

; ********************************************************************************
; [TRS] BASIC POS Entry Point
; Gets the position of the cursor on the current line being output to video 
; from location 78A6 (value will be in range 0 - 63), and stores in the ACC
; in integer format (NTF=2).
FuncPOS:
	ld a,(CURSORPOS)	; position of Cursor in Edited line	;27f5	3a a6 78 	: . x 
ByteToAcc:
	ld l,a			;27f8	6f 	o 
	xor a			;27f9	af 	. 
l27fah:
	ld h,a			;27fa	67 	g 
	jp ACCfromHLValue	; copy value from hl to ACC as integer number		;27fb	c3 9a 0a 	. . . 

; ********************************************************************************
; BASIC USR
; Argument can be numeric (any precision) or string,, and that the result 
; of the evaluated expression will be stored in the ACC, with the NTF set appropriately.
; 
l27feh:
	call SysExtUsr		;27fe	cd a9 79 	. . y 
	rst $10				; move hl to next Basic token				;2801	d7 	. 
	call EvalSubExpression	; evaluate expression (assert it starts with '(' and ends with ')'	;2802	cd 2c 25 	. , % 
	push hl			;2805	e5 	. 
	ld hl,l0890h		;2806	21 90 08 	! . . 
	push hl			;2809	e5 	. 
	ld a,(MATH_NTF)		;280a	3a af 78 	: . x 
	push af			;280d	f5 	. 
	cp 003h		;280e	fe 03 	. . 
	call z,sub_29dah		;2810	cc da 29 	. . ) 
	pop af			;2813	f1 	. 
	ex de,hl			;2814	eb 	. 
	ld hl,(BAS_UsrVector)	; BASIC USR routine pointer	;2815	2a 8e 78 	* . x 
	jp (hl)			;2818	e9 	. 
sub_2819h:
	push hl			;2819	e5 	. 
	and $07			; a - values in range 0..7			;281a	e6 07 	. . 
	ld hl,l18a1h	; jump table	;281c	21 a1 18 	! . . 
	ld c,a			;    ;281f	4f 	O 
	ld b,0			; bc - index of entry ;2820	06 00 	. . 
	add hl,bc		; add offset once (second time will be added in JmpHLPlusBC)	;2822	09 	. 
	call SysJmpHLPlusBC		;2823	cd 86 25 	. . % 
	pop hl			;2826	e1 	. 
	ret			;2827	c9 	. 

; *****************************************************************************************
; CHECK FOR ILLEGAL DIRECT ERROR
; Checks the current BASIC line number (stored at 78A2-78A3) for a value of FFFF, 
; which indicates that commands are being executed from the direct mode (and BASIC statements 
; currently being executed are stored in the BASIC input buffer, so it is not available
; to receive input). If this is the case an Illegal Direct error exists, otherwise 
; returns to caller
sub_2828h:
	push hl					; save hl													;2828	e5 	. 
	ld hl,(BasicLineNo)	    ; hl - current BASIC line number or $ffff in direct mode		;2829	2a a2 78 	* . x 
	inc hl					; hl - 0 if current line is -1 ($ffff)						;282c	23 	# 
	ld a,h					; a - high byte to check									;282d	7c 	| 
	or l					; is hl == 0 (line number -1)								;282e	b5 	. 
	pop hl					; restore hl before return									;282f	e1 	. 
	ret nz					; no - return with no error 								;2830	c0 	. 
	ld e,#16				; ERROR 16 - ILLEGAL DIRECT									;2831	1e 16 	. . 
	jp ErrRaiseError		; Raise Error												;2833	c3 a2 19 	. . . 



; ********************************************************************************
; BASIC STR$ Entry Point
; Convert number in ACC to string.
; IN: ACC - number to be converted to a string (with the NTF set appropriately).
;     STACK - <return address> <HL> <BC>
; OUT: ACC - result string
FuncSTRS:
	call NumToStr	; Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)		;2836	cd bd 0f 	. . . 
	call strACCfromCStr	; create Basic string in ACC from null terminated str (hl)	;2839	cd 65 28 	. e ( 
	call sub_29dah		;283c	cd da 29 	. . ) 
	ld bc,l2a2bh		;283f	01 2b 2a 	. + * 
	push bc			;2842	c5 	. 
sub_2843h:
	ld a,(hl)			;2843	7e 	~ 
	inc hl			;2844	23 	# 
	push hl			;2845	e5 	. 
	call StrAlloc		;2846	cd bf 28 	. . ( 
	pop hl			;2849	e1 	. 
	ld c,(hl)			;284a	4e 	N 
	inc hl			;284b	23 	# 
	ld b,(hl)			;284c	46 	F 
	call StrFromADE	; store new string in StringVector variable	;284d	cd 5a 28 	. Z ( 
	push hl			;2850	e5 	. 
	ld l,a			    ; length of string ;2851	6f 	o 
	call StrCopy; Copy l bytes from (BC) to (DE)	;2852	cd ce 29 	. . ) 
	pop de			;2855	d1 	. 
	ret			;2856	c9 	. 

; ************************************************************************************
; Allocate string and Create String Vector for new string.
; IN: a - number of bytes to reserve
; OUT: de - address of reserved space
;      BAS_StrFreePtr - equal to DE minus one (next usable string space location).
; 	   BAS_CurStrVec  - string vector
;      hl - varptr of new string (equal to BAS_StrFreePtr)	
StrNew:
	call StrAlloc		;2857	cd bf 28 	. . ( 

;**************************************************************************
; Store String attributes in StringVector variable
; IN: a - length of Basic String
;     de - address of text 
StrFromADE:
	ld hl,StrVecBuf 	; Basic String Vector address   	            ;285a	21 d3 78 	! . x 
	push hl			    ; save hl                                       ;285d	e5 	. 
	ld (hl),a			; store String Length                           ;285e	77 	w 
	inc hl			    ; points to String Data member                  ;285f	23 	# 
	ld (hl),e			; store Low byte of String Data address         ;2860	73 	s 
	inc hl			    ; points to MSB of String Data member           ;2861	23 	# 
	ld (hl),d			; store High byte of String Data address        ;2862	72 	r 
	pop hl			    ; restore hl - Basic String Vector              ;2863	e1 	. 
	ret			        ; ---------- End of Proc ---------------------- ;2864	c9 	. 


; ******************************************************************************************
; CREATE A STRING VECTOR
; This routine will create a string vector for any string stored in memory. 
; IN: hl - null terminated (or quoted with char '"') string 
; OUT: ACC - varptr of the string
strACCfromCStr:
	dec hl			; points to byte before text start (loop starts with inc hl) 		;2865	2b 	+ 
BAS_MakeStrVecHL:	
; -- prepeare delimiters
	ld b,'"'		; b - start delimiter '"'											;2866	06 22 	. " 
	ld d,b			; d - end delimiter '"'												;2868	50 	P 

; IN: hl - address 1 byte before 1st char of string
;     b - start delimiter
;     d - end delimiter 
BAS_MakeStrVecDelim:
	push hl			; save hl - (1 byte before current char)							;2869	e5 	. 
	ld c,-1			; char in text index (1 position before current char)				;286a	0e ff 	. . 
; -- find end of string
l286ch:
	inc hl			; point to current char												;286c	23 	# 
	ld a,(hl)		; a - char to display												;286d	7e 	~ 
	inc c			; index of char in string											;286e	0c 	. 
	or a			; is end of string (0 terminator)									;286f	b7 	. 
	jr z,l2878h		; yes - ;2870	28 06 	( . 
	cp d			; is this end delimiter ('"' or other provided)						;2872	ba 	. 
	jr z,l2878h		; yes - ;2873	28 03 	( . 
	cp b			; is this start delimiter ('"' or other provided)					;2875	b8 	. 
	jr nz,l286ch	; no - continue next char until any delimiter found					;2876	20 f4 	  . 
l2878h:
	cp '"'			; check if this char is quote '"' 									;2878	fe 22 	. " 
	call z,NextToken; yes -	move hl to next Basic token ;287a	cc 78 1d 	. x . 
	ex (sp),hl			;287d	e3 	. 
	inc hl			; skip '"' char ;287e	23 	# 
	ex de,hl		; de - address of text 	;287f	eb 	. 
	ld a,c			; a - length of text ;2880	79 	y 
	call StrFromADE	; store new string in StringVector variable		;2881	cd 5a 28 	. Z ( 
l2884h:
	ld de,StrVecBuf 		;2884	11 d3 78 	. . x 
	ld a,0d5h		;2887	3e d5 	> . 
	ld hl,(BAS_StrNextVar)	; next location in literal string pool	;2889	2a b3 78 	* . x 
	ld (ACC_SNG),hl	 ; Int,Single,String (2 or 4 bytes): 	;288c	22 21 79 	" ! y 
	ld a,3			; variable type String ;288f	3e 03 	> . 
	ld (MATH_NTF),a		;2891	32 af 78 	2 . x 
	call DEMemToHLMem	; copy math variable from (de) to (hl) mem			;2894	cd d3 09 	. . . 
	ld de,BAS_StrFreePtr	; Pointer to next free byte in string storage area	;2897	11 d6 78 	. . x 
	rst #18			; Compare HL and DE ;289a	df 	. 
	ld (BAS_StrNextVar),hl	; set as next location in literal string pool	;289b	22 b3 78 	" . x 
	pop hl			;289e	e1 	. 
	ld a,(hl)			;289f	7e 	~ 
	ret nz			;28a0	c0 	. 
	ld e,#1e			; ERROR 1E - FORMULA TOO COMPLEX		;28a1	1e 1e 	. . 
	jp ErrRaiseError	; Raise Error							;28a3	c3 a2 19 	. . . 
BAS_SendStringInc:
	inc hl			;28a6	23 	# 

; **********************************************************************************
; Essentially the same effect as the routine at 2b75 (described below), except 
; that text may also end with a quotation mark ($22), creates string vector 
; before output (destroys current contents of ACCOM, sets NTF to 3,
; and also uses BC & DE registers. Depends heavily on BASIC string management routines 
; (use of 2b75 or other routines may be preferable). 
; If string contains a carriage return (Od) character, a CALL will be made 
; to the Disk BASIC link at 79d0. Used by BASIC PRINT statement. 
; This routine may also be entered at 28a6, in which case the HL register pair 
; will be incremented prior to beginning to output string.
; IN: hl - zero terminated or quoted string to send to Current Out Device
PrintBasicStr:
	call strACCfromCStr	; ACC = null terminated or quoted string from (hl)		;28a7	cd 65 28 	. e ( 
; IN: ACC - basic String structure (addres + length)
PrintACCStr:
	call sub_29dah		;28aa	cd da 29 	. . ) 
	call HLToBCD		; Copy 3 bytes from (HL) to BCD		;28ad	cd c4 09 	. . . 
	inc d			;28b0	14 	. 
l28b1h:
	dec d			;28b1	15 	. 
	ret z			;28b2	c8 	. 
	ld a,(bc)			;28b3	0a 	. 
	call PrintChar	; Print char on screen		;28b4	cd 2a 03 	. * . 
	cp $0d		    ; was it CR char ? ;28b7	fe 0d 	. . 
	call z,sub_2103h; yes - 		;28b9	cc 03 21 	. . ! 
	inc bc			;28bc	03 	. 
	jr l28b1h		;28bd	18 f2 	. . 

; ******************************************************************************************
; MAKE ROOM FOR A STRING IN STRING STORAGE AREA.
; This routine will make room for a string in the string storage area if possible 
; or raise Out of String space Error if not possible.
; IN: a - number of bytes to reserve
; OUT: de - address of reserved space
;      BAS_StrFreePtr - equal to DE minus one (next usable string space location).
StrAlloc:
	or a			;28bf	b7 	. 
	ld c,0f1h		;28c0	0e f1 	. . 
	push af			;28c2	f5 	. 
	ld hl,(STACKTOPPTR)	; top of Basic Stack Pointer		;28c3	2a a0 78 	* . x 
	ex de,hl			;28c6	eb 	. 
	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;28c7	2a d6 78 	* . x 
	cpl			;28ca	2f 	/ 
	ld c,a			;28cb	4f 	O 
	ld b,0ffh		;28cc	06 ff 	. . 
	add hl,bc			;28ce	09 	. 
	inc hl			;28cf	23 	# 
	rst #18			; Compare HL and DE ;28d0	df 	. 
	jr c,l28dah		;28d1	38 07 	8 . 
	ld (BAS_StrFreePtr),hl	; set as pointer to next free byte in string storage area	;28d3	22 d6 78 	" . x 
	inc hl			;28d6	23 	# 
	ex de,hl			;28d7	eb 	. 
l28d8h:
	pop af			;28d8	f1 	. 
	ret			;28d9	c9 	. 
l28dah:
	pop af			;28da	f1 	. 
	ld e,#1a			; ERROR 1A - OUT OF SPACE		;28db	1e 1a 	. . 
	jp z,ErrRaiseError	; Raise Error if 	;28dd	ca a2 19 	. . . 
	cp a			;28e0	bf 	. 
	push af			;28e1	f5 	. 
	ld bc,028c1h		;28e2	01 c1 28 	. . ( 
	push bc			;28e5	c5 	. 
sub_28e6h:
	ld hl,(MEMORY_TOP)		;28e6	2a b1 78 	* . x 
l28e9h:
	ld (BAS_StrFreePtr),hl	; set as pointer to next free byte in string storage area	;28e9	22 d6 78 	" . x 
	ld hl,$0000		;28ec	21 00 00 	! . . 
	push hl			;28ef	e5 	. 
	ld hl,(STACKTOPPTR)	; top of Basic Stack Pointer		;28f0	2a a0 78 	* . x 
	push hl			;28f3	e5 	. 
	ld hl,BAS_StrVars	; address of BASIC String Variables Area					;28f4	21 b5 78 	! . x 
l28f7h:
	ex de,hl			;28f7	eb 	. 
	ld hl,(BAS_StrNextVar)	; next location in literal string pool	;28f8	2a b3 78 	* . x 
	ex de,hl			;28fb	eb 	. 
	rst #18			; Compare HL and DE ;28fc	df 	. 
	ld bc,l28f7h		;28fd	01 f7 28 	. . ( 
	jp nz,l294ah		;2900	c2 4a 29 	. J ) 
	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program						;2903	2a f9 78 	* . x 
l2906h:
	ex de,hl			;2906	eb 	. 
	ld hl,(ArrStartPtr)	; address of Start of Basic Array area			;2907	2a fb 78 	* . x 
	ex de,hl			;290a	eb 	. 
	rst #18			; Compare HL and DE ;290b	df 	. 
	jr z,l2921h		;290c	28 13 	( . 
	ld a,(hl)			;290e	7e 	~ 
	inc hl			;290f	23 	# 
	inc hl			;2910	23 	# 
	inc hl			;2911	23 	# 
	cp 003h		;2912	fe 03 	. . 
	jr nz,l291ah		;2914	20 04 	  . 
	call sub_294bh		;2916	cd 4b 29 	. K ) 
	xor a			;2919	af 	. 
l291ah:
	ld e,a			;291a	5f 	_ 
	ld d,000h		;291b	16 00 	. . 
	add hl,de			;291d	19 	. 
	jr l2906h		;291e	18 e6 	. . 
l2920h:
	pop bc			;2920	c1 	. 
l2921h:
	ex de,hl			;2921	eb 	. 
	ld hl,(ArrEndPtr)	; address of End of Basic Array area		;2922	2a fd 78 	* . x 
	ex de,hl			;2925	eb 	. 
	rst #18			; Compare HL and DE ;2926	df 	. 
	jp z,l296bh		;2927	ca 6b 29 	. k ) 
	ld a,(hl)			;292a	7e 	~ 
	inc hl			;292b	23 	# 
	call HLToBCDE	; Copy value from (HL) to BCDE (Single)  	;292c	cd c2 09 	. . . 
	push hl			;292f	e5 	. 
	add hl,bc			;2930	09 	. 
	cp 003h		;2931	fe 03 	. . 
	jr nz,l2920h		;2933	20 eb 	  . 
	ld (BAS_TempPtr),hl	; temporary pointer	;2935	22 d8 78 	" . x 
	pop hl			;2938	e1 	. 
	ld c,(hl)			;2939	4e 	N 
	ld b,000h		;293a	06 00 	. . 
	add hl,bc			;293c	09 	. 
	add hl,bc			;293d	09 	. 
l293eh:
	inc hl			;293e	23 	# 
l293fh:
	ex de,hl			;293f	eb 	. 
	ld hl,(BAS_TempPtr)	; temporary pointer	;2940	2a d8 78 	* . x 
	ex de,hl			;2943	eb 	. 
	rst #18			; Compare HL and DE ;2944	df 	. 
	jr z,l2921h		;2945	28 da 	( . 
	ld bc,l293fh		;2947	01 3f 29 	. ? ) 
l294ah:
	push bc			;294a	c5 	. 
sub_294bh:
	xor a			;294b	af 	. 
	or (hl)			;294c	b6 	. 
	inc hl			;294d	23 	# 
	ld e,(hl)			;294e	5e 	^ 
	inc hl			;294f	23 	# 
	ld d,(hl)			;2950	56 	V 
	inc hl			;2951	23 	# 
	ret z			;2952	c8 	. 
	ld b,h			;2953	44 	D 
	ld c,l			;2954	4d 	M 
	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;2955	2a d6 78 	* . x 
	rst #18			; Compare HL and DE ;2958	df 	. 
	ld h,b			;2959	60 	` 
	ld l,c			;295a	69 	i 
	ret c			;295b	d8 	. 
	pop hl			;295c	e1 	. 
	ex (sp),hl			;295d	e3 	. 
	rst #18			; Compare HL and DE ;295e	df 	. 
	ex (sp),hl			;295f	e3 	. 
	push hl			;2960	e5 	. 
	ld h,b			;2961	60 	` 
	ld l,c			;2962	69 	i 
	ret nc			;2963	d0 	. 
	pop bc			;2964	c1 	. 
	pop af			;2965	f1 	. 
	pop af			;2966	f1 	. 
	push hl			;2967	e5 	. 
	push de			;2968	d5 	. 
	push bc			;2969	c5 	. 
	ret			;296a	c9 	. 
l296bh:
	pop de			;296b	d1 	. 
	pop hl			;296c	e1 	. 
	ld a,l			;296d	7d 	} 
	or h			;296e	b4 	. 
	ret z			;296f	c8 	. 
	dec hl			;2970	2b 	+ 
	ld b,(hl)			;2971	46 	F 
	dec hl			;2972	2b 	+ 
	ld c,(hl)			;2973	4e 	N 
	push hl			;2974	e5 	. 
	dec hl			;2975	2b 	+ 
	ld l,(hl)			;2976	6e 	n 
	ld h,000h		;2977	26 00 	& . 
	add hl,bc			;2979	09 	. 
	ld d,b			;297a	50 	P 
	ld e,c			;297b	59 	Y 
	dec hl			;297c	2b 	+ 
	ld b,h			;297d	44 	D 
	ld c,l			;297e	4d 	M 
	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;297f	2a d6 78 	* . x 
	call sub_1958h		;2982	cd 58 19 	. X . 
	pop hl			;2985	e1 	. 
	ld (hl),c			;2986	71 	q 
	inc hl			;2987	23 	# 
	ld (hl),b			;2988	70 	p 
	ld l,c			;2989	69 	i 
	ld h,b			;298a	60 	` 
	dec hl			;298b	2b 	+ 
	jp l28e9h		;298c	c3 e9 28 	. . ( 
l298fh:
	push bc			;298f	c5 	. 
	push hl			;2990	e5 	. 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2991	2a 21 79 	* ! y 
	ex (sp),hl			;2994	e3 	. 
	call sub_249fh		;2995	cd 9f 24 	. . $ 
	ex (sp),hl			;2998	e3 	. 
	call AssertACCIsString	; Assert ACC contains String	;2999	cd f4 0a 	. . . 

; **********************************************************************************
; [299c] Concatenate two strings. 
; IN: STACK - <return address> <BC> <HL> 
;     hl - varptr(String 1)
;     ACC - varptr(String 2) with NTF set to String (3)
; OUT: ACC - varptr(concatenated string) 
	ld a,(hl)			;299c	7e 	~ 
	push hl			;299d	e5 	. 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;299e	2a 21 79 	* ! y 
	push hl			;29a1	e5 	. 
	add a,(hl)			; a - string/text length in bytes ;29a2	86 	. 
	ld e,#1c			; ERROR 1C - STRING TOO LONG	;29a3	1e 1c 	. . 
	jp c,ErrRaiseError	; Raise Error					;29a5	da a2 19 	. . . 
	call StrNew		; Allocate string and Create String Vector ;29a8	cd 57 28 	. W ( 
	pop de			;29ab	d1 	. 
	call sub_29deh		;29ac	cd de 29 	. . ) 
	ex (sp),hl			;29af	e3 	. 
	call sub_29ddh		;29b0	cd dd 29 	. . ) 
	push hl			;29b3	e5 	. 
	ld hl,(078d4h)		;29b4	2a d4 78 	* . x 
	ex de,hl			;29b7	eb 	. 
	call strSPOPcopyToDE    ; Copy string from (SP) to (DE) 		;29b8	cd c6 29 	. . ) 
	call strSPOPcopyToDE	; Copy string from (SP) to (DE) 	;29bb	cd c6 29 	. . ) 
	ld hl,l2349h		;29be	21 49 23 	! I # 
	ex (sp),hl			;29c1	e3 	. 
	push hl			;29c2	e5 	. 
	jp l2884h		;29c3	c3 84 28 	. . ( 

; **********************************************************************************
; Copy string from (SP) to (DE) - used to concatenate strings. 
; IN: de - destination memory for string 
;     STACK - address of string structure
strSPOPcopyToDE:
	pop hl			;29c6	e1 	. 
	ex (sp),hl			;29c7	e3 	. 
	ld a,(hl)			;29c8	7e 	~ 
	inc hl			;29c9	23 	# 
	ld c,(hl)			;29ca	4e 	N 
	inc hl			;29cb	23 	# 
	ld b,(hl)			;29cc	46 	F 
	ld l,a			;29cd	6f 	o 


; **********************************************************************************
; Copy l bytes from (BC) to (DE) - used to concatenate strings. 
; IN: de - destination memory for string
;     bc - source memory with string
;     l  - length of string
StrCopy:
	inc l			; length of string to copy in range (1..x)					;29ce	2c 	, 
.copyNext:
	dec l			; decrement char counter - all copied?						;29cf	2d 	- 
	ret z			; yes --------------- End of Proc -------------------------	;29d0	c8 	. 
	ld a,(bc)		; a - char from source string								;29d1	0a 	. 
	ld (de),a		; store into destination string 							;29d2	12 	. 
	inc bc			; increment source pointer									;29d3	03 	. 
	inc de			; increment destination pointer								;29d4	13 	. 
	jr .copyNext	; copy next char 											;29d5	18 f8 	. . 



sub_29d7h:
	call AssertACCIsString	; Assert ACC contains String	;29d7	cd f4 0a 	. . . 
sub_29dah:
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;29da	2a 21 79 	* ! y 
sub_29ddh:
	ex de,hl			;29dd	eb 	. 
sub_29deh:
	call sub_29f5h		;29de	cd f5 29 	. . ) 
	ex de,hl			;29e1	eb 	. 
	ret nz			;29e2	c0 	. 
	push de			;29e3	d5 	. 
	ld d,b			;29e4	50 	P 
	ld e,c			;29e5	59 	Y 
	dec de			;29e6	1b 	. 
	ld c,(hl)			;29e7	4e 	N 
	ld hl,(BAS_StrFreePtr)	; Pointer to next free byte in string storage area	;29e8	2a d6 78 	* . x 
	rst #18			; Compare HL and DE ;29eb	df 	. 
	jr nz,l29f3h		;29ec	20 05 	  . 
	ld b,a			;29ee	47 	G 
	add hl,bc			;29ef	09 	. 
	ld (BAS_StrFreePtr),hl	; Pointer to next free byte in string storage area	;29f0	22 d6 78 	" . x 
l29f3h:
	pop hl			;29f3	e1 	. 
	ret			;29f4	c9 	. 
sub_29f5h:
	ld hl,(BAS_StrNextVar)	; next location in literal string pool	;29f5	2a b3 78 	* . x 
	dec hl			;29f8	2b 	+ 
	ld b,(hl)			;29f9	46 	F 
	dec hl			;29fa	2b 	+ 
	ld c,(hl)			;29fb	4e 	N 
	dec hl			;29fc	2b 	+ 
	rst #18			; Compare HL and DE ;29fd	df 	. 
	ret nz			;29fe	c0 	. 
	ld (BAS_StrNextVar),hl	; set as next location in literal string pool	;29ff	22 b3 78 	" . x 
	ret			;2a02	c9 	. 

; ********************************************************************************
; BASIC LEN Entry Point
; Get length (number of bytes) of a string to ACC
; IN: ACC - varptr(string) with NTF set to 3.
; OUT: ACC - length of the string (Single)
; NOTE; When programming in Assembly Language, it is generally unnecessary to use this 
; routine (unless you intend to perform further calculations with the resulting value, etc.),
; because the string length is contained in the byte pointed to by the VARPTR.
FuncLEN
	ld bc,ByteToAcc	; routine Copy reg A to ACC									;2a03	01 f8 27 	. . ' 
	push bc			; set as return routine to execute after					;2a06	c5 	. 

; ********************************************************************************
; Get length (number of bytes) of a string to reg A
; IN: ACC - varptr(string) with NTF set to 3.
; OUT: A - length of the string
StrLen:
	call sub_29d7h		;2a07	cd d7 29 	. . ) 
	xor a			;2a0a	af 	. 
	ld d,a			;2a0b	57 	W 
	ld a,(hl)			;2a0c	7e 	~ 
	or a			;2a0d	b7 	. 
	ret			;2a0e	c9 	. 

; ********************************************************************************
; BASIC ASC Entry Point
; Get ASCII value of first character of string to ACC.
; IN: ACC - varptr of the string with the NTF set to 3. 
; OUT: ACC - the ASCII value of the first character of the string (Integer).
; NOTE: Keep in mind that the two bytes following the byte pointed to by the VARPTR 
; in turn point to the beginning of the string. Therefore, use of this routine would-be
; considered highly inefficient programming, except when the resulting value is to be 
; further processed by the ROM arithmetic routines.
FuncASC:
	ld bc,ByteToAcc	; Copy a to ACC		;2a0f	01 f8 27 	. . ' 
	push bc			;2a12	c5 	. 
sub_2a13h:
	call StrLen		;2a13	cd 07 2a 	. . * 
	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2a16	ca 4a 1e 	. J . 
	inc hl			;2a19	23 	# 
	ld e,(hl)			;2a1a	5e 	^ 
	inc hl			;2a1b	23 	# 
	ld d,(hl)			;2a1c	56 	V 
	ld a,(de)			;2a1d	1a 	. 
	ret			;2a1e	c9 	. 


; ********************************************************************************
; BASIC CHR$ Entry Point
; Make a one-character string from ASCII byte
; IN: ACC - the ASCII value of the character (Single).
;     STACK - <return address> <HL> <BC> 
; OUT: ACC - varptr of string (1 character) with the NTF set to 3.
FuncCHRS
	ld a,1			; a - string/text length in bytes 							;2a1f	3e 01 	> . 
	call StrNew	; Allocate 1 char string and Create String Vector			;2a21	cd 57 28 	. W ( 
	call ACCToByte	; convert ACC to 8bit value or throw FUNCTION CODE error	;2a24	cd 1f 2b 	. . + 
	ld hl,(078d4h)		;2a27	2a d4 78 	* . x 
	ld (hl),e			;2a2a	73 	s 
l2a2bh:
	pop bc			;2a2b	c1 	. 
	jp l2884h		;2a2c	c3 84 28 	. . ( 
l2a2fh:
	rst $10			; move hl to next Basic token				;2a2f	d7 	. 
	rst $08			; Assert next token is '('                  ;2a30	cf 	. 
	defb '('		; Basic '(' token                           ;2a31	28 (  
	call EvalByteExpr; expression ACC, de and a - must be 8bit value	;2a32	cd 1c 2b 	. 
	push de			;2a35	d5 	. 
	rst $08			; Assert next token is ',' ;2a36	cf 	. 
	defb ','		; Basic ',' token	;2a37	2c 	, 
	call EvalExpr	; evaluate expression pointed by hl and store in ACC	;2a38	cd 37 23 	. 7 # 
	rst $08			; Assert next token is ')' ;2a3b	cf 	. 
	defb ')'		; Basic ')' token	;2a3c	29 	) 


; *****************************************************************************************
; STRING$ Make a string of multiple bytes of one character.
; IN: ACC - ASCII value of the character (Integer)
;     STACK - <return address> <desired Length>
; OUT: ACC - vartptr of created string with the NTF set to 3. 
	ex (sp),hl			;2a3d	e3 	. 
	push hl			;2a3e	e5 	. 
	rst #20			; test NTF (Number Type Format) ;2a3f	e7 	. 
	jr z,l2a47h		; String - ;2a40	28 05 	( . 
	call ACCToByte	; convert ACC to 8bit value or throw FUNCTION CODE error		;2a42	cd 1f 2b 	. . + 
	jr l2a4ah		;2a45	18 03 	. . 
l2a47h:
	call sub_2a13h		;2a47	cd 13 2a 	. . * 
l2a4ah:
	pop de			; e - text length, d - ???  ;2a4a	d1 	. 
	push af			;2a4b	f5 	. 
	push af			;2a4c	f5 	. 
	ld a,e			; a - string/text length in bytes ;2a4d	7b 	{ 
	call StrNew	; Allocate string and Create String Vector	;2a4e	cd 57 28 	. W ( 
	ld e,a			;2a51	5f 	_ 
	pop af			;2a52	f1 	. 
	inc e			;2a53	1c 	. 
	dec e			;2a54	1d 	. 
	jr z,l2a2bh		;2a55	28 d4 	( . 
	ld hl,(078d4h)		;2a57	2a d4 78 	* . x 
l2a5ah:
	ld (hl),a			;2a5a	77 	w 
	inc hl			;2a5b	23 	# 
	dec e			;2a5c	1d 	. 
	jr nz,l2a5ah		;2a5d	20 fb 	  . 
	jr l2a2bh		;2a5f	18 ca 	. . 


; ********************************************************************************
; [TRS] BASIC LEFT$ Entry Point
; IN: STACK <return address> <varptr of string> <number of characters>
;     de - must point to '('
; OUT: ACC - varptr of new string with the NTF set to 3
FuncLEFTS:
	call sub_2adfh		;2a61	cd df 2a 	. . * 


; ********************************************************************************
; Make a string of the leftmost n characters of string
; IN: STACK <return address> <varptr of string> 
;     b - number of characters to be retained at the left side of the string
; OUT: ACC - varptr of new string with the NTF set to 3
	xor a			;2a64	af 	. 
l2a65h:
	ex (sp),hl			;2a65	e3 	. 
	ld c,a			;2a66	4f 	O 
	db $3e 			; trick byte - with next constructs irrevelant ld a,0e5h		;2a67	3e e5 	> . 

; ********************************************************************************
; CREATE OR DUPLICATE STRING OR SUBSTRING.
; This routine is used by LEFT$ , MID$, and RIGHT$ to create new substrings. 
; It can also be used to duplicate existing strings in memory or to create 
; a permanent storage area for a temporary string.
; IN: hl - varptr of string
;     b - maximum length of generated string (255 to duplicate string)
;     c - number of characters to ignore at the start (0 to duplicate string)
;  Note that the new string will not exceed the current string length 
; or the length placed in the B register, whichever is less.
; However, if the C register contains a value other than zero, it is possible 
; that "garbage" characters may be included in the new string unless precautions 
; are taken to avoid this. 
; For example, if the B register contains a value of 25 decimal but the current string 
; is only 10 characters long, the maximum string length will be 10 characters.
; If a value of 5 is placed In the C register, the resulting string will contain 
; the last five characters of the original string plus the five bytes following 
; the original string in memory (which probably contain "garbage" or parts 
; of other strings).
; OUT: ACC - varptr of created string with the NTF set to 3.
	push hl			;2a68	e5 	> . 
l2a69h:
	push hl			;2a69	e5 	. 
	ld a,(hl)			;2a6a	7e 	~ 
	cp b			;2a6b	b8 	. 
	jr c,$+4		;2a6c	38 02 	8 . 
	ld a,b			;2a6e	78 	x 
	ld de,$000e		;2a6f	11 0e 00 	. . . 
	push bc			;2a72	c5 	. 
	call StrAlloc		;2a73	cd bf 28 	. . ( 
	pop bc			;2a76	c1 	. 
	pop hl			;2a77	e1 	. 
	push hl			;2a78	e5 	. 
	inc hl			;2a79	23 	# 
	ld b,(hl)			;2a7a	46 	F 
	inc hl			;2a7b	23 	# 
	ld h,(hl)			;2a7c	66 	f 
	ld l,b			;2a7d	68 	h 
	ld b,000h		;2a7e	06 00 	. . 
	add hl,bc			;2a80	09 	. 
	ld b,h				;2a81	44 	D 
	ld c,l			; bc - address of source string to copy	;2a82	4d 	M 
	call StrFromADE	; store new string in StringVector variable (de - new string chars)		;2a83	cd 5a 28 	. Z ( 
	ld l,a			; length of string ;2a86	6f 	o 
	call StrCopy	; Copy l bytes from (BC) to (DE) 	;2a87	cd ce 29 	. . ) 
	pop de			;2a8a	d1 	. 
	call sub_29deh		;2a8b	cd de 29 	. . ) 
	jp l2884h		;2a8e	c3 84 28 	. . ( 


; ********************************************************************************
; BASIC RIGHT$ Entry Point
; IN: STACK <return address> <varptr of string> <number of characters>
;     de - must point to '('
; OUT: ACC - varptr of new string with the NTF set to 3
FuncRIGHTS
	call sub_2adfh		;2a91	cd df 2a 	. . * 

; ********************************************************************************
; Make a string of the rightmost n characters of string
; IN: STACK <return address> <varptr of string>
;     b - number of characters to be retained at the right side of the string.
; OUT: ACC - varptr of new string with the NTF set to 3
	pop de			;2a94	d1 	. 
	push de			;2a95	d5 	. 
	ld a,(de)			;2a96	1a 	. 
	sub b			;2a97	90 	. 
	jr l2a65h		;2a98	18 cb 	. . 


; ********************************************************************************
; BASIC MID$ Entry Point
FuncMIDS:
	ex de,hl			;2a9a	eb 	. 
	ld a,(hl)			;2a9b	7e 	~ 
	call sub_2ae2h		;2a9c	cd e2 2a 	. . * 
	inc b			;2a9f	04 	. 
	dec b			;2aa0	05 	. 
	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2aa1	ca 4a 1e 	. J . 
	push bc			;2aa4	c5 	. 
	ld e,0ffh		;2aa5	1e ff 	. . 
	cp 029h		;2aa7	fe 29 	. ) 
	jr z,l2ab0h		;2aa9	28 05 	( . 
	rst $08			; Assert next token is ',' ;2aab	cf 	. 
	defb ','		; Basic ',' token	;2aac	2c 	, 
	call EvalByteExpr; expression ACC, de and a - must be 8bit value	;2aad	cd 1c 2b 	. . + 
l2ab0h:
	rst $08			; Assert next token is ')' ;2ab0	cf 	. 
	defb ')'		; Basic ')' token 	;2ab1	29 	) 
	pop af			;2ab2	f1 	. 

; ********************************************************************************
; Make a string from a portion of another string.
; IN: a - position of the first character to be retained
;     e - maximum length of the new string - ff if no limit 
;     STACK - <return address> <varptr of string> 
; OUT: ACC - string created with the NTF set to 3.
; NOTE: The "standard" entry point to MID$ is 2A9AH, however that entry point 
; requires extra setup procedures. 
	ex (sp),hl			;2ab3	e3 	. 
	ld bc,l2a69h		;2ab4	01 69 2a 	. i * 
	push bc			;2ab7	c5 	. 
	dec a			;2ab8	3d 	= 
	cp (hl)			;2ab9	be 	. 
	ld b,000h		;2aba	06 00 	. . 
	ret nc			;2abc	d0 	. 
	ld c,a			;2abd	4f 	O 
	ld a,(hl)			;2abe	7e 	~ 
	sub c			;2abf	91 	. 
	cp e			;2ac0	bb 	. 
	ld b,a			;2ac1	47 	G 
	ret c			;2ac2	d8 	. 
	ld b,e			;2ac3	43 	C 
	ret			;2ac4	c9 	. 




; ********************************************************************************
; BASIC VAL Entry Point
; Get value of numeric string to ACC
; IN: ACC - varptr of string  with the NTF set to 3. 
; OUT: ACC - value of the number represented in the string (Double) with the NTF set to 8.
FuncVAL
	call StrLen		;2ac5	cd 07 2a 	. . * 
	jp z,ByteToAcc	; Copy a to ACC		;2ac8	ca f8 27 	. . ' 
	ld e,a			;2acb	5f 	_ 
	inc hl			;2acc	23 	# 
	ld a,(hl)			;2acd	7e 	~ 
	inc hl			;2ace	23 	# 
	ld h,(hl)			;2acf	66 	f 
	ld l,a			;2ad0	6f 	o 
	push hl			;2ad1	e5 	. 
	add hl,de			;2ad2	19 	. 
	ld b,(hl)			;2ad3	46 	F 
	ld (hl),d			;2ad4	72 	r 
	ex (sp),hl			;2ad5	e3 	. 
	push bc			;2ad6	c5 	. 
	ld a,(hl)			;2ad7	7e 	~ 
	call StrToDbl	; convert string (hl) to number (double)		;2ad8	cd 65 0e 	. e . 
	pop bc			;2adb	c1 	. 
	pop hl			;2adc	e1 	. 
	ld (hl),b			;2add	70 	p 
	ret			;2ade	c9 	. 
sub_2adfh:
	ex de,hl			;2adf	eb 	. 
	rst $08			; Assert next token is ')' ;2ae0	cf 	. 
	defb ')'		; Basic ')' token 	;2ae1	29 	) 
sub_2ae2h:
	pop bc			;2ae2	c1 	. 
	pop de			;2ae3	d1 	. 
	push bc			;2ae4	c5 	. 
	ld b,e			;2ae5	43 	C 
	ret			;2ae6	c9 	. 
l2ae7h:
	cp 07ah		;2ae7	fe 7a 	. z 
	jp nz,ErrRaiseSyntax	; no - Raise 'SYNTAX ERROR'	;2ae9	c2 97 19 	. . . 
	jp SysExtAssign		;2aec	c3 d9 79 	. . y 

; ********************************************************************************
; [TRS] BASIC INP Entry Point
FuncINP
	call ACCToByte		; convert ACC to 8bit value or throw FUNCTION CODE error	;2aef	cd 1f 2b 	. . + 
	ld (smcPortInAddr),a	; set port number inside routine code					;2af2	32 94 78 	2 . x 
	call smcPortIn		; execute routine (in a,(<port>))							;2af5	cd 93 78 	. . x 
	jp ByteToAcc		; Copy a to ACC - result ----------------------------------	;2af8	c3 f8 27 	. . ' 


; ***************************************************************************************************
; BASIC OUT Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdOUT
	call sub_2b0eh		;2afb	cd 0e 2b 	. . + 
	jp smcPortOut		;2afe	c3 96 78 	. . x 
sub_2b01h:
	rst $10			; move hl to next Basic token				;2b01	d7 	. 

; *********************************************************************************
; LOAD INTEGER EXPRESSION INTO DE
; Evaluate the string at the address pointed to by HL register pair for an integer 
; value, stopping at the first non-numeric character. The result is returned
; in DE register pair. A value of zero is returned if no numeric value is found. 
; Maximum allowable number is in range -32768 to 32767.
; IN:  hl - address of ASCII string of number to convert
; OUT: de - number converted
EvalIntExpr:
	call EvalExpr	; evaluate expression pointed by hl and store in ACC	;2b02	cd 37 23 	. 7 # 


; ********************************************************************************
; Math : Convert from Any (ACC) to Integer (ACC)
; Result also in DE, Z flag set if number in range 0..ff (8bit).
ACCToInt:
	push hl			;2b05	e5 	. 
	call FuncCINT	; convert ACC to integer		;2b06	cd 7f 0a 	.  . 
	ex de,hl			;2b09	eb 	. 
	pop hl			;2b0a	e1 	. 
	ld a,d			;2b0b	7a 	z 
	or a			;2b0c	b7 	. 
	ret			;2b0d	c9 	. 
sub_2b0eh:
	call EvalByteExpr; expression ACC, de and a - must be 8bit value	;2b0e	cd 1c 2b 	. . + 
	ld (smcPortInAddr),a		;2b11	32 94 78 	2 . x 
	ld (smcPortOutAddr),a		;2b14	32 97 78 	2 . x 
	rst $08			; Assert next token is ',' ;2b17	cf 	. 
	defb ','		; Basic ',' token 	;2b18	2c 	, 
	jr EvalByteExpr	; expression ACC, de and a - must be 8bit value	;2b19	18 01 	. . 
sub_2b1bh:
	rst $10			; move hl to next Basic token				;2b1b	d7 	. 

; **************************************************************************************
; Evaluate Integer expression and places it in ACC and register de
; If expression is not Integer, raise FUNCTION CODE error
EvalByteExpr:
	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;2b1c	cd 37 23 	. 7 # 
ACCToByte:
	call ACCToInt	; Convert ACC to Integer - set Z if it is 8bit value	;2b1f	cd 05 2b 	. . + 
	jp nz,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2b22	c2 4a 1e 	. J . 
	dec hl			;2b25	2b 	+ 
	rst $10			; move hl to next Basic token				;2b26	d7 	. 
	ld a,e			;2b27	7b 	{ 
	ret			;2b28	c9 	. 

; *************************************************************************************
; BASIC LIST Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdLLIST
	ld a,$01			; 1 - Printer Device 											;2b29	3e 01 	> . 
	ld (SysCurOutDev),a	; set Printer as Current Out Device								;2b2b	32 9c 78 	2 . x 

; *************************************************************************************
; BASIC LIST Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdLIST
	pop bc			;2b2e	c1 	. 
	call sub_1b10h		;2b2f	cd 10 1b 	. . . 
	push bc			;2b32	c5 	. 
l2b33h:
	call sub_3b25h		;2b33	cd 25 3b 	. % ; 
	ld (BasicLineNo),hl	; set as Current Basic Line Number 		;2b36	22 a2 78 	" . x 
	pop hl			;2b39	e1 	. 
	pop de			;2b3a	d1 	. 
	ld c,(hl)			;2b3b	4e 	N 
	inc hl			;2b3c	23 	# 
	ld b,(hl)			;2b3d	46 	F 
	inc hl			;2b3e	23 	# 
	ld a,b			;2b3f	78 	x 
	or c			;2b40	b1 	. 
	jp z,BasicREADY	; jump to Basic Ready and display prompt to user           	;2b41	ca 19 1a 	. . . 
	call SysExtExtraTest		;2b44	cd df 79 	. . y 
	call sub_1d9bh		;2b47	cd 9b 1d 	. . . 
	push bc			;2b4a	c5 	. 
	ld c,(hl)			;2b4b	4e 	N 
	inc hl			;2b4c	23 	# 
	ld b,(hl)			;2b4d	46 	F 
	inc hl			;2b4e	23 	# 
	push bc			;2b4f	c5 	. 
	ex (sp),hl			;2b50	e3 	. 
	ex de,hl			;2b51	eb 	. 
	rst #18			; Compare HL and DE ;2b52	df 	. 
	pop bc			;2b53	c1 	. 
	jp c,BAS_ReadyPopBC	; take address from CPU stack and goto Basic READY state		;2b54	da 18 1a 	. . . 
	ex (sp),hl			;2b57	e3 	. 
	push hl			;2b58	e5 	. 
	push bc			;2b59	c5 	. 
	ex de,hl			;2b5a	eb 	. 
	ld (EditLineNo),hl	; set as current Edited Basic Line Number		;2b5b	22 ec 78 	" . x 
	call PrintLineNo	; Print Line number 	;2b5e	cd af 0f 	. . . 
	ld a,' '		;2b61	3e 20 	>   
	pop hl			;2b63	e1 	. 
	call PrintChar	; Print ' ' char on screen		;2b64	cd 2a 03 	. * . 
	call DetokenizeLine	; detokenize Basic Line into LineBuffer	;2b67	cd 7e 2b 	. ~ + 
	ld hl,(LINEBUFPTR)	; address of Line Buffer with text of Basic Line	;2b6a	2a a7 78 	* . x 
	call PrintCStr	    ; Print Line Buffer to screen 	;2b6d	cd 75 2b 	. u + 
	call PrintCR	    ; Print CR on screen 	;2b70	cd fe 20 	. .   
	jr l2b33h		;2b73	18 be 	. . 

; **********************************************************************************
; Output a string to device indicated by device type flag stored at SysCurOutDev. 
; Calls routine at 032a (note warning for that routine - see above)
; IN:  (hl) - string to send to device (terminated with 0)
PrintCStr:
	ld a,(hl)			; a - char to send to DCB Device				;2b75	7e 	~ 
	or a				; is this \0 (end of string)					;2b76	b7 	. 
	ret z				; yes ----------- End of Proc ----------------- ;2b77	c8 	. 
	call PrintChar	    ; Print ' ' char on screen						;2b78	cd 2a 03 	. * . 
	inc hl				; address of next char to send					;2b7b	23 	# 
	jr PrintCStr	    ; continue with next chars --------------------	;2b7c	18 f7 	. . 

; **********************************************************************************
; EXPAND COMPRESSED BASIC LINE
; After a BASIC line has been compressed, this routine may be used to expand it back 
; into a line of text, so that it can be LISTed, EDITed, etc. 
; On entry, HL must point to the first byte of compressed text in the line 
; (that is, the first byte following the forward pointer and line number). 
; The line will be decoded and the result placed in the BASIC text buffer 
; until a zero byte is encountered in the line (address of the buffer at 78A7).
; The expanded line will be terminated with a zero byte. 
; IN: hl - tokenized BASIC line (null terminated)
; OUT: Buffer ([78A7]) detokenized BASIC line
DetokenizeLine:
	push hl			    ; save hl - address of Basic Line 						;2b7e	e5 	. 
	ld hl,(LINEBUFPTR)	; address of Line Buffer 								;2b7f	2a a7 78 	* . x 
	ld b,h				; high byte of Line Buffer address						;2b82	44 	D 
	ld c,l			    ; bc - address of Line Buffer 							;2b83	4d 	M 
	pop hl				; hl - address of tokenized Basic line					;2b84	e1 	. 
	ld d,255			; max 225 chars 										;2b85	16 ff 	. . 
	jr l2b8ch			; skip first decrement and check						;2b87	18 03 	. . 
l2b89h:
	inc bc				; points to next address in Buffer (dst) 				;2b89	03 	. 
	dec d				; decrement number of chars left in destination Buffer 	;2b8a	15 	. 
	ret z				; none left ----------- End of Proc -------------------	;2b8b	c8 	. 
l2b8ch:
	ld a,(hl)			; a - token byte from Baci line							;2b8c	7e 	~ 
	or a				; is it '\0' (end of line)?								;2b8d	b7 	. 
	inc hl				; points to next char or token							;2b8e	23 	# 
	ld (bc),a			; store char in BUffer									;2b8f	02 	. 
	ret z				; yes (end of line) -------- End of Proc --------------	;2b90	c8 	. 
; -- stored char/token 
	jp l2e9dh		;2b91	c3 9d 2e 	. . . 


; (cont) Detokenize line
; IN: a - token from basic line (also stored in Edit Buffer) 
;     hl - (src) address of next char 
;     bc - (dst) address of current char in Buffer
l2b94h:
	cp $fb			; is this "'" Basic Token (REM alias)						;2b94	fe fb 	. . 
	jr nz,l2ba0h	; no -	;2b96	20 08 	  . 
; -- "'" token (REM alias) - comment
	dec bc			;2b98	0b 	. 
	dec bc			;2b99	0b 	. 
	dec bc			;2b9a	0b 	. 
	dec bc			;2b9b	0b 	. 
	inc d			;2b9c	14 	. 
	inc d			;2b9d	14 	. 
	inc d			;2b9e	14 	. 
	inc d			;2b9f	14 	. 
l2ba0h:
	cp $95			; is it 'ELSE' Token?										;2ba0	fe 95 	. . 
	call z,sub_0b24h; yes -		;2ba2	cc 24 0b 	. $ . 
; -- other token - find text of this command
	sub $7f			; token index in range 1..127								;2ba5	d6 7f 	.  
	push hl			; save hl - address of current token in source Basic Line	;2ba7	e5 	. 
	ld e,a			; e - token index											;2ba8	5f 	_ 
	ld hl,BasicCmdNames	; All Basic Commands Names table 						;2ba9	21 50 16 	! P . 
.next:
;-- find start of Command name in table 
	ld a,(hl)		; a - char from table										;2bac	7e 	~ 
	or a			; is bit 7 set (start of name)?								;2bad	b7 	. 
	inc hl			; points to next char										;2bae	23 	# 
	jp p,.next		; no - check next char										;2baf	f2 ac 2b 	. . + 
; -- start of name found - is it for this token?
	dec e			; decrement index - is it for this token?					;2bb2	1d 	. 
	jr nz,.next		; no - check next char										;2bb3	20 f7 	  . 
; -- name found - copy to buffer
	and $7f			; clear bit 7 for the first char (start marker)				;2bb5	e6 7f 	.  
.copynext:
	ld (bc),a		; store char in buffer										;2bb7	02 	. 
	inc bc			; increment destination pointer								;2bb8	03 	. 
	dec d			; decrement number of chars left in buffer 					;2bb9	15 	. 
	jp z,l28d8h		; no more space in buffer ----- Exit with "pop af"			;2bba	ca d8 28 	. . ( 
	ld a,(hl)		; a - char from name 										;2bbd	7e 	~ 
	inc hl			; points to next char										;2bbe	23 	# 
	or a			; is bit 7 set (start of next name)?						;2bbf	b7 	. 
	jp p,.copynext	; no - copy next char										;2bc0	f2 b7 2b 	. . + 
	pop hl			; restore hl - address of current token in source Line		;2bc3	e1 	. 
	jr l2b8ch		;2bc4	18 c6 	. . 



; ************************************************************************************************
; [TRS] BASIC DELETE Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdDELETE
	call sub_1b10h		;2bc6	cd 10 1b 	. . . 
	pop de			; de - Basic Line number ;2bc9	d1 	. 
	push bc			;2bca	c5 	. 
	push bc			;2bcb	c5 	. 
	call FindBasicLine	; find Basic line with number in de						;2bcc	cd 2c 1b 	. , . 
	jr nc,l2bd6h		;2bcf	30 05 	0 . 
	ld d,h			;2bd1	54 	T 
	ld e,l			;2bd2	5d 	] 
	ex (sp),hl			;2bd3	e3 	. 
	push hl			;2bd4	e5 	. 
	rst #18			; Compare HL and DE ;2bd5	df 	. 
l2bd6h:
	jp nc,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2bd6	d2 4a 1e 	. J . 
	ld hl,TXT_READY		;2bd9	21 29 19 	! ) . 
	call PrintBasicStr	; print "READY" text on Screen	;2bdc	cd a7 28 	. . ( 
	pop bc			;2bdf	c1 	. 
	ld hl,l1ae8h		;2be0	21 e8 1a 	! . . 
	ex (sp),hl			;2be3	e3 	. 


; ********************************************************************************
; DELETE BASIC LINE(s)
; On entry, the BC register must point to the start of the first BASIC line to delete, 
; and the HL register must point to the start of the following line to be retained 
; On exit, the lines are deleted, but the forward line pointers are not corrected
; by this routine. Therefore, suggested entry to this routine is to PUSH BC prior 
; to the CALL. Then, after the return from this routine, you can POP DE and CALL 
; BAS_AdjustLines to adjust the forward pointers.
; IN: bc - first BASIC line to delete
;     hl - first BASIC line to retain
DelBasicLines:
	ex de,hl			; de - first basic line to retain						;2be4	eb 	. 
	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program					;2be5	2a f9 78 	* . x 
.next:
	ld a,(de)			; get byte from source 									;2be8	1a 	. 
	ld (bc),a			; store in destination									;2be9	02 	. 
	inc bc				; increment destination pointer							;2bea	03 	. 
	inc de				; increment source pointer								;2beb	13 	. 
	rst #18				; is src pointer = end of Basic program?				;2bec	df 	. 
	jr nz,.next			; no - continue copy bytes								;2bed	20 f9 	  . 
	ld h,b																		;2bef	60 	` 
	ld l,c				; hl - destination address after copy					;2bf0	69 	i 
	ld (PrgEndPtr),hl	; set as address of End of Basic Program				;2bf1	22 f9 78 	" . x 
	ret					; ----------------- End of Proc -----------------------	;2bf4	c9 	. 



; *************************************************************************************
; TRS BASIC CSA¥E routine. 
; Saves a BASIC program to tape. On entry, HL register pair must point to the start 
; of a valid filename sequence (a quotation mark followed by a single character
; filename, which in turn may be optionally followed by a second quotation mark. 
; The entire filename sequence must be terminated by a zero byte or colon).
; IN: hl - valid filename sequence


; *************************************************************************************
; BASIC SOUND Entry Point
; SOUND <freq>,<duration> [;<freq>,<duration>] ...
; Where: freq = 0..31 (0 - silent/pause), duration = 1..9 
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdSOUND:
; -- parse syntax - read Frequency
	call EvalByteExpr	; expression to ACC, de and a - must be 8bit value			;2bf5	cd 1c 2b 	. . + 
	cp 32				; is Freq >= 32 ?										;2bf8	fe 20 	.   
	jp nc,ErrRaiseFuncCode	; yes Invalid - raise FUNCTION CODE Error			;2bfa	d2 4a 1e 	. J . 
; -- Freq valid - save it
	ld (TAPEFILETYPE),a	; save Frequency parameter 								;2bfd	32 d2 7a 	2 . z 
; -- next char must be ',' - args separator 
	rst $08				; Assert next token is ',' - args separator				;2c00	cf 	. 
	defb ','			; Basic ',' token 										;2c01	2c 	, 
; -- parse syntax - read Duration 
	call EvalByteExpr	; expression to ACC, de and a - must be 8bit value		;2c02	cd 1c 2b 	. . + 
	or a				; is it 0 (invalid value)?								;2c05	b7 	. 
	jp z,ErrRaiseFuncCode	; yes Invalid - raise FUNCTION CODE Error			;2c06	ca 4a 1e 	. J . 
	cp 10				; is Duration >= 10 ? 									;2c09	fe 0a 	. . 
	jp nc,ErrRaiseFuncCode	; yes Invalid - raise FUNCTION CODE Error			;2c0b	d2 4a 1e 	. J . 
; -- Validated params: (TAPEFILETYPE) = Freq, reg A = Duration - generate Sound
	di					; disable interrupts									;2c0e	f3 	. 
	push hl				; save hl - interpreter current pointer					;2c0f	e5 	. 
	dec a				; decrement Duration counter 							;2c10	3d 	= 
	push af				; save af - duration counter w/ flags after decrement	;2c11	f5 	. 
; -- find counters' values for given Freq
	ld a,(TAPEFILETYPE)	; a - Frequency index									;2c12	3a d2 7a 	: . z 
	or a				; is it 0 (silent/pause note)?							;2c15	b7 	. 
	jr z,.playrest		; yes - play silent (rest) note							;2c16	28 40 	( @ 
; -- Freq index in range 1..30 - calculate offset in SNDFREQTAB
	dec a				; a - Freq index in range 0..29							;2c18	3d 	= 
	sla a				; a * 2 - every entry in table is 16bit value			;2c19	cb 27 	. ' 
	ld c,a				; c - low byte of offset								;2c1b	4f 	O 
	xor a				; 0 value for high byte of offset						;2c1c	af 	. 
	ld b,a				; bc - offset in SNDFREQTAB								;2c1d	47 	G 
	pop af				; restore af - duration counter w/ flags after decrement;2c1e	f1 	. 
; -- calculate address in Sound Frequency Table - get Period counter
	ld hl,SNDFREQTAB	; base addres of Table									;2c1f	21 cf 02 	! . . 
	add hl,bc			; add offset 											;2c22	09 	. 
	ld e,(hl)			; e - low byte of Freq Counter							;2c23	5e 	^ 
	inc hl				; points to High byte of entry							;2c24	23 	# 
	ld d,(hl)			; de - Freq Counter										;2c25	56 	V 
	push de				; save de - Freq Counter								;2c26	d5 	. 
; -- get how many periods of given freq must be played for 1/8 note (??)
	ld hl,SNDFCNTTAB	; base address of Table									;2c27	21 61 03 	! a . 
	srl c				; bc / 2 - back as index 0..29							;2c2a	cb 39 	. 9 
	add hl,bc			; add offset - address in SNDFCNTTAB					;2c2c	09 	. 
	ld e,(hl)			; e - period counter									;2c2d	5e 	^ 
	ld d,0				; de - 16bit period counter								;2c2e	16 00 	. . 
; -- calculate duration for given index (0..8)
	ld hl,SNDDURTAB		; base address of Table 								;2c30	21 21 03 	! ! . 
	ld c,a				; bc - duration param (0..8) of sound					;2c33	4f 	O 
	add hl,bc			; add offet												;2c34	09 	. 
	ld b,(hl)			; b - multiplier of 1/8 note length to play				;2c35	46 	F 
; -- calculate total number of periods to play for whole note = b x number of periodd
	push de				; copy de to hl											;2c36	d5 	. 
	pop hl				; hl - periods per 1/8 note 							;2c37	e1 	. 
.addmore:
	add hl,de			; add de to sum											;2c38	19 	. 
	djnz .addmore		; decrement b counter and add more if not zero			;2c39	10 fd 	. . 
	push hl				; move hl to bc											;2c3b	e5 	. 
	pop bc				; bc - total number of periods to play for this note	;2c3c	c1 	. 
	pop hl				; hl - Freq counter (Period length)						;2c3d	e1 	. 
.next:
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;2c3e	cd f8 3a 	. . : 
	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  					;2c41	3a 3b 78 	: ; x 
	ld d,a				; save IO_LATCH value to reg d							;2c44	57 	W 
	call PlayOneTone		;2c45	cd 69 34 	. i 4 
; -- check if we've played bc times already
	dec bc				; decrement periods to play counter						;2c48	0b 	. 
	ld a,c				; a - low byte of counter								;2c49	79 	y 
	or b				; are both 0 (end of sound)?							;2c4a	b0 	. 
	jr nz,.next			; no - check Break and play again						;2c4b	20 f1 	  . 
.exit:
	pop hl				; restore hl - interpreter current pointer				;2c4d	e1 	. 
	ei					; enable interrupts										;2c4e	fb 	. 
; -- check optional follow up sound definitions
	ld a,(hl)			; a - next char from Basic code 						;2c4f	7e 	~ 
	inc hl				; increment interpreter pointer							;2c50	23 	# 
	cp ';'				; is it ';' (list separator)							;2c51	fe 3b 	. ; 
	jp z,CmdSOUND		; yes - parse and play next sound						;2c53	ca f5 2b 	. . + 
	dec hl				; decrement back interpreter pointer					;2c56	2b 	+ 
	ret					; --------------- End of Proc -------------------------	;2c57	c9 	. 


.playrest:
; -- calculate duration for given index (0..8)
	pop af				; restore af - duration param (0..8) 					;2c58	f1 	. 
	ld c,a				; c - low byte of offset 								;2c59	4f 	O 
	xor a				; 0 value for high byte of offset						;2c5a	af 	. 
	ld b,a				; bc - offset to note duration in Table					;2c5b	47 	G 
	ld hl,SNDDURTAB		; base address of Table									;2c5c	21 21 03 	! ! . 
	add hl,bc			; add offset											;2c5f	09 	. 
	ld b,(hl)			; b - multiplier of 1/8 note length to play				;2c60	46 	F 
; -- calculate total number of periods to play for whole note = b x number of period
; -- NOTE: there is no Frequency for rest note so we have simply loop count
	ld hl,$1936			; "number of periods" for 1/8 note						;2c61	21 36 19 	! 6 . 
	push hl				; copy hl to de											;2c64	e5 	. 
	pop de				; de - periods per 1/8 note 							;2c65	d1 	. 
.addmore2:
	add hl,de			; add to sum											;2c66	19 	. 
	djnz .addmore2		; decrement b counter and add more if not zero			;2c67	10 fd 	. . 
.next2:
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;2c69	cd f8 3a 	. . : 
	dec hl				; decrement loop counter								;2c6c	2b 	+ 
	ld a,l				; a - low byte of counter								;2c6d	7d 	} 
	or h				;is hl = 0 (end of rest note)?							;2c6e	b4 	. 
	jr nz,.next2		; no - continue ;2c6f	20 f8 	  . 
	jr .exit			; continue from exit proc -----------------------------	;2c71	18 da 	. . 


sub_2c73h:
	push bc			;2c73	c5 	. 
	ld b,a			;2c74	47 	G 
	ld a,008h		;2c75	3e 08 	> . 
	call sub_3abah		;2c77	cd ba 3a 	. . : 
	ld a,b			;2c7a	78 	x 
	and 00fh		;2c7b	e6 0f 	. . 
	push hl			;2c7d	e5 	. 
	sla a		;2c7e	cb 27 	. ' 
	ld c,a			;2c80	4f 	O 
	xor a			;2c81	af 	. 
	ld b,a			;2c82	47 	G 
	ld hl,l02afh		;2c83	21 af 02 	! . . 
	add hl,bc			;2c86	09 	. 
	ld a,(hl)			;2c87	7e 	~ 
	ld b,a			;2c88	47 	G 
	inc hl			;2c89	23 	# 
	ld a,(hl)			;2c8a	7e 	~ 
	ld c,a			;2c8b	4f 	O 
	ld a,b			;2c8c	78 	x 
	call sub_3abah		;2c8d	cd ba 3a 	. . : 
	call sub_3abah		;2c90	cd ba 3a 	. . : 
	call sub_3abah		;2c93	cd ba 3a 	. . : 
	ld a,c			;2c96	79 	y 
	call sub_3abah		;2c97	cd ba 3a 	. . : 
	call sub_3abah		;2c9a	cd ba 3a 	. . : 
	call sub_3abah		;2c9d	cd ba 3a 	. . : 
	pop hl			;2ca0	e1 	. 
	pop bc			;2ca1	c1 	. 
	ld a,00fh		;2ca2	3e 0f 	> . 
	call sub_3abah		;2ca4	cd ba 3a 	. . : 
	ret			;2ca7	c9 	. 

 ifdef VER_12
	adc a,b			;2ca8	88 	. 
	sbc a,d			;2ca9	9a 	. 
 else ; VER_20
	jr nc,$-97		;2ca8	30 9d 	0 . 
 endif


; ********************************************************************************
; [TRS] BASIC PEEK Entry Point
FuncPEEK
	call FuncCINT		; convert ACC to integer	;2caa	cd 7f 0a 	.  . 
	ld a,(hl)			;2cad	7e 	~ 
	jp ByteToAcc	; Copy a to ACC		;2cae	c3 f8 27 	. . ' 


; **********************************************************************************
; BASIC POKE Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdPOKE
	call EvalIntExpr	; load integer expression ito de register			;2cb1	cd 02 2b 	. . + 
	push de			;2cb4	d5 	. 
	rst $08			; Assert next token is ',' ;2cb5	cf 	. 
	defb ','		; Basic ',' token 	;2cb6	2c 	, 
	call EvalByteExpr	; expression ACC, de and a - must be 8bit value	;2cb7	cd 1c 2b 	. . + 
	pop de			;2cba	d1 	. 
	ld (de),a			;2cbb	12 	. 
	ret			;2cbc	c9 	. 
l2cbdh:
	call sub_2338h		;2cbd	cd 38 23 	. 8 # 
	call AssertACCIsString	; Assert ACC contains String	;2cc0	cd f4 0a 	. . . 
	rst $08			; Assert next token is ';' ;2cc3	cf 	. 
	defb ';'		; Basic ';' token - End of statement	;2cc4	3b 	; 
	ex de,hl			;2cc5	eb 	. 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2cc6	2a 21 79 	* ! y 
	jr l2cd3h		;2cc9	18 08 	. . 
l2ccbh:
	ld a,(BAS_PrintUsingDelim)	; delimiter for PRINT USING		;2ccb	3a de 78 	: . x 
	or a			;2cce	b7 	. 
l2ccfh:
	jr z,l2cddh		;2ccf	28 0c 	( . 
	pop de			;2cd1	d1 	. 
	ex de,hl			;2cd2	eb 	. 
l2cd3h:
	push hl			;2cd3	e5 	. 
	xor a			;2cd4	af 	. 
	ld (BAS_PrintUsingDelim),a	; delimiter for PRINT USING		;2cd5	32 de 78 	2 . x 
	cp d			;2cd8	ba 	. 
	push af			;2cd9	f5 	. 
	push de			;2cda	d5 	. 
	ld b,(hl)			;2cdb	46 	F 
	or b			;2cdc	b0 	. 
l2cddh:
	jp z,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2cdd	ca 4a 1e 	. J . 
	inc hl			;2ce0	23 	# 
	ld c,(hl)			;2ce1	4e 	N 
	inc hl			;2ce2	23 	# 
	ld h,(hl)			;2ce3	66 	f 
	ld l,c			;2ce4	69 	i 
	jr l2d03h		;2ce5	18 1c 	. . 
l2ce7h:
	ld e,b			;2ce7	58 	X 
	push hl			;2ce8	e5 	. 
	ld c,002h		;2ce9	0e 02 	. . 
l2cebh:
	ld a,(hl)			;2ceb	7e 	~ 
	inc hl			;2cec	23 	# 
	cp 025h		;2ced	fe 25 	. % 
	jp z,02e17h		;2cef	ca 17 2e 	. . . 
	cp 020h		;2cf2	fe 20 	.   
	jr nz,l2cf9h		;2cf4	20 03 	  . 
	inc c			;2cf6	0c 	. 
	djnz l2cebh		;2cf7	10 f2 	. . 
l2cf9h:
	pop hl			;2cf9	e1 	. 
	ld b,e			;2cfa	43 	C 
	ld a,025h		;2cfb	3e 25 	> % 
l2cfdh:
	call sub_2e49h		;2cfd	cd 49 2e 	. I . 
	call PrintChar	; Print  char on screen		;2d00	cd 2a 03 	. * . 
l2d03h:
	xor a			;2d03	af 	. 
	ld e,a			;2d04	5f 	_ 
	ld d,a			;2d05	57 	W 
l2d06h:
	call sub_2e49h		;2d06	cd 49 2e 	. I . 
	ld d,a			;2d09	57 	W 
	ld a,(hl)			;2d0a	7e 	~ 
	inc hl			;2d0b	23 	# 
	cp 021h		;2d0c	fe 21 	. ! 
	jp z,l2e14h		;2d0e	ca 14 2e 	. . . 
	cp 023h		;2d11	fe 23 	. # 
	jr z,l2d4ch		;2d13	28 37 	( 7 
	dec b			;2d15	05 	. 
	jp z,l2dfeh		;2d16	ca fe 2d 	. . - 
	cp 02bh		;2d19	fe 2b 	. + 
	ld a,008h		;2d1b	3e 08 	> . 
	jr z,l2d06h		;2d1d	28 e7 	( . 
	dec hl			;2d1f	2b 	+ 
	ld a,(hl)			;2d20	7e 	~ 
	inc hl			;2d21	23 	# 
	cp 02eh		;2d22	fe 2e 	. . 
	jr z,l2d66h		;2d24	28 40 	( @ 
	cp 025h		;2d26	fe 25 	. % 
	jr z,l2ce7h		;2d28	28 bd 	( . 
	cp (hl)			;2d2a	be 	. 
	jr nz,l2cfdh		;2d2b	20 d0 	  . 
	cp 024h		;2d2d	fe 24 	. $ 
	jr z,$+22		;2d2f	28 14 	( . 
	cp 02ah		;2d31	fe 2a 	. * 
	jr nz,l2cfdh		;2d33	20 c8 	  . 
	ld a,b			;2d35	78 	x 
	cp 002h		;2d36	fe 02 	. . 
	inc hl			;2d38	23 	# 
	jr c,l2d3eh		;2d39	38 03 	8 . 
	ld a,(hl)			;2d3b	7e 	~ 
	cp 024h		;2d3c	fe 24 	. $ 
l2d3eh:
	ld a,020h		;2d3e	3e 20 	>   
	jr nz,l2d49h		;2d40	20 07 	  . 
	dec b			;2d42	05 	. 
	inc e			;2d43	1c 	. 
	cp 0afh		;2d44	fe af 	. . 
	add a,010h		;2d46	c6 10 	. . 
	inc hl			;2d48	23 	# 
l2d49h:
	inc e			;2d49	1c 	. 
	add a,d			;2d4a	82 	. 
	ld d,a			;2d4b	57 	W 
l2d4ch:
	inc e			;2d4c	1c 	. 
	ld c,000h		;2d4d	0e 00 	. . 
	dec b			;2d4f	05 	. 
	jr z,l2d99h		;2d50	28 47 	( G 
	ld a,(hl)			;2d52	7e 	~ 
	inc hl			;2d53	23 	# 
	cp 02eh		;2d54	fe 2e 	. . 
	jr z,l2d70h		;2d56	28 18 	( . 
	cp 023h		;2d58	fe 23 	. # 
	jr z,l2d4ch		;2d5a	28 f0 	( . 
	cp 02ch		;2d5c	fe 2c 	. , 
	jr nz,l2d7ah		;2d5e	20 1a 	  . 
	ld a,d			;2d60	7a 	z 
	or 040h		;2d61	f6 40 	. @ 
	ld d,a			;2d63	57 	W 
	jr l2d4ch		;2d64	18 e6 	. . 
l2d66h:
	ld a,(hl)			;2d66	7e 	~ 
	cp 023h		;2d67	fe 23 	. # 
	ld a,02eh		;2d69	3e 2e 	> . 
	jr nz,l2cfdh		;2d6b	20 90 	  . 
	ld c,001h		;2d6d	0e 01 	. . 
	inc hl			;2d6f	23 	# 
l2d70h:
	inc c			;2d70	0c 	. 
	dec b			;2d71	05 	. 
	jr z,l2d99h		;2d72	28 25 	( % 
	ld a,(hl)			;2d74	7e 	~ 
	inc hl			;2d75	23 	# 
	cp 023h		;2d76	fe 23 	. # 
	jr z,l2d70h		;2d78	28 f6 	( . 
l2d7ah:
	push de			;2d7a	d5 	. 
	ld de,02d97h		;2d7b	11 97 2d 	. . - 
	push de			;2d7e	d5 	. 
	ld d,h			;2d7f	54 	T 
	ld e,l			;2d80	5d 	] 
	cp 05bh		;2d81	fe 5b 	. [ 
	ret nz			;2d83	c0 	. 
	cp (hl)			;2d84	be 	. 
	ret nz			;2d85	c0 	. 
	inc hl			;2d86	23 	# 
	cp (hl)			;2d87	be 	. 
	ret nz			;2d88	c0 	. 
	inc hl			;2d89	23 	# 
	cp (hl)			;2d8a	be 	. 
	ret nz			;2d8b	c0 	. 
	inc hl			;2d8c	23 	# 
	ld a,b			;2d8d	78 	x 
	sub 004h		;2d8e	d6 04 	. . 
	ret c			;2d90	d8 	. 
	pop de			;2d91	d1 	. 
	pop de			;2d92	d1 	. 
	ld b,a			;2d93	47 	G 
	inc d			;2d94	14 	. 
	inc hl			;2d95	23 	# 
	jp z,0d1ebh		;2d96	ca eb d1 	. . . 
l2d99h:
	ld a,d			;2d99	7a 	z 
	dec hl			;2d9a	2b 	+ 
	inc e			;2d9b	1c 	. 
	and 008h		;2d9c	e6 08 	. . 
	jr nz,l2db5h		;2d9e	20 15 	  . 
	dec e			;2da0	1d 	. 
	ld a,b			;2da1	78 	x 
	or a			;2da2	b7 	. 
	jr z,l2db5h		;2da3	28 10 	( . 
	ld a,(hl)			;2da5	7e 	~ 
	sub 02dh		;2da6	d6 2d 	. - 
	jr z,l2db0h		;2da8	28 06 	( . 
	cp 0feh		;2daa	fe fe 	. . 
	jr nz,l2db5h		;2dac	20 07 	  . 
	ld a,008h		;2dae	3e 08 	> . 
l2db0h:
	add a,004h		;2db0	c6 04 	. . 
	add a,d			;2db2	82 	. 
	ld d,a			;2db3	57 	W 
	dec b			;2db4	05 	. 
l2db5h:
	pop hl			;2db5	e1 	. 
	pop af			;2db6	f1 	. 
	jr z,l2e09h		;2db7	28 50 	( P 
	push bc			;2db9	c5 	. 
	push de			;2dba	d5 	. 
	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;2dbb	cd 37 23 	. 7 # 
	pop de			;2dbe	d1 	. 
	pop bc			;2dbf	c1 	. 
	push bc			;2dc0	c5 	. 
	push hl			;2dc1	e5 	. 
	ld b,e			;2dc2	43 	C 
	ld a,b			;2dc3	78 	x 
	add a,c			;2dc4	81 	. 
	cp 019h		;2dc5	fe 19 	. . 
	jp nc,ErrRaiseFuncCode	; raise FUNCTION CODE Error			;2dc7	d2 4a 1e 	. J . 
	ld a,d			;2dca	7a 	z 
	or 080h			; format flag (bit3) - force sign (+/-) in front ;2dcb	f6 80 	. . 
	call NumToStrFmt	; ; Convert value from ACC (Any) to String in Buffer (SysyConvBuffer)		;2dcd	cd be 0f 	. . . 
	call PrintBasicStr	; print null termianted or quoted string from (hl) on Screen		;2dd0	cd a7 28 	. . ( 
l2dd3h:
	pop hl			;2dd3	e1 	. 
	dec hl			;2dd4	2b 	+ 
	rst $10			; move hl to next Basic token				;2dd5	d7 	. 
	scf			;2dd6	37 	7 
	jr z,l2de6h		; jump if End of Statement found ;2dd7	28 0d 	( . 
	ld (BAS_PrintUsingDelim),a	; delimiter for PRINT USING		;2dd9	32 de 78 	2 . x 
	cp ';'		;2ddc	fe 3b 	. ; 
	jr z,l2de5h		;2dde	28 05 	( . 
	cp ','		            ; is it ',' char ? ;2de0	fe 2c 	. , 
	jp nz,ErrRaiseSyntax	; no - Raise 'SYNTAX ERROR'	;2de2	c2 97 19 	. . . 
l2de5h:
	rst $10			; move hl to next Basic token				;2de5	d7 	. 
l2de6h:
	pop bc			;2de6	c1 	. 
	ex de,hl			;2de7	eb 	. 
	pop hl			;2de8	e1 	. 
	push hl			;2de9	e5 	. 
	push af			;2dea	f5 	. 
	push de			;2deb	d5 	. 
	ld a,(hl)			;2dec	7e 	~ 
	sub b			;2ded	90 	. 
	inc hl			;2dee	23 	# 
	ld c,(hl)			;2def	4e 	N 
	inc hl			;2df0	23 	# 
	ld h,(hl)			;2df1	66 	f 
	ld l,c			;2df2	69 	i 
	ld d,000h		;2df3	16 00 	. . 
	ld e,a			;2df5	5f 	_ 
	add hl,de			;2df6	19 	. 
	ld a,b			;2df7	78 	x 
	or a			;2df8	b7 	. 
	jp nz,l2d03h		;2df9	c2 03 2d 	. . - 
	jr l2e04h		;2dfc	18 06 	. . 
l2dfeh:
	call sub_2e49h		;2dfe	cd 49 2e 	. I . 
	call PrintChar	; Print char on screen		;2e01	cd 2a 03 	. * . 
l2e04h:
	pop hl			;2e04	e1 	. 
	pop af			;2e05	f1 	. 
	jp nz,l2ccbh		;2e06	c2 cb 2c 	. . , 
l2e09h:
	call c,PrintCR	; Print CR on screen 	;2e09	dc fe 20 	. .   
	ex (sp),hl			;2e0c	e3 	. 
	call sub_29ddh		;2e0d	cd dd 29 	. . ) 
	pop hl			;2e10	e1 	. 
	jp SysSetOutAsScreen		;2e11	c3 69 21 	. i ! 
l2e14h:
	ld c,001h		;2e14	0e 01 	. . 
	ld a,0f1h		;2e16	3e f1 	> . 
	dec b			;2e18	05 	. 
	call sub_2e49h		;2e19	cd 49 2e 	. I . 
	pop hl			;2e1c	e1 	. 
	pop af			;2e1d	f1 	. 
	jr z,l2e09h		;2e1e	28 e9 	( . 
	push bc			;2e20	c5 	. 
	call EvalExpr	; evaluate expression pointed by hl and store in ACC		;2e21	cd 37 23 	. 7 # 
	call AssertACCIsString	; Assert ACC contains String	;2e24	cd f4 0a 	. . . 
	pop bc			;2e27	c1 	. 
	push bc			;2e28	c5 	. 
	push hl			;2e29	e5 	. 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2e2a	2a 21 79 	* ! y 
	ld b,c			;2e2d	41 	A 
	ld c,000h		;2e2e	0e 00 	. . 
	push bc			;2e30	c5 	. 
	call 02a68h		;2e31	cd 68 2a 	. h * 
	call PrintACCStr; print Basic String from ACC on screen			;2e34	cd aa 28 	. . ( 
	ld hl,(ACC_SNG)	 ; Int,Single,String (2 or 4 bytes): 	;2e37	2a 21 79 	* ! y 
	pop af			;2e3a	f1 	. 
	sub (hl)			;2e3b	96 	. 
	ld b,a			;2e3c	47 	G 
	ld a,020h		;2e3d	3e 20 	>   
	inc b			;2e3f	04 	. 
l2e40h:
	dec b			;2e40	05 	. 
	jp z,l2dd3h		;2e41	ca d3 2d 	. . - 
	call PrintChar	; Print  char on screen		;2e44	cd 2a 03 	. * . 
	jr l2e40h		;2e47	18 f7 	. . 
sub_2e49h:
	push af			;2e49	f5 	. 
	ld a,d			;2e4a	7a 	z 
	or a			;2e4b	b7 	. 
	ld a,'+'		;2e4c	3e 2b 	> + 
	call nz,PrintChar	; Print '+' char on screen		;2e4e	c4 2a 03 	. * . 
	pop af			;2e51	f1 	. 
	ret			;2e52	c9 	. 
; IN: bc - start of Basic Line record
PrintBasicLine:
; -- copy Basic Line Record address from bc to hl
	ld h,b			    ; High Byte of Basic Line address                       ;2e53	60 	` 
	ld l,c			    ; Low Byte of Basic Line address                        ;2e54	69 	i 
; -- skip header data: Next Line Address and Line Number
	inc hl			    ; skip Low Byte of Next Line Address                    ;2e55	23 	# 
	inc hl			    ; skip High Byte of Next Line Address                   ;2e56	23 	# 
	inc hl			    ; skip Low Byte of Line Number                          ;2e57	23 	# 
	inc hl			    ; skip High Byte of Line Number                         ;2e58	23 	# 
	call DetokenizeLine	; detokenize Basic Line into LineBuffer	                ;2e59	cd 7e 2b 	. ~ + 
	ld hl,(LINEBUFPTR)	; address of Line Buffer with text of Basic Line	    ;2e5c	2a a7 78 	* . x 
	call PrintCStr	    ; Print Line Buffer to screen or printer	            ;2e5f	cd 75 2b 	. u + 
	ret			        ; ----------------- End of Proc ----------------------- ;2e62	c9 	. 


; ****************************************************************************************
; BASIC MODE Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdMODE
; -- assert next char is '('
	rst $08				; Assert next token is '(' 								;2e63	cf 	. 
	defb '('			; Basic '(' token 										;2e64	28 cd 	( . 
; -- parse argument
	call EvalByteExpr	; expression ACC, de and a - must be 8bit value			;2e65	cd 1c 2b	. 
	or a				; test if argument is '0'?								;2e68	b7 	. 
	jr z,.mode0			; yes - MODE(0)											;2e69	28 12 	( . 
	dec a				; test if argument is '1'?								;2e6b	3d 	= 
	jr z,.mode1			; yes - MODE (1)										;2e6c	28 03 	( . 
; -- invalid argument value 
	jp ErrRaiseFuncCode	; raise FUNCTION CODE Error	---------------------------	;2e6e	c3 4a 1e 	. J . 
.mode1:
	ld d,$00			; byte to fill VRAM - all pixels off					;2e71	16 00 	. . 
	ld a,(IOLATCH_COPY)	; get last value written to IO_LATCH  					;2e73	3a 3b 78 	: ; x 
	or %00001000		; set bit 3 - Gfx Mode 1 								;2e76	f6 08 	. . 
	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH				;2e78	32 3b 78 	2 ; x 
	jr .commit			; commit change to hardware register					;2e7b	18 0a 	. . 
.mode0:
	ld d,020h			; char to fill VRAM - Space char						;2e7d	16 20 	.   
	ld a,(IOLATCH_COPY)	; get last value written to IO_LATCH  					;2e7f	3a 3b 78 	: ; x 
	and %11110111		; clear bit 3 - Gfx Mode 0 								;2e82	e6 f7 	. . 
	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH				;2e84	32 3b 78 	2 ; x 
.commit:
	ld (IO_LATCH),a		; store in hardware register							;2e87	32 00 68 	2 . h 
; -- mode changed - clear screen (fiil VRAM with predefined char/byte)
	push hl				; save hl												;2e8a	e5 	. 
	ld hl,VRAM			; hl - start of screen memory							;2e8b	21 00 70 	! . p 
	ld bc,$800			; 2k bytes of whole VRAM								;2e8e	01 00 08 	. . . 
.next:
	ld a,d				; a - char/byte to fill VRAM							;2e91	7a 	z 
	ld (hl),a			; set byte in VRAM										;2e92	77 	w 
	inc hl				; points to next byte									;2e93	23 	# 
	dec bc				; decrement byte counter 								;2e94	0b 	. 
	ld a,b				; high byte of counter									;2e95	78 	x 
	or c				; is it 0 ?												;2e96	b1 	. 
	jr nz,.next			; no - fill all 2048 bytes								;2e97	20 f8 	  . 
	pop hl				; restore hl 											;2e99	e1 	. 
; -- assert next token is ')'
	rst $08				; Assert next token is ')' 								;2e9a	cf 	. 
	defb ')'			; Basic ')' token 										;2e9b	29 	) 
	ret					; ----------------- End of Proc -----------------------	;2e9c	c9 	. 


; (cont) Detokenize line
; IN: a - char or token from basic line (also stored in Edit Buffer) 
;     hl - (src) address of next char 
;     bc - (dst) address of current char in Buffer
l2e9dh:
; -- check if it is string literal
	cp '"'				; is it '"' (start of string literal)?					;2e9d	fe 22 	. " 
	jp z,l2eb3h			; yes - copy chars until '\0' or '"' found				;2e9f	ca b3 2e 	. . . 
; -- can be token when (a < 0) or char (literal data)
	or a				; is it Basic Token (a < 0 or bit7 is set)?				;2ea2	b7 	. 
	jp p,l2b89h			; no - process as char data 							;2ea3	f2 89 2b 	. . + 
	jp l2b94h			; yes - process as Basic Token							;2ea6	c3 94 2b 	. . + 
l2ea9h:
	ld a,(hl)			; a - char from Bacic line								;2ea9	7e 	~ 
	or a				; is it '\0' (end of line)?								;2eaa	b7 	. 
	inc hl				; points to next char of string							;2eab	23 	# 
	ld (bc),a			; store char in destination Buffer						;2eac	02 	. 
	ret z				; yes (end of line) -------- End of Proc --------------	;2ead	c8 	. 
	cp '"'				; is it '"' (end of string literal)?					;2eae	fe 22 	. " 
	jp z,l2b89h			; yes - ;2eb0	ca 89 2b 	. . + 

l2eb3h:
	inc bc				; points to next address in Buffer (dst) 				;2eb3	03 	. 
	dec d				; decrement number of chars left in destination Buffer 	;2eb4	15 	. 
	ret z				; none left ----------- End of Proc -------------------	;2eb5	c8 	. 
	jr l2ea9h			; ;2eb6	18 f1 	. . 



; ****************************************************************************
; Main Interrupt Handler
CpuINTHandler:
; Save Cpu Registers
	push af				; save AF on stack 									;2eb8	f5 	. 
	push bc				; save BC on stack 									;2eb9	c5 	. 
	push de				; save DE on stack									;2eba	d5 	. 
	push hl				; save HL on stack									;2ebb	e5 	. 
; -- call System Update routines
	call OnCpuINT		; call extension hook								;2ebc	cd 7d 78 	. } x 
 ifdef VER_12
	call sub_30e8h		;2ebf	cd e8 30 	. . 0 
 else
 	call sub_3f7bh		;2ebf	cd 7b 3f 	. { ? 
 endif


	call sub_2edch		;2ec2	cd dc 2e 	. . . 
	call l2efdh		;2ec5	cd fd 2e 	. . . 



; --
	push af				; save af											;2ec8	f5 	. 
	ld hl,SYSFLAGS	; System flags	;2ec9	21 39 78 	! 9 x 
	bit 0,(hl)		;2ecc	cb 46 	. F 
	call z,sub_301bh		;2ece	cc 1b 30 	. . 0 
	pop af				; restore af										;2ed1	f1 	. 
	call sub_3430h		;2ed2	cd 30 34 	. 0 4 
	pop hl			;2ed5	e1 	. 
	pop de			;2ed6	d1 	. 
	pop bc			;2ed7	c1 	. 
	pop af			;2ed8	f1 	. 
	ei			;2ed9	fb 	. 
	reti		;2eda	ed 4d 	. M 
sub_2edch:
	ld a,(SYSFLAGS)		;2edc	3a 39 78 	: 9 x 
	bit 0,a		;2edf	cb 47 	. G 
	ret nz			;2ee1	c0 	. 
; -- decrement Cursor Inverse Timer 
	ld hl,CURSORTIMER	; timer for inverse char under cursor					;2ee2	21 41 78 	! A x 
	dec (hl)			; decrement timer - time for inverse?					;2ee5	35 	5 
	ret nz				; no -------------------- End of Proc -----------------	;2ee6	c0 	. 
; -- reset timer
	ld a,16				; initial timer value									;2ee7	3e 10 	> . 
	ld (CURSORTIMER),a	; reset timer											;2ee9	32 41 78 	2 A x 
; -- inverse char under cursor
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 								;2eec	2a 20 78 	*   x 
	ld a,%01000000		; bit 6 of char (char inverse color) 					;2eef	3e 40 	> @ 
	xor (hl)			; a - inverted char										;2ef1	ae 	. 
	ld (hl),a			; store directly in VRAM								;2ef2	77 	w 
	ret					; ----------------------- End of Proc -----------------	;2ef3	c9 	. 



; *****************************************************************************
					ASSERT($==$2ef4)
// Keyboard Device Handler
; IN: ix - Keyboard Device Control Block address
;     FLAGS - 
KBD_DevHandler:
	call l2efdh		;2ef4	cd fd 2e 	. . . 
	push af			;2ef7	f5 	. 
	call sub_2f0eh		;2ef8	cd 0e 2f 	. . / 
	pop af			;2efb	f1 	. 
	ret			;2efc	c9 	. 


l2efdh:
	ld a,(KEYS_MATRIX)		; read all keys at once								;2efd	3a 00 68 	: . h 
	or %11000000			; set bits 7,6 (not used by keyboards)				;2f00	f6 c0 	. . 
	cpl						; invert bits (pressed key makes bit set now)		;2f02	2f 	/ 
	cp %00000000			; check if any key is pressed (0 means none)		;2f03	fe 00 	. . 
	jr z,sub_2f0eh			; no - ;2f05	28 07 	( . 
; -- some key(s) pressed
	call ScanKeyMatrix		; scan Keyboard Matrix								;2f07	cd 28 2f 	. ( / 
	or a					; is Key detected (except Shift, Ctrl, Function)	;2f0a	b7 	. 
	jp nz,l05d7h			; yes - ;2f0b	c2 d7 05 	. . . 

sub_2f0eh:
	ld hl,KEYSFLAGS	    ; Keyboard's current State						;2f0e	21 38 78 	! 8 x 
	bit 2,(hl)				; is FUNCTION mode active							;2f11	cb 56 	. V 
	jr z,l2f1dh				; no - ;2f13	28 08 	( . 
	ld a,(KEYS_DEBOUNCER)	; read Key Debounce Counter							;2f15	3a 3a 78 	: : x 
	or a					; is any Key pressed but not reported yet (a > 0)	;2f18	b7 	. 
	jr z,l2f1dh				; no - ;2f19	28 02 	( . 
; -- yes - we have incomming Key 
	res 2,(hl)				; clear Key Modifier bit 2 - FUNCTION not active	;2f1b	cb 96 	. . 
l2f1dh:
	ld a,(hl)				; read Key Modifier									;2f1d	7e 	~ 
	and %00000110			; clear except Function and ??? 					;2f1e	e6 06 	. . 
	ld (KEYSFLAGS),a	; save changed modifiers							;2f20	32 38 78 	2 8 x 
	xor a				;2f23	af 	. 
	ld (KEYCODE1),a		;2f24	32 36 78 	2 6 x 
	ret			;2f27	c9 	. 

// ************************************************************************
; Scan Keyboard Matrix
ScanKeyMatrix:
	ld hl,KEYS_ROW_0	; start with selecting Keyboard Row 0							;2f28	21 fe 68 	! . h 
	ld c,8				; number of Keyboard Rows to scan 								;2f2b	0e 08 	. . 
l2f2dh:
	ld b,6				; number of Keyboard Columns (bits) to scan						;2f2d	06 06 	. . 
	ld a,(hl)			; read Keyboard Row (pressed key makes bit 0)					;2f2f	7e 	~ 
	or %00000100		; ignore bit 3 (keys CTRL, SHIFT, RETURN, :)					;2f30	f6 04 	. . 
l2f32h:
	rra					; rotate byte - bit 0 into CY									;2f32	1f 	. 
	jr nc,l2f62h		; jump if bit 0 - key pressed 									;2f33	30 2d 	0 - 
; IN: c - Keyboard Row (8..1)
;     b - bit number (6..1)
;     hl - Keyborad Matrix Row address
sub_2f35h:
	djnz l2f32h			; check next bit in current row									;2f35	10 fb 	. . 
; -- all bits checked in this row - calculate next row address
	rlc l				; shift bits in address LSB (ie: FE => FD, BF => 7F, etc) 		;2f37	cb 05 	. . 
	dec c				; decrement current Keyboard Row and check if 0 (all scanned)	;2f39	0d 	. 
	jr nz,l2f2dh		; repeat scan for all 8 rows									;2f3a	20 f1 	  . 
; -- all Keyboard Rows scanned - check extra keys: ':','-' and RETURN
	ld b,4				; set bit number to 4 											;2f3c	06 04 	. . 
	ld hl,KEYS_ROW_5	; select Keyboard row with '-'									;2f3e	21 df 68 	! . h 
	ld a,(hl)			; read Keyboard Row												;2f41	7e 	~ 
	bit 2,a				; is '-' key pressed											;2f42	cb 57 	. W 
	jr z,l2f56h			; yes - set row and bits, convert to Ascii and Exit 			;2f44	28 10 	( . 
	rlc l				; shift bits in address => select Keyboard Row with RETURN		;2f46	cb 05 	. . 
	ld a,(hl)			; read Keyboard row												;2f48	7e 	~ 
	bit 2,a				; is RETURN pressed												;2f49	cb 57 	. W 
	jr z,l2f5ah			; yes - set row and bits, convert to Ascii and Exit				;2f4b	28 0d 	( . 
	rlc l				; shift bits in address => select Keyboard Row with ':'			;2f4d	cb 05 	. . 
	ld a,(hl)			; read Keyboard row												;2f4f	7e 	~ 
	bit 2,a				; is ':' key pressed											;2f50	cb 57 	. W 
	jr z,l2f5eh			; yes - set row and bits, convert to Ascii and Exit				;2f52	28 0a 	( . 
	xor a				; set return value 0 - no key pressed							;2f54	af 	. 
	ret					; ------------------ End of Proc ------------------------------	;2f55	c9 	. 
l2f56h:
	ld c,3				; set keyboard row 3 (with '-' char)							;2f56	0e 03 	. . 
	jr l2f60h			; set bit 2 - detected key '-'									;2f58	18 06 	. . 
l2f5ah:
	ld c,2				; set keyboard row 2 (with RETURN key)							;2f5a	0e 02 	. . 
	jr l2f60h			; set bit 2 - detected Key RETURN								;2f5c	18 02 	. . 
l2f5eh:
	ld c,1			; set keyboard row 1 (with ':' key)							;2f5e	0e 01 	. . 
l2f60h:
	or %00000100	; set bit 2 - detected key (':','-' or RETURN)				;2f60	f6 04 	. . 


; ************************************************************************************
; Key Pressed
; IN: b - bit number (6..1)
;	  c - row number (8..1)
;	  hl - address of Keyboard row scanned
;     a - bits read from Keyboard row 
;     CY - 0 (key pressed)
l2f62h:
	ld e,a			; save a - bits read from Keyboard Row					;2f62	5f 	_ 
; calculate scan code byte: bits 7-3 - bit number, bits 2-0 - matrix row

; -- normalize bit number
	ld a,6			; normalize bit number from (6..1) to (0..5)				;2f63	3e 06 	> . 
	sub b			; a - bit number for pressed key (0..5)						;2f65	90 	. 
	sla a			; shift left bit number 										;2f66	cb 27 	. ' 
	sla a			; shift left bit number 										;2f68	cb 27 	. ' 
	sla a			; shift left bit number => bit number on bits 7-3				;2f6a	cb 27 	. ' 
; -- normalize row number and add to scan code
	add a,8			; normalize row number from (8..1) to (0..7)					;2f6c	c6 08 	. . 
	sub c			; a - scan code with row and bit number							;2f6e	91 	. 

; -- save data about detected key
	ld (KEYS_SCAN_COORDS),bc		; b - bit number (6..1), c - row number (8..1)					;2f6f	ed 43 42 78 	. C B x 
	ld (KEYS_SCAN_ROWADR),hl		; save address of Keyboard row with scanned key	;2f73	22 44 78 	" D x 

; -- determine proper Key to Ascii/Command Table
	ld hl,TabKey2Char		; normal ScanCode to ASCII Table (default)				;2f76	21 d9 01 	! . . 
	ld c,a					; copy ScanCode to C											;2f79	4f 	O 
	ld b,0					; bc - key index in ScanCode to Ascii Table						;2f7a	06 00 	. . 
; -- check if Shift Key is pressed
	ld a,(KEYS_ROW_SHIFT)	; read keyboard row with Shift Key						;2f7c	3a fb 68 	: . h 
	bit 2,a					; is Shift pressed										;2f7f	cb 57 	. W 
	jr nz,.CheckCTRLKey		; no - check Ctrl Key									;2f81	20 0a 	  . 
; -- mark Shift Modifier Active
	ld hl,KEYSFLAGS	    ; Keyboard current State											;2f83	21 38 78 	! 8 x 
	set 0,(hl)				; set bit 0 (Shift is pressed)									;2f86	cb c6 	. . 
	ld hl,TabShiftKey2Char	; Shift ScanCode to ASCII Table							;2f88	21 09 02 	! . . 
	jr l2fcah_ExitWithKey	; convert Key to Char and return to caller 	            ;2f8b	18 3d 	. = 
.CheckCTRLKey:
	ld a,(KROW_CTRL)	; read keyboard row with Ctrl Key						;2f8d	3a fd 68 	: . h 
	bit 2,a					; is Ctrl pressed										;2f90	cb 57 	. W 
	jr nz,l2fcdh			; no - ;2f92	20 39 	  9 
; -- Ctrl Key is pressed
	ld a,(KEYS_ROW_INVERSE)	; read keyboard row with Inverse Key					;2f94	3a 7f 68 	:  h 
	bit 2,a					; is Inverse also pressed								;2f97	cb 57 	. W 
	jr nz,l2fa9h			; no - ;2f99	20 0e 	  . 
; -- Ctrl + Inverse is pressed
	ld hl,KEYSFLAGS	    ; Keyboard current State								;2f9b	21 38 78 	! 8 x 
	bit 5,(hl)				; is bit 5 (???) set? ;2f9e	cb 6e 	. n 
	jr nz,l2fa6h_Exit_noKey	; no - exit with no key pressed	                        ;2fa0	20 04 	  . 
; flip bit 1 and 5 
	ld a,(hl)				; a - Keyboard current State										;2fa2	7e 	~ 
	xor %00100010			; flip (clear) bits 1 and 5										;2fa3	ee 22 	. " 
	ld (hl),a				; store new value										;2fa5	77 	w 
l2fa6h_Exit_noKey:
	xor a					; set return value 0 (no key pressed)					;2fa6	af 	. 
	pop bc					; restore BC											;2fa7	c1 	. 
	ret						; ---------- End of Proc ------------------------------ ;2fa8	c9 	. 

; -- Ctrl key is pressed
l2fa9h:
	ld hl,KEYSFLAGS	    ; Keyboard current State								;2fa9	21 38 78 	! 8 x 
	set 7,(hl)				; set bit 7 (CTRL is pressed)						    ;2fac	cb fe 	. . 
	bit 2,(hl)				; check if bit 2 (Function) is active					;2fae	cb 56 	. V 
	jr z,.CheckCtrlFunc		; no - check if now Function (RETURN) is pressed        ;2fb0	28 05 	( . 

; -- Function Mode is Active - convert Key to BASIC Funcion byte and Exit
	ld hl,TabCtrlKey2Func	; Control Key to BASIC Function Table					;2fb2	21 69 02 	! i . 
	jr l2fcah_ExitWithKey	; convert Key to Function and return to caller			;2fb5	18 13 	. . 

; -- Ctrl key is pressed (Function Inactive)
.CheckCtrlFunc:
	ld a,(KEYS_ROW_RETURN)	; read keyboard row with RETURN/FUNCTION Key			;2fb7	3a bf 68 	: . h 
	bit 2,a					; is RETURN + Ctrl pressed (FUNCTION)					;2fba	cb 57 	. W 
	jr nz,.ExitWithCtrlAndKey; no - set FUNCTION Inactive and get just Ctrl+Key		;2fbc	20 07 	  . 
; -- mark FUNCTION pressed
	set 2,(hl)				; set bit 2 (FUNCTION is Active)			            ;2fbe	cb d6 	. . 
	xor a					; set return value 0 - no key pressed					;2fc0	af 	. 
	ld (KEYS_DEBOUNCER),a	; reset Key Debounce Counter							;2fc1	32 3a 78 	2 : x 
	ret						; return to caller - no key pressed						;2fc4	c9 	. 
.ExitWithCtrlAndKey:
	res 2,(hl)				; clear Key Modifier bit 2 - FUNCTION is not active 	;2fc5	cb 96 	. . 
	ld hl,TabCtrlKey2Cmd	; convert Key to BASIC Command and return to caller	;2fc7	21 39 02 	! 9 . 
l2fcah_ExitWithKey:
; IN: hl - address of Key to Char Conversion Table
;     bc - index of key (scancode)
	add hl,bc			; calculate address of Char for Key pressed					;2fca	09 	. 
	ld a,(hl)			; a - Char from Keyboard									;2fcb	7e 	~ 
	ret					; ----------- End of Proc --------------------------------- ;2fcc	c9 	. 

; both Shift and Ctrl aren't pressed at this time
l2fcdh:
	ld a,(KEYSFLAGS)	    ; get Keyboard current State							;2fcd	3a 38 78 	: 8 x 
	and %10000001			; check bit 7 (CTRL) and bit 0 (Shift)					;2fd0	e6 81 	. . 
	jr z,l2fcah_ExitWithKey	; none - get Char from table and Exit					;2fd2	28 f6 	( . 
	xor a					; set no key pressed									;2fd4	af 	. 
	pop hl			;2fd5	e1 	. 
	ret			;2fd6	c9 	. 
l2fd7h:
	ld hl,KEYSFLAGS		; Keyboard current State                                ;2fd7	21 38 78 	! 8 x 
	bit 5,(hl)		        ; check if bit 5 (???) is set ;2fda	cb 6e 	. n 
	jr z,l3003h		        ; no - ;2fdc	28 25 	( % 
; -- bit 5 (???) is set
	ld a,(KEYS_DEBOUNCER)		;2fde	3a 3a 78 	: : x 
	inc a			;2fe1	3c 	< 
	ld (KEYS_DEBOUNCER),a		;2fe2	32 3a 78 	2 : x 
	cp 42		;2fe5	fe 2a 	. * 
	jr z,l2febh		;2fe7	28 02 	( . 
	xor a			;2fe9	af 	. 
	ret			;2fea	c9 	. 
l2febh:
	ld a,(hl)			    ; get Keyboard current State ;2feb	7e 	~ 
	and %11011111		    ; clear bit 5 (???) ;2fec	e6 df 	. . 
	or  %01000000		    ; set bit 6 (???) ;2fee	f6 40 	. @ 
	ld (KEYSFLAGS),a		; sore modified Keyboard State ;2ff0	32 38 78 	2 8 x 
l2ff3h:
	xor a			;2ff3	af 	. 
	ld (KEYS_DEBOUNCER),a		;2ff4	32 3a 78 	2 : x 
	bit 4,(hl)		;2ff7	cb 66 	. f 
	jr nz,l2fffh		;2ff9	20 04 	  . 
	ld a,(KEYCODE1)		;2ffb	3a 36 78 	: 6 x 
	ret			;2ffe	c9 	. 
l2fffh:
	ld a,(KEYCODE2)		;2fff	3a 37 78 	: 7 x 
	ret			;3002	c9 	. 
l3003h:
	bit 6,(hl)		;3003	cb 76 	. v 
	jr nz,l300eh		;3005	20 07 	  . 
	set 5,(hl)		;3007	cb ee 	. . 
	xor a			;3009	af 	. 
	ld (KEYS_DEBOUNCER),a		;300a	32 3a 78 	2 : x 
	ret			;300d	c9 	. 
l300eh:
	ld a,(KEYS_DEBOUNCER)		;300e	3a 3a 78 	: : x 
	inc a			;3011	3c 	< 
	ld (KEYS_DEBOUNCER),a		;3012	32 3a 78 	2 : x 
	cp 006h		;3015	fe 06 	. . 
	jr z,l2ff3h		;3017	28 da 	( . 
	xor a			;3019	af 	. 
	ret			;301a	c9 	. 

;***************************************************************************
; CPU Interrupt subroutine 
sub_301bh:
	or a			;301b	b7 	. 
	ret z			;301c	c8 	. 
	push af			;301d	f5 	. 
	call sub_3039h		;301e	cd 39 30 	. 9 0 
	pop af			;3021	f1 	. 
	cp 00dh		;3022	fe 0d 	. . 
	ret z			;3024	c8 	. 
	cp 001h		;3025	fe 01 	. . 
	ret z			;3027	c8 	. 
	ld a,(SYSFLAGS)	; System flags	;3028	3a 39 78 	: 9 x 
	bit 0,a		;302b	cb 47 	. G 
	ret nz			;302d	c0 	. 
; -- set initial value for Cursor Timer
	ld a,32				; initial timer value (twice as normal)					;302e	3e 20 	>   
	ld (CURSORTIMER),a	; reset timer for inverse char under cursor				;3030	32 41 78 	2 A x 
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 								;3033	2a 20 78 	*   x 
 ifdef VER_12
	set 6,(hl)			; set Inverse bit of char under Cursor					;3036	cb f6 	. . 
	ret					; ---------------- End of Proc ------------------------	;3038	c9 	. 
 else ; VER_20
 	jp l3eb2h		;3036	c3 b2 3e 	. . > 
 endif	
; -- IN: a = ???
sub_3039h:
	ld hl,KEYSFLAGS	; Keyboard current State	;3039	21 38 78 	! 8 x 
	bit 7,(hl)		    ; check bit 7 (CTRL is pressed) ;303c	cb 7e 	. ~ 
	jp z,sub_3157h		; no - ;303e	ca 57 31 	. W 1 

	or a			;3041	b7 	. 
	jp p,sub_3157h		;3042	f2 57 31 	. W 1 
	push af			;3045	f5 	. 
	sub 080h		;3046	d6 80 	. . 
	inc a			;3048	3c 	< 
	ld b,a			;3049	47 	G 
	ld hl,0164fh		;304a	21 4f 16 	! O . 
l304dh:
	inc hl			;304d	23 	# 
	bit 7,(hl)		;304e	cb 7e 	. ~ 
	jr z,l304dh		;3050	28 fb 	( . 
	djnz l304dh		;3052	10 f9 	. . 
	ld a,(hl)			;3054	7e 	~ 
l3055h:
	call sub_3082h		;3055	cd 82 30 	. . 0 
	ld a,(hl)			;3058	7e 	~ 
	bit 7,a		;3059	cb 7f 	.  
	jr z,l3055h		;305b	28 f8 	( . 
	pop af			;305d	f1 	. 
	ld b,22		;305e	06 16 	. . 
	ld hl,l0299h		;3060	21 99 02 	! . . 
l3063h:
	cp (hl)			;3063	be 	. 
	jr z,l307ch		;3064	28 16 	( . 
	inc hl			;3066	23 	# 
	djnz l3063h		;3067	10 fa 	. . 
	cp #b0		;3069	fe b0 	. . 
	ret nz			;306b	c0 	. 
	ld a,020h		;306c	3e 20 	>   
	call sub_3082h		;306e	cd 82 30 	. . 0 
	ld a,046h		;3071	3e 46 	> F 
	call sub_3082h		;3073	cd 82 30 	. . 0 
	ld a,04eh		;3076	3e 4e 	> N 
	call sub_3082h		;3078	cd 82 30 	. . 0 
	ret			;307b	c9 	. 
l307ch:
	ld a,028h		;307c	3e 28 	> ( 
	call sub_3082h		;307e	cd 82 30 	. . 0 
	ret			;3081	c9 	. 
sub_3082h:
	and 07fh		;3082	e6 7f 	. 
	push hl			;3084	e5 	. 
	call sub_3157h		;3085	cd 57 31 	. W 1 
	pop hl			;3088	e1 	. 
	inc hl			;3089	23 	# 
	ret			;308a	c9 	. 

; **************************************************************************************
; Print Char to Screen at current Cursor Position (and advance Cursor)
; Ensures MODE 0 for screen, ...
; IN: a - char to print
ScrPrintChar:
	push af				; save af														;308b	f5 	. 

; check if MODE 0 - if not also clear screen
	ld a,(IOLATCH_COPY); a - last value written to Hardware Register 					;308c	3a 3b 78 	: ; x 
	bit 3,a				; check if bit 3 (MC6847 AG pin) equals 0 (MODE 0)				;308f	cb 5f 	. _ 
	jr z,.modeIs0		; yes - skip change MODE and Clear Screen						;3091	28 17 	( . 

; -- change MC6847 graphics mode to 0 
	and %11110111		; clear bit 3 - set MODE 0										;3093	e6 f7 	. . 
	ld (IOLATCH_COPY),a	; save to Shadow Register for future read						;3095	32 3b 78 	2 ; x 
	ld (IO_LATCH),a		; store value to Hardware Register - force MODE 0				;3098	32 00 68 	2 . h 

; -- clear Screen Memory - set 512 bytes to ' ' ($20)
	ld bc,$200			; set counter to 512 bytes to fill								;309b	01 00 02 	. . . 
	ld hl,VRAM			; Video RAM start												;309e	21 00 70 	! . p 
.loop:
 ifdef VER_12
	ld a,' '			; a - space char												;30a1	3e 20 	>   
	ld (hl),a			; store to Video Memory											;30a3	77 	w 
 else ; VER_20
 	call sub_3ebeh		;30a1	cd be 3e 	. . > 
 endif
	inc hl				; next address													;30a4	23 	# 
	dec bc				; decrement bytes counter										;30a5	0b 	. 
	ld a,c				; test if counter (bc) is 0										;30a6	79 	y 
	or b																				;30a7	b0 	. 
	jr nz,.loop			; no - fill all 512 bytes										;30a8	20 f7 	  . 


; -- 
.modeIs0:
	pop af				; restore af - char to display on screen						;30aa	f1 	. 
	ld hl,SYSFLAGS		; System flags ;30ab	21 39 78 	! 9 x 
	bit 5,(hl)			; buffered output? ;30ae	cb 6e 	. n 
	jp z,l3106h		;30b0	ca 06 31 	. . 1 
	cp ' '				; is this printable char (greater than or equal to ' ')			;30b3	fe 20 	.   
	jp nc,l30c0h		; yes - skip ??? ;30b5	d2 c0 30 	. . 0 
; -- ???
	push af			;30b8	f5 	. 
l30b9h:
	ld a,(07aafh)		;30b9	3a af 7a 	: . z 
	or a			;30bc	b7 	. 
	jr nz,l30b9h		;30bd	20 fa 	  . 
	pop af			;30bf	f1 	. 
l30c0h:
	di					; disable interrupts											;30c0	f3 	. 
	ld hl,(07ab0h)		;30c1	2a b0 7a 	* . z 
	ld (hl),a			;30c4	77 	w 
	inc hl			;30c5	23 	# 
	ld (07ab0h),hl		;30c6	22 b0 7a 	" . z 
	ld hl,07aafh		;30c9	21 af 7a 	! . z 
	inc (hl)			;30cc	34 	4 
	push af			;30cd	f5 	. 
	ld a,(CURSORPOS)	; position of Cursor in Edited line	;30ce	3a a6 78 	: . x 
	add a,(hl)			;30d1	86 	. 
	ld (07aaeh),a		;30d2	32 ae 7a 	2 . z 
	pop af			;30d5	f1 	. 
	ei			;30d6	fb 	. 
	cp 020h		;30d7	fe 20 	.   
	jp c,l30e3h		;30d9	da e3 30 	. . 0 
	ld a,014h		;30dc	3e 14 	> . 
l30deh:
	cp (hl)			;30de	be 	. 
	jp c,l30deh		;30df	da de 30 	. . 0 
	ret			;30e2	c9 	. 
l30e3h:
	xor a			;30e3	af 	. 
l30e4h:
	cp (hl)			;30e4	be 	. 
	jr nz,l30e4h		;30e5	20 fd 	  . 
	ret			;30e7	c9 	. 
sub_30e8h:
	ld a,(07aafh)		;30e8	3a af 7a 	: . z 
	or a			;30eb	b7 	. 
	ret z			;30ec	c8 	. 
	ld b,a			;30ed	47 	G 
	ld hl,TAPEFILENAME	; tape buffer for filename (18) bytes	;30ee	21 b2 7a 	! . z 
	push hl			;30f1	e5 	. 
l30f2h:
	ld a,(hl)			;30f2	7e 	~ 
	inc hl			;30f3	23 	# 
	push hl			;30f4	e5 	. 
	push bc			;30f5	c5 	. 
	call l3106h		;30f6	cd 06 31 	. . 1 
	pop bc			;30f9	c1 	. 
	pop hl			;30fa	e1 	. 
	djnz l30f2h		;30fb	10 f5 	. . 
	pop hl			;30fd	e1 	. 
	ld (07ab0h),hl		;30fe	22 b0 7a 	" . z 
	xor a			;3101	af 	. 
	ld (07aafh),a		;3102	32 af 7a 	2 . z 
	ret			;3105	c9 	. 
l3106h:
	call ScrRefreshCursor	; refresh char at Cursor Position					;3106	cd 0d 03 	. . . 
	or a					; is 0 (null) to print   ;3109	b7 	. 
	jr z,l3110h				; yes - ;310a	28 04 	( . 
	cp #0d					; is CR to print 	;310c	fe 0d 	. . 
	jr nz,l315ah			; no - ;310e	20 4a 	  J 

; -- char to rint is 0 or CR
l3110h:
	push af					; save a 											;3110	f5 	. 
; -- get Cursor current address and position in line 
	ld hl,(CURSORADDR)	    ; hl - addres of Cursor in VRAM						;3111	2a 20 78 	*   x 
	ld a,(CURSORPOS)	    ; position of Cursor in Edited line					;3114	3a a6 78 	: . x 
	ld c,a					; c - Cursor Position								;3117	4f 	O 
	xor a					; 													;3118	af 	. 
	ld b,a					; bc - Cursor Position in line						;3119	47 	G 
; -- move Cursor to start of next line
	ld (CURSORPOS),a	    ; reset Cursor In Line to 0 (begin of line)			;311a	32 a6 78 	2 . x 
	sbc hl,bc				; hl - address of begin of line with cursor			;311d	ed 42 	. B 
	ld bc,32				; line contains 32 bytes 							;311f	01 20 00 	.   . 
	add hl,bc				; hl - address of begin of next line				;3122	09 	. 
; -- test if Cursor is out of Screen and Screen Scroll is needed
; -- in MODE 0 (text) Screen addresses are in range 7000..71ff
	ld a,h					; a - MSB of Cursor address							;3123	7c 	| 
	cp $72					; is address out of Screen							;3124	fe 72 	. r 
	call p,ScrScrollUp		; yes - scroll screen 1 line up						;3126	f4 f3 33 	. . 3 
	ld (CURSORADDR),hl		; set as new Cursor Address in VRAM                 ;3129	22 20 78 	"   x 
	call SetCursorFromHL	; update Cursor char	;312c	cd 53 00 	. S . 
	pop af			;312f	f1 	. 
	or a			;3130	b7 	. 
	ret z			;3131	c8 	. 
	call GetEditorLineFlag		;3132	cd a8 33 	. . 3 
	cp 080h		;3135	fe 80 	. . 
	ret z			;3137	c8 	. 
	cp 081h		;3138	fe 81 	. . 
	jr nz,l3141h		;313a	20 05 	  . 
	dec a			;313c	3d 	= 
	ld (hl),a			;313d	77 	w 
	inc hl			;313e	23 	# 
	ld (hl),a			;313f	77 	w 
	ret			;3140	c9 	. 
l3141h:
	ld a,080h		;3141	3e 80 	> . 
	ld (hl),a			;3143	77 	w 
	ret			;3144	c9 	. 
l3145h:
	bit 6,a		;3145	cb 77 	. w 
	jr z,l314dh		;3147	28 04 	( . 
 ifdef VER_12
	and 07fh		;3149	e6 7f 	.  
	jr l3154h		;314b	18 07 	. . 
 else ; VER_20
	jp l3f60h		;3149	c3 60 3f 	. ` ? 
	nop			;314c	00 	. 
 endif
l314dh:
	and 08fh		;314d	e6 8f 	. . 
	ld b,a			;314f	47 	G 
	ld a,(FCOLOR)	; Foreground Color	;3150	3a 46 78 	: F x 
	or b			;3153	b0 	. 
l3154h:
	ld b,a			;3154	47 	G 
	jr l31b6h		;3155	18 5f 	. _ 
sub_3157h:
	call ScrRefreshCursor		;3157	cd 0d 03 	. . . 
l315ah:
	or a			;315a	b7 	. 
	jp m,l3145h		;315b	fa 45 31 	. E 1 
	cp 00dh		;315e	fe 0d 	. . 
	ret z			;3160	c8 	. 
	cp 008h		;3161	fe 08 	. . 
	jp z,l3227h		;3163	ca 27 32 	. ' 2 
	cp 01bh		;3166	fe 1b 	. . 
	jp z,l3253h		;3168	ca 53 32 	. S 2 
	cp 00ah		;316b	fe 0a 	. . 
	jp z,l326dh		;316d	ca 6d 32 	. m 2 
	cp 008h		;3170	fe 08 	. . 
	jp z,l3227h		;3172	ca 27 32 	. ' 2 
	cp 009h		;3175	fe 09 	. . 
	jp z,l31b8h		;3177	ca b8 31 	. . 1 
	cp 001h		;317a	fe 01 	. . 
	ret z			;317c	c8 	. 
	cp 07fh		;317d	fe 7f 	. 
	jp z,l33cbh		;317f	ca cb 33 	. . 3 
	cp 015h		;3182	fe 15 	. . 
	jp z,l32c6h		;3184	ca c6 32 	. . 2 
	cp 018h		;3187	fe 18 	. . 
	jp z,l3227h		;3189	ca 27 32 	. ' 2 
	cp 019h		;318c	fe 19 	. . 
	jp z,l31b8h		;318e	ca b8 31 	. . 1 
	cp 01bh		;3191	fe 1b 	. . 
	jp z,l3253h		;3193	ca 53 32 	. S 2 
	cp $1c		;3196	fe 1c 	. . 
	jp z,CursorHome		; moves Cursor to top-left corner of Screen	;3198	ca 87 32 	. . 2 
	cp 01dh		;319b	fe 1d 	. . 
	jp z,CursorLineStart	; set Cursor at start of line						;319d	ca b4 32 	. . 2 
	cp 01fh		;31a0	fe 1f 	. . 
	jp z,ResetEditor		; clear Screen and Editor Flags						;31a2	ca 92 32 	. . 2 
	cp 020h		;31a5	fe 20 	.   
	ret m			;31a7	f8 	. 
 ifdef VER_12
	and 03fh		;31a8	e6 3f 	. ? 
	push hl			    ; save hl ;31aa	e5 	. 
 else ; VER_20
	jp l3ecah		;31a8	c3 ca 3e 	. . > 
 endif


l31abh:
	ld hl,KEYSFLAGS	; Keyboard current State	;31ab	21 38 78 	! 8 x 
	bit 1,(hl)		    ; check bit 1 (???) ;31ae	cb 4e 	. N 
	pop hl			    ; restore hl ;31b0	e1 	. 
	jr z,l31b5h		    ; not set - ;31b1	28 02 	( . 
	or 040h		;31b3	f6 40 	. @ 
l31b5h:
	ld b,a			;31b5	47 	G 
l31b6h:
	ld a,b			;31b6	78 	x 
	ld (hl),a			;31b7	77 	w 
l31b8h:
	call sub_31bfh		;31b8	cd bf 31 	. . 1 
	call UpdateCursorChar	; update Cursor Char	;31bb	cd 50 00 	. P . 
	ret			;31be	c9 	. 
sub_31bfh:
	ld a,(CURSORPOS)	; position of Cursor in Edited line	;31bf	3a a6 78 	: . x 
	inc a			    ; increment Cursor position ;31c2	3c 	< 
	cp 32		        ; is it next screen line ? ;31c3	fe 20 	.   
	jr nz,l31f2h		; no - ;31c5	20 2b 	  + 
	call GetEditorLineFlag		;31c7	cd a8 33 	. . 3 
	cp 081h		;31ca	fe 81 	. . 
	jr z,l31f1h		;31cc	28 23 	( # 
	or a			;31ce	b7 	. 
	jr nz,l3206h		;31cf	20 35 	  5 
	ld b,a			;31d1	47 	G 
	ld a,(SYSFLAGS)	; System flags	;31d2	3a 39 78 	: 9 x 
	bit 0,a		;31d5	cb 47 	. G 
	ld a,b			;31d7	78 	x 
	ret z			;31d8	c8 	. 
l31d9h:
	xor a			;31d9	af 	. 
	inc hl			;31da	23 	# 
	ld (hl),a			;31db	77 	w 
	inc hl			;31dc	23 	# 
	push hl			;31dd	e5 	. 
	ld bc,(PrgStartPtr)	; bc - address of start of BASIC program 				;31de	ed 4b a4 78 	. K . x 
	dec bc			;31e2	0b 	. 
	dec bc			;31e3	0b 	. 
	or a			;31e4	b7 	. 
	sbc hl,bc		;31e5	ed 42 	. B 
	pop hl			;31e7	e1 	. 
	jr nc,l31f1h		;31e8	30 07 	0 . 
	ld a,(hl)			;31ea	7e 	~ 
	or a			;31eb	b7 	. 
	jr nz,l31f1h		;31ec	20 03 	  . 
	ld a,080h		;31ee	3e 80 	> . 
	ld (hl),a			;31f0	77 	w 
l31f1h:
	xor a			;31f1	af 	. 
l31f2h:
	ld (CURSORPOS),a	; set new position of Cursor in Edited line	;31f2	32 a6 78 	2 . x 
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 	;31f5	2a 20 78 	*   x 
	ld bc,1		        ; 1 position to move cursor right   ;31f8	01 01 00 	. . . 
	add hl,bc			;31fb	09 	. 
	ld a,h			    ;31fc	7c 	| 
	cp $72		;31fd	fe 72 	. r 
	call p,ScrScrollUp	; yes - scroll screen and Editor 1 line Up		;31ff	f4 f3 33 	. . 3 
	ld (CURSORADDR),hl	; Cursor Address in VRAM (last line) 	;3202	22 20 78 	"   x 
	ret			;3205	c9 	. 
l3206h:
	push af			;3206	f5 	. 
	ld de,(CURSORADDR)	; Cursor Address in VRAM 		;3207	ed 5b 20 78 	. [   x 
	inc de			;320b	13 	. 
	ld a,d			;320c	7a 	z 
	cp 072h		;320d	fe 72 	. r 
	jr z,l3221h		;320f	28 10 	( . 
	push hl			;3211	e5 	. 
	ld hl,SYSFLAGS	; System flags	;3212	21 39 78 	! 9 x 
	bit 0,(hl)		;3215	cb 46 	. F 
	jr nz,l3220h		;3217	20 07 	  . 
	bit 4,(hl)		;3219	cb 66 	. f 
	jr nz,l3220h		;321b	20 03 	  . 
	call sub_332ch		;321d	cd 2c 33 	. , 3 
l3220h:
	pop hl			;3220	e1 	. 
l3221h:
	pop af			;3221	f1 	. 
	inc a			;3222	3c 	< 
	ld (hl),a			;3223	77 	w 
	jp l31d9h		;3224	c3 d9 31 	. . 1 
l3227h:
	ld a,(CURSORPOS)	; position of Cursor in Edited line	;3227	3a a6 78 	: . x 
	dec a			    ; decrement position of Cursor ;322a	3d 	= 
	jp p,l3235h		    ; jump if less than 0 ;322b	f2 35 32 	. 5 2 
l322eh:
	call GetEditorLineFlag		;322e	cd a8 33 	. . 3 
	or a			;3231	b7 	. 
	ret nz			;3232	c0 	. 
	ld a,31		;3233	3e 1f 	> . 
l3235h:
	ld (CURSORPOS),a    ; set new position of Cursor in Edited line		;3235	32 a6 78 	2 . x 
	ld bc,$0001		;3238	01 01 00 	. . . 
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 		;323b	2a 20 78 	*   x 
	xor a			;323e	af 	. 
	sbc hl,bc		;323f	ed 42 	. B 
	ld a,h			;3241	7c 	| 
	cp 070h		;3242	fe 70 	. p 
	jp c,l324eh		;3244	da 4e 32 	. N 2 
	ld (CURSORADDR),hl	; save new address of Cursor  		;3247	22 20 78 	"   x 
	call SetCursorFromHL; update Cursor char 		;324a	cd 53 00 	. S . 
	ret			;324d	c9 	. 
l324eh:
	xor a			    ; new Cursor position - begin of line                   ;324e	af 	. 
	ld (CURSORPOS),a	; reset position of Cursor to 0 (begin of Edited line)	;324f	32 a6 78 	2 . x 
	ret			        ; ------------ End of Proc ---------------------------- ;3252	c9 	. 
l3253h:
	ld hl,SYSFLAGS		; System flags ;3253	21 39 78 	! 9 x 
	bit 4,(hl)		;3256	cb 66 	. f 
	ret nz			;3258	c0 	. 
	ld bc,32		    ; 32 bytes per line ;3259	01 20 00 	.   . 
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 		;325c	2a 20 78 	*   x 
	xor a			    ;325f	af 	. 
	sbc hl,bc		;3260	ed 42 	. B 
	ld a,h			;3262	7c 	| 
	cp 070h		;3263	fe 70 	. p 
	ret m			;3265	f8 	. 
	ld (CURSORADDR),hl	; Cursor Address in VRAM 			;3266	22 20 78 	"   x 
	call SetCursorFromHL; update Cursor char		;3269	cd 53 00 	. S . 
	ret			;326c	c9 	. 
l326dh:
	ld hl,SYSFLAGS		; System flags ;326d	21 39 78 	! 9 x 
	bit 4,(hl)		;3270	cb 66 	. f 
	ret nz			;3272	c0 	. 
	ld bc,32		    ; 32 bytes per line ;3273	01 20 00 	.   . 
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 			;3276	2a 20 78 	*   x 
	add hl,bc			;3279	09 	. 
	ld a,h				; high byte of new Cursor address			;327a	7c 	| 
	cp $72				; is id outside of screen? 					;327b	fe 72 	. r 
	call p,ScrollEditorUp	; yes - scroll screen up 1 line 		;327d	f4 24 34 	. $ 4 
	ld (CURSORADDR),hl	; store new Cursor Address in VRAM 			;3280	22 20 78 	"   x 
	call SetCursorFromHL; update Cursor char		;3283	cd 53 00 	. S . 
	ret			;3286	c9 	. 



;************************************************************************************
; Moves Cursor to top-left corner of Screen
CursorHome:
	ld hl,VRAM		    ; address of top-left corner in VRAM                    ;3287	21 00 70 	! . p 
	ld (CURSORADDR),hl	; set as new Cursor Address in VRAM 			        ;328a	22 20 78 	"   x 
	xor a			    ; new Cursor position - begin of line                   ;328d	af 	. 
	ld (CURSORPOS),a    ; reset position of Cursor to 0 (begin of Edited line)	;328e	32 a6 78 	2 . x 
	ret			        ; ------------ End of Proc ---------------------------- ;3291	c9 	. 



;************************************************************************************
; Clear Screen and Editor Flags
ResetEditor:
; -- reset Cursor Screen Address
	ld hl,VRAM		    ; address of top-left corner in VRAM                    ;3292	21 00 70 	! . p 
	ld (CURSORADDR),hl	; set as current Cursor Address in VRAM 			    ;3295	22 20 78 	"   x 
; -- clear Screen 
	ld bc,512		    ; 512 bytes of Screen in Text Mode (0)                  ;3298	01 00 02 	. . . 
.next:
 ifdef VER_12
	ld a,' '		    ; space char to fill Screen                             ;329b	3e 20 	>   
	ld (hl),a			; store int VRAM                                        ;329d	77 	w 
 else ; VER_20
	call sub_3ebeh		;329b	cd be 3e 	. . > 
 endif
	inc hl			    ; next address                                          ;329e	23 	# 
	dec bc			    ; decrement char's counter                              ;329f	0b 	. 
	ld a,c			                                                            ;32a0	79 	y 
	or b			    ; is counter = 0 ?                                      ;32a1	b0 	. 
	jr nz,.next			; no - continue with all 512 bytes                      ;32a2	20 f7 	  . 
; -- reset Cursor in line position
	xor a			    ; new Cursor position - begin of line                   ;32a4	af 	. 
	ld (CURSORPOS),a    ; reset position of Cursor to 0 (begin of Edited line)	;32a5	32 a6 78 	2 . x 
; -- clear Editor flags
	ld b,16		        ; 16 lines of Screen/Editor                             ;32a8	06 10 	. . 
	ld a,$80			; default Editor Line status - single or empty line 	;32aa	3e 80 	> . 
	ld hl,EDITORLINES	; Editor Flags for every Screen line	                ;32ac	21 d7 7a 	! . z 
.nextline:
	ld (hl),a			; set $80 as flag for line (single line)                ;32af	77 	w 
	inc hl			    ; next line                                             ;32b0	23 	# 
	djnz .nextline		; fill all 16 flags lines                               ;32b1	10 fc 	. . 
	ret			        ; ----------------- End Of Proc ----------------------- ;32b3	c9 	. 




;************************************************************************************
; Set Cursor at start of line
CursorLineStart:
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 			                 	;32b4	2a 20 78 	*   x 
	ld a,(CURSORPOS)	; position of Cursor in Edited line						;32b7	3a a6 78 	: . x 
	ld c,a				; c - Cursor Position									;32ba	4f 	O 
	xor a				; 0 as High Byte 										;32bb	af 	. 
	ld b,a				; bc - posion of Cursor in Edited line					;32bc	47 	G 
	ld (CURSORPOS),a	; reset position of Cursor to 0 (begin of Edited line)	;32bd	32 a6 78 	2 . x 
	sbc hl,bc			; VRAM address of start of line							;32c0	ed 42 	. B 
	ld (CURSORADDR),hl	; set Cursor Address at start of edited line			;32c2	22 20 78 	"   x 
	ret					; ----------------- End Of Proc ----------------------- ;32c5	c9 	. 

l32c6h:
	call GetEditorLineFlag		;32c6	cd a8 33 	. . 3 
	cp 081h		;32c9	fe 81 	. . 
	jr z,l32feh		;32cb	28 31 	( 1 
	ld a,(CURSORPOS)	; position of Cursor in Edited line			;32cd	3a a6 78 	: . x 
	cp 31		;32d0	fe 1f 	. . 
	jr z,l32f9h		;32d2	28 25 	( % 
	ld c,a			;32d4	4f 	O 
	xor a			;32d5	af 	. 
	ld b,a			;32d6	47 	G 
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 				;32d7	2a 20 78 	*   x 
	sbc hl,bc		;32da	ed 42 	. B 
	ld bc,$001f		;32dc	01 1f 00 	. . . 
	add hl,bc			;32df	09 	. 
 ifdef VER_12
	ld a,(hl)			;32e0	7e 	~ 
	cp 020h		;32e1	fe 20 	.   
 else ; VER_20
	call sub_3ee9h		;32e0	cd e9 3e 	. . > 
 endif
	jr nz,l32f9h		;32e3	20 14 	  . 
	push hl			;32e5	e5 	. 
	pop de			;32e6	d1 	. 
	dec hl			;32e7	2b 	+ 
	ld a,(CURSORPOS)	; position of Cursor in Edited line			;32e8	3a a6 78 	: . x 
	ld c,a			;32eb	4f 	O 
	ld a,01fh		;32ec	3e 1f 	> . 
l32eeh:
	sub c			;32ee	91 	. 
	ld c,a			;32ef	4f 	O 
	lddr		;32f0	ed b8 	. . 
 ifdef VER_12
	ld a,' '		    ; space character ;32f2	3e 20 	>   
	ld (CURSORCHAR),a	; set as current character at cursor position	;32f4	32 3c 78 	2 < x 
	ld (de),a			;32f7	12 	. 
 else ; VER_20
	call sub_3ef6h		;32f2	cd f6 3e 	. . > 
	ld (0783ch),a		;32f5	32 3c 78 	2 < x 
 endif	
	ret			;32f8	c9 	. 


l32f9h:
	call GetEditorLineFlag		;32f9	cd a8 33 	. . 3 
	or a			;32fc	b7 	. 
	ret z			;32fd	c8 	. 
l32feh:
	cp 080h		;32fe	fe 80 	. . 
	jr z,l3320h		;3300	28 1e 	( . 
	ld a,(CURSORPOS)    ; position of Cursor in Edited line				;3302	3a a6 78 	: . x 
	ld c,a			;3305	4f 	O 
	xor a			;3306	af 	. 
	ld b,a			;3307	47 	G 
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 				;3308	2a 20 78 	*   x 
	sbc hl,bc		;330b	ed 42 	. B 
	ld bc,0003fh		;330d	01 3f 00 	. ? . 
	add hl,bc			;3310	09 	. 
 ifdef VER_12
	ld a,(hl)			;3311	7e 	~ 
	cp 020h		;3312	fe 20 	.   
 else ; VER_20
	call sub_3ee9h		;3311	cd e9 3e 	. . > 
 endif
	ret nz			;3314	c0 	. 
	push hl			;3315	e5 	. 
	pop de			;3316	d1 	. 
	dec hl			;3317	2b 	+ 
	ld a,(CURSORPOS)	; position of Cursor in Edited line			;3318	3a a6 78 	: . x 
	ld c,a			;331b	4f 	O 
	ld a,03fh		;331c	3e 3f 	> ? 
	jr l32eeh		;331e	18 ce 	. . 
l3320h:
	push hl			;3320	e5 	. 
	call sub_332ch		;3321	cd 2c 33 	. , 3 
	pop hl			;3324	e1 	. 
	ld a,081h		;3325	3e 81 	> . 
	ld (hl),a			;3327	77 	w 
	inc hl			;3328	23 	# 
	xor a			;3329	af 	. 
	ld (hl),a			;332a	77 	w 
	ret			;332b	c9 	. 


sub_332ch:
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 				;332c	2a 20 78 	*   x 
	ld a,h			    ; upper byte of VRAM address            ;332f	7c 	| 
	cp $71		        ; is it bottom half of Screen?          ;3330	fe 71 	. q 
	jr nz,l335fh		; no -;3332	20 2b 	  + 
	ld a,l			    ; lower byte of VRAM address            ;3334	7d 	} 
	cp $e0				; is it last line of Screen?  			;3335	fe e0 	. . 
	jp c,l335fh		;3337	da 5f 33 	. _ 3 
	ld a,(CURSORPOS)	; position of Cursor in Edited line			;333a	3a a6 78 	: . x 
	push af			;333d	f5 	. 
	ld a,(EDITORLINES)	; Editor first Line info				;333e	3a d7 7a 	: . z 
	cp $81				; is it first of two-line statement/program ;3341	fe 81 	. . 
	jr nz,l334dh		; no - ;3343	20 08 	  . 
	push hl				; save hl ;3345	e5 	. 
	call ScrScrollUp	; Scroll Screen and Editor 1 line Up	;3346	cd f3 33 	. . 3 
	pop hl				; restore hl ;3349	e1 	. 
	call sub_0317h		;334a	cd 17 03 	. . . 
l334dh:
	push hl				; save hl - ;334d	e5 	. 
	call ScrScrollUp	; Scroll Screen and Editor 1 line Up 		;334e	cd f3 33 	. . 3 
	pop hl				; restore hl - ;3351	e1 	. 
	call sub_0317h		;3352	cd 17 03 	. . . 
	pop af			;3355	f1 	. 
	ld (CURSORPOS),a	; set new position of Cursor in Edited line			;3356	32 a6 78 	2 . x 
	pop de			;3359	d1 	. 
	pop hl			;335a	e1 	. 
	dec hl			;335b	2b 	+ 
	push hl			;335c	e5 	. 
	push de			;335d	d5 	. 
	ret			;335e	c9 	. 


; IN - hl - curent address of cursor on screen 
l335fh:
	ld a,(CURSORPOS)	; position of Cursor in Edited line		;335f	3a a6 78 	: . x 
	ld c,a			    ; store position as lsb in register bc  ;3362	4f 	O 
	xor a			    ; msb of BC is 0                        ;3363	af 	. 
	ld b,a			    ; bc - cursor in line position          ;3364	47 	G 
	sbc hl,bc		    ; hl - first char in current line       ;3365	ed 42 	. B 
	ld bc,64		    ; 64 bytes per line                     ;3367	01 40 00 	. @ . 
	add hl,bc			; hl - first char in next line          ;336a	09 	. 
	push hl			    ; save hl                               ;336b	e5 	. 
	ex de,hl			;336c	eb 	. 
	ld hl,07200h		;336d	21 00 72 	! . r 
	sbc hl,de		;3370	ed 52 	. R 
	push hl			;3372	e5 	. 
	pop bc			;3373	c1 	. 
	ld hl,071dfh		;3374	21 df 71 	! . q 
	ld de,071ffh		;3377	11 ff 71 	. . q 
	ld a,c			;337a	79 	y 
	or b			;337b	b0 	. 
	jr z,l3380h		;337c	28 02 	( . 
	lddr		;337e	ed b8 	. . 
l3380h:
	pop hl			;3380	e1 	. 
 ifdef VER_12
	ld b,020h		;3381	06 20 	.   
	ld a,020h		;3383	3e 20 	>   
 else ; VER_20
	call sub_3f02h		;3381	cd 02 3f 	. . ? 
	nop 			;3384	00
 endif


l3385h:
	ld (de),a			;3385	12 	. 
	dec de			;3386	1b 	. 
	djnz l3385h		;3387	10 fc 	. . 
	call GetEditorLineFlag		;3389	cd a8 33 	. . 3 
	push hl			;338c	e5 	. 
	pop bc			;338d	c1 	. 
	ld hl,07ae6h		;338e	21 e6 7a 	! . z 
	push hl			;3391	e5 	. 
	or a			;3392	b7 	. 
	sbc hl,bc		;3393	ed 42 	. B 
	push hl			;3395	e5 	. 
	pop bc			;3396	c1 	. 
	pop hl			;3397	e1 	. 
	push hl			;3398	e5 	. 
	pop de			;3399	d1 	. 
	dec hl			;339a	2b 	+ 
	lddr		;339b	ed b8 	. . 
	ld a,(07ae6h)		;339d	3a e6 7a 	: . z 
	cp 081h		;33a0	fe 81 	. . 
	ret nz			;33a2	c0 	. 
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 				;33a3	2a 20 78 	*   x 
	jr l335fh		;33a6	18 b7 	. . 
GetEditorLineFlag:
; -- get Cursor in-line position (column) into BC register
	ld a,(CURSORPOS); position of Cursor in Edited line							;33a8	3a a6 78 	: . x 
	ld c,a			; c - LSB of Cursor position (column)						;33ab	4f 	O 
	xor a																		;33ac	af 	. 
	ld b,a			; bc - Cursor position (column)								;33ad	47 	G 
; -- calculate VRAM address of Start of current line on screeen
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 								;33ae	2a 20 78 	*   x 
	sbc hl,bc		; hl - address of Start current line						;33b1	ed 42 	. B 
	push hl			; copy address to bc 										;33b3	e5 	. 
	pop bc			; bc - address of Start current line						;33b4	c1 	. 
; -- calculate screen line number
	ld a,b			; a - high byte of address									;33b5	78 	x 
	and $0f			; constrain range to (0..4095) 								;33b6	e6 0f 	. . 
; -- divide offset by 32 chars per line
	srl a			; divide by 2 (now range 0..2047)								;33b8	cb 3f 	. ? 
	ld b,a			; store high byte of address								;33ba	47 	G 
	rr c			; divide by 2 (with bit0 from high byte) (0..1023)			;33bb	cb 19 	. . 
	srl c			; divide by 2 (0..511)										;33bd	cb 39 	. 9 
	srl c			; divide by 2 (0..256)										;33bf	cb 39 	. 9 
	srl c			; divide by 2 (0..127)										;33c1	cb 39 	. 9 
	srl c			; divide by 2 (0..63)										;33c3	cb 39 	. 9 
; -- get Editor Line Info for current line
	ld hl,EDITORLINES	; hl - Editor Info for every Screen line	            ;33c5	21 d7 7a 	! . z 
	add hl,bc		; hl - pointer to Info entry for current line 				;33c8	09 	. 
	ld a,(hl)		; a - Editor Line Info for current line						;33c9	7e 	~ 
	ret				; ------------------- End of Proc -------------------------	;33ca	c9 	. 




l33cbh:
	call GetEditorLineFlag		;33cb	cd a8 33 	. . 3 
	cp 081h		;33ce	fe 81 	. . 
	ld hl,(CURSORADDR)	; Cursor Address in VRAM 					;33d0	2a 20 78 	*   x 
	push hl			;33d3	e5 	. 
	pop de			;33d4	d1 	. 
	inc hl			;33d5	23 	# 
	ld a,(CURSORPOS)	; position of Cursor in Edited line			;33d6	3a a6 78 	: . x 
	ld c,a			;33d9	4f 	O 
	jr z,l33efh		;33da	28 13 	( . 
	cp 01fh		;33dc	fe 1f 	. . 
	jr z,l33e8h		;33de	28 08 	( . 
	ld a,01fh		;33e0	3e 1f 	> . 
l33e2h:
	sub c			;33e2	91 	. 
	ld c,a			;33e3	4f 	O 
	xor a			;33e4	af 	. 
	ld b,a			;33e5	47 	G 
	ldir		;33e6	ed b0 	. . 
l33e8h:
 ifdef VER_12
	ld a,020h		;33e8	3e 20 	>   
	ld (de),a			;33ea	12 	. 
 else ; VER_20
	call sub_3ef6h		;33e8	cd f6 3e 	. . > 
 endif

	call UpdateCursorChar	; update Cursor Char	;33eb	cd 50 00 	. P . 
	ret			;33ee	c9 	. 
l33efh:
	ld a,03fh		;33ef	3e 3f 	> ? 
	jr l33e2h		;33f1	18 ef 	. . 

;**************************************************************************************
; Scroll Screen and Editor 1 line Up
; OUT: hl - VRAM address of Start of Last line on screen
ScrScrollUp:
; -- move content of Screen 1 line up
	ld de,VRAM			; de - dest address - start of 1st line on Screen			;33f3	11 00 70 	. . p 
	ld hl,VRAM+32		; hl - src address - start of 2nd line on Screen			;33f6	21 20 70 	!   p 
	ld bc,32*(16-1)		; bc - 15 lines x 32 bytes per line to move 				;33f9	01 e0 01 	. . . 
	ldir				; copy Screen bytes 1 line up 								;33fc	ed b0 	. . 
; -- clear last line of screen (fill with ' ')
 ifdef VER_12
	ld b,32				; 32 bytes in line to fill									;33fe	06 20 	.   
	ld a,' '			; char to fill on Screen									;3400	3e 20 	>   
 else ; VER_20
	call sub_3f02h		;33fe	cd 02 3f 	. . ? 
	nop					;3401	00
 endif	
 
; -- after above copy de already points to start of last line
.nextbyte:
	ld (de),a			; store ' ' on screen 									;3402	12 	. 
	inc de				; nex byte												;3403	13 	. 
	djnz .nextbyte		; fill all 32 bytes										;3404	10 fc 	. . 
; -- move Editor Lines Infos 1 line up
	ld hl,EDITORLINES	; hl - Editor Lines Info Table 							;3406	21 d7 7a 	! . z 
	push hl				; copy hl to de											;3409	e5 	. 
	pop de				; de - destination pionter (1st line entry)					;340a	d1 	. 
	inc hl				; hl - source pointer (2nd line entry)						;340b	23 	# 
	ld bc,15			; 15 lines/entries to move 								;340c	01 0f 00 	. . . 
	ldir				; copy Editor Line Infos one line up					;340f	ed b0 	. . 
; -- correct last line Info 
	ld a,(de)			; a - last line Info									;3411	1a 	. 
	cp $81				; was it first of two-line statement?					;3412	fe 81 	. . 
	jr nz,l3419h		; no - ;3414	20 03 	  . 
	xor a			;3416	af 	. 
	jr l341bh		;3417	18 02 	. . 
l3419h:
	ld a,$80		;3419	3e 80 	> . 
l341bh:
	ld (de),a			;341b	12 	. 
; -- set Cursor at Start of line
	xor a			    ; new Cursor position - begin of line                   ;341c	af 	. 
	ld (CURSORPOS),a	; reset position of Cursor to 0 (begin of Edited line)	;341d	32 a6 78 	2 . x 
; -- return hl pointing to Start of last line of screen
	ld hl,$71e0			; start of last line on screen							;3420	21 e0 71 	! . q 
	ret					; ----------- End of Proc ----------------------------	;3423	c9 	. 



ScrollEditorUp:
	ld a,(EDITORLINES)	; a - Editor first Line info  								;3424	3a d7 7a 	: . z 
	cp $81				; is it first of two line statement						;3427	fe 81 	. . 
	call z,ScrScrollUp	; yes - scroll screen one time more					;3429	cc f3 33 	. . 3 
	call ScrScrollUp	; Scroll Screen and Editor 1 line Up				;342c	cd f3 33 	. . 3 
	ret					; ------------- End of Proc -----------------------	;342f	c9 	. 
sub_3430h:
	ld hl,SYSFLAGS		; System flags ;3430	21 39 78 	! 9 x 
	or a			;3433	b7 	. 
	jr nz,l3441h		;3434	20 0b 	  . 
	set 1,(hl)		;3436	cb ce 	. . 
	ld bc,003ffh		;3438	01 ff 03 	. . . 
l343bh:
	dec bc			;343b	0b 	. 
	ld a,c			;343c	79 	y 
	or b			;343d	b0 	. 
	jr nz,l343bh		;343e	20 fb 	  . 
	ret			;3440	c9 	. 
l3441h:
	bit 0,(hl)		;3441	cb 46 	. F 
	ret nz			;3443	c0 	. 
	cp 00dh		;3444	fe 0d 	. . 
	jr z,l344eh		;3446	28 06 	( . 
	cp 001h		;3448	fe 01 	. . 
	jr nz,l3450h		;344a	20 04 	  . 
	set 2,(hl)		;344c	cb d6 	. . 
l344eh:
	set 0,(hl)		;344e	cb c6 	. . 
l3450h:
	push hl			;3450	e5 	. 
	ld hl,000a0h		;3451	21 a0 00 	! . . 
	ld bc,$0006		;3454	01 06 00 	. . . 
	call sub_345ch		;3457	cd 5c 34 	. \ 4 
	pop hl			;345a	e1 	. 
	ret			;345b	c9 	. 
sub_345ch:
	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  						;345c	3a 3b 78 	: ; x 
	ld d,a			;345f	57 	W 
l3460h:
	call PlayOneTone		;3460	cd 69 34 	. i 4 
	dec bc			;3463	0b 	. 
	ld a,c			;3464	79 	y 
	or b			;3465	b0 	. 
	jr nz,l3460h		;3466	20 f8 	  . 
	ret			;3468	c9 	. 


;************************************************************************************
; Play one sound
; IN: d - value currently written into IO_LATCH
;     hl - frequency counter (period length)
;     bc - total number of periods to play
PlayOneTone:
	push bc			; save bc - number of freq periods to play 					;3469	c5 	. 
; -- set Speaker Pins to opposite values
	ld a,d			; a - value from IO_LATCH									;346a	7a 	z 
	xor %00100001	; inverse Speaker Pins (bits 5 and 0)						;346b	ee 21 	. ! 
	ld (IO_LATCH),a	; store in hardware register								;346d	32 00 68 	2 . h 
; -- wait delay defined as period length
	push hl			; copy hl to bc												;3470	e5 	. 
	pop bc			; bc - period length (delay counter)						;3471	c1 	. 
.wait1:
	dec bc			; decrement delay counter									;3472	0b 	. 
	ld a,c			; a - low byte of counter									;3473	79 	y 
	or b			; are both 0 (time elapsed)?								;3474	b0 	. 
	jr nz,.wait1	; no - wait more											;3475	20 fb 	  . 
; -- revert Speaker Pins to previous values
	ld a,d			; a - previous value from IO_LATCH							;3477	7a 	z 
	ld (IO_LATCH),a	; store in hardware register								;3478	32 00 68 	2 . h 
; -- wait delay defined as period length
	push hl			; copy hl to bc 											;347b	e5 	. 
	pop bc			; bc - period length (delay counter)						;347c	c1 	. 
.wait2:
	dec bc			; decrement delay counter									;347d	0b 	. 
	ld a,c			; a - low byte of counter									;347e	79 	y 
	or b			; are both 0 (time elapsed)?								;347f	b0 	. 
	jr nz,.wait2	; no - wait more											;3480	20 fb 	  . 
; -- restore bc and return back
	pop bc			; restore bc - number of freq periods to play 				;3482	c1 	. 
	ret				; -------------------- End of Proc ------------------------	;3483	c9 	. 




sub_3484h:
; -- set Space as current Cursor char 
 ifdef VER_12
	ld a,' '		    ; space character and also Gfx Mode 0 byte  			;3484	3e 20 	>   
	ld (CURSORCHAR),a	; set as current character at cursor position			;3486	32 3c 78 	2 < x 
 else ; VER_20
	call sub_3fa0h		;3484	cd a0 3f 	. . ? 
	ld a,%00100000		;3487	3e 20
 endif
; -- reset video Mode to Text (0)
	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH  				;3489	32 3b 78 	2 ; x 
	ld (IO_LATCH),a		; store in hardware register	;348c	32 00 68 	2 . h 
; -- 
	ld a,60		;348f	3e 3c 	> < 
	ld (KEYS_DEBOUNCER),a		;3491	32 3a 78 	2 : x 
; -- set initial value for Cursor Timer
	ld a,16				; initial timer value 									;3494	3e 10 	> . 
	ld (CURSORTIMER),a	; reset timer for inverse char under cursor				;3496	32 41 78 	2 A x 
; --
	xor a				;3499	af 	. 
	ld (07aafh),a		;349a	32 af 7a 	2 . z 
	ld hl,TAPEFILENAME	; tape buffer for filename (18) bytes	;349d	21 b2 7a 	! . z 
	ld (07ab0h),hl		;34a0	22 b0 7a 	" . z 
	ld a,0c9h		;34a3	3e c9 	> . 
	jp l3e37h		;34a5	c3 37 3e 	. 7 > 
	ret			;34a8	c9 	. 



; **********************************************************************************************
; BASIC CSAVE Entry Point
; Saves a BASIC program to tape. 
; On entry, the HL register pair must point to the start of a valid filename sequence (a quotation 
; mark followed by a single character filename, which in turn may be optionally followed by a second
; quotation mark, The entire filename sequence must be terminated by a zero byte or colon).
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdCSAVE
; -- disable interrupt to avoid timing issues
	di					; disable interrupts 									;34a9	f3 	. 
; -- send to Tape header - sync blocks, file type (Basic) and file name 
	ld c,$f0			; file type - Basic 									;34aa	0e f0 	. . 
	call TapeWriteHeader; Send sync and file header to Tape						;34ac	cd 58 35 	. X 5 
	jp c,TapeAbort		; Break - Cancel loading Tape and pass control to Basic ;34af	da fe 3a 	. . : 
	push hl				; save hl 												;34b2	e5 	. 
; -- wait delay (10+(6+4+4+13)*410+8)x0.279us = 11088x0.297us = 3293.136us ~3.3ms
	ld bc,410			; delay counter											;34b3	01 9a 01 	. . . 
.wait:
	dec bc				; decrement delay counter								;34b6	0b 	. 
	ld a,c				; low byte of counter									;34b7	79 	y 
	or b				; is counter 0?											;34b8	b0 	. 
	jr nz,.wait			; no - wait delay 3.3ms									;34b9	20 fb 	  . 
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;34bb	cd f8 3a 	. . : 
	ld ix,TAPE_CRC		; ix - pointer to CRC 16bit value						;34be	dd 21 23 78 	. ! # x 

; -- send program start address (destination for CLOAD later)
	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;34c2	2a a4 78 	* . x 
	ld a,l				; low byte of address									;34c5	7d 	} 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34c6	cd 11 35 	. . 5 
	ld (ix+0),a			; store into CRC 										;34c9	dd 77 00 	. w . 
	xor a				; high byte of init CRC (0)								;34cc	af 	. 
	ld (ix+1),a			; CRC = 0 + LSB of program address						;34cd	dd 77 01 	. w . 
	ld a,h				; high byte of address									;34d0	7c 	| 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34d1	cd 11 35 	. . 5 
	call AddToCRC		; Add high byte of addres to Tape CRC 					;34d4	cd 8e 38 	. . 8 
; -- save program addres in de for later use
	ex de,hl			; de - program start address							;34d7	eb 	. 
; -- send program end address 
	ld hl,(PrgEndPtr)	; hl - address of End of Basic Program					;34d8	2a f9 78 	* . x 
	ld a,l				; low byte of address									;34db	7d 	} 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34dc	cd 11 35 	. . 5 
	call AddToCRC		; Add low byte of addres to Tape CRC 					;34df	cd 8e 38 	. . 8 
	ld a,h				; high byte of address									;34e2	7c 	| 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34e3	cd 11 35 	. . 5 
	call AddToCRC		; Add high byte of addres to Tape CRC 					;34e6	cd 8e 38 	. . 8 
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;34e9	cd f8 3a 	. . : 
; -- send Basic Program content
.next:
	ld a,(de)			; a - byte of Basic Program code 						;34ec	1a 	. 
	inc de				; points to next byte									;34ed	13 	. 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34ee	cd 11 35 	. . 5 
	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;34f1	cd 8e 38 	. . 8 
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;34f4	cd f8 3a 	. . : 
; -- test if all Program bytes are sent
	rst #18				; compare if HL equals DE - all bytes sent				;34f7	df 	. 
	jr nz,.next			; no - send all bytes of Basic Program 					;34f8	20 f2 	  . 
; -- all bytes sent - now send calculated CRC
	ld a,(ix+0)			; low byte of CRC										;34fa	dd 7e 00 	. ~ . 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;34fd	cd 11 35 	. . 5 
	ld a,(ix+1)			; high byte of CRC										;3500	dd 7e 01 	. ~ . 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;3503	cd 11 35 	. . 5 
; -- send trailing sequence block - 20 x $00
	ld b,20				; counter - 20 bytes to send							;3506	06 14 	. . 
	xor a				; byte value to send									;3508	af 	. 
.next0:
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;3509	cd 11 35 	. . 5 
	djnz .next0			; decrement counter - send 20 times						;350c	10 fb 	. . 
; -- restore hl, enable interrupts and exit
	pop hl				; restore hl											;350e	e1 	. 
	ei					; enable interrupts										;350f	fb 	. 
	ret					; --------------------- End of Proc -------------------	;3510	c9 	. 



;*********************************************************************************************
; Send 1 byte to Tape via hardware register (IO_LATCH)
; IN: a - byte to send
TapeWriteByte:
; -- preserve used registers
	push af				; save af 												;3511	f5 	. 
	push bc				; save bc 												;3512	c5 	. 
	push hl				; save hl												;3513	e5 	. 
; -- initialize bit counter 
	ld l,8				; 8 bits to send 										;3514	2e 08 	. . 
	ld h,a				; h - data byte to send 								;3516	67 	g 
; -- send data byte (MSB first) as sequence of pulse packs (1680us long):
;    0 - Short Long 		(560us + 1120us)
;    1 - Short Short Short	(560us + 560us + 560us) 
.nextbit:
	call TapeShortPulse	; Send one pulse 1/0 (280us each) to Tape via IO_LATCH	;3517	cd 42 35 	. B 5 
	rlc h				; CY - next bit to send									;351a	cb 04 	. . 
	jr nc,TapeLongPulse	; Send one pulse 1/0 (560us each) to Tape via IO_LATCH	;351c	30 0d 	0 . 
	call TapeShortPulse	; Send one pulse 1/0 (280us each) to Tape via IO_LATCH	;351e	cd 42 35 	. B 5 
	call TapeShortPulse	; Send one pulse 1/0 (280us each) to Tape via IO_LATCH	;3521	cd 42 35 	. B 5 
.cont:
	dec l				; decrement bit counter - all bits sent?				;3524	2d 	- 
	jr nz,.nextbit		; no - send next bit									;3525	20 f0 	  . 
; -- restore registers
	pop hl				; restore hl											;3527	e1 	. 
	pop bc				; restore bc											;3528	c1 	. 
	pop af				; restore af											;3529	f1 	. 
	ret					; ------------------- End of Proc ---------------------	;352a	c9 	. 



;**************************************************************************************
; Send one pulse 1/0 (560us each) to Tape via IO_LATCH
TapeLongPulse:
; -- set bit 2 and bit 1 (Cassette Out) to 1
	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  							;352b	3a 3b 78 	: ; x 
	or %00000110		; set bit 2 (Cassette Out(-)) and bit 1 (Cassette Out(+))		;352e	f6 06 	. . 
	ld (IO_LATCH),a		; store in hardware register									;3530	32 00 68 	2 . h 
; -- wait long delay (7+153*13+8)*0.279us = 2004*0.279us = 559.116us ~ 560us
	ld b,153			; delay counter 												;3533	06 99 	. . 
.wait1:
	djnz .wait1			; wait 560us													;3535	10 fe 	. . 
; -- clear bit 2 and bit 1 (Cassette Out) to 0
	and %11111001		; clear bit 2 (Cassette Out(-)) and bit 1 (Cassette Out(+))		;3537	e6 f9 	. . 
	ld (IO_LATCH),a		; store in hardware register									;3539	32 00 68 	2 . h 
; -- wait long delay (7+153*13+8)*0.279us = 2004*0.279us = 559.116us ~ 560us
	ld b,153			; delay counter													;353c	06 99 	. . 
.wait2:
	djnz .wait2			; wait 560us													;353e	10 fe 	. . 
	jr TapeWriteByte.cont; continue sending bits											;3540	18 e2 	. . 




;****************************************************************************************
; Send one pulse 1/0 (280us each) to Tape via IO_LATCH
TapeShortPulse:
; -- set bit 2 and bit 1 (Cassette Out) to 1
	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  							;3542	3a 3b 78 	: ; x 
	or %00000110		; set bit 2 (Cassette Out(-)) and bit 1 (Cassette Out(+))		;3545	f6 06 	. . 
	ld (IO_LATCH),a		; store in hardware register									;3547	32 00 68 	2 . h 
; -- wait short delay (7+76*13+8)*0.279us = 1003*0.279us = 279.837us ~ 280us
	ld b,76				; delay counter													;354a	06 4c 	. L 
.wait1:
	djnz .wait1			; wait 280us													;354c	10 fe 	. . 
; -- clear bit 2 and bit 1 (Cassette Out) to 0
	and %11111001		; clear bit 2 (Cassette Out(-)) and bit 1 (Cassette Out(+))		;354e	e6 f9 	. . 
	ld (IO_LATCH),a		; store in hardware register									;3550	32 00 68 	2 . h 
; -- wait short delay (7+76*13+8)*0.279us = 1003*0.279us = 279.837us ~ 280us
	ld b,76				; delay counter													;3553	06 4c 	. L 
.wait2:
	djnz .wait2			; wait 280us													;3555	10 fe 	. . 
	ret					; ----------------- End of Proc -------------------------------	;3557	c9 	. 




;****************************************************************************************
; Send sync and file header to Tape
; IN: c - file type (F0 or F2)
TapeWriteHeader:
; -- get filename from command parameter and store in Tape Filename Buffer
	call TapeParseFilename	; parse filename into FileNameBuf					;3558	cd 8c 35 	. . 5 

; -- send sync (1) block to Tape - 255 x $80
	ld b,255			; counter - 255 bytes to send							;355b	06 ff 	. . 
.next1:
	ld a,$80			; byte to send											;355d	3e 80 	> . 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;355f	cd 11 35 	. . 5 
	call TestCtrlBreak	; Test if Ctrl+Break keys pressed						;3562	cd e8 3a 	. . : 
	ret c			    ; yes ---------- End of Proc -------------------------- ;3565	d8 	. 
	djnz .next1			; decrement byte counter - jump if not all sent yet		;3566	10 f5 	. . 

; -- send sync (2) block to Tape - 5 x $fe
	ld b,5				; counter - 5 bytes to send								;3568	06 05 	. . 
.next2:
	ld a,$fe			; byte to send											;356a	3e fe 	> . 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;356c	cd 11 35 	. . 5 
	call TestCtrlBreak	; Test if Ctrl+Break keys pressed						;356f	cd e8 3a 	. . : 
	ret c			    ; yes ---------- End of Proc -------------------------- ;3572	d8 	. 
	djnz .next2			; decrement byte counter - jump if not all sent yet		;3573	10 f5 	. . 
; -- send file type byte
	ld a,c				; file type byte										;3575	79 	y 
	call TapeWriteByte	; Send 1 byte to Tape via hardware register (IO_LATCH)	;3576	cd 11 35 	. . 5 
	call TestCtrlBreak	; Test if Ctrl+Break keys pressed						;3579	cd e8 3a 	. . : 
	ret c			    ; yes ---------- End of Proc -------------------------- ;357c	d8 	. 
; -- send file name 
	ld a,(FILENAMELEN)	; length of file name for tape (including 0 terminator)	;357d	3a d6 7a 	: . z 
	ld b,a				; char counter											;3580	47 	G 
	ld de,FileNameBuf	; addres of tape file name buffer (17 bytes)			;3581	11 9d 7a 	. . z 
.nextchar:
	ld a,(de)			; char of file name										;3584	1a 	. 
	inc de				; points to next char									;3585	13 	. 
	call TapeWriteByte	; Send char to Tape via hardware register (IO_LATCH)	;3586	cd 11 35 	. . 5 
	djnz .nextchar		; decrement counter - jump if not all sent yet			;3589	10 f9 	. . 
	ret					; ------------------- End of Proc ---------------------	;358b	c9 	. 


;***************************************************************************************
; Parse filename (quoted with '"') and copy into File Name Buffer
; IN: hl - address of filename text 
; OUT: a - filename length
TapeParseFilename:
; -- filename can have max 16 chars
	ld b,16				; 16 chars maximum										;358c	06 10 	. . 
	ld de,FileNameBuf	; addres of tape file name buffer (16 bytes)			;358e	11 9d 7a 	. . z 
; -- test if there is no filename given - end of statement or line
	ld a,(hl)			; a - byte from program									;3591	7e 	~ 
	cp ':'				; is it End of Basic Statement (no filename given)		;3592	fe 3a 	. : 
	jr z,.exit			; yes - add '\0' terminator (empty filename)			;3594	28 12 	( . 
	or a				; is it End of Basic Line or Command (no filename) 		;3596	b7 	. 
	jr z,.exit			; yes - add '\0' terminator (empty filename)			;3597	28 0f 	( . 
; -- filename text must be enclosed with '"' char
	rst $08				; Assert next token is '"' 								;3599	cf 	. 
	defb '"'			; Basic '"' token - start of string 					;359a	22 
.next
; -- copy filename into FileNameBuf (max 16 chars)
	ld a,(hl)			; char of filename										;359b	7e 	" . 
	or a				; is it End of Basic Line or Command?					;359b	b7  
	jr z,.exit			; yes - add '\0' terminator (filename ready)			;359d	28 09 	( . 
	inc hl				; advance source char pointer							;359f	23 	# 
	cp '"'				; is it end of string delimiter							;35a0	fe 22 	. " 
	jr z,.exit			; yes - add '\0' terminator (filename ready)			;35a2	28 04 	( . 
	ld (de),a			; copy char into buffer									;35a4	12 	. 
	inc de				; advance destination char pointer						;35a5	13 	. 
	djnz .next 			; decrement counter - copy max 16 chars					;35a6	10 f3 	. . 
.exit:
; -- filename text must always be terminated with '\0' 
	xor a				; 0 - string terminator									;35a8	af 	. 
	ld (de),a			; store at last position in buffer						;35a9	12 	. 
; -- calculate text length (including 0 terminator)
	ld a,17				; 17 chars (max 16 + 1 termiantor)						;35aa	3e 11 	> . 
	sub b				; substract downcounter value							;35ac	90 	. 
	ld (FILENAMELEN),a	; store length of file name for tape					;35ad	32 d6 7a 	2 . z 
	ret					; ----------------- End of Proc -----------------------	;35b0	c9 	. 



;*********************************************************************************
; Prepeare Screen for TAPE info texts
; Set cursor at the end of screen
TapePrepScreen:
; -- if Hide Info Flag is set then skip Screen preparation
	ld a,(TAPEHIDEINFO)		; Tape Hide Info flag								;35b1	3a 4c 78 	: L x 
	or a					; hide info about Tape operation?					;35b4	b7 	. 
	ret nz					; yes - ---------- End of Proc --------------------	;35b5	c0 	. 
; -- check if Gfx MODE 0 (TXT) and Reset Screen/Editor if not
	ld a,(IOLATCH_COPY)		; a - last value written to IO_LATCH  				;35b6	3a 3b 78 	: ; x 
	bit 3,a					; is Gfx MOde 0 already?							;35b9	cb 5f 	. _ 
	jr z,.setCursor			; yes - skip Editor Reset							;35bb	28 0b 	( . 
; -- set Text Mode, clear Screen and reset Editor
	and %11110111			; clear bit 3 - set Mode 0 (text)					;35bd	e6 f7 	. . 
	ld (IOLATCH_COPY),a		; save as last value written to IO_LATCH  			;35bf	32 3b 78 	2 ; x 
	ld (IO_LATCH),a			; set Gfx Mode 0 									;35c2	32 00 68 	2 . h 
	call ResetEditor		; clear Screen and Editor Flags						;35c5	cd 92 32 	. . 2 
.setCursor:
; -- set Cursor at bottom-right of Screen (last char)
	ld hl,VRAM+511			; hl - last char of screen (bottom-right)			;35c8	21 ff 71 	! . q 
	ld (CURSORADDR),hl		; set Cursor Address in VRAM 						;35cb	22 20 78 	"   x 
	ld a,31		        	; new Cursor position - end of line                 ;35ce	3e 1f 	> . 
	ld (CURSORPOS),a		; set new position of Cursor in Edited line			;35d0	32 a6 78 	2 . x 
; -- correct Editor flags for last 2 lines
	ld a,(EDITORLINES+14)	; Editor 15th Line Info 							;35d3	3a e5 7a 	: . z 
	cp $81					; is it first of two-line-statement					;35d6	fe 81 	. . 
	ret nz					; no - no correction needed -----------------------	;35d8	c0 	. 
; -- lines 15 and 16 was taken as one 2 line edit - convert into two single lines
	dec a					; a = $80 - single line								;35d9	3d 	= 
	ld (EDITORLINES+14),a	; set Editor line 15 as single line					;35da	32 e5 7a 	2 . z 
	ld (EDITORLINES+15),a	; set Editor line 16 as single line					;35dd	32 e6 7a 	2 . z 
	ret						; ----------------- End of Proc -------------------	;35e0	c9 	. 




	ld hl,TXT_WAITING	; text 'WAITING'										;35e1	21 42 38 	! B 8 
	call TapeDispOper	; Display Tape Operation Info 'WAITING' 				;35e4	cd f4 37 	. . 7 


;********************************************************************************
; Read sync, file type and name from Tape 
TapeReadHeader:
.start
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;35e7	cd f8 3a 	. . : 
; -- wait for transmission start
	ld a,(CassIn)		; read Tape input bit									;35ea	3a 00 68 	: . h 
	bit 6,a				; is bit reset (Tape input Active)?						;35ed	cb 77 	. w 
	jr nz,.start		; no - wait for bit active								;35ef	20 f6 	  . 
.waitforStart:
	call TapeReadBit	; Read 1 bit from Tape and insert into d MSB first		;35f1	cd 8f 37 	. . 7 
	jr c,.start			; error ----------- start over with BREAK check ------- ;35f4	38 f1 	8 . 
; -- a contains bit 0 already read
	bit 0,a				; is data bit = 1										;35f6	cb 47 	. G 
	jr z,.waitforStart			; no - read next bit - we want 1 						;35f8	28 f7 	( . 
; -- first bit was 1 - read remaining 7 bits
	ld b,7				; bit counter											;35fa	06 07 	. . 
.nextBit:
	call TapeReadBit	; Read 1 bit from Tape and insert into d MSB first		;35fc	cd 8f 37 	. . 7 
	jr c,.start			; error ----------- start over with BREAK check ------- ;35ff	38 e6 	8 . 
	djnz .nextBit		; success - read all 7 bits								;3601	10 f9 	. . 
; -- all 8 bits from Tape stored in a
	cp $80				; is it SYNC80 byte	?									;3603	fe 80 	. . 
	jr nz,.start		; no ------------- start over with BREAK check -------- ;3605	20 e0 	  . 

.next80:
	call TapeReadByte	; Read 1 byte from Tape 								;3607	cd 75 37 	. u 7 
	jp c,.start			; error ----------- start over with BREAK check ------- ;360a	da e7 35 	. . 5 
	cp $80				; is it SYNC80 byte	?									;360d	fe 80 	. . 
	jr z,.next80		; yes - read next sync byte								;360f	28 f6 	( . 
; -- sync (80) ended - 1 byte already read - 4 more to go
	ld b,4				; 4 bytes (SYNCFE) to read								;3611	06 04 	. . 
.nextFE:
	cp $fe				; is it SYNCFE byte	?									;3613	fe fe 	. . 
	jp nz,.start		; no ------------- start over with BREAK check -------- ;3615	c2 e7 35 	. . 5 
	call TapeReadByte	; Read 1 byte from Tape 								;3618	cd 75 37 	. u 7 
	jp c,.start			; error ----------- start over with BREAK check ------- ;361b	da e7 35 	. . 5 
	djnz .nextFE		; read all 4 bytes 										;361e	10 f3 	. . 
; -- sunc (FE) ended - read file type (F0 or F2)
	call TapeReadByte	; Read 1 byte from Tape 								;3620	cd 75 37 	. u 7 
	ld (TAPEFILETYPE),a	; save as File Type byte								;3623	32 d2 7a 	2 . z 
; -- read File Name 
	ld hl,TAPEFILENAME	; address of buffer for filename (18) bytes				;3626	21 b2 7a 	! . z 
	ld b,18				; maximum 18 bytes to read								;3629	06 12 	. . 
.nextChar:
	call TapeReadByte	; Read 1 char from Tape 								;362b	cd 75 37 	. u 7 
	ld (hl),a			; store char in buffer									;362e	77 	w 
	or a				; is it '\0' (end of text)?								;362f	b7 	. 
	jr z,.fileFound			; yes - display filename and copy to system buffer		;3630	28 06 	( . 
	inc hl				; points to next location in buffer						;3632	23 	# 
	djnz .nextChar		; read from Tape 18 bytes or until terminated with 0	;3633	10 f6 	. . 
; -- FAIL: filename must be terminated with '\0'
	jp .start			; error ----------- start over with BREAK check ------- ;3635	c3 e7 35 	. . 5 

.fileFound:
; -- display text 'FOUND' on Screen
	ld hl,TXT_FOUND		; text 'FOUND'											;3638	21 5a 38 	! Z 8 
	call TapeDispOper	; Display Tape Operation Info 'FOUND'					;363b	cd f4 37 	. . 7 
; -- display file name and type on Screen
	ld hl,TAPEFILENAME	; address of tape buffer with filename 					;363e	21 b2 7a 	! . z 
	call TapeDispFileInfo	; display file type and file name					;3641	cd 14 38 	. . 8 
; -- compare filename requested by user with filename found
	ld hl,TAPEFILENAME	; address of buffer with filename found 				;3644	21 b2 7a 	! . z 
	ld de,FileNameBuf	; address of buffer with filename requested by user		;3647	11 9d 7a 	. . z 
.cmpNext:
	ld a,(de)			; char of requested filename							;364a	1a 	. 
	or a				; is it '\0' (end of string)?							;364b	b7 	. 
	ret z				; yes - filenames match --------- End of Proc ---------	;364c	c8 	. 
	cp (hl)				; is the same as char of found filename?				;364d	be 	. 
	jp nz,.start		; no -------------- start over with BREAK check ------- ;364e	c2 e7 35 	. . 5 
	inc hl				; points to next char of found filename					;3651	23 	# 
	inc de				; points to next char of requested filename				;3652	13 	. 
	jr .cmpNext			; compare all chars of filenames						;3653	18 f5 	. . 
; -- dead code
	ret					; --------------- End of Proc ------------------------- ;3655	c9 	. 


; *******************************************************************************************
; BASIC CLOAD Entry Point
; Loads a BASIC program from tape. 
; On entry, the HL register pair must point to a valid argument for the CLOAD command, 
; or to a zero byte or colon terminator. A valid argument could consist of a filename 
; sequence (as explained for above CSA¥E routine), a question mark (to verify 
; the program on tape against the program in memory), etc. 
; Arguments must be properly terminated with a colon or zero byte, 
; NOTE: This routine 'does NOT return to the calling program, but instead exits 
; to the BASIC command level ("READY" prompt)
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdCLOAD
; -- setup state 
	push hl				; save hl 												;3656	e5 	. 
	ld hl,SYSFLAGS		; address of System flags 								;3657	21 39 78 	! 9 x 
	res 6,(hl)			; clear load for VERIFY flag							;365a	cb b6 	. . 
	res 3,(hl)			; clear load for CRUN flag								;365c	cb 9e 	. . 
	pop hl				; rstore hl												;365e	e1 	. 


TapeReadFile:
	di					; disable interrupt 									;365f	f3 	. 
; -- get filename from command parameter and store in Tape Filename Buffer
	call TapeParseFilename	; parse filename into FileNameBuf					;3660	cd 8c 35 	. . 5 
	push hl				; save hl - current parse point 						;3663	e5 	. 
;-- prepare Screen - move Cursor to end of last line
	call TapePrepScreen	; Prepeare Screen for TAPE info texts					;3664	cd b1 35 	. . 5 
TapeReadStart:
; -- clean last line of Screen and copy there text 'WAITING' 
	ld hl,TXT_WAITING	; hl - text 'WAITING'									;3667	21 42 38 	! B 8 
	call TapeDispOper	; Display Tape Operation Info 'WAITING'					;366a	cd f4 37 	. . 7 
.start:
; -- read file header - found filename must match requested filename (unless it's empty)
	call TapeReadHeader	; Read sync, file type and name from Tape				;366d	cd e7 35 	. . 5 
; -- we want Program (text or bin) file - check if it is Data file type 
	ld a,(TAPEFILETYPE)	; file type read from Tape								;3670	3a d2 7a 	: . z 
	cp $f2				; is it Data File (type F2)?							;3673	fe f2 	. . 
	jr z,.start			; yes ----------------- load again another file -------	;3675	28 f6 	( . 
; -- found requested file - chabge displayed operation to 'LOADING'
	ld hl,TXT_LOADING	; text 'LOADING'										;3677	21 60 38 	! ` 8 
	call TapeDispOper2	; Display Tape Operation Info 'LOADING'					;367a	cd 04 38 	. . 8 
; -- rest of file data must conform CRC
	ld ix,TAPE_CRC		; ix - address of 16bit variable for CRC				;367d	dd 21 23 78 	. ! # x 
; -- load Program Start and Program End from file
	call TapeReadPrgStartEnd	; load Start and End addresses 					;3681	cd 68 38 	. h 8 
 ifdef VER_12
	jp c,.start			; error ---------------- try load again ---------------	;3684	da 6d 36 	. m 6 
 else ; VER_20
	jp c,TapeLoadError		;3684	da 11 37 	. . 7 
 endif
; -- verify Start (de) and End (hl) address of Program
	push hl				; save hl - Program End address							;3687	e5 	. 
	sbc hl,de			; subtract Program Start = length - is End < Start?		;3688	ed 52 	. R 
 ifdef VER_12
	jp c,.start			; yes - invalid -------- try load again ---------------	;368a	da 6d 36 	. m 6 
 else ; VER_20
	jp c,TapeLoadError		;368a	da 11 37 	. . 7 
 endif
; -- store program addresses and length
	ld (TAPESTARTPRG),de; set as Autostart address (in case it's binary file)	;368d	ed 53 1e 78 	. S . x 
	push hl				; copy hl to bc											;3691	e5 	. 
	pop bc				; bc - program length (bytes to read counter)			;3692	c1 	. 
	pop hl				; restore hl - Program End address						;3693	e1 	. 
; -- check if we're loading for VERIFY (just compare) or CLOAD/CRUN (store)
	ld a,(SYSFLAGS)		; System flags 											;3694	3a 39 78 	: 9 x 
	bit 3,a				; is tape loading for VERIFY?							;3697	cb 5f 	. _ 
	jp nz,TapeReadVerify; yes - just compare data from Tape to Memory			;3699	c2 42 37 	. B 7 

.next:
; -- store data loaded from Tape 
 ifdef VER_12
	call TapeReadByte	; Read 1 byte from Tape 								;369c	cd 75 37 	. u 7 
 else ; VER_20
	call sub_3f73h		;369c	cd 73 3f 	. s ? 
 endif
	ld (de),a			; store byte into Program memory						;369f	12 	. 
	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;36a0	cd 8e 38 	. . 8 
	inc de				; points to next location in Program memory				;36a3	13 	. 
	dec bc				; decrement bytes counter 								;36a4	0b 	. 
	ld a,c				; low byte of counter									;36a5	79 	y 
	or b				; is 0 bytes to read left?								;36a6	b0 	. 
	jr nz,.next		; no - read all Program bytes 							;36a7	20 f3 	  . 
; -- all Program data read - check CRC match
	call TapeReadByte	; Read 1 byte from Tape - low byte of stored CRC 		;36a9	cd 75 37 	. u 7 
	cp (ix+0)			; is the same as just calculated?						;36ac	dd be 00 	. . . 
	jp nz,TapeLoadError	; no ------------------- display 'LOADING ERROR' ------	;36af	c2 11 37 	. . 7 
	call TapeReadByte	; Read 1 byte from Tape - high byte of stored CRC 		;36b2	cd 75 37 	. u 7 
	cp (ix+1)			; is the same as just calculated?						;36b5	dd be 01 	. . . 
	jp nz,TapeLoadError	; no ------------------- display 'LOADING ERROR' ------	;36b8	c2 11 37 	. . 7 
; -- CRC OK - store Program End address and
	ld (PrgEndPtr),hl	; store Program End address 							;36bb	22 f9 78 	" . x 
	ei					; enable interrupts										;36be	fb 	. 
; -- Print CR on Screen 
	ld a,#0D			; CR special char										;36bf	3e 0d 	> . 
	call ScrPrintChar	; print char at Cursor position							;36c1	cd 8b 30 	. . 0 
; -- file type determine autostart code or return to READY prompt
	ld a,(TAPEFILETYPE)	; file type read from Tape								;36c4	3a d2 7a 	: . z 
	cp $f1				; is it Binary file? 									;36c7	fe f1 	. . 
	jr nz,TapeReadExit	; no - skip autorun binary code							;36c9	20 04 	  . 
; -- it's Binary file - run from start
	ld hl,(TAPESTARTPRG); saved Program Start address							;36cb	2a 1e 78 	* . x 
	jp (hl)				; execute code ----------------------------------------	;36ce	e9 	. 

; -- Basic/Text file loaded
TapeReadExit:
; -- print 'READY' prompt
	ld hl,TXT_READY		; text 'READY'											;36cf	21 29 19 	! ) . 
	call PrintBasicStr	; print "READY" text on Screen							;36d2	cd a7 28 	. . ( 
; -- set current Program Start as return addres on CPU Stack
	ld hl,(PrgStartPtr)	; hl - address of start of BASIC program 				;36d5	2a a4 78 	* . x 
	push hl				; push on Stack as return address						;36d8	e5 	. 
; -- check Tape load for CRUN flag
	ld hl,SYSFLAGS		; System flags 											;36d9	21 39 78 	! 9 x 
	bit 6,(hl)			; is tape loading for CRUN?								;36dc	cb 76 	. v 
	jr nz,TapeRunPrg	; yes - run loaded Basic Program						;36de	20 03 	  . 

; -- for CLOAD - adjust Basic lines, clear variables and exit to BASIC prompt
	jp l1ae8h			;36e0	c3 e8 1a 	. . . 

TapeRunPrg:
; -- clear CRUN flag
	ld hl,SYSFLAGS		; System flags 											;36e3	21 39 78 	! 9 x 
	res 6,(hl)			; clear tape loading for CRUN flag						;36e6	cb b6 	. . 
; -- adjust Basic lines and clear variables
	pop de				; de - Basic line address to start from 				;36e8	d1 	. 

;***********************************************************************************
; Execute RUN command on existing BASIC program
; IN: de - Basic line number to start from
; -- called from DOS after program is loaded from Disk and need to be run
SysExecRUN:
	call AdjustBasLines	; Adjust BASIC line pointers 							;36e9	cd fc 1a 	. . . 
	call OnLineChanged	; call external OnLineChanged hook						;36ec	cd b5 79 	. . y 
	call ResetBasicPrg	; Reset Parse point, variables, arrays, strings, stack and error state	;36ef	cd 5d 1b 	. ] . 
	call OnResetBasPrg	; call external OnResetBasPrg hook						;36f2	cd b8 79 	. . y 
; -- set current Basic Line Number to -1 - means Interractive Commands Mode
	ld hl,-1		    ; hl = -1 - interractive mode 							;36f5	21 ff ff 	! . . 
	ld (BasicLineNo),hl	; set as Current Basic Line Number 						;36f8	22 a2 78 	" . x 
; -- copy to Edit Buffer command 'RUN'
	ld hl,EditLineBuf	; address of Editor Line Buffer							;36fb	21 e8 79 	! . y 
 ifdef VER_12
	ld de,TXT_RUN		; text 'RUN'											;36fe	11 7b 05 	. { . 
 else ; VER_20
	ld de,TXT_RUN		;36fe	11 70 05 	. p . 
 endif
.next:
	ld a,(de)			; char from source text									;3701	1a 	. 
	ld (hl),a			; store char in Editor Buffer							;3702	77 	w 
	or a				; is it '\0' (end of string)?							;3703	b7 	. 
	jr z,.parseBuf		; yes - Parse text in Buffer - RUN Program				;3704	28 04 	( . 
	inc hl				; points to next location in Editor Buffer				;3706	23 	# 
	inc de				; points to next char of text							;3707	13 	. 
	jr .next			; copy all chars of text including '\0' terminator		;3708	18 f7 	. . 
.parseBuf:
	ld hl,EditLineBuf-1	; hl - address just before buffer - parse point			;370a	21 e7 79 	! . y 
	xor a				; a=0 - simulate previous token was End Of Basic Line	;370d	af 	. 
	jp ParseEditBuf		; Parse text in Editor Line Buffer - RUN Program		;370e	c3 81 1a 	. . . 


TapeLoadError:
; -- display LOADING ERROR message
	ld hl,TXT_LOADINGERROR	; text 'LOADING ERROR'								;3711	21 4a 38 	! J 8 
	ei					; enable interrupts										;3714	fb 	. 
	call PrintBasicStr	; print "LOADING ERROR" text on Screen					;3715	cd a7 28 	. . ( 
	di					; disable interrupts again								;3718	f3 	. 
; -- if Hide Info Flag is set then skip Screen operation
	ld a,(TAPEHIDEINFO)	; Tape Hide Info flag									;3719	3a 4c 78 	: L x 
	or a				; hide info about Tape operation?						;371c	b7 	. 
	jp nz,TapeReadStart	; yes - ;371d	c2 67 36 	. g 6 
; -- set Cursor at bootom-right edge of Screen
	ld hl,VRAM+511		; last char in last line of Screen						;3720	21 ff 71 	! . q 
	ld (CURSORADDR),hl	; set Cursor Address in VRAM 							;3723	22 20 78 	"   x 
	ld a,31		        ; new Cursor position - end of line                   	;3726	3e 1f 	> . 
	ld (CURSORPOS),a	; set new position of Cursor in Edited line				;3728	32 a6 78 	2 . x 
	jp TapeReadStart			;372b	c3 67 36 	. g 6 


; *****************************************************************************************************
; BASIC CRUN Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdCRUN
	push hl			; save hl 													;372e	e5 	. 
	ld hl,SYSFLAGS	; System flags												;372f	21 39 78 	! 9 x 
	set 6,(hl)		; set tape load for CRUN flag								;3732	cb f6 	. . 
	pop hl			; restore hl												;3734	e1 	. 
	jp TapeReadFile	; read file from Tape										;3735	c3 5f 36 	. _ 6 


; *****************************************************************************************************
; BASIC VERIFY Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdVERIFY
	push hl				; save hl 												;3738	e5 	. 
	ld hl,SYSFLAGS		; System flags											;3739	21 39 78 	! 9 x 
	set 3,(hl)			; set tape load for VERIFY flag							;373c	cb de 	. . 
	pop hl				; restore hl											;373e	e1 	. 
	jp TapeReadFile		; read file from Tape									;373f	c3 5f 36 	. _ 6 


;******************************************************************************************************
; Read Program data from Tape and compare to program existing in memory
; IN: de - Program Start address as loaded from file
TapeReadVerify:
	ex de,hl			; hl - Program Start address							;3742	eb 	. 
.next:
	call TapeReadByte	; Read 1 byte from Tape 								;3743	cd 75 37 	. u 7 
	cp (hl)				; is the same as currrent in memory? 					;3746	be 	. 
	jr z,.nextaaddr		; yes - update address and counter and continue 		;3747	28 09 	( . 
; -- bytes mismatch - display VERIFY ERROR
	ld hl,TXT_VERIFY	; text 'VERIFY'											;3749	21 6c 37 	! l 7 
	call PrintBasicStr	; print "VERIFY " text on Screen						;374c	cd a7 28 	. . ( 
	jp l0183h			;374f	c3 83 01 	. . . 
.nextaaddr:
	inc hl				; points to next location in memory						;3752	23 	# 
	dec bc				; decrement bytes counter								;3753	0b 	. 
	ld a,c				; low byte of number bytes to read						;3754	79 	y 
	or b				; is 0 bytes to read left?								;3755	b0 	. 
	jr nz,.next			; no - read and compare all program data				;3756	20 eb 	  . 
; -- all bytes read an verified - clear VERIFY flag
	ld hl,SYSFLAGS		; System flags											;3758	21 39 78 	! 9 x 
	res 3,(hl)			; clear tape load for VERIFY flag						;375b	cb 9e 	. . 
; -- display VERIFY OK
	ld hl,TXT_VERIFY	; text 'VERIFY'											;375d	21 6c 37 	! l 7 
	call PrintBasicStr	; print "VERIFY " text on Screen						;3760	cd a7 28 	. . ( 
	ld hl,TXT_OK		; text 'OK'												;3763	21 80 03 	! . . 
	call PrintBasicStr	; print "OK" text on Screen								;3766	cd a7 28 	. . ( 
	jp TapeReadExit		; finalize Tape Read and exit to READY prompt			;3769	c3 cf 36 	. . 6 

TXT_VERIFY:             db $d,"VERIFY ",0       ;376c	0d 56 45 52 49 46 59 20 00 	  . 



;*********************************************************************************
; Read 1 byte from Tape 
; OUT: a - data byte
;      CY=1 - error - no data detected, CY=0 - success 
TapeReadByte:
	push bc				; save bc 												;3775	c5 	. 
	push de				; save de												;3776	d5 	. 
	ld b,8				; 8 bits to read from Tape								;3777	06 08 	. . 
.next:
	call TapeReadBit	; Read 1 bit from Tape and insert into a MSB first		;3779	cd 8f 37 	. . 7 
	jr c,.exitError		; error --------- exit with CY=1 ---------------------- ;377c	38 0e 	8 . 
	djnz .next			; read all 8 bits										;377e	10 f9 	. . 
; -- a contains data byte from Tape
	pop de				; restore de											;3780	d1 	. 
	pop bc				; restore bc											;3781	c1 	. 
	ld (TAPEBYTEBUF),a	; save byte read from Tape								;3782	32 d3 7a 	2 . z 
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP				;3785	cd f8 3a 	. . : 
	ld a,(TAPEBYTEBUF)	; restore byte read from Tape							;3788	3a d3 7a 	: . z 
	ret					; ---------------- End of Proc ------------------------	;378b	c9 	. 
.exitError:
	pop de				; restore de											;378c	d1 	. 
	pop bc				; restore bc											;378d	c1 	. 
	ret					; ---------------- End of Proc ------------------------	;378e	c9 	. 

;*********************************************************************************
; Read 1 bit from Tape and insert it data byte (d) MSB first
; IN: d - current data byte (partially read)
; OUT: d - updated data byte
;      a - updated data byte
;      CY=1 - error - no data detected, CY=0 - success 
TapeReadBit:
	push bc			; save bc 													;378f	c5 	. 
.startRead:
; -- set timeout 32767*(13+8+7+6+4+4+13) = 32767*55 = 1802185*0.279 = 500ms
 ifdef VER_12
	ld bc,32767		; timeout counter for 500ms									;3790	01 ff 7f 	. . 
 else ; VER_20
	ld bc,2047		;3790	01 ff 07 	. . . 
 endif
.waitforStart:
; -- wait for Tape signal (0)
	ld a,(CassIn)	; read Tape input bit										;3793	3a 00 68 	: . h 
	bit 6,a			; is bit reset - Tape signal (0)							;3796	cb 77 	. w 
	jr z,.confirmStart	; yes - confirm two times more that it wasn't glitch 	;3798	28 08 	( . 
	dec bc			; decrement timeout counter									;379a	0b 	. 
	ld a,c			; low byte of counter										;379b	79 	y 
	or b			; is it 0 - timeout?										;379c	b0 	. 
	jr nz,.waitforStart	; no - wait 500ms										;379d	20 f4 	  . 
; -- FAIL: no Tape signal (0) from Tape for last 500ms - return with CY=1
	pop bc			; restore bc												;379f	c1 	. 
	scf				; set CY - timeout elapsed									;37a0	37 	7 
	ret				; ---------------- End of Proc ----------------------------	;37a1	c9 	. 
.confirmStart:
; -- PASS: Tape singal (0) detected - confirm it
	ld a,(CassIn)	; read Tape input bit										;37a2	3a 00 68 	: . h 
	bit 6,a			; is bit reset - Tape signal (0)?							;37a5	cb 77 	. w 
	jr nz,.waitforStart	; no ------------- start over from 1st probe ----------	;37a7	20 ea 	  . 
; -- PASS: Tape signal (0) confirmed once - confirm again
	ld a,(CassIn)	; read Tape input bit										;37a9	3a 00 68 	: . h 
	bit 6,a			; is bit reset - Tape signal (0)?							;37ac	cb 77 	. w 
	jr nz,.waitforStart	; no ------------- start over from 1st probe ----------	;37ae	20 e3 	  . 

; -- PASS: Tape signal (0) confirmed twice - expected Tape signal (1) after 280us
	ld b,82			; delay counter	for 279us									;37b0	06 52 	. R 
.delay280us:
	djnz .delay280us; wait 82*13*0.279us = 1066*0.279us = 297.414us ~ 279us		;37b2	10 fe 	. . 
; -- expected Tape signal (1) after ~280us
	ld a,(CassIn)	; read Tape input bit										;37b4	3a 00 68 	: . h 
	bit 6,a			; is bit set - Tape signal (1)?								;37b7	cb 77 	. w 
	jr nz,.readBit	; yes - determine BIT value									;37b9	20 09 	  . 
; -- FAIL: wait for bit set (idle state) and start over with new timeout 500ms
.waitforIdle:
	ld a,(CassIn)	; read Tape input bit										;37bb	3a 00 68 	: . h 
	bit 6,a			; is bit set - Tape signal (1)?								;37be	cb 77 	. w 
	jr z,.waitforIdle	; no - wait for bit set									;37c0	28 f9 	( . 
	jr .startRead	; ------------ start over with new 500ms timeout ----------	;37c2	18 cc 	. . 

.readBit:
; -- PASS: we have 1st Short pulse 0-1 - read bit value: 0101 or 0011
	ld b,90			; delay counter	for 1.03ms									;37c4	06 5a 	. Z 
	ld c,0			; conter for detected Tape signal (0) (pulses within 1ms)	;37c6	0e 00 	. . 
.waitFor0:
; -- wait for Tape signal (0)
	ld a,(CassIn)	; read Tape input bit										;37c8	3a 00 68 	: . h 
	bit 6,a			; is bit reset - Tape signal (0)?							;37cb	cb 77 	. w 
	jr z,.confirm0	; yes - confirm Tape signal (0)								;37cd	28 0b 	( . 
.wait0again:
	djnz .waitFor0	; wait 90*(13+8+7+13)*0.279us = 3690*0.279us = 1029.510us ~ 1.03ms	;37cf	10 f7 	. . 

.exit:
; -- 1ms window elapsed - c contains number of 0 pulsed detected in this time
	ld a,c			; a - number of pulses (1 for databit=0, 2 for databit=1)	;37d1	79 	y 
	dec a			; decrement counter - bit 0 will be databit equivalent 		;37d2	3d 	= 
	rra				; roll register right - CY = databit						;37d3	1f 	. 
	rl d			; roll data byte left - insert CY as bit 0					;37d4	cb 12 	. . 
; -- restore bc and exit with CY = 0 (no error)
	pop bc			; restore bc												;37d6	c1 	. 
	ld a,d			; a - updated data byte										;37d7	7a 	z 
	or a			; clear CY flag												;37d8	b7 	. 
	ret				; ------------- End of Proc -------------------------------	;37d9	c9 	. 
.confirm0:
; -- found Tape signal (0) - confirm 
	ld a,(CassIn)	; read Tape input bit										;37da	3a 00 68 	: . h 
	bit 6,a			; is bit reset - Tape signal (0)?							;37dd	cb 77 	. w 
	jr nz,.wait0again	; no - it was glitch - continue waiting for 0				;37df	20 ee 	  . 
; -- found Tape signal (0) - confirmed once 
	ld a,(CassIn)	; read Tape input bit										;37e1	3a 00 68 	: . h 
	bit 6,a			; is bit reset - Tape signal (0)?							;37e4	cb 77 	. w 
	jr nz,.wait0again	; no - it was glitch - continue waiting for 0				;37e6	20 e7 	  . 
; -- found Tape signal (0) - confirmed twice 
	inc c			; increment pulses counter									;37e8	0c 	. 
.waitfor1:
; -- wait for Tape signal (1)
	ld a,(CassIn)	; read Tape input bit										;37e9	3a 00 68 	: . h 
	bit 6,a			; is bit set - Tape signal (1)?								;37ec	cb 77 	. w 
	jr nz,.wait0again	; yes ---------------- go back and wait for Tape Signal (0)	;37ee	20 df 	  . 
	djnz .waitfor1	; wait for Tape signal (1) for the rest of 1ms window 		;37f0	10 f7 	. . 
; -- 1ms time elapsed - calculate read data bit
	jr .exit		; calculate data bit and exit proc ------------------------ ;37f2	18 dd 	. . 

;*********************************************************************************************
; Clear last line of Screen and Display Tape Operation Info
; IN: hl - text to display at last screen line
TapeDispOper:
; -- if Hide Info Flag is set then skip Screen operation
	ld a,(TAPEHIDEINFO)	; Tape Hide Info flag									;37f4	3a 4c 78 	: L x 
	or a				; hide info about Tape operation?						;37f7	b7 	. 
	ret nz				; yes - ---------- End of Proc ------------------------	;37f8	c0 	. 
; -- clear last line of Screen 
	ld de,VRAM+480		; de - address of last line on screen					;37f9	11 e0 71 	. . q 
	ld b,32				; 32 chars per line										;37fc	06 20 	.   
.next:
 ifdef VER_12
	ld a,' '			; Space - char to fill line								;37fe	3e 20 	>   
	ld (de),a			; store in VRAM											;3800	12 	. 
 else ; VER_20
	call sub_3ef6h		;37fe	cd f6 3e 	. . > 
 endif
	inc de				; points to next char									;3801	13 	. 
	djnz .next			; fill all 32 chars in line								;3802	10 fa 	. . 

;*********************************************************************************************
; Display Tape Operation Info
; IN: hl - text to display at last screen line
TapeDispOper2:
; -- if Hide Info Flag is set then skip Screen operation
	ld a,(TAPEHIDEINFO)	; Tape Hide Info flag									;3804	3a 4c 78 	: L x 
	or a				; hide info about Tape operation?						;3807	b7 	. 
	ret nz				; yes - ---------- End of Proc ------------------------	;3808	c0 	. 
; -- copy chars from text to last line of Screen
 ifdef VER_12
	ld de,VRAM+480		; de - address of last line on screen					;3809	11 e0 71 	. . q 
 else ; VER_20
	call sub_3f0eh		;3809	cd 0e 3f 	. . ? 
 endif 
.next:
	ld a,(hl)			; char from given text									;380c	7e 	~ 
	or a				; is it '\0' (end of string)?							;380d	b7 	. 
	ret z				; yes ---------- End of Proc --------------------------	;380e	c8 	. 
	ld (de),a			; store char in VRAM - display char						;380f	12 	. 
	inc de				; points to next location on screen						;3810	13 	. 
	inc hl				; points to next char in given text						;3811	23 	# 
	jr .next			; copy all chars from text to screen last line			;3812	18 f8 	. . 


;**********************************************************************************************
; Display File Type and Name
; IN: hl - address of filename text (terminated with '\0')
;     TAPEFILETYPE - file type
TapeDispFileInfo:
; -- if Hide Info Flag is set then skip Screen operation
	ld a,(TAPEHIDEINFO)	; Tape Hide Info flag									;3814	3a 4c 78 	: L x 
	or a				; hide info about Tape operation?						;3817	b7 	. 
	ret nz				; yes - ---------- End of Proc ------------------------	;3818	c0 	. 
; -- display file type in last line of Screen
	ld de,VRAM+480+9	; destination address - offset 9 chars to skip 'FOUND'	;3819	11 e9 71 	. . q 
	push hl				; save hl - address of buffer with filename				;381c	e5 	. 
; -- decode FileType Byte to char 
	ld a,(TAPEFILETYPE)	; a - file type read from Tape ($f0,$f1 or $f2)			;381d	3a d2 7a 	: . z 
	and $0f				; constrain range to (0..15) - index for FileTypeChars	;3820	e6 0f 	. . 
	ld hl,FILETYPECHARS	; address of table with chars (screen encoded)			;3822	21 3f 38 	! ? 8 
	add a,l				; add low byte of address								;3825	85 	. 
	ld l,a				; store back low byte									;3826	6f 	o 
	ld a,0				; zero value to add only CY flag						;3827	3e 00 	> . 
	adc a,h				; add CY 												;3829	8c 	. 
	ld h,a				; hl - address in FileTypeChars table					;382a	67 	g 
 ifdef VER_12
	ld a,(hl)			; a - char (screen encoded) for given File Type			;382b	7e 	~ 
	ld (de),a			; store in VRAM - display char							;382c	12 	. 
	inc de				; points to next location on screen						;382d	13 	. 
; -- display separator ':'
	ld a,':'			; visual separator										;382e	3e 3a 	> : 
 else ; VER_20
	call sub_3f21h		;382b	cd 21 3f 	. ! ? 
	nop			;382e	00 	. 
	nop			;382f	00 	. 
 endif	
	ld (de),a			; store in VRAM - display char							;3830	12 	. 
	inc de				; points to next location on screen						;3831	13 	. 
; -- skip 1 char (leave space)
	inc de				; points to next location on screen						;3832	13 	. 
; -- display filename 
	pop hl				; restore hl - address of buffer with filename			;3833	e1 	. 
.next:
	ld a,(hl)			; a - filename char from buffer							;3834	7e 	~ 
	or a				; is it '\0' (end of string)?							;3835	b7 	. 
	ret z				; yes ------------ End of Proc ------------------------	;3836	c8 	. 
 ifdef VER_12
	and $3f				; convert ascii char to Screen char						;3837	e6 3f 	. ? 
	ld (de),a			; store in VRAM - display char							;3839	12 	. 
 else ; VER_20
	call sub_3f33h		;3837	cd 33 3f 	. 3 ? 
 endif
	inc de				; points to next location on string						;383a	13 	. 
	inc hl				; points to next char in source buffer					;383b	23 	# 
	jr .next			; copy all chars of filename							;383c	18 f6 	. . 
; -- dead code
	ret					; ---------------- End of Proc ------------------------	;383e	c9 	. 



;***************************************************************
; Table with chars (screen codes) for 3 file Types 
FILETYPECHARS:
	db	$14			; 'T' - F0 - Text (Basic) File 	;383f	14 	. 
	db	$02			; 'B' - F1 - Binary (Code) File	;3840	02 	. 
	db	$04			; 'D' - F2 - Data File			;3841	04 	. 


TXT_WAITING:        db "WAITING",0                  ;3842	57 41 49 54 49 4e 47 00 	. 
TXT_LOADINGERROR:   db $d,"LOADING ERROR",$d,0		;384a	0d 4c 4f 41 44 49 4e 47 20 45 52 52 4f 52 0d 00 	. 
TXT_FOUND:          db "FOUND",0		            ;385a	46 4f 55 4e 44 00 	. 
TXT_LOADING:        db "LOADING",0                  ;3860	4c 4f 41 44 49 4e 47 00 	. 


;*********************************************************************************
; Load from Tape Program Start and Program End 
; IN: ix - address of 16bit variable to calculate CRC
; OUT: de - program Start address (destination)
;      hl - program End address
;      CY=1 - error, Cy=0 - success 
TapeReadPrgStartEnd:
; -- read Program Start (also destination) address
	call TapeReadByte	; Read 1 byte from Tape 								;3868	cd 75 37 	. u 7 
	ret c				; error -------------- End of Proc --------------------	;386b	d8 	. 
	ld e,a				; e - low byte of Program Start address					;386c	5f 	_ 
	ld (ix+0),a			; store as low byte of CRC 								;386d	dd 77 00 	. w . 
	xor a				; a = 0 												;3870	af 	. 
	ld (ix+1),a			; store as high byte of CRC								;3871	dd 77 01 	. w . 
	call TapeReadByte	; Read 1 byte from Tape 								;3874	cd 75 37 	. u 7 
	ret c				; error -------------- End of Proc --------------------	;3877	d8 	. 
	ld d,a				; de - Program Start address							;3878	57 	W 
	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;3879	cd 8e 38 	. . 8 
; -- read Program End address
	call TapeReadByte	; Read 1 byte from Tape 								;387c	cd 75 37 	. u 7 
	ret c				; error -------------- End of Proc --------------------	;387f	d8 	. 
	ld l,a				; l - low byte of Program End address					;3880	6f 	o 
	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;3881	cd 8e 38 	. . 8 
	call TapeReadByte	; Read 1 byte from Tape 								;3884	cd 75 37 	. u 7 
	ret c				; error -------------- End of Proc --------------------	;3887	d8 	. 
	ld h,a				; hl - Program End address								;3888	67 	g 
	call AddToCRC		; Add byte value to Tape CRC (16bit Control Sum)		;3889	cd 8e 38 	. . 8 
	or a				; clear CY flag											;388c	b7 	. 
	ret					; ------------------- End of Proc ---------------------	;388d	c9 	. 

;********************************************************************
; Add byte value to Tape CRC (16bit Control Sum)
; IN: a - value to add
;     ix - address of CRC 
AddToCRC:
	add a,(ix+0)	; add low byte of CRC to given value						;388e	dd 86 00 	. . . 
	ld (ix+0),a		; store new low byte of CRC									;3891	dd 77 00 	. w . 
	ld a,0			; high byte of given value (always 0)						;3894	3e 00 	> . 
	adc a,(ix+1)	; add high byte of CRC to 0 and CY 							;3896	dd 8e 01 	. . . 
	ld (ix+1),a		; store new high byte of CRC								;3899	dd 77 01 	. w . 
	ret				; ------------------------ End of Proc --------------------	;389c	c9 	. 


; **********************************************************************************
; BASIC COLOR Entry Point
; COLOR [<F>|,<B>]
; Changes colors for Text Mode where: <F> foreground (1..8) and <B> background (0..1)
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdCOLOR
	ld a,(hl)			; a = char of first argument or ','						;389d	7e 	~ 
	cp ','				; is it ',' (foreground arg skipped)?					;389e	fe 2c 	. , 
	jr z,.bgcolor		; yes - change only background color					;38a0	28 20 	(   
; -- parse <F> foreground color argument 
	call EvalByteExpr	; a - given <F> color as Integer (8bit) value			;38a2	cd 1c 2b 	. . + 
; -- valid range is 1..8
	or a				; is it 0? 												;38a5	b7 	. 
	jp z,ErrRaiseFuncCode	; yes - raise FUNCTION CODE Error					;38a6	ca 4a 1e 	. J . 
	cp 9				; is it >= 9?											;38a9	fe 09 	. . 
	jp nc,ErrRaiseFuncCode	; yes - raise FUNCTION CODE Error					;38ab	d2 4a 1e 	. J . 
; -- <F> color in valid range 
	dec a				; a - color in range 0..7								;38ae	3d 	= 
; -- shift <F>oreground color value to high nibble of ForeColor variable 
	and $07				; clear bits 7..3										;38af	e6 07 	. . 
	sla a				; shift left 1 bit 										;38b1	cb 27 	. ' 
	sla a				; shift left 1 bit										;38b3	cb 27 	. ' 
	sla a				; shift left 1 bit										;38b5	cb 27 	. ' 
	sla a				; shift left 1 bit										;38b7	cb 27 	. ' 
	ld (FCOLOR),a		; store as Foreground Color								;38b9	32 46 78 	2 F x 
; -- check if <B>ackground argument was given
	ld a,(hl)			; next char in Program									;38bc	7e 	~ 
	or a				; is it '\0' (end of Basic Line)?						;38bd	b7 	. 
	ret z				; yes --------------- End of Proc ---------------------	;38be	c8 	. 
	cp ':'				; is it ':' (end of statement)?							;38bf	fe 3a 	. : 
	ret z				; yes --------------- End of Proc ---------------------	;38c1	c8 	. 
.bgcolor:
; -- try to set <B>ackground color
	rst $08				; Assert next token is ',' 								;38c2	cf 	. 
	defb ','			; Basic ',' token 										;38c3	2c 	, 
	call EvalByteExpr	; a - given <B> color as Integer (8bit) value			;38c4	cd 1c 2b 	. . + 
	or a				; is it 0 (green)?										;38c7	b7 	. 
	jr nz,.orange		; no - check if it is 1 (orange)						;38c8	20 0c 	  . 
; -- set color 0 (green)
	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH 					;38ca	3a 3b 78 	: ; x 
	res 4,a				; set COLOR 0 (Green)									;38cd	cb a7 	. . 
	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH  				;38cf	32 3b 78 	2 ; x 
	ld (IO_LATCH),a		; store in hardware (VDG CSS pin)						;38d2	32 00 68 	2 . h 
	ret					; ------------------ End of Proc ----------------------	;38d5	c9 	. 
.orange:
	cp 1				; is it 1 (orange)?										;38d6	fe 01 	. . 
	jp nz,ErrRaiseFuncCode	; no - raise FUNCTION CODE Error					;38d8	c2 4a 1e 	. J . 
	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH 					;38db	3a 3b 78 	: ; x 
	set 4,a				; set COLOR 1 (Orange)									;38de	cb e7 	. . 
	ld (IOLATCH_COPY),a	; save as last value written to IO_LATCH  				;38e0	32 3b 78 	2 ; x 
	ld (IO_LATCH),a		; store in hardware (VDG CSS pin)						;38e3	32 00 68 	2 . h 
	ret					; ------------------ End of Proc ----------------------	;38e6	c9 	. 


l38e7h:
	ld c,0c0h		;38e7	0e c0 	. . 
l38e9h:
	rrc c		;38e9	cb 09 	. . 
	djnz l38e9h		;38eb	10 fc 	. . 
	ld a,(de)			;38ed	1a 	. 
	and c			;38ee	a1 	. 
	ld b,a			;38ef	47 	G 
	ld a,c			;38f0	79 	y 
l38f1h:
	rrc b		;38f1	cb 08 	. . 
	rrc a		;38f3	cb 0f 	. . 
	cp 003h		;38f5	fe 03 	. . 
	jr nz,l38f1h		;38f7	20 f8 	  . 
	ld a,b			;38f9	78 	x 
	inc a			;38fa	3c 	< 
	push hl			;38fb	e5 	. 
	call sub_098dh		;38fc	cd 8d 09 	. . . 
	pop hl			;38ff	e1 	. 
	jp l390fh		;3900	c3 0f 39 	. . 9 
l3903h:
	ld b,a			;3903	47 	G 
	ld a,(de)			;3904	1a 	. 
	and c			;3905	a1 	. 
	ld (de),a			;3906	12 	. 
	pop af			;3907	f1 	. 
	or a			;3908	b7 	. 
	jp p,l390fh		;3909	f2 0f 39 	. . 9 
	ld a,(de)			;390c	1a 	. 
	or b			;390d	b0 	. 
	ld (de),a			;390e	12 	. 
l390fh:
	rst $08			; Assert next token is ')' ;390f	cf 	. 
	defb ')'		; Basic ')' token 	;3910	29 	) 
	ret			;3911	c9 	. 


; ***********************************************************************************************
; BASIC COPY Entry Point
; IN: hl - current executed command parser
;     a - command byte
;     Z = 1 - end of statement ('\0' or ':' found)
;     CY = 1 - char is digit
CmdCOPY
	di			;3912	f3 	. 
	push hl			;3913	e5 	. 
	ld a,(IOLATCH_COPY)	; a - last value written to IO_LATCH  							;3914	3a 3b 78 	: ; x 
	bit 3,a		;3917	cb 5f 	. _ 
	jp nz,l398eh		;3919	c2 8e 39 	. . 9 
	ld hl,VRAM		;391c	21 00 70 	! . p 
	ld c,010h		;391f	0e 10 	. . 
l3921h:
	ld b,020h		;3921	06 20 	.   
l3923h:
	ld a,(hl)			;3923	7e 	~ 
	or a			;3924	b7 	. 
	jp p,l392dh		;3925	f2 2d 39 	. - 9 
	call sub_2c73h		;3928	cd 73 2c 	. s , 
	jr l3943h		;392b	18 16 	. . 
l392dh:
 ifdef VER_12
	bit 6,a		;392d	cb 77 	. w 
	jr z,l3938h		;392f	28 07 	( . 
 else ; VER_20
	jp l3f44h		;392d	c3 44 3f 	. D ? 
	nop			;3930	00 	. 
 endif

l3931h:
	and 03fh		;3931	e6 3f 	. ? 
	call sub_3956h		;3933	cd 56 39 	. V 9 
	jr l3943h		;3936	18 0b 	. . 
l3938h:
	and 03fh		;3938	e6 3f 	. ? 
	bit 5,a		;393a	cb 6f 	. o 
	jr nz,l3940h		;393c	20 02 	  . 
	or 040h		;393e	f6 40 	. @ 
l3940h:
	call sub_3abah		;3940	cd ba 3a 	. . : 
l3943h:
	inc hl			;3943	23 	# 
	djnz l3923h		;3944	10 dd 	. . 
	ld a,00dh		;3946	3e 0d 	> . 
	call sub_3abah		;3948	cd ba 3a 	. . : 
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP			;394b	cd f8 3a 	. . : 
	dec c			;394e	0d 	. 
	ld a,c			;394f	79 	y 
	or a			;3950	b7 	. 
	jr nz,l3921h		;3951	20 ce 	  . 
	pop hl			;3953	e1 	. 
	ei			;3954	fb 	. 
	ret			;3955	c9 	. 
sub_3956h:
	push af			;3956	f5 	. 
	push bc			;3957	c5 	. 
	push de			;3958	d5 	. 
	push hl			;3959	e5 	. 
	ld l,a			;395a	6f 	o 
	ld h,000h		;395b	26 00 	& . 
	ld a,008h		;395d	3e 08 	> . 
	call sub_3abah		;395f	cd ba 3a 	. . : 
	ld b,004h		;3962	06 04 	. . 
	push hl			;3964	e5 	. 
	pop de			;3965	d1 	. 
	or a			;3966	b7 	. 
l3967h:
	adc hl,de		;3967	ed 5a 	. Z 
	djnz l3967h		;3969	10 fc 	. . 
	push hl			;396b	e5 	. 
	pop bc			;396c	c1 	. 
	ld hl,PrinterCharsDef	; table with char definitions for printer			;396d	21 94 3b 	! . ; 
	add hl,bc			;3970	09 	. 
	ld a,0ffh		;3971	3e ff 	> . 
	call sub_3abah		;3973	cd ba 3a 	. . : 
	ld b,005h		;3976	06 05 	. . 
l3978h:
	ld a,(hl)			;3978	7e 	~ 
	inc hl			;3979	23 	# 
	call sub_3abah		;397a	cd ba 3a 	. . : 
	djnz l3978h		;397d	10 f9 	. . 
	ld a,0ffh		;397f	3e ff 	> . 
	call sub_3abah		;3981	cd ba 3a 	. . : 
	ld a,00fh		;3984	3e 0f 	> . 
	call sub_3abah		;3986	cd ba 3a 	. . : 
	pop hl			;3989	e1 	. 
	pop de			;398a	d1 	. 
	pop bc			;398b	c1 	. 
	pop af			;398c	f1 	. 
	ret			;398d	c9 	. 
l398eh:
	xor a			;398e	af 	. 
	ld (FILENAMELEN),a	; length of file name for tape	;398f	32 d6 7a 	2 . z 
	ld (FILENAMELEN),a	; length of file name for tape	;3992	32 d6 7a 	2 . z 
	ld a,008h		;3995	3e 08 	> . 
	call sub_3abah		;3997	cd ba 3a 	. . : 
	ld ix,TAPEFILETYPE	; file type read from Tape	;399a	dd 21 d2 7a 	. ! . z 
	ld hl,VRAM		;399e	21 00 70 	! . p 
	ld de,$0000		;39a1	11 00 00 	. . . 
l39a4h:
	ld c,0c0h		;39a4	0e c0 	. . 
l39a6h:
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP			;39a6	cd f8 3a 	. . : 
	push hl			;39a9	e5 	. 
	call FillPrnBuffer		; Fill 4-byte Print Buffer with value in register A ;39aa	cd c9 05 	. . . 
	ld b,003h		;39ad	06 03 	. . 
l39afh:
	ld a,(hl)			;39af	7e 	~ 
	and c			;39b0	a1 	. 
	push bc			;39b1	c5 	. 
	ld b,a			;39b2	47 	G 
l39b3h:
	rrc b		;39b3	cb 08 	. . 
	rrc b		;39b5	cb 08 	. . 
	rrc c		;39b7	cb 09 	. . 
	rrc c		;39b9	cb 09 	. . 
	ld a,c			;39bb	79 	y 
	cp 003h		;39bc	fe 03 	. . 
	jp nz,l39b3h		;39be	c2 b3 39 	. . 9 
	ld a,b			;39c1	78 	x 
	pop bc			;39c2	c1 	. 
	cp 003h		;39c3	fe 03 	. . 
	jr z,l39d4h		;39c5	28 0d 	( . 
	cp 002h		;39c7	fe 02 	. . 
	jr z,l39d9h		;39c9	28 0e 	( . 
	cp 001h		;39cb	fe 01 	. . 
	jr z,l39dfh		;39cd	28 10 	( . 
	ld de,$0000		;39cf	11 00 00 	. . . 
	jr l39e3h		;39d2	18 0f 	. . 
l39d4h:
	ld de,0e0e0h		;39d4	11 e0 e0 	. . . 
	jr l39e3h		;39d7	18 0a 	. . 
l39d9h:
	ld d,040h		;39d9	16 40 	. @ 
	ld e,0a0h		;39db	1e a0 	. . 
	jr l39e3h		;39dd	18 04 	. . 
l39dfh:
	ld d,0a0h		;39df	16 a0 	. . 
	ld e,040h		;39e1	1e 40 	. @ 
l39e3h:
	ld a,(ix+000h)		;39e3	dd 7e 00 	. ~ . 
	srl a		;39e6	cb 3f 	. ? 
	srl a		;39e8	cb 3f 	. ? 
	srl a		;39ea	cb 3f 	. ? 
	push hl			;39ec	e5 	. 
	ld hl,TAPEBYTEBUF		;39ed	21 d3 7a 	! . z 
	call sub_3a6ah		;39f0	cd 6a 3a 	. j : 
	pop hl			;39f3	e1 	. 
	or d			;39f4	b2 	. 
	ld (ix+000h),a		;39f5	dd 77 00 	. w . 
	ld a,(ix+002h)		;39f8	dd 7e 02 	. ~ . 
	srl a		;39fb	cb 3f 	. ? 
	srl a		;39fd	cb 3f 	. ? 
	srl a		;39ff	cb 3f 	. ? 
	push hl			;3a01	e5 	. 
	ld hl,07ad5h		;3a02	21 d5 7a 	! . z 
	call sub_3a6ah		;3a05	cd 6a 3a 	. j : 
	pop hl			;3a08	e1 	. 
	or e			;3a09	b3 	. 
	ld (ix+002h),a		;3a0a	dd 77 02 	. w . 
	ld a,020h		;3a0d	3e 20 	>   
	add a,l			;3a0f	85 	. 
	ld l,a			;3a10	6f 	o 
	ld a,000h		;3a11	3e 00 	> . 
	adc a,h			;3a13	8c 	. 
	ld h,a			;3a14	67 	g 
	djnz l3a67h		;3a15	10 50 	. P 
	call sub_3a73h		;3a17	cd 73 3a 	. s : 
	pop hl			;3a1a	e1 	. 
	srl c		;3a1b	cb 39 	. 9 
	srl c		;3a1d	cb 39 	. 9 
	ld a,c			;3a1f	79 	y 
	or a			;3a20	b7 	. 
	jr nz,l39a6h		;3a21	20 83 	  . 
	inc hl			;3a23	23 	# 
	ld a,l			;3a24	7d 	} 
	and 01fh		;3a25	e6 1f 	. . 
	jp nz,l39a4h		;3a27	c2 a4 39 	. . 9 
	call sub_3ae2h		;3a2a	cd e2 3a 	. . : 
	ld a,(FILENAMELEN)	; length of file name for tape	;3a2d	3a d6 7a 	: . z 
	inc a			;3a30	3c 	< 
	cp 003h		;3a31	fe 03 	. . 
	jr nz,l3a36h		;3a33	20 01 	  . 
	xor a			;3a35	af 	. 
l3a36h:
	ld (FILENAMELEN),a	; length of file name for tape	;3a36	32 d6 7a 	2 . z 
	jr nz,l3a3fh		;3a39	20 04 	  . 
	ld a,040h		;3a3b	3e 40 	> @ 
	jr l3a41h		;3a3d	18 02 	. . 
l3a3fh:
	ld a,020h		;3a3f	3e 20 	>   
l3a41h:
	add a,l			;3a41	85 	. 
	ld l,a			;3a42	6f 	o 
	ld a,000h		;3a43	3e 00 	> . 
	adc a,h			;3a45	8c 	. 
	ld h,a			;3a46	67 	g 
	cp 078h		;3a47	fe 78 	. x 
	jp nc,l3a5fh		;3a49	d2 5f 3a 	. _ : 
	cp 077h		;3a4c	fe 77 	. w 
	jp nz,l39a4h		;3a4e	c2 a4 39 	. . 9 
	ld a,l			;3a51	7d 	} 
	cp 0e0h		;3a52	fe e0 	. . 
	jp c,l39a4h		;3a54	da a4 39 	. . 9 
	ld a,0ffh		;3a57	3e ff 	> . 
	ld (FILENAMELEN),a	; length of file name for tape	;3a59	32 d6 7a 	2 . z 
	jp l39a4h		;3a5c	c3 a4 39 	. . 9 
l3a5fh:
	ld a,00fh		;3a5f	3e 0f 	> . 
	call sub_3abah		;3a61	cd ba 3a 	. . : 
	pop hl			;3a64	e1 	. 
	ei			;3a65	fb 	. 
	ret			;3a66	c9 	. 
l3a67h:
	jp l39afh		;3a67	c3 af 39 	. . 9 
sub_3a6ah:
	jp nc,l3a70h		;3a6a	d2 70 3a 	. p : 
	set 0,(hl)		;3a6d	cb c6 	. . 
	ret			;3a6f	c9 	. 
l3a70h:
	res 0,(hl)		;3a70	cb 86 	. . 
	ret			;3a72	c9 	. 
sub_3a73h:
	call sub_3a85h		;3a73	cd 85 3a 	. . : 
	inc ix		;3a76	dd 23 	. # 
	inc ix		;3a78	dd 23 	. # 
	call sub_3a85h		;3a7a	cd 85 3a 	. . : 
	dec ix		;3a7d	dd 2b 	. + 
	dec ix		;3a7f	dd 2b 	. + 
	call sub_3a85h		;3a81	cd 85 3a 	. . : 
	ret			;3a84	c9 	. 
sub_3a85h:
	ld a,(ix+001h)		;3a85	dd 7e 01 	. ~ . 
	rrc a		;3a88	cb 0f 	. . 
	ld a,(ix+000h)		;3a8a	dd 7e 00 	. ~ . 
	push af			;3a8d	f5 	. 
	ld a,(FILENAMELEN)	; length of file name for tape	;3a8e	3a d6 7a 	: . z 
	cp 002h		;3a91	fe 02 	. . 
	jr z,l3ab2h		;3a93	28 1d 	( . 
	cp 001h		;3a95	fe 01 	. . 
	jr z,l3aafh		;3a97	28 16 	( . 
	pop af			;3a99	f1 	. 
	rla			;3a9a	17 	. 
l3a9bh:
	push af			;3a9b	f5 	. 
	ld a,(FILENAMELEN)	; length of file name for tape	;3a9c	3a d6 7a 	: . z 
	cp 0ffh		;3a9f	fe ff 	. . 
	jr nz,l3aa8h		;3aa1	20 05 	  . 
	pop af			;3aa3	f1 	. 
	and 007h		;3aa4	e6 07 	. . 
	jr l3aa9h		;3aa6	18 01 	. . 
l3aa8h:
	pop af			;3aa8	f1 	. 
l3aa9h:
	or 080h		;3aa9	f6 80 	. . 
	call sub_3abah		;3aab	cd ba 3a 	. . : 
	ret			;3aae	c9 	. 
l3aafh:
	pop af			;3aaf	f1 	. 
	jr l3a9bh		;3ab0	18 e9 	. . 
l3ab2h:
	pop af			;3ab2	f1 	. 
	rra			;3ab3	1f 	. 
	jr l3a9bh		;3ab4	18 e5 	. . 
sub_3ab6h:
	or a			;3ab6	b7 	. 
	jp m,l3ad8h		;3ab7	fa d8 3a 	. . : 
sub_3abah:
	push af			;3aba	f5 	. 
l3abbh:
	call TestCtrlBreak	; Test if Ctrl+Break keys pressed	;3abb	cd e8 3a 	. . : 
	jp nc,l3ac4h		; no - ;3abe	d2 c4 3a 	. . : 
	pop af			;3ac1	f1 	. 
	scf			;3ac2	37 	7 
	ret			;3ac3	c9 	. 
l3ac4h:
	in a,(000h)		;3ac4	db 00 	. . 
	bit 0,a		;3ac6	cb 47 	. G 
	jr nz,l3abbh		;3ac8	20 f1 	  . 
	pop af			;3aca	f1 	. 
	out (00eh),a		;3acb	d3 0e 	. . 
	out (00dh),a		;3acd	d3 0d 	. . 
	cp 00dh		;3acf	fe 0d 	. . 
	scf			;3ad1	37 	7 
	ccf			;3ad2	3f 	? 
	ret nz			;3ad3	c0 	. 
	ld a,00ah		;3ad4	3e 0a 	> . 
	jr sub_3abah		;3ad6	18 e2 	. . 
l3ad8h:
	bit 6,a		;3ad8	cb 77 	. w 
	jp z,sub_2c73h		;3ada	ca 73 2c 	. s , 
	and 03fh		;3add	e6 3f 	. ? 
	jp sub_3956h		;3adf	c3 56 39 	. V 9 
sub_3ae2h:
	ld a,00dh		;3ae2	3e 0d 	> . 
	call sub_3abah		;3ae4	cd ba 3a 	. . : 
	ret			;3ae7	c9 	. 

;***********************************************************************************
; Test if Ctrl+Break keys pressed
; OUT: CY - 1 Ctrl+Break detected, 0 - not detected
TestCtrlBreak:
	or a			    ; clear Carry Flag (CY=0) - no Ctrl+Break pressed   ;3ae8	b7 	. 
	ld a,(KROW_CTRL)    ; read Keyboard Row with CTRL key		            ;3ae9	3a fd 68 	: . h 
	bit 2,a		        ; is CTRL key pressed                               ;3aec	cb 57 	. W 
	ret nz			    ; no ------------ End of Proc (CY=0) -------------- ;3aee	c0 	. 
	ld a,(KROW_BREAK)	; read Keyboard Row with BREAK key ('-' and '=')	;3aef	3a df 68 	: . h 
	scf			        ; set Carry Flag (CY=1) - Ctrl+Break pressed        ;3af2	37 	7 
	bit 2,a		        ; is BREAK pressed ?                                ;3af3	cb 57 	. W 
	ret z			    ; yes ----------- End of Proc (CY=1) -------------- ;3af5	c8 	. 
	ccf			        ; invert Carry Flag (CY=0) - no Ctrl+Break pressed  ;3af6	3f 	? 
	ret			        ; --------------- End of Proc (CY=0) -------------- ;3af7	c9 	. 


;*****************************************************************************
; Test if Ctrl+Break is pressed.
; If Break then ckear Tape loading flags and pass control to Basic (STOP)
TapeTestBreak:
; -- check if Ctrl+Break pressed
	call TestCtrlBreak	; Test if Ctrl+Break keys pressed	                ;3af8	cd e8 3a 	. . : 
	ret nc			    ; no ------------ End of Proc --------------------- ;3afb	d0 	. 
; -- 
	pop hl			;3afc	e1 	. 
	pop hl			;3afd	e1 	. 

;*****************************************************************************
; Ckear Tape loading flags and pass control to Basic (STOP)
; by sumulete Ctrl+Break key pressed (keycode=01)
TapeAbort:
	ld a,(SYSFLAGS)		; System flags										;3afe	3a 39 78 	: 9 x 
	and %10110111		; clear VERIFY and CRUN flags						;3b01	e6 b7 	. . 
	ld (SYSFLAGS),a		; store updated System flags 						;3b03	32 39 78 	2 9 x 
; -- enable interrupts and execute Basic STOP command
	ld a,1				; key pressed value - Ctrl+Break 					;3b06	3e 01 	> . 
	ei					; enable interrupt 									;3b08	fb 	. 
	jp sub_1da0h		;3b09	c3 a0 1d 	. . . 


l3b0ch:
	ld a,(SysCurOutDev)		;3b0c	3a 9c 78 	: . x 
	or a			;3b0f	b7 	. 
	jp nz,l2164h		;3b10	c2 64 21 	. d ! 
l3b13h:
	ld a,(07aafh)		;3b13	3a af 7a 	: . z 
	or a			;3b16	b7 	. 
	jr nz,l3b13h		;3b17	20 fa 	  . 
	jp l2164h		;3b19	c3 64 21 	. d ! 
sub_3b1ch:
	ld a,(07aafh)		;3b1c	3a af 7a 	: . z 
	or a			;3b1f	b7 	. 
	ret nz			;3b20	c0 	. 
	ld a,(CURSORPOS)	; position of Cursor in Edited line				;3b21	3a a6 78 	: . x 
	ret			;3b24	c9 	. 
sub_3b25h:
	ld hl,KROW_SPACE    ; select Keyboard Row with Space key		    ;3b25	21 ef 68 	! . h 
	bit 4,(hl)		    ; is SPACE key pressed ?                        ;3b28	cb 66 	. f 
	jr nz,l3b44h		; no - return with hl = -1                      ;3b2a	20 18 	  . 
; -- detected Space Key pressed 
	call DelaySpaceKey	; wait 14,8 ms delay                            ;3b2c	cd 48 3b 	. H ; 
.waitForRelease:
	bit 4,(hl)		    ; is SPACE key pressed ?                        ;3b2f	cb 66 	. f 
	jr z,.waitForRelease; yes - wait for release                        ;3b31	28 fc 	( . 
; -- detected Space Key released
	call DelaySpaceKey	; wait 14,8 ms and read keys row with space  	;3b33	cd 48 3b 	. H ; 
l3b36h:
; -- test Ctrl+Break and execute Basic STOP command
	call TapeTestBreak	; if Ctrl+Break is pressed go to Basic STOP		;3b36	cd f8 3a 	. . : 
	bit 4,(hl)		;3b39	cb 66 	. f 
	jr nz,l3b36h		;3b3b	20 f9 	  . 
	call DelaySpaceKey	; wait 14,8 ms and read keys row with space  	;3b3d	cd 48 3b 	. H ; 
l3b40h:
	bit 4,(hl)		    ; is SPACE key pressed ?                        ;3b40	cb 66 	. f 
	jr z,l3b40h		    ; yes - wait for release                        ;3b42	28 fc 	( . 
l3b44h:
	ld hl,-1		;3b44	21 ff ff 	! . . 
	ret			;3b47	c9 	. 

;*********************************************************************************************
; Delay 14,8 ms
; 10 + 2047 * 26 + 20 = 53252 T => 14,8 ms
DelaySpaceKey:
	ld hl,2047		    ; delay counter                                                 ;3b48	21 ff 07 	! . . 
.loop:
	dec hl			    ; decrement counter                                             ;3b4b	2b 	+ 
	ld a,l			    ; a - low byte of counter                                       ;3b4c	7d 	} 
	or h			    ; is hl = 0 ?                                                   ;3b4d	b4 	. 
	jr nz,.loop		    ; no - continue                                                 ;3b4e	20 fb 	  . 
	ld hl,KROW_SPACE	; restore hl to contain Keyboard Row with Space key 	        ;3b50	21 ef 68 	! . h 
	ret			        ; --------------- End of Proc --------------------------------- ;3b53	c9 	. 

;*********************************************************************************************
; Send char to Tape via hardware register (IO_LATCH)
; IN: a - char to send
TapeWriteChar:
	call TapeWriteByte	; Send char to Tape via hardware register (IO_LATCH)			;3b54	cd 11 35 	. . 5 
	ret					; ------------------- End of Proc -----------------------------	;3b57	c9 	. 



sub_3b58h:
	di			;3b58	f3 	. 
	inc hl			;3b59	23 	# 
	ld c,$f2		; file type - Binary ;3b5a	0e f2 	. . 
	call TapeWriteHeader	; Send sync and file header to Tape	;3b5c	cd 58 35 	. X 5 
	jp c,TapeAbort	; Break - Cancel loading Tape and pass control to Basic ;3b5f	da fe 3a 	. . : 
	dec hl			;3b62	2b 	+ 
	rst $08			; Assert next token is '"' ;3b63	cf 	. 
	defb '"'		; Basic '"' token - end oif string ;3b64	22 "
	rst $08			; Assert next token is ',' ;3b65	cf . 
	defb ','		; Basic ',' token ;3b66	2c 	, 
	ret			;3b67	c9 	. 
sub_3b68h:
	di			;3b68	f3 	. 
	inc hl			;3b69	23 	# 
; -- get filename from command parameter and store in Tape Filename Buffer
	call TapeParseFilename	; parse filename into FileNameBuf					;3b6a	cd 8c 35 	. . 5 
	dec hl			;3b6d	2b 	+ 
	rst $08			; Assert next token is '"' ;3b6e	cf 	. 
	defb '"'		; Basic '"' token - end of string ;3b6f	22 "
	rst $08			; Assert next token is ',' ;3b70	cf . 
	defb ','		; Basic ',' token ;3b71	2c 	, 
	push hl			;3b72	e5 	. 
	call TapePrepScreen	; Prepeare Screen for TAPE info texts		;3b73	cd b1 35 	. . 5 
	ld hl,TXT_WAITING	; text 'WAITING'							;3b76	21 42 38 	! B 8 
	call TapeDispOper	; Display Tape Operation Info 'WAITING'		;3b79	cd f4 37 	. . 7 
l3b7ch:
	call TapeReadHeader	; Read sync, file type and name from Tape	;3b7c	cd e7 35 	. . 5 
	ld a,(TAPEFILETYPE)	; file type read from Tape	;3b7f	3a d2 7a 	: . z 
	cp 0f2h		;3b82	fe f2 	. . 
	jr nz,l3b7ch		;3b84	20 f6 	  . 
	pop hl			;3b86	e1 	. 
	ret			;3b87	c9 	. 
sub_3b88h:
	call TapeReadByte	; Read 1 byte from Tape 	;3b88	cd 75 37 	. u 7 
	cp 00dh		;3b8b	fe 0d 	. . 
	ret nz			;3b8d	c0 	. 
	push af			;3b8e	f5 	. 
	call SysNewLine		;3b8f	cd f9 20 	. .   
	pop af			;3b92	f1 	. 
	ret			;3b93	c9 	. 

;*********************************************************************************************

PrinterCharsDef:
	dg 	##-----#	; @		;3b94	c1 	. 
	dg	#-#####-			;3b95	be 	. 
	dg	#-#---#-			;3b96	a2 	. 
	dg 	#-#-###-			;3b97	ae 	. 
	dg	#-##---#			;3b98	b1 	. 
	
	dg  #-----##	; A		;3b99	83 	. 
	dg	###-##-#			;3b9a	ed 	. 
	dg 	###-###-			;3b9b	ee 	. . 
	dg	###-##-#			;3b9c	ed 	. . 
	dg	#-----##			;3b9d	83 	. 

	dg	#-------	; B		;3b9e	80 	. 
	dg 	#-##-##-			;3b9f	b6 	. 
	dg	#-##-##-			;3ba0	b6 	. 
	dg 	#-##-##-			;3ba1	b6 	. 
	dg	##-----#			;3ba2	c1 	. 
	
	dg 	##-----#	; C		;3ba3	c1 	. 
	dg	#-#####-			;3ba4	be 	. 
	dg	#-#####-			;3ba5	be 	. 
	dg	#-#####-			;3ba6	be 	. 
	dg	##-###-#			;3ba7	dd 

	dg	#-------	; D		;3ba8	80 
	dg  #-#####-			;3ba9	be 	. . . 
	dg  #-#####-			;3baa	be 	. 
	dg  #-#####-			;3bab	be 	. 
	dg	##-----#			;3bac	c1 	. 

	dg	#-------	; E		;3bad	80 	. 
	dg	#-##-##-			;3bae	b6 	. 
	dg	#-##-##-			;3baf	b6 	. 
	dg	#-##-##-			;3bb0	b6 	. 
	dg	#-#####-			;3bb1	be 	. 
	
	dg	#-------	; F		;3bb2	80 	. 
	dg	####-##-			;3bb3	f6 	. . 
	dg	####-##-			;3bb4	f6 	. . 
	dg	####-##-			;3bb5	f6 	. . 
	dg	#######-			;3bb6	fe 	. . 

	dg	##-----#	; G		;3bb7	c1 	. 
	dg	#-#####-			;3bb8	be 	. 
	dg	#-#####-			;3bb9	be 	. 
	dg	#-#-###-			;3bba	ae 	. 
	dg	#---##--			;3bbb	8c 	. 
	
	dg	#-------	; H		;3bbc	80 	. 
	dg	####-###			;3bbd	f7 	. 
	dg	####-###			;3bbe	f7 	. 
	dg	####-###			;3bbf	f7 	. 
	dg	#-------			;3bc0	80 	. 
	
	dg	########	; I		;3bc1	ff 	. 
	dg	#-#####-			;3bc2	be 	. 
	dg 	#-------			;3bc3	80 	. 
	dg	#-#####-			;3bc4	be 	. 
	dg	########			;3bc5	ff 	. 
	
	dg	##-#####	; J		;3bc6	df 	. 
	dg	#-######			;3bc7	bf 	. 
	dg	#-######			;3bc8	bf 	. 
	dg	##------			;3bc9	c0 	. 
	dg	#######-			;3bca	fe 	. . 
	
	dg	#-------	; K		;3bcb	80 	. . 
	dg	####-###			;3bcc	f7 	. 
	dg	###-#-##			;3bcd	eb 	. 
	dg	##-###-#			;3bce	dd  	. . . 
	dg	#-#####-			;3bcf	be 	. . . 
	
	dg	#-------	; L		;3bd0	80 	. . . 
	dg	#-######			;3bd1	bf 	. 
	dg	#-######			;3bd2	bf 	. 
	dg	#-######			;3bd3	bf 	. 
	dg	#-######			;3bd4	bf 	. 
	
	dg	#-------	; M		;3bd5	80 	. 
	dg	######-#			;3bd6	fd  	. . . 
	dg	####--##			;3bd7	f3 	. . . 
	dg	######-#			;3bd8	fd  	. . . 
	dg	#-------			;3bd9	80 	. 
	
	dg	#-------	; N		;3bda	80 	. 
	dg	######-#			;3bdb	fd  	. . . 
	dg	#####-##			;3bdc	fb 	. . . 
	dg	####-###			;3bdd	f7 	. . . 
	dg 	#-------			;3bde	80 	. 

	dg	##-----#	; O		;3bdf	c1 	. 
	dg	#-#####-			;3be0	be 	. 
	dg	#-#####-			;3be1	be 	. 
	dg	#-#####-			;3be2	be 	. 
	dg	##-----#			;3be3	c1 	. 

	dg	#-------	; P		;3be4	80 	. 
	dg	####-##-			;3be5	f6 	. . 
	dg	####-##-			;3be6	f6 	. . 
	dg	####-##-			;3be7	f6 	. . 
	dg	#####--#			;3be8	f9 	. . 

	dg	##-----#	; Q		;3be9	c1 	. 
	dg	#-#####-			;3bea	be 	. 
	dg	#-#-###-			;3beb	ae 	. 
	dg	##-####-			;3bec	de 	. . 
	dg	#-#----#			;3bed	a1 	. . 
	
	dg	#-------	; R		;3bee	80 	. 
	dg	####-##-			;3bef	f6 	. . 
	dg	###--##-			;3bf0	e6 	. . 
	dg	##-#-##-			;3bf1	d6 	. . 
	dg	#-###--#			;3bf2	b9 	. . 
	
	dg	##-##--#	; S		;3bf3	d9 	. 
	dg	#-##-##-			;3bf4	b6 	. 
	dg	#-##-##-			;3bf5	b6 	. 
	dg	#-##-##-			;3bf6	b6 	. 
	dg	##--##-#			;3bf7	cd 	. . . 
	
	dg	#######-	; T		;3bf8	fe 	. . . 
	dg	#######-			;3bf9	fe 	. . . 
	dg 	#-------			;3bfa	80 	. 
	dg	#######-			;3bfb	fe 	. . 
	dg	#######-			;3bfc	fe 	. . 
	
	dg	##------	; U		;3bfd	c0 	. 
	dg	#-######			;3bfe	bf 	. 
	dg	#-######			;3bff	bf 	. 
	dg	#-######			;3c00	bf 	. 
	dg	##------			;3c01	c0 	. 

	dg	#####---	; V		;3c02	f8 	. 
	dg	###--###			;3c03	e7 	. 
	dg	#--#####			;3c04	9f 	. 
	dg	###--###			;3c05	e7 	. 
	dg	#####---			;3c06	f8 	. 

	dg	#-------	; W		;3c07	80 	. 
	dg	##-#####			;3c08	df 	. 
	dg	###--###			;3c09	e7 	. 
	dg	##-#####			;3c0a	df 	. 
	dg	#-------			;3c0b	80 	. 
	
	dg	#--###--	; X		;3c0c	9c 	. 
	dg	###-##-#			;3c0d	ed 	. 
	dg	####-###			;3c0e	f7 	. 
	dg	###-#-##			;3c0f	eb 	. 
	dg	#--###--			;3c10	9c 	. 

	dg	######--	; Y		;3c11	fc 	. . . 
	dg	#####-##			;3c12	fb 	. . . 
	dg	#----###			;3c13	87 	. . . 
	dg	#####-##			;3c14	fb 	. 
	dg	######--			;3c15	fc 	. . . 

	dg	#--####-	; Z		;3c16	9e 	. . . 
	dg	#-#-###-			;3c17	ae 	. . . 
	dg	#-##-##-			;3c18	b6 	. 
	dg	#-###-#-			;3c19	ba 	. 
	dg	#-####--			;3c1a	bc 	. 

	dg	########	; [		;3c1b	ff 	. 
	dg	#-------			;3c1c	80 	. 
	dg	#-#####-			;3c1d	be 	. 
	dg	#-#####-			;3c1e	be 	. 
	dg	########			;3c1f	ff 	. 
	
	dg	######-#	; /		;3c20	fd 	. . . 
	dg	#####-##			;3c21	fb 	. . . 
	dg	####-###			;3c22	f7 	. . . 
	dg	###-####			;3c23	ef 	. 
	dg	##-#####			;3c24	df 	. 

	dg	########	; ]		;3c25	ff 	. 
	dg	#-#####-			;3c26	be 	. 
	dg	#-#####-			;3c27	be 	. 
	dg	#-------			;3c28	80 	. 
	dg	########			;3c29	ff 	. 

	dg	#####-##	; ^		;3c2a	fb 	. 
	dg	######-#			;3c2b	fd 	. . . 
	dg	#-------			;3c2c	80 	. . . 
	dg	######-#			;3c2d	fd 	. . . 
	dg	#####-##			;3c2e	fb 	. 
	
	dg	####-###	; <-	;3c2f	f7 	. 
	dg	###---##			;3c30	e3 	. 
	dg	##-#-##-			;3c31	d6 . . 
	dg	####-###			;3c32	f7 	. . 
	dg	####-###			;3c33	f7 	. . 

	dg	########	; space	;3c34	ff 	. 
	dg	########			;3c35	ff 	. 
	dg	########			;3c36	ff 	. 
	dg	########			;3c37	ff 	. 
	dg	########			;3c38	ff 	. 
	
	dg	########	; !		;3c39	ff 	. 
	dg	########			;3c3a	ff 	. 
	dg	#-#-----			;3c3b	a0 	. 
	dg	########			;3c3c	ff 	. 
	dg	########			;3c3d	ff 	. 

	dg	########	; "		;3c3e	ff 	. 
	dg	#####---			;3c3f	f8 	. 
	dg	########			;3c40	ff 	. 
	dg	#####---			;3c41	f8 	. 
	dg	########			;3c42	ff 	. 
	
	dg	###-#-##	; #		;3c43	eb 	. 
	dg	#-------			;3c44	80 	. 
	dg	###-#-##			;3c45	eb 	. 
	dg	#-------			;3c46	80 	. 
	dg	###-##-#			;3c47	ed 	. 

	dg	##-##-##	; $		;3c48	db 	. . 
	dg	##-#-##-			;3c49	d6 	. . 
	dg	#-------			;3c4a	80 	. 
	dg	##-#-##-			;3c4b	d6 	. . 
	dg	###-##-#			;3c4c	ed 	. . 

	dg	##-##--#	; %		;3c4d	d9 	. 
	dg	###-#--#			;3c4e	e9 	. 
	dg	####-###			;3c4f	f7 	. 
	dg	##--#-##			;3c50	cb 	. . 
	dg	##--##-#			;3c51	cd 	. . 

	dg	##--#--#	; &		;3c52	c9 	. 
	dg	##-#-##-			;3c53	d6 	. . 
	dg	#-#-#--#			;3c54	a9 	. . 
	dg	##-#####			;3c55	df 	. 
	dg	#-#-####			;3c56	af 	. 

	dg	####-###	; '		;3c57	f7 	. 
	dg	#####---			;3c58	f8 	. 
	dg	######--			;3c59	fc 	. . . 
	dg	########			;3c5a	ff 	. . . 
	dg	########			;3c5b	ff 	. . . 

	dg	########	; (		;3c5c	ff 	. . . 
	dg	###---##			;3c5d	e3 	. 
	dg	##-###-#			;3c5e	dd 	. . . 
	dg	#-#####-			;3c5f	be 	. . . 
	dg	########			;3c60	ff 	. . . 

	dg	########	; )		;3c61	ff 	. 
	dg	#-#####-			;3c62	be 	. 
	dg	##-###-#			;3c63	e3 	. . 
	dg	###---##			;3c64	e3 	. . 
	dg	########			;3c65	ff 	. 

	dg	##-#-##-	; *		;3c66	d6 	. . 
	dg	###---##			;3c67	e3 	. . 
	dg	#-------			;3c68	80 	. 
	dg	###---##			;3c69	e3 	. 
	dg	##-#-#-#			;3c6a	d5 	. 
	
	dg	####-###	; +		;3c6b	f7 	. 
	dg	####-###			;3c6c	f7 	. 
	dg	##-----#			;3c6d	c1 	. 
	dg	####-###			;3c6e	f7 	. 
	dg	####-###			;3c6f	f7 	. 

	dg	##-#####	; /		;3c70	df 	. 
	dg	##---###			;3c71	c7 	. 
	dg	####-###			;3c72	f7 	. 
	dg	########			;3c73	ff 	. 
	dg	########			;3c74	ff 	. 

	dg	####-###	; -		;3c75	f7 	. 
	dg	####-###			;3c76	f7 	. 
	dg	####-###			;3c77	f7 	. 
	dg	####-###			;3c78	f7 	. 
	dg	####-###			;3c79	f7 	. 

	dg	########	; .		;3c7a	ff 	. 
	dg	#--#####			;3c7b	9f 	. 
	dg	#--#####			;3c7c	9f 	. 
	dg	########			;3c7d	ff 	. 
	dg	########			;3c7e	ff 	. 
	
	dg	##-#####	; \		;3c7f	df 	. 
	dg	###-####			;3c80	ef 	. 
	dg	####-###			;3c81	f7 	. 
	dg	#####-##			;3c82	fb 	. 
	dg	######-#			;3c83	fd . . . 
	
	dg	##-----#	; 0		;3c84	c1 	. . . 
	dg	#-#-###-			;3c85	ae 	. . . 
	dg	#-##-##-			;3c86	b6 	. 
	dg	#-###-#-			;3c87	ba 	. 
	dg	##-----#			;3c88	c1 	. 
	
	dg	########	; 1		;3c89	ff 	. 
	dg	#-####-#			;3c8a	bd 	. 
	dg 	#-------			;3c8b	80 	. 
	dg	#-######			;3c8c	bf 	. 
	dg	########			;3c8d	ff 	. 
	
	dg	#--###-#	; 2		;3c8e	9d 	. 
	dg	#-#-###-			;3c8f	ae 	. 
	dg	#-##-##-			;3c90	b6 	. 
	dg	#-###-#-			;3c91	ba 	. 
	dg	#-####-#			;3c92	bd 	. 

	dg	##-###-#	;3		;3c93	dd  	. . . 
	dg	#-###-##			;3c94	bb 	. . . 
	dg	#-###-##			;3c95	bb 	. . . 
	dg	#-###-##			;3c96	bb 	. . . 
	dg	##--#--#			;3c97	c9 	. 

	dg	###--###	; 4		;3c98	e7 	. 
	dg	###-#-##			;3c99	eb 	. 
	dg	###-##-#			;3c9a	ed 	. 
	dg	#-------			;3c9b	80 	. 
	dg	###-####			;3c9c	ef 	. 

	dg	##-##---	; 5		;3c9d	d8 	. 
	dg	#-###-#-			;3c9e	ba 	. 
	dg	##-##-#-			;3c9f	da	. . . 
	dg	##-##-#-			;3ca0	da 	. . . 
	dg	##---##-			;3ca1	c6 	. . . 

	dg	##-----#	; 6		;3ca2	c1 	. 
	dg	#-##-##-			;3ca3	b6 	. 
	dg	#-##-##-			;3ca4	b6 	. 
	dg	#-##-##-			;3ca5	b6 	. 
	dg	##--####			;3ca6	cf 	. 

	dg	######--	; 7		;3ca7	fc 
	dg	#######-			;3ca8	fe 	. . . 
	dg	#----##-			;3ca9	86 	. . . 
	dg	#####-#-			;3caa	fa 	. . . 
	dg	######--			;3cab	fc 	. . . 

	dg	##--#--#	; 8		;3cac	c9 	. . . 
	dg	#-##-##-			;3cad	b6 	. 
	dg	#-##-##-			;3cae	b6 	. 
	dg	#-##-##-			;3caf	b6 	. 
	dg	##--#--#			;3cb0	c9 	. 

	dg	#####--#	; 9		;3cb1	f9 	. 
	dg	#-##-##-			;3cb2	b6 	. 
	dg	#-##-##-			;3cb3	b6 	. 
	dg	#-##-##-			;3cb4	b6 	. 
	dg	##-----#			;3cb5	c1 	. 

	dg	########	; :		;3cb6	ff 	. 
	dg	##--#--#			;3cb7	c9 	. 
	dg	##--#--#			;3cb8	c9 	. 
	dg 	########			;3cb9	ff 	. 
	dg 	########			;3cba	ff 	. 
	
	dg	#-######	; ;		;3cbb	bf 	. 
	dg	##---#--			;3cbc	c4 	. . . 
	dg	###--#--			;3cbd	e4 	. . . 
	dg	########			;3cbe	ff 	. 
	dg	########			;3cbf	ff 	. 

	dg	####-###	; <		;3cc0	f7 	. 
	dg	###-#-##			;3cc1	eb 	. 
	dg	##-###-#			;3cc2	dd 	. . . 
	dg	##-####-			;3cc3	de 	. . . 
	dg	##-####-			;3cc4	de 	. . . 

	dg	###-#-##	; =		;3cc5	eb 	. 
	dg	###-#-##			;3cc6	eb 	. 
	dg	###-#-##			;3cc7	eb 	. 
	dg	###-#-##			;3cc8	eb 	. 
	dg	###-#-##			;3cc9	eb 	. 

	dg	##-####-	; >		;3cca	de 	. . 
	dg	##-####-			;3ccb	de 	. . 
	dg	##-###-#			;3ccc	dd 	. . . 
	dg	###-#-##			;3ccd	eb 	. . . 
	dg	####-###			;3cce	f7 	. . . 

	dg	######-#	; ?		;3ccf	fd 	. . . 
	dg	#######-			;3cd0	fe 	. . . 
	dg	#-#--##-			;3cd1	a6 	. . . 
	dg	#####-#-			;3cd2	fa 	. . . 
	dg	######-#			;3cd3	fd 	. . . 



;*****************************************************************************************
; Print text of Error taken from ErrorTextTable
; First char of every error text (entry) in table is inverted in order to mark start of entry 
; IN: hl - address of table with texts for errors
;     e -  error number (0,2,4,..44)
PrintErrorText:
	srl e			; e = Error number / 2 -> range 0..22						;3cd4	cb 3b 	. 
	inc e			; e = Error number in range 1..23							;3cd6	1c 	. 
; -- find start of Error text for given error number 
.next:
	ld a,(hl)		; a - char of text to test									;3cd7	7e 	~ 
	inc hl			; next char pointer											;3cd8	23 	# 
	or a			; is inverted? 												;3cd9	b7 	. 
	jp p,.next		; no - check next char										;3cda	f2 d7 3c 	. . < 
; -- inverted char found - start of text
	dec e			; is it error we are looking for?							;3cdd	1d 	. 
	jr nz,.next		; no - seek for next text									;3cde	20 f7 	  . 
; -- error text found (1st char already in register a and hl points to next char)
	and $7f			; remove char inversion 									;3ce0	e6 7f 	.  
.print:
	call PrintChar	; Print char on screen										;3ce2	cd 2a 03 	. * . 
	ld a,(hl)		; char of error text 										;3ce5	7e 	~ 
	inc hl			; next char													;3ce6	23 	# 
	or a			; is is inverted char (already next text entry)?			;3ce7	b7 	. 
	jp p,.print		; no - print char and get next								;3ce8	f2 e2 3c 	. . < 
	ret				; ----------------- End of Proc ---------------------------	;3ceb	c9 	. 



;****************************************************************************************
;  Error Messages
; Every 1st byte of message text has 7 bit set meaning start of text (and end of previous) 
ERR_TXT_TABLE:
	db $80|'N','EXT WITHOUT FOR'	; Error 00 - NEXT WITHOUT FOR	;3cec	ce 45 58 54 20 57 49 54 48 4f 55 54 20 46 4f 52 	R 
	db $80|'S','YNTAX'				; Error 02 - SYNTAX				;3cfc	d3 59 4e 54 41 58 	X 
	db $80|'R',"ET'N WITHOUT GOSUB"	; Error 04 - RET'N WITHOUT GOSUB;3d02	d2 45 54 27 4e 20 57 49 54 48 4f 55 54 20 47 4f 53 55 42 	B 
	db $80|'O','UT OF DATA'			; Error 06 - OUT OF DATA		;3d15	cf 55 54 20 4f 46 20 44 41 54 41 	A 
	db $80|'F','UNCTION CODE'		; Error 08 - FUNCTION CODE		;3d20	c6 55 4e 43 54 49 4f 4e 20 43 4f 44 45 	E 
	db $80|'O','VERFLOW'			; Error 0A - OVERFLOW 			;3d2d	cf 56 45 52 46 4c 4f 57 	W 
	db $80|'O','UT OF MEMORY'		; Error 0C - OUT OF MEMORY		;3d35	cf 55 54 20 4f 46 20 4d 45 4d 4f 52 59 	Y 
	db $80|'U',"NDEF'D STATEMENT"	; Error 0E - UNDEF'D STATEMENT	;3d42	d5 4e 44 45 46 27 44 20 53 54 41 54 45 4d 45 4e 54 	T 
	db $80|'B','AD SUBSCRIPT'		; Error 10 - BAD SUBSCRIPT		;3d53	c2 41 44 20 53 55 42 53 43 52 49 50 54 	T 
	db $80|'R',"EDIM'D ARRAY"		; Error 12 - REDIM'D ARRAY		;3d60	d2 45 44 49 4d 27 44 20 41 52 52 41 59 	Y 
	db $80|'D','IVISION BY ZERO'	; Error 14 - DIVISION BY ZERO	;3d6d	c4 49 56 49 53 49 4f 4e 20 42 59 20 5a 45 52 4f 	O 
	db $80|'I','LLEGAL DIRECT'		; Error 16 - ILLEGAL DIRECT		;3d7d	c9 4c 4c 45 47 41 4c 20 44 49 52 45 43 54 	T 
	db $80|'T','YPE MISMATCH'		; Error 18 - TYPE MISMACH		;3d8b	d4 59 50 45 20 4d 49 53 4d 41 54 43 48 	H 
	db $80|'O','UT OF SPACE'		; Error 1A - OUT OF SPACE		;3d98	cf 55 54 20 4f 46 20 53 50 41 43 45 	E 
	db $80|'S','TRING TOO LONG'		; Error 1C - STRING TOO LONG	;3da4	d3 54 52 49 4e 47 20 54 4f 4f 20 4c 4f 4e 47 	G 
	db $80|'F','ORMULA TOO COMPLEX'	; Error 1E - FORMULA TOO COMPLEX;3db3	c6 4f 52 4d 55 4c 41 20 54 4f 4f 20 43 4f 4d 50 4c 45 58 	X 
	db $80|'C',"AN'T CONT"			; Error 20 - CAN'T CONT			;3dc6	c3 41 4e 27 54 20 43 4f 4e 54 	T 
	db $80|'N','O RESUME'			; Error 22 - NO RESUME			;3dd0	ce 4f 20 52 45 53 55 4d 45 	E 
	db $80|'R','ESUME WITHOUT' 		; Error 24 - RESUME WITHOUT		;3dd9	d2 45 53 55 4d 45 20 57 49 54 48 4f 55 54 	T 
	db $80|'U','NPRINTABLE'			; Error 26 - UNPRINTABLE		;3de7	d5 4e 50 52 49 4e 54 41 42 4c 45 	E 
	db $80|'M','ISSING OPERAND' 	; Error 28 - MISSING OPERAND	;3df2	cd 49 53 53 49 4e 47 20 4f 50 45 52 41 4e 44 	D 
	db $80|'B','AD FILE DATA'		; Error 2A - BAD FILE DATA		;3e01	c2 41 44 20 46 49 4c 45 20 44 41 54 41 	A 
	db $80|'D','ISK COMMAND'		; Error 2C - DISK COMMAND		;3e0e	c4 49 53 4b 20 43 4f 4d 4d 41 4e 44 	D 

TXT_SYNTAXERROR:
	db '?SYNTAX ERROR',$0d,0		; Interractive Error - SYNTAX ERROR	;3e1a	3f 53 59 4e 54 41 58 20 45 52 52 4f 52 0d 00 	. 

; -- Make sure there is at least 1 char in Edit Buffer
; -- if 1st byte is 0 (Buffer is empty), puts one Space char
; IN: hl - start of Editor Line Buffer
;     [stack] - saved AF
l3e29h:
	ld a,(hl)				; a - 1st char/byte from Edit Buffer							;3e29	7e 	~ 
	or a					; is it 0? (empty buffer)										;3e2a	b7 	. 
	jr nz,.exit			; no - return 													;3e2b	20 07 	  . 
; -- buffer is empty - add Space char and 0 terminator
	ld a,' '				; a - Space char 												;3e2d	3e 20 	>   
	ld (hl),a				; store as 1st char in Buffer									;3e2f	77 	w 
	inc hl					; hl - point to next location in Buffer							;3e30	23 	# 
	xor a					; a = 0 - null String Terminator								;3e31	af 	. 
	ld (hl),a				; put into Buffer												;3e32	77 	w 
	dec hl					; hl - move pointer back to 1st char							;3e33	2b 	+ 
.exit:
	dec hl					; hl - points to address just before beginig of Edit Buffer		;3e34	2b 	+ 
	pop af					; restore af - edit Abort/Commit state  						;3e35	f1 	. 
	ret						; return 														;3e36	c9 	. 



l3e37h:
	ld (OnCpuINT),a		;3e37	32 7d 78 	2 } x 
	ld a,010h		;3e3a	3e 10 	> . 
	ld (FCOLOR),a	; Foreground Color	;3e3c	32 46 78 	2 F x 
	ret			;3e3f	c9 	. 



 ifdef VER_12
// *********************************************************************
; Dummy fill data
	defs 60,0			;3e40	00 	. 
	db   $53			;3e7c	53 	S 
	defs 386,$ff
	db   0				;3fff	00 	. 
// *********************************************************************


 else ; VER_20

l3e40h:
	ld a,(hl)			;3e40	7e 	~ 
	bit 6,a		;3e41	cb 77 	. w 
	jr z,l3e4ah		;3e43	28 05 	( . 
	cp 080h		;3e45	fe 80 	. . 
	jp c,l3e5dh		;3e47	da 5d 3e 	. ] > 
l3e4ah:
	pop bc			;3e4a	c1 	. 
	ld de,l3e53h		;3e4b	11 53 3e 	. S > 
	push de			;3e4e	d5 	. 
l3e4fh:
	push bc			;3e4f	c5 	. 
	jp l0502h		;3e50	c3 02 05 	. . . 
l3e53h:
	ret c			;3e53	d8 	. 
	ld hl,TXT_SYNTAXERROR		;3e54	21 1a 3e 	! . > 
l3e57h:
	call PrintBasicStr		;3e57	cd a7 28 	. . ( 
	jp ReadLine			; Read Line as typed by User	;3e5a	c3 e3 03 	. . . 
l3e5dh:
	cp 062h		;3e5d	fe 62 	. b 
	jr nz,l3e9ah		;3e5f	20 39 	  9 
	and 0bfh		;3e61	e6 bf 	. . 
	ld (de),a			;3e63	12 	. 
	inc hl			;3e64	23 	# 
	inc de			;3e65	13 	. 
	dec b			;3e66	05 	. 
	jp z,FinishParse		;3e67	ca ee 04 	. . . 
l3e6ah:
	ld a,(hl)			;3e6a	7e 	~ 
	bit 7,a		;3e6b	cb 7f 	.  
	jr nz,l3e75h		;3e6d	20 06 	  . 
	bit 6,a		;3e6f	cb 77 	. w 
	jr nz,l3e7fh		;3e71	20 0c 	  . 
	jr l3e7bh		;3e73	18 06 	. . 
l3e75h:
	and 08fh		;3e75	e6 8f 	. . 
	or 080h		;3e77	f6 80 	. . 
	jr l3e92h		;3e79	18 17 	. . 
l3e7bh:
	or 0c0h		;3e7b	f6 c0 	. . 
	jr l3e92h		;3e7d	18 13 	. . 
l3e7fh:
	cp 062h		;3e7f	fe 62 	. b 
	jr nz,l3e8ch		;3e81	20 09 	  . 
	push hl			;3e83	e5 	. 
	ld hl,07839h		;3e84	21 39 78 	! 9 x 
	bit 4,(hl)		;3e87	cb 66 	. f 
	pop hl			;3e89	e1 	. 
	jr z,l3e9ah		;3e8a	28 0e 	( . 
l3e8ch:
	bit 5,a		;3e8c	cb 6f 	. o 
	jr z,l3e92h		;3e8e	28 02 	( . 
	and 0bfh		;3e90	e6 bf 	. . 
l3e92h:
	ld (de),a			;3e92	12 	. 
	inc hl			;3e93	23 	# 
	inc de			;3e94	13 	. 
	djnz l3e6ah		;3e95	10 d3 	. . 
	jp FinishParse		;3e97	c3 ee 04 	. . . 
l3e9ah:
	bit 5,a		;3e9a	cb 6f 	. o 
	jr z,l3ea0h		;3e9c	28 02 	( . 
	and 0bfh		;3e9e	e6 bf 	. . 
l3ea0h:
	ld (de),a			;3ea0	12 	. 
	inc hl			;3ea1	23 	# 
	inc de			;3ea2	13 	. 
	djnz l3e40h		;3ea3	10 9b 	. . 
	jp FinishParse		;3ea5	c3 ee 04 	. . . 
l3ea8h:
	ld a,(07818h)		;3ea8	3a 18 78 	: . x 
	or a			;3eab	b7 	. 
	jp nz,l04b8h		;3eac	c2 b8 04 	. . . 
	jp l3e6ah		;3eaf	c3 6a 3e 	. j > 
l3eb2h:
	ld a,(07818h)		;3eb2	3a 18 78 	: . x 
	or a			;3eb5	b7 	. 
	jr nz,l3ebbh		;3eb6	20 03 	  . 
	res 6,(hl)		;3eb8	cb b6 	. . 
	ret			;3eba	c9 	. 
l3ebbh:
	set 6,(hl)		;3ebb	cb f6 	. . 
	ret			;3ebd	c9 	. 
sub_3ebeh:
	ld a,(07818h)		;3ebe	3a 18 78 	: . x 
	or a			;3ec1	b7 	. 
	ld a,020h		;3ec2	3e 20 	>   
	jr nz,l3ec8h		;3ec4	20 02 	  . 
	or 040h		;3ec6	f6 40 	. @ 
l3ec8h:
	ld (hl),a			;3ec8	77 	w 
	ret			;3ec9	c9 	. 
l3ecah:
	push af			;3eca	f5 	. 
	ld a,(07818h)		;3ecb	3a 18 78 	: . x 
	or a			;3ece	b7 	. 
	jr z,l3ed8h		;3ecf	28 07 	( . 
	pop af			;3ed1	f1 	. 
	and 03fh		;3ed2	e6 3f 	. ? 
	push hl			;3ed4	e5 	. 
	jp l31abh		;3ed5	c3 ab 31 	. . 1 
l3ed8h:
	pop af			;3ed8	f1 	. 
	or 040h		;3ed9	f6 40 	. @ 
	push hl			;3edb	e5 	. 
	ld hl,07838h		;3edc	21 38 78 	! 8 x 
	bit 1,(hl)		;3edf	cb 4e 	. N 
	pop hl			;3ee1	e1 	. 
	jr z,l3ee6h		;3ee2	28 02 	( . 
	and 0bfh		;3ee4	e6 bf 	. . 
l3ee6h:
	jp l31b5h		;3ee6	c3 b5 31 	. . 1 
sub_3ee9h:
	ld a,(07818h)		;3ee9	3a 18 78 	: . x 
	or a			;3eec	b7 	. 
	ld a,(hl)			;3eed	7e 	~ 
	jr nz,l3ef3h		;3eee	20 03 	  . 
	cp 060h		;3ef0	fe 60 	. ` 
	ret			;3ef2	c9 	. 
l3ef3h:
	cp 020h		;3ef3	fe 20 	.   
	ret			;3ef5	c9 	. 
sub_3ef6h:
	ld a,(07818h)		;3ef6	3a 18 78 	: . x 
	or a			;3ef9	b7 	. 
	ld a,020h		;3efa	3e 20 	>   
	jr nz,l3f00h		;3efc	20 02 	  . 
	or 040h		;3efe	f6 40 	. @ 
l3f00h:
	ld (de),a			;3f00	12 	. 
	ret			;3f01	c9 	. 
sub_3f02h:
	ld b,020h		;3f02	06 20 	.   
	ld a,(07818h)		;3f04	3a 18 78 	: . x 
	or a			;3f07	b7 	. 
	ld a,020h		;3f08	3e 20 	>   
	ret nz			;3f0a	c0 	. 
	or 040h		;3f0b	f6 40 	. @ 
	ret			;3f0d	c9 	. 
sub_3f0eh:
	ld de,071e0h		;3f0e	11 e0 71 	. . q 
	ld a,(07818h)		;3f11	3a 18 78 	: . x 
	or a			;3f14	b7 	. 
	ret nz			;3f15	c0 	. 
	pop af			;3f16	f1 	. 
l3f17h:
	ld a,(hl)			;3f17	7e 	~ 
	or a			;3f18	b7 	. 
	ret z			;3f19	c8 	. 
	res 6,a		;3f1a	cb b7 	. . 
	ld (de),a			;3f1c	12 	. 
	inc de			;3f1d	13 	. 
	inc hl			;3f1e	23 	# 
	jr l3f17h		;3f1f	18 f6 	. . 
sub_3f21h:
	ld a,(07818h)		;3f21	3a 18 78 	: . x 
	or a			;3f24	b7 	. 
	ld a,(hl)			;3f25	7e 	~ 
	jr nz,l3f2fh		;3f26	20 07 	  . 
	set 6,a		;3f28	cb f7 	. . 
	ld (de),a			;3f2a	12 	. 
	inc de			;3f2b	13 	. 
	ld a,07ah		;3f2c	3e 7a 	> z 
	ret			;3f2e	c9 	. 
l3f2fh:
	ld (de),a			;3f2f	12 	. 
	ld a,03ah		;3f30	3e 3a 	> : 
	ret			;3f32	c9 	. 
sub_3f33h:
	push af			;3f33	f5 	. 
	ld a,(07818h)		;3f34	3a 18 78 	: . x 
	or a			;3f37	b7 	. 
	jr nz,l3f3fh		;3f38	20 05 	  . 
	pop af			;3f3a	f1 	. 
	or 040h		;3f3b	f6 40 	. @ 
	ld (de),a			;3f3d	12 	. 
	ret			;3f3e	c9 	. 
l3f3fh:
	pop af			;3f3f	f1 	. 
	and 03fh		;3f40	e6 3f 	. ? 
	ld (de),a			;3f42	12 	. 
	ret			;3f43	c9 	. 
l3f44h:
	push af			;3f44	f5 	. 
	ld a,(07818h)		;3f45	3a 18 78 	: . x 
	or a			;3f48	b7 	. 
	jr nz,l3f54h		;3f49	20 09 	  . 
	pop af			;3f4b	f1 	. 
	bit 6,a		;3f4c	cb 77 	. w 
	jp nz,l3938h		;3f4e	c2 38 39 	. 8 9 
	jp l3931h		;3f51	c3 31 39 	. 1 9 
l3f54h:
	pop af			;3f54	f1 	. 
	bit 6,a		;3f55	cb 77 	. w 
	jp z,l3938h		;3f57	ca 38 39 	. 8 9 
	jp l3931h		;3f5a	c3 31 39 	. 1 9 
	jp l3931h		;3f5d	c3 31 39 	. 1 9 
l3f60h:
	push af			;3f60	f5 	. 
	ld a,(07818h)		;3f61	3a 18 78 	: . x 
	or a			;3f64	b7 	. 
	jr nz,l3f6dh		;3f65	20 06 	  . 
	pop af			;3f67	f1 	. 
	and 03fh		;3f68	e6 3f 	. ? 
	jp l3154h		;3f6a	c3 54 31 	. T 1 
l3f6dh:
	pop af			;3f6d	f1 	. 
	and 07fh		;3f6e	e6 7f 	.  
	jp l3154h		;3f70	c3 54 31 	. T 1 
sub_3f73h:
	call TapeReadByte		;3f73	cd 75 37 	. u 7 
	ret nc			;3f76	d0 	. 
	pop hl			;3f77	e1 	. 
	jp TapeLoadError		;3f78	c3 11 37 	. . 7 
sub_3f7bh:
	ld a,(07819h)		;3f7b	3a 19 78 	: . x 
	ld b,a			;3f7e	47 	G 
	ld a,(07818h)		;3f7f	3a 18 78 	: . x 
	cp b			;3f82	b8 	. 
	jp z,sub_30e8h		;3f83	ca e8 30 	. . 0 
	ld (07819h),a		;3f86	32 19 78 	2 . x 
	ld hl,07000h		;3f89	21 00 70 	! . p 
	ld bc,0200h		;3f8c	01 00 02 	. . . 
l3f8fh:
	ld a,(hl)			;3f8f	7e 	~ 
	or a			;3f90	b7 	. 
	jp m,l3f97h		;3f91	fa 97 3f 	. . ? 
	xor 040h		;3f94	ee 40 	. @ 
	ld (hl),a			;3f96	77 	w 
l3f97h:
	inc hl			;3f97	23 	# 
	dec bc			;3f98	0b 	. 
	ld a,b			;3f99	78 	x 
	or c			;3f9a	b1 	. 
	jr nz,l3f8fh		;3f9b	20 f2 	  . 
	jp sub_30e8h		;3f9d	c3 e8 30 	. . 0 

sub_3fa0h:
	ld a,(068fdh)		;3fa0	3a fd 68 	: . h 
	bit 2,a		;3fa3	cb 57 	. W 
	ld a,020h		;3fa5	3e 20 	>   
	jr nz,l3fb1h		;3fa7	20 08 	  . 
	or 040h		;3fa9	f6 40 	. @ 
	ld (07818h),a		;3fab	32 18 78 	2 . x 
	ld (07819h),a		;3fae	32 19 78 	2 . x 
l3fb1h:
	ld (0783ch),a		;3fb1	32 3c 78 	2 < x 
	jp CmdCLS		;3fb4	c3 c9 01 	. . . 
	
	defs 57,0			;3fb7	00 	. 
	defs 16,$ff			;3ff0	ff 	. 
 endif
	;DISPLAY $
	ASSERT $ == 0x4000